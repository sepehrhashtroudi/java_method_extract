@Override	public String previous() {	    if (hasPrevious()) {	        return tokens[--tokenPos];	    }	    throw new NoSuchElementException();	}
protected void setFieldSeparator(String fieldSeparator) {	    if (fieldSeparator == null) {	        fieldSeparator = "";	    }	    this.fieldSeparator = fieldSeparator;	}
static Object removeAll(final Object array, final BitSet indices) {	    final int srcLength = ArrayUtils.getLength(array);	    final int removals = indices.cardinality();	    final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals);	    int srcIndex = 0;	    int destIndex = 0;	    int count;	    int set;	    while ((set = indices.nextSetBit(srcIndex)) != -1) {	        count = set - srcIndex;	        if (count > 0) {	            System.arraycopy(array, srcIndex, result, destIndex, count);	            destIndex += count;	        }	        srcIndex = indices.nextClearBit(set);	    }	    count = srcLength - srcIndex;	    if (count > 0) {	        System.arraycopy(array, srcIndex, result, destIndex, count);	    }	    return result;	}
public static <T> T initialize(final ConcurrentInitializer<T> initializer) throws ConcurrentException {	    return initializer != null ? initializer.get() : null;	}
public boolean replaceIn(final StrBuilder source, final int offset, final int length) {	    if (source == null) {	        return false;	    }	    return substitute(source, offset, length);	}
public int capacity() {	    return buffer.length;	}
public boolean isIgnoreEmptyTokens() {	    return ignoreEmptyTokens;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public String getNullText() {	    return nullText;	}
protected boolean isDefaultFullDetail() {	    return defaultFullDetail;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public char getStart() {	    return this.start;	}
@Override	public int length() {	    return size;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public static int getThrowableCount(final Throwable throwable) {	    return getThrowableList(throwable).size();	}
public EqualsBuilder appendSuper(final boolean superEquals) {	    if (isEquals == false) {	        return this;	    }	    isEquals = superEquals;	    return this;	}
public boolean contains(final CharRange range) {	    if (range == null) {	        throw new IllegalArgumentException("The Range must not be null");	    }	    if (negated) {	        if (range.negated) {	            return start >= range.start && end <= range.end;	        }	        return range.end < start || range.start > end;	    }	    if (range.negated) {	        return start == 0 && end == Character.MAX_VALUE;	    }	    return start <= range.start && end >= range.end;	}
public static String upperCase(final String str, final Locale locale) {	    if (str == null) {	        return null;	    }	    return str.toUpperCase(locale);	}
public static String repeat(final char ch, final int repeat) {	    final char[] buf = new char[repeat];	    for (int i = repeat - 1; i >= 0; i--) {	        buf[i] = ch;	    }	    return new String(buf);	}
public static StrTokenizer getTSVInstance(final char[] input) {	    final StrTokenizer tok = getTSVClone();	    tok.reset(input);	    return tok;	}
@Override	public String next() {	    if (hasNext()) {	        return tokens[tokenPos++];	    }	    throw new NoSuchElementException();	}
@Override	public short shortValue() {	    return value;	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public static <T extends CharSequence> T validIndex(final T chars, final int index) {	    return validIndex(chars, index, DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE, Integer.valueOf(index));	}
@Override	public String toString() {	    return StringUtils.repeat(this.value.toString(), this.count);	}
public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale) {	    return cache.getDateInstance(style, timeZone, locale);	}
public static String appendIfMissing(final String str, final CharSequence suffix, final CharSequence... suffixes) {	    return appendIfMissing(str, suffix, false, suffixes);	}
protected String getNullText() {	    return nullText;	}
public int capacity() {	    return buffer.length;	}
protected void appendContentStart(final StringBuffer buffer) {	    buffer.append(contentStart);	}
@Override	public T get() throws ConcurrentException {	    return getObject();	}
@Override	public int hashCode() {	    return toHashCode();	}
public void subtract(final Number operand) {	    this.value -= operand.shortValue();	}
public static String chop(final String str) {	    if (str == null) {	        return null;	    }	    final int strLen = str.length();	    if (strLen < 2) {	        return EMPTY;	    }	    final int lastIdx = strLen - 1;	    final String ret = str.substring(0, lastIdx);	    final char last = str.charAt(lastIdx);	    if (last == CharUtils.LF && ret.charAt(lastIdx - 1) == CharUtils.CR) {	        return ret.substring(0, lastIdx - 1);	    }	    return ret;	}
public StrBuilder trim() {	    if (size == 0) {	        return this;	    }	    int len = size;	    final char[] buf = buffer;	    int pos = 0;	    while (pos < len && buf[pos] <= ' ') {	        pos++;	    }	    while (pos < len && buf[len - 1] <= ' ') {	        len--;	    }	    if (len < size) {	        delete(len, size);	    }	    if (pos > 0) {	        delete(0, pos);	    }	    return this;	}
public StrBuilder appendSeparator(final char separator, final int loopIndex) {	    if (loopIndex > 0) {	        append(separator);	    }	    return this;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public StrBuilder ensureCapacity(final int capacity) {	    if (capacity > buffer.length) {	        final char[] old = buffer;	        buffer = new char[capacity * 2];	        System.arraycopy(old, 0, buffer, 0, size);	    }	    return this;	}
public int lastIndexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex >= size ? size - 1 : startIndex);	    if (matcher == null || startIndex < 0) {	        return -1;	    }	    final char[] buf = buffer;	    final int endIndex = startIndex + 1;	    for (int i = startIndex; i >= 0; i--) {	        if (matcher.isMatch(buf, i, 0, endIndex) > 0) {	            return i;	        }	    }	    return -1;	}
public HashCodeBuilder appendSuper(final int superHashCode) {	    iTotal = iTotal * iConstant + superHashCode;	    return this;	}
protected void appendIdentityHashCode(final StringBuffer buffer, final Object object) {	    if (this.isUseIdentityHashCode() && object != null) {	        register(object);	        buffer.append('@');	        buffer.append(Integer.toHexString(System.identityHashCode(object)));	    }	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
static Token[] lexx(final String format) {	    final char[] array = format.toCharArray();	    final ArrayList<Token> list = new ArrayList<Token>(array.length);	    boolean inLiteral = false;	    StringBuilder buffer = null;	    Token previous = null;	    final int sz = array.length;	    for (int i = 0; i < sz; i++) {	        final char ch = array[i];	        if (inLiteral && ch != '\'') {	            buffer.append(ch);	            continue;	        }	        Object value = null;	        switch(ch) {	            case '\'':	                if (inLiteral) {	                    buffer = null;	                    inLiteral = false;	                } else {	                    buffer = new StringBuilder();	                    list.add(new Token(buffer));	                    inLiteral = true;	                }	                break;	            case 'y':	                value = y;	                break;	            case 'M':	                value = M;	                break;	            case 'd':	                value = d;	                break;	            case 'H':	                value = H;	                break;	            case 'm':	                value = m;	                break;	            case 's':	                value = s;	                break;	            case 'S':	                value = S;	                break;	            default:	                if (buffer == null) {	                    buffer = new StringBuilder();	                    list.add(new Token(buffer));	                }	                buffer.append(ch);	        }	        if (value != null) {	            if (previous != null && previous.getValue() == value) {	                previous.increment();	            } else {	                final Token token = new Token(value);	                list.add(token);	                previous = token;	            }	            buffer = null;	        }	    }	    return list.toArray(new Token[list.size()]);	}
@Override	public int length() {	    return size;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static float max(final float a, final float b) {	    if (Float.isNaN(a)) {	        return b;	    } else if (Float.isNaN(b)) {	        return a;	    } else {	        return Math.max(a, b);	    }	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public String getNullText() {	    return nullText;	}
public static String difference(final String str1, final String str2) {	    if (str1 == null) {	        return str2;	    }	    if (str2 == null) {	        return str1;	    }	    final int at = indexOfDifference(str1, str2);	    if (at == INDEX_NOT_FOUND) {	        return EMPTY;	    }	    return str2.substring(at);	}
public char getEnd() {	    return this.end;	}
public static Integer toIntegerObject(final Boolean bool, final Integer trueValue, final Integer falseValue, final Integer nullValue) {	    if (bool == null) {	        return nullValue;	    }	    return bool.booleanValue() ? trueValue : falseValue;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public boolean equalsIgnoreCase(final StrBuilder other) {	    if (this == other) {	        return true;	    }	    if (this.size != other.size) {	        return false;	    }	    final char[] thisBuf = this.buffer;	    final char[] otherBuf = other.buffer;	    for (int i = size - 1; i >= 0; i--) {	        final char c1 = thisBuf[i];	        final char c2 = otherBuf[i];	        if (c1 != c2 && Character.toUpperCase(c1) != Character.toUpperCase(c2)) {	            return false;	        }	    }	    return true;	}
public static String prependIfMissing(final String str, final CharSequence prefix, final CharSequence... prefixes) {	    return prependIfMissing(str, prefix, false, prefixes);	}
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = Integer.MAX_VALUE;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.indexOf(str, search, 0);	        if (tmp == INDEX_NOT_FOUND) {	            continue;	        }	        if (tmp < ret) {	            ret = tmp;	        }	    }	    return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;	}
public String getNullText() {	    return nullText;	}
public String getNewLineText() {	    return newLine;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static double[] addAll(final double[] array1, final double... array2) {	    if (array1 == null) {	        return clone(array2);	    } else if (array2 == null) {	        return clone(array1);	    }	    final double[] joinedArray = new double[array1.length + array2.length];	    System.arraycopy(array1, 0, joinedArray, 0, array1.length);	    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);	    return joinedArray;	}
public boolean isEmptyTokenAsNull() {	    return this.emptyAsNull;	}
public static Field[] getAllFields(Class<?> cls) {	    final List<Field> allFieldsList = getAllFieldsList(cls);	    return allFieldsList.toArray(new Field[allFieldsList.size()]);	}
public String getNullText() {	    return nullText;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) {	    if (array == null) {	        return null;	    }	    if (startIndexInclusive < 0) {	        startIndexInclusive = 0;	    }	    if (endIndexExclusive > array.length) {	        endIndexExclusive = array.length;	    }	    final int newSize = endIndexExclusive - startIndexInclusive;	    if (newSize <= 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] subarray = new boolean[newSize];	    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);	    return subarray;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static boolean isAsciiPrintable(final char ch) {	    return ch >= 32 && ch < 127;	}
public StrBuilder replaceAll(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, -1);	}
@Override	public Date parse(final String source, final ParsePosition pos) {	    final int offset = pos.getIndex();	    final Matcher matcher = parsePattern.matcher(source.substring(offset));	    if (!matcher.lookingAt()) {	        return null;	    }	    final Calendar cal = Calendar.getInstance(timeZone, locale);	    cal.clear();	    for (int i = 0; i < strategies.length; ) {	        final Strategy strategy = strategies[i++];	        strategy.setCalendar(this, cal, matcher.group(i));	    }	    pos.setIndex(offset + matcher.end());	    return cal.getTime();	}
protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    appendSummarySize(buffer, fieldName, array.length);	}
public static <T> T CONST(final T v) {	    return v;	}
public static boolean isEmpty(final boolean[] array) {	    return array == null || array.length == 0;	}
protected String getSizeStartText() {	    return sizeStartText;	}
public static final String escapeEcmaScript(final String input) {	    return ESCAPE_ECMASCRIPT.translate(input);	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public int elementCompareTo(final T element) {	    if (element == null) {	        throw new NullPointerException("Element is null");	    }	    if (isAfter(element)) {	        return -1;	    } else if (isBefore(element)) {	        return 1;	    } else {	        return 0;	    }	}
public static boolean[] removeElements(final boolean[] array, final boolean... values) {	    if (isEmpty(array) || isEmpty(values)) {	        return clone(array);	    }	    final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2);	    for (final boolean v : values) {	        final Boolean boxed = Boolean.valueOf(v);	        final MutableInt count = occurrences.get(boxed);	        if (count == null) {	            occurrences.put(boxed, new MutableInt(1));	        } else {	            count.increment();	        }	    }	    final BitSet toRemove = new BitSet();	    for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) {	        final Boolean v = e.getKey();	        int found = 0;	        for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {	            found = indexOf(array, v.booleanValue(), found);	            if (found < 0) {	                break;	            }	            toRemove.set(found++);	        }	    }	    return (boolean[]) removeAll(array, toRemove);	}
static boolean isRegistered(final Object value) {	    final Map<Object, Object> m = getRegistry();	    return m != null && m.containsKey(value);	}
public static String toString(final boolean bool, final String trueString, final String falseString) {	    return bool ? trueString : falseString;	}
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, true);	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
@Override	public int compare(final Object obj1, final Object obj2) {	    return ((Comparable) obj1).compareTo(obj2);	}
public static String right(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(str.length() - len);	}
@Override	public double doubleValue() {	    return (double) numerator / (double) denominator;	}
public static boolean isAlphanumericSpace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetterOrDigit(cs.charAt(i)) == false && cs.charAt(i) != ' ') {	            return false;	        }	    }	    return true;	}
public boolean contains(final StrMatcher matcher) {	    return indexOf(matcher, 0) >= 0;	}
public static float min(final float a, final float b, final float c) {	    return Math.min(Math.min(a, b), c);	}
public static void handleCauseUnchecked(final ExecutionException ex) {	    final ConcurrentRuntimeException crex = extractCauseUnchecked(ex);	    if (crex != null) {	        throw crex;	    }	}
@Override	public void mark(final int readAheadLimit) {	    mark = pos;	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public char getEscapeChar() {	    return this.escapeChar;	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
@Override	public int length() {	    return size;	}
protected String getNullText() {	    return nullText;	}
public static float max(final float a, final float b, final float c) {	    return Math.max(Math.max(a, b), c);	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public void setRight(final R right) {	    this.right = right;	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes) {	    if ((src.length == 0 && srcPos == 0) || 0 == nBytes) {	        return dstInit;	    }	    if ((nBytes - 1) * 8 + dstPos >= 16) {	        throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 16");	    }	    short out = dstInit;	    int shift = 0;	    for (int i = 0; i < nBytes; i++) {	        shift = i * 8 + dstPos;	        final int bits = (0xff & src[i + srcPos]) << shift;	        final int mask = 0xff << shift;	        out = (short) ((out & ~mask) | bits);	    }	    return out;	}
public static String[] substringsBetween(final String str, final String open, final String close) {	    if (str == null || isEmpty(open) || isEmpty(close)) {	        return null;	    }	    final int strLen = str.length();	    if (strLen == 0) {	        return ArrayUtils.EMPTY_STRING_ARRAY;	    }	    final int closeLen = close.length();	    final int openLen = open.length();	    final List<String> list = new ArrayList<String>();	    int pos = 0;	    while (pos < strLen - closeLen) {	        int start = str.indexOf(open, pos);	        if (start < 0) {	            break;	        }	        start += openLen;	        final int end = str.indexOf(close, start);	        if (end < 0) {	            break;	        }	        list.add(str.substring(start, end));	        pos = end + closeLen;	    }	    if (list.isEmpty()) {	        return null;	    }	    return list.toArray(new String[list.size()]);	}
public static String getMessage(final Throwable th) {	    if (th == null) {	        return "";	    }	    final String clsName = ClassUtils.getShortClassName(th, null);	    final String msg = th.getMessage();	    return clsName + ": " + StringUtils.defaultString(msg);	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public static String deleteWhitespace(final String str) {	    if (isEmpty(str)) {	        return str;	    }	    final int sz = str.length();	    final char[] chs = new char[sz];	    int count = 0;	    for (int i = 0; i < sz; i++) {	        if (!Character.isWhitespace(str.charAt(i))) {	            chs[count++] = str.charAt(i);	        }	    }	    if (count == sz) {	        return str;	    }	    return new String(chs, 0, count);	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
@Override	public String getFieldSeparator() {	    return super.getFieldSeparator();	}
public static boolean[] removeElements(final boolean[] array, final boolean... values) {	    if (isEmpty(array) || isEmpty(values)) {	        return clone(array);	    }	    final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2);	    for (final boolean v : values) {	        final Boolean boxed = Boolean.valueOf(v);	        final MutableInt count = occurrences.get(boxed);	        if (count == null) {	            occurrences.put(boxed, new MutableInt(1));	        } else {	            count.increment();	        }	    }	    final BitSet toRemove = new BitSet();	    for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) {	        final Boolean v = e.getKey();	        int found = 0;	        for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {	            found = indexOf(array, v.booleanValue(), found);	            if (found < 0) {	                break;	            }	            toRemove.set(found++);	        }	    }	    return (boolean[]) removeAll(array, toRemove);	}
public static String difference(final String str1, final String str2) {	    if (str1 == null) {	        return str2;	    }	    if (str2 == null) {	        return str1;	    }	    final int at = indexOfDifference(str1, str2);	    if (at == INDEX_NOT_FOUND) {	        return EMPTY;	    }	    return str2.substring(at);	}
public static boolean startsWithAny(final CharSequence string, final CharSequence... searchStrings) {	    if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {	        return false;	    }	    for (final CharSequence searchString : searchStrings) {	        if (StringUtils.startsWith(string, searchString)) {	            return true;	        }	    }	    return false;	}
public Byte toByte() {	    return Byte.valueOf(byteValue());	}
protected String getContentEnd() {	    return contentEnd;	}
public static boolean isAsciiAlpha(final char ch) {	    return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');	}
@Override	public int length() {	    return size;	}
public synchronized void shutdown() {	    if (!shutdown) {	        if (ownExecutor) {	            getExecutorService().shutdownNow();	        }	        if (task != null) {	            task.cancel(false);	        }	        shutdown = true;	    }	}
public static String lowerCase(final String str, final Locale locale) {	    if (str == null) {	        return null;	    }	    return str.toLowerCase(locale);	}
public static String[] substringsBetween(final String str, final String open, final String close) {	    if (str == null || isEmpty(open) || isEmpty(close)) {	        return null;	    }	    final int strLen = str.length();	    if (strLen == 0) {	        return ArrayUtils.EMPTY_STRING_ARRAY;	    }	    final int closeLen = close.length();	    final int openLen = open.length();	    final List<String> list = new ArrayList<String>();	    int pos = 0;	    while (pos < strLen - closeLen) {	        int start = str.indexOf(open, pos);	        if (start < 0) {	            break;	        }	        start += openLen;	        final int end = str.indexOf(close, start);	        if (end < 0) {	            break;	        }	        list.add(str.substring(start, end));	        pos = end + closeLen;	    }	    if (list.isEmpty()) {	        return null;	    }	    return list.toArray(new String[list.size()]);	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts) {	    if (0 == nInts) {	        return dst;	    }	    if ((nInts - 1) * 32 + srcPos >= 64) {	        throw new IllegalArgumentException("(nInts-1)*32+srcPos is greather or equal to than 64");	    }	    int shift = 0;	    for (int i = 0; i < nInts; i++) {	        shift = i * 32 + srcPos;	        dst[dstPos + i] = (int) (0xffffffff & (src >> shift));	    }	    return dst;	}
protected String getSummaryObjectEndText() {	    return summaryObjectEndText;	}
public StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, 1);	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
@Override	public int length() {	    return size;	}
public static ConcurrentException extractCause(final ExecutionException ex) {	    if (ex == null || ex.getCause() == null) {	        return null;	    }	    throwCause(ex);	    return new ConcurrentException(ex.getMessage(), ex.getCause());	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static Boolean[] nullToEmpty(final Boolean[] array) {	    if (array == null || array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    return array;	}
public static <E extends Enum<E>> boolean isValidEnum(final Class<E> enumClass, final String enumName) {	    if (enumName == null) {	        return false;	    }	    try {	        Enum.valueOf(enumClass, enumName);	        return true;	    } catch (final IllegalArgumentException ex) {	        return false;	    }	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
@Override	public R getValue() {	    return getRight();	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) {	    return new Range<T>(fromInclusive, toInclusive, comparator);	}
public static <K, V> V createIfAbsentUnchecked(final ConcurrentMap<K, V> map, final K key, final ConcurrentInitializer<V> init) {	    try {	        return createIfAbsent(map, key, init);	    } catch (final ConcurrentException cex) {	        throw new ConcurrentRuntimeException(cex.getCause());	    }	}
public static void reverse(final boolean[] array) {	    if (array == null) {	        return;	    }	    int i = 0;	    int j = array.length - 1;	    boolean tmp;	    while (j > i) {	        tmp = array[j];	        array[j] = array[i];	        array[i] = tmp;	        j--;	        i++;	    }	}
public static String chop(final String str) {	    if (str == null) {	        return null;	    }	    final int strLen = str.length();	    if (strLen < 2) {	        return EMPTY;	    }	    final int lastIdx = strLen - 1;	    final String ret = str.substring(0, lastIdx);	    final char last = str.charAt(lastIdx);	    if (last == CharUtils.LF && ret.charAt(lastIdx - 1) == CharUtils.CR) {	        return ret.substring(0, lastIdx - 1);	    }	    return ret;	}
public static String removeEnd(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.endsWith(remove)) {	        return str.substring(0, str.length() - remove.length());	    }	    return str;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public int lastIndexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex >= size ? size - 1 : startIndex);	    if (matcher == null || startIndex < 0) {	        return -1;	    }	    final char[] buf = buffer;	    final int endIndex = startIndex + 1;	    for (int i = startIndex; i >= 0; i--) {	        if (matcher.isMatch(buf, i, 0, endIndex) > 0) {	            return i;	        }	    }	    return -1;	}
public EqualsBuilder appendSuper(final boolean superEquals) {	    if (isEquals == false) {	        return this;	    }	    isEquals = superEquals;	    return this;	}
public static final String escapeCsv(final String input) {	    return ESCAPE_CSV.translate(input);	}
@Deprecated	public static String chomp(final String str, final String separator) {	    return removeEnd(str, separator);	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
public int capacity() {	    return buffer.length;	}
public static String repeat(final char ch, final int repeat) {	    final char[] buf = new char[repeat];	    for (int i = repeat - 1; i >= 0; i--) {	        buf[i] = ch;	    }	    return new String(buf);	}
static void setAccessibleWorkaround(final AccessibleObject o) {	    if (o == null || o.isAccessible()) {	        return;	    }	    final Member m = (Member) o;	    if (Modifier.isPublic(m.getModifiers()) && isPackageAccess(m.getDeclaringClass().getModifiers())) {	        try {	            o.setAccessible(true);	        } catch (final SecurityException e) {	        }	    }	}
public static String[] stripAll(final String[] strs, final String stripChars) {	    int strsLen;	    if (strs == null || (strsLen = strs.length) == 0) {	        return strs;	    }	    final String[] newArr = new String[strsLen];	    for (int i = 0; i < strsLen; i++) {	        newArr[i] = strip(strs[i], stripChars);	    }	    return newArr;	}
public static String repeat(final char ch, final int repeat) {	    final char[] buf = new char[repeat];	    for (int i = repeat - 1; i >= 0; i--) {	        buf[i] = ch;	    }	    return new String(buf);	}
public static boolean isAllUpperCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isUpperCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
protected boolean isFieldSeparatorAtEnd() {	    return fieldSeparatorAtEnd;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public boolean isEmpty() {	    return size == 0;	}
protected void setContentStart(String contentStart) {	    if (contentStart == null) {	        contentStart = "";	    }	    this.contentStart = contentStart;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static boolean isNumber(final String str) {	    if (StringUtils.isEmpty(str)) {	        return false;	    }	    final char[] chars = str.toCharArray();	    int sz = chars.length;	    boolean hasExp = false;	    boolean hasDecPoint = false;	    boolean allowSigns = false;	    boolean foundDigit = false;	    final int start = (chars[0] == '-') ? 1 : 0;	    if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') {	        int i = start + 2;	        if (i == sz) {	            return false;	        }	        for (; i < chars.length; i++) {	            if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) {	                return false;	            }	        }	        return true;	    }	    sz--;	    int i = start;	    while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {	        if (chars[i] >= '0' && chars[i] <= '9') {	            foundDigit = true;	            allowSigns = false;	        } else if (chars[i] == '.') {	            if (hasDecPoint || hasExp) {	                return false;	            }	            hasDecPoint = true;	        } else if (chars[i] == 'e' || chars[i] == 'E') {	            if (hasExp) {	                return false;	            }	            if (!foundDigit) {	                return false;	            }	            hasExp = true;	            allowSigns = true;	        } else if (chars[i] == '+' || chars[i] == '-') {	            if (!allowSigns) {	                return false;	            }	            allowSigns = false;	            foundDigit = false;	        } else {	            return false;	        }	        i++;	    }	    if (i < chars.length) {	        if (chars[i] >= '0' && chars[i] <= '9') {	            return true;	        }	        if (chars[i] == 'e' || chars[i] == 'E') {	            return false;	        }	        if (chars[i] == '.') {	            if (hasDecPoint || hasExp) {	                return false;	            }	            return foundDigit;	        }	        if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) {	            return foundDigit;	        }	        if (chars[i] == 'l' || chars[i] == 'L') {	            return foundDigit && !hasExp && !hasDecPoint;	        }	        return false;	    }	    return !allowSigns && foundDigit;	}
public static String stripEnd(final String str, final String stripChars) {	    int end;	    if (str == null || (end = str.length()) == 0) {	        return str;	    }	    if (stripChars == null) {	        while (end != 0 && Character.isWhitespace(str.charAt(end - 1))) {	            end--;	        }	    } else if (stripChars.isEmpty()) {	        return str;	    } else {	        while (end != 0 && stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND) {	            end--;	        }	    }	    return str.substring(0, end);	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public static <E extends Enum<E>> E getEnum(final Class<E> enumClass, final String enumName) {	    if (enumName == null) {	        return null;	    }	    try {	        return Enum.valueOf(enumClass, enumName);	    } catch (final IllegalArgumentException ex) {	        return null;	    }	}
public String getNewLineText() {	    return newLine;	}
public StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, 1);	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public boolean isEmptyTokenAsNull() {	    return this.emptyAsNull;	}
public StrSubstitutor setVariablePrefix(final String prefix) {	    if (prefix == null) {	        throw new IllegalArgumentException("Variable prefix must not be null!");	    }	    return setVariablePrefixMatcher(StrMatcher.stringMatcher(prefix));	}
public static String replaceEachRepeatedly(final String text, final String[] searchList, final String[] replacementList) {	    final int timeToLive = searchList == null ? 0 : searchList.length;	    return replaceEach(text, searchList, replacementList, true, timeToLive);	}
public static Set<Locale> availableLocaleSet() {	    return SyncAvoid.AVAILABLE_LOCALE_SET;	}
public static String substringBetween(final String str, final String open, final String close) {	    if (str == null || open == null || close == null) {	        return null;	    }	    final int start = str.indexOf(open);	    if (start != INDEX_NOT_FOUND) {	        final int end = str.indexOf(close, start + open.length());	        if (end != INDEX_NOT_FOUND) {	            return str.substring(start + open.length(), end);	        }	    }	    return null;	}
public StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, 1);	}
public final String getNamingPattern() {	    return namingPattern;	}
public int capacity() {	    return buffer.length;	}
public static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools) {	    if ((src.length == 0 && srcPos == 0) || 0 == nBools) {	        return dstInit;	    }	    if (nBools - 1 + dstPos >= 16) {	        throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 16");	    }	    short out = dstInit;	    int shift = 0;	    for (int i = 0; i < nBools; i++) {	        shift = i * 1 + dstPos;	        final int bits = (src[i + srcPos] ? 1 : 0) << shift;	        final int mask = 0x1 << shift;	        out = (short) ((out & ~mask) | bits);	    }	    return out;	}
public static <K, V> V putIfAbsent(final ConcurrentMap<K, V> map, final K key, final V value) {	    if (map == null) {	        return null;	    }	    final V result = map.putIfAbsent(key, value);	    return result != null ? result : value;	}
public int capacity() {	    return buffer.length;	}
public StrTokenizer asTokenizer() {	    return new StrBuilderTokenizer();	}
public static boolean endsWithAny(final CharSequence string, final CharSequence... searchStrings) {	    if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {	        return false;	    }	    for (final CharSequence searchString : searchStrings) {	        if (StringUtils.endsWith(string, searchString)) {	            return true;	        }	    }	    return false;	}
public static final String unescapeHtml4(final String input) {	    return UNESCAPE_HTML4.translate(input);	}
public static short[] removeElement(final short[] array, final short element) {	    final int index = indexOf(array, element);	    if (index == INDEX_NOT_FOUND) {	        return clone(array);	    }	    return remove(array, index);	}
public static String prependIfMissing(final String str, final CharSequence prefix, final CharSequence... prefixes) {	    return prependIfMissing(str, prefix, false, prefixes);	}
public static long getFragmentInHours(final Calendar calendar, final int fragment) {	    return getFragment(calendar, fragment, Calendar.HOUR_OF_DAY);	}
public static Number createNumber(final String str) throws NumberFormatException {	    if (str == null) {	        return null;	    }	    if (StringUtils.isBlank(str)) {	        throw new NumberFormatException("A blank string is not a valid number");	    }	    final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" };	    int pfxLen = 0;	    for (final String pfx : hex_prefixes) {	        if (str.startsWith(pfx)) {	            pfxLen += pfx.length();	            break;	        }	    }	    if (pfxLen > 0) {	        final int hexDigits = str.length() - pfxLen;	        if (hexDigits > 16) {	            return createBigInteger(str);	        }	        if (hexDigits > 8) {	            return createLong(str);	        }	        return createInteger(str);	    }	    final char lastChar = str.charAt(str.length() - 1);	    String mant;	    String dec;	    String exp;	    final int decPos = str.indexOf('.');	    final int expPos = str.indexOf('e') + str.indexOf('E') + 1;	    int numDecimals = 0;	    if (decPos > -1) {	        if (expPos > -1) {	            if (expPos < decPos || expPos > str.length()) {	                throw new NumberFormatException(str + " is not a valid number.");	            }	            dec = str.substring(decPos + 1, expPos);	        } else {	            dec = str.substring(decPos + 1);	        }	        mant = str.substring(0, decPos);	        numDecimals = dec.length();	    } else {	        if (expPos > -1) {	            if (expPos > str.length()) {	                throw new NumberFormatException(str + " is not a valid number.");	            }	            mant = str.substring(0, expPos);	        } else {	            mant = str;	        }	        dec = null;	    }	    if (!Character.isDigit(lastChar) && lastChar != '.') {	        if (expPos > -1 && expPos < str.length() - 1) {	            exp = str.substring(expPos + 1, str.length() - 1);	        } else {	            exp = null;	        }	        final String numeric = str.substring(0, str.length() - 1);	        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);	        switch(lastChar) {	            case 'l':	            case 'L':	                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {	                    try {	                        return createLong(numeric);	                    } catch (final NumberFormatException nfe) {	                    }	                    return createBigInteger(numeric);	                }	                throw new NumberFormatException(str + " is not a valid number.");	            case 'f':	            case 'F':	                try {	                    final Float f = NumberUtils.createFloat(numeric);	                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {	                        return f;	                    }	                } catch (final NumberFormatException nfe) {	                }	            case 'd':	            case 'D':	                try {	                    final Double d = NumberUtils.createDouble(numeric);	                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {	                        return d;	                    }	                } catch (final NumberFormatException nfe) {	                }	                try {	                    return createBigDecimal(numeric);	                } catch (final NumberFormatException e) {	                }	            default:	                throw new NumberFormatException(str + " is not a valid number.");	        }	    }	    if (expPos > -1 && expPos < str.length() - 1) {	        exp = str.substring(expPos + 1, str.length());	    } else {	        exp = null;	    }	    if (dec == null && exp == null) {	        try {	            return createInteger(str);	        } catch (final NumberFormatException nfe) {	        }	        try {	            return createLong(str);	        } catch (final NumberFormatException nfe) {	        }	        return createBigInteger(str);	    }	    final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);	    try {	        if (numDecimals <= 7) {	            final Float f = createFloat(str);	            if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {	                return f;	            }	        }	    } catch (final NumberFormatException nfe) {	    }	    try {	        if (numDecimals <= 16) {	            final Double d = createDouble(str);	            if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {	                return d;	            }	        }	    } catch (final NumberFormatException nfe) {	    }	    return createBigDecimal(str);	}
public static boolean isAsciiAlpha(final char ch) {	    return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');	}
public int capacity() {	    return buffer.length;	}
public static short[] removeElement(final short[] array, final short element) {	    final int index = indexOf(array, element);	    if (index == INDEX_NOT_FOUND) {	        return clone(array);	    }	    return remove(array, index);	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public static boolean isNumericSpace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isDigit(cs.charAt(i)) == false && cs.charAt(i) != ' ') {	            return false;	        }	    }	    return true;	}
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return true;	    }	    if (lhs == null || rhs == null) {	        return false;	    }	    final Class<?> lhsClass = lhs.getClass();	    final Class<?> rhsClass = rhs.getClass();	    Class<?> testClass;	    if (lhsClass.isInstance(rhs)) {	        testClass = lhsClass;	        if (!rhsClass.isInstance(lhs)) {	            testClass = rhsClass;	        }	    } else if (rhsClass.isInstance(lhs)) {	        testClass = rhsClass;	        if (!lhsClass.isInstance(rhs)) {	            testClass = lhsClass;	        }	    } else {	        return false;	    }	    final EqualsBuilder equalsBuilder = new EqualsBuilder();	    try {	        reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {	            testClass = testClass.getSuperclass();	            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        }	    } catch (final IllegalArgumentException e) {	        return false;	    }	    return equalsBuilder.isEquals();	}
public static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts) {	    if ((src.length == 0 && srcPos == 0) || 0 == nInts) {	        return dstInit;	    }	    if ((nInts - 1) * 32 + dstPos >= 64) {	        throw new IllegalArgumentException("(nInts-1)*32+dstPos is greather or equal to than 64");	    }	    long out = dstInit;	    int shift = 0;	    for (int i = 0; i < nInts; i++) {	        shift = i * 32 + dstPos;	        final long bits = ((0xffffffffL & src[i + srcPos]) << shift);	        final long mask = 0xffffffffL << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
public static String leftPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return leftPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return padStr.concat(str);	    } else if (pads < padLen) {	        return padStr.substring(0, pads).concat(str);	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return new String(padding).concat(str);	    }	}
public static <T> Range<T> is(final T element, final Comparator<T> comparator) {	    return between(element, element, comparator);	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public static <K, V> V createIfAbsentUnchecked(final ConcurrentMap<K, V> map, final K key, final ConcurrentInitializer<V> init) {	    try {	        return createIfAbsent(map, key, init);	    } catch (final ConcurrentException cex) {	        throw new ConcurrentRuntimeException(cex.getCause());	    }	}
public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException {	    return parseDateWithLeniency(str, null, parsePatterns, false);	}
public static boolean containsOnly(final CharSequence cs, final String validChars) {	    if (cs == null || validChars == null) {	        return false;	    }	    return containsOnly(cs, validChars.toCharArray());	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public byte clearByte(final byte holder) {	    return (byte) clear(holder);	}
public StrBuilder deleteCharAt(final int index) {	    if (index < 0 || index >= size) {	        throw new StringIndexOutOfBoundsException(index);	    }	    deleteImpl(index, index + 1, 1);	    return this;	}
public static Boolean[] nullToEmpty(final Boolean[] array) {	    if (array == null || array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    return array;	}
public static String right(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(str.length() - len);	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static boolean containsOnly(final CharSequence cs, final String validChars) {	    if (cs == null || validChars == null) {	        return false;	    }	    return containsOnly(cs, validChars.toCharArray());	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) {	    if (s == null || t == null) {	        throw new IllegalArgumentException("Strings must not be null");	    }	    if (threshold < 0) {	        throw new IllegalArgumentException("Threshold must not be negative");	    }	    int n = s.length();	    int m = t.length();	    if (n == 0) {	        return m <= threshold ? m : -1;	    } else if (m == 0) {	        return n <= threshold ? n : -1;	    }	    if (n > m) {	        final CharSequence tmp = s;	        s = t;	        t = tmp;	        n = m;	        m = t.length();	    }	    int[] p = new int[n + 1];	    int[] d = new int[n + 1];	    int[] _d;	    final int boundary = Math.min(n, threshold) + 1;	    for (int i = 0; i < boundary; i++) {	        p[i] = i;	    }	    Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);	    Arrays.fill(d, Integer.MAX_VALUE);	    for (int j = 1; j <= m; j++) {	        final char t_j = t.charAt(j - 1);	        d[0] = j;	        final int min = Math.max(1, j - threshold);	        final int max = Math.min(n, j + threshold);	        if (min > max) {	            return -1;	        }	        if (min > 1) {	            d[min - 1] = Integer.MAX_VALUE;	        }	        for (int i = min; i <= max; i++) {	            if (s.charAt(i - 1) == t_j) {	                d[i] = p[i - 1];	            } else {	                d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);	            }	        }	        _d = p;	        p = d;	        d = _d;	    }	    if (p[n] <= threshold) {	        return p[n];	    }	    return -1;	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public short clearShort(final short holder) {	    return (short) clear(holder);	}
public static boolean endsWithIgnoreCase(final CharSequence str, final CharSequence suffix) {	    return endsWith(str, suffix, true);	}
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) {	    if (str == null) {	        if (trueString == null) {	            return Boolean.TRUE;	        }	        if (falseString == null) {	            return Boolean.FALSE;	        }	        if (nullString == null) {	            return null;	        }	    } else if (str.equals(trueString)) {	        return Boolean.TRUE;	    } else if (str.equals(falseString)) {	        return Boolean.FALSE;	    } else if (str.equals(nullString)) {	        return null;	    }	    throw new IllegalArgumentException("The String did not match any specified value");	}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    buffer.append(arrayStart);	    for (int i = 0; i < array.length; i++) {	        if (i > 0) {	            buffer.append(arraySeparator);	        }	        appendDetail(buffer, fieldName, array[i]);	    }	    buffer.append(arrayEnd);	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
@Override	public float floatValue() {	    return (float) numerator / (float) denominator;	}
public StrBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar) {	    return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);	}
public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale) {	    return cache.getDateInstance(style, timeZone, locale);	}
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) {	    if (str == null) {	        if (trueString == null) {	            return Boolean.TRUE;	        }	        if (falseString == null) {	            return Boolean.FALSE;	        }	        if (nullString == null) {	            return null;	        }	    } else if (str.equals(trueString)) {	        return Boolean.TRUE;	    } else if (str.equals(falseString)) {	        return Boolean.FALSE;	    } else if (str.equals(nullString)) {	        return null;	    }	    throw new IllegalArgumentException("The String did not match any specified value");	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public static String random(final int count, final char... chars) {	    if (chars == null) {	        return random(count, 0, 0, false, false, null, RANDOM);	    }	    return random(count, 0, chars.length, false, false, chars, RANDOM);	}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    buffer.append(arrayStart);	    for (int i = 0; i < array.length; i++) {	        if (i > 0) {	            buffer.append(arraySeparator);	        }	        appendDetail(buffer, fieldName, array[i]);	    }	    buffer.append(arrayEnd);	}
@Override	public int nextIndex() {	    return tokenPos;	}
@Override	public Integer getValue() {	    return Integer.valueOf(this.value);	}
public static String removePattern(final String source, final String regex) {	    return replacePattern(source, regex, StringUtils.EMPTY);	}
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) {	    style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));	    return this;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
private static Date set(final Date date, final int calendarField, final int amount) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final Calendar c = Calendar.getInstance();	    c.setLenient(false);	    c.setTime(date);	    c.set(calendarField, amount);	    return c.getTime();	}
public static String defaultString(final String str, final String defaultStr) {	    return str == null ? defaultStr : str;	}
@Override	public int length() {	    return size;	}
public char getEscapeChar() {	    return this.escapeChar;	}
public static String chop(final String str) {	    if (str == null) {	        return null;	    }	    final int strLen = str.length();	    if (strLen < 2) {	        return EMPTY;	    }	    final int lastIdx = strLen - 1;	    final String ret = str.substring(0, lastIdx);	    final char last = str.charAt(lastIdx);	    if (last == CharUtils.LF && ret.charAt(lastIdx - 1) == CharUtils.CR) {	        return ret.substring(0, lastIdx - 1);	    }	    return ret;	}
@Override	public void mark(final int readAheadLimit) {	    mark = pos;	}
public StrBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar) {	    return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static <T> T clone(final T obj) {	    if (obj instanceof Cloneable) {	        final Object result;	        if (obj.getClass().isArray()) {	            final Class<?> componentType = obj.getClass().getComponentType();	            if (!componentType.isPrimitive()) {	                result = ((Object[]) obj).clone();	            } else {	                int length = Array.getLength(obj);	                result = Array.newInstance(componentType, length);	                while (length-- > 0) {	                    Array.set(result, length, Array.get(obj, length));	                }	            }	        } else {	            try {	                final Method clone = obj.getClass().getMethod("clone");	                result = clone.invoke(obj);	            } catch (final NoSuchMethodException e) {	                throw new CloneFailedException("Cloneable type " + obj.getClass().getName() + " has no clone method", e);	            } catch (final IllegalAccessException e) {	                throw new CloneFailedException("Cannot clone Cloneable type " + obj.getClass().getName(), e);	            } catch (final InvocationTargetException e) {	                throw new CloneFailedException("Exception cloning Cloneable type " + obj.getClass().getName(), e.getCause());	            }	        }	        @SuppressWarnings("unchecked")	        final T checked = (T) result;	        return checked;	    }	    return null;	}
protected void appendFieldStart(final StringBuffer buffer, final String fieldName) {	    if (useFieldNames && fieldName != null) {	        buffer.append(fieldName);	        buffer.append(fieldNameValueSeparator);	    }	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
@Override	public StringBuffer format(final Calendar calendar, final StringBuffer buf) {	    return printer.format(calendar, buf);	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public static String removeEnd(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.endsWith(remove)) {	        return str.substring(0, str.length() - remove.length());	    }	    return str;	}
public static Object invokeExactStaticMethod(final Class<?> cls, final String methodName, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {	    if (args == null) {	        args = ArrayUtils.EMPTY_OBJECT_ARRAY;	    }	    final Class<?>[] parameterTypes = ClassUtils.toClass(args);	    return invokeExactStaticMethod(cls, methodName, args, parameterTypes);	}
protected String getArrayEnd() {	    return arrayEnd;	}
public int size() {	    return size;	}
public String getNewLineText() {	    return newLine;	}
public int capacity() {	    return buffer.length;	}
public static <T extends CharSequence> T notEmpty(final T chars) {	    return notEmpty(chars, DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE);	}
protected String getSummaryObjectEndText() {	    return summaryObjectEndText;	}
@Override	public TimeZone getTimeZone() {	    return timeZone;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static String abbreviate(final String str, int offset, final int maxWidth) {	    if (str == null) {	        return null;	    }	    if (maxWidth < 4) {	        throw new IllegalArgumentException("Minimum abbreviation width is 4");	    }	    if (str.length() <= maxWidth) {	        return str;	    }	    if (offset > str.length()) {	        offset = str.length();	    }	    if (str.length() - offset < maxWidth - 3) {	        offset = str.length() - (maxWidth - 3);	    }	    final String abrevMarker = "...";	    if (offset <= 4) {	        return str.substring(0, maxWidth - 3) + abrevMarker;	    }	    if (maxWidth < 7) {	        throw new IllegalArgumentException("Minimum abbreviation width with offset is 7");	    }	    if (offset + maxWidth - 3 < str.length()) {	        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);	    }	    return abrevMarker + str.substring(str.length() - (maxWidth - 3));	}
public void add(final Number operand) {	    this.value += operand.intValue();	}
public char getEnd() {	    return this.end;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public static String removeEndIgnoreCase(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (endsWithIgnoreCase(str, remove)) {	        return str.substring(0, str.length() - remove.length());	    }	    return str;	}
public int setBoolean(final int holder, final boolean flag) {	    return flag ? set(holder) : clear(holder);	}
public static String repeat(final char ch, final int repeat) {	    final char[] buf = new char[repeat];	    for (int i = repeat - 1; i >= 0; i--) {	        buf[i] = ch;	    }	    return new String(buf);	}
public static String stripToNull(String str) {	    if (str == null) {	        return null;	    }	    str = strip(str, null);	    return str.isEmpty() ? null : str;	}
public static short[] removeElement(final short[] array, final short element) {	    final int index = indexOf(array, element);	    if (index == INDEX_NOT_FOUND) {	        return clone(array);	    }	    return remove(array, index);	}
public void subtract(final Number operand) {	    this.value -= operand.byteValue();	}
public static String stripEnd(final String str, final String stripChars) {	    int end;	    if (str == null || (end = str.length()) == 0) {	        return str;	    }	    if (stripChars == null) {	        while (end != 0 && Character.isWhitespace(str.charAt(end - 1))) {	            end--;	        }	    } else if (stripChars.isEmpty()) {	        return str;	    } else {	        while (end != 0 && stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND) {	            end--;	        }	    }	    return str.substring(0, end);	}
public static short[] removeElement(final short[] array, final short element) {	    final int index = indexOf(array, element);	    if (index == INDEX_NOT_FOUND) {	        return clone(array);	    }	    return remove(array, index);	}
@Override	public String getPattern() {	    return pattern;	}
public static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts) {	    if ((src.length == 0 && srcPos == 0) || 0 == nShorts) {	        return dstInit;	    }	    if ((nShorts - 1) * 16 + dstPos >= 32) {	        throw new IllegalArgumentException("(nShorts-1)*16+dstPos is greather or equal to than 32");	    }	    int out = dstInit;	    int shift = 0;	    for (int i = 0; i < nShorts; i++) {	        shift = i * 16 + dstPos;	        final int bits = (0xffff & src[i + srcPos]) << shift;	        final int mask = 0xffff << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static boolean isAsciiNumeric(final char ch) {	    return ch >= '0' && ch <= '9';	}
public boolean isInfinite() {	    return Float.isInfinite(value);	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static int reflectionHashCode(final Object object, final String... excludeFields) {	    return reflectionHashCode(17, 37, object, false, null, excludeFields);	}
public static float min(final float a, final float b, final float c) {	    return Math.min(Math.min(a, b), c);	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public StrBuilder setLength(final int length) {	    if (length < 0) {	        throw new StringIndexOutOfBoundsException(length);	    }	    if (length < size) {	        size = length;	    } else if (length > size) {	        ensureCapacity(length);	        final int oldEnd = size;	        final int newEnd = length;	        size = length;	        for (int i = oldEnd; i < newEnd; i++) {	            buffer[i] = '\0';	        }	    }	    return this;	}
public static boolean isNumeric(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isDigit(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf) {	    return printer.applyRules(calendar, buf);	}
public static final String escapeHtml4(final String input) {	    return ESCAPE_HTML4.translate(input);	}
public static Boolean[] nullToEmpty(final Boolean[] array) {	    if (array == null || array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    return array;	}
public static Type[] getImplicitLowerBounds(final WildcardType wildcardType) {	    final Type[] bounds = wildcardType.getLowerBounds();	    return bounds.length == 0 ? new Type[] { null } : bounds;	}
public static void isTrue(final boolean expression) {	    if (expression == false) {	        throw new IllegalArgumentException(DEFAULT_IS_TRUE_EX_MESSAGE);	    }	}
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) {	    return new Range<T>(fromInclusive, toInclusive, comparator);	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public static boolean isValidAnnotationMemberType(Class<?> type) {	    if (type == null) {	        return false;	    }	    if (type.isArray()) {	        type = type.getComponentType();	    }	    return type.isPrimitive() || type.isEnum() || type.isAnnotation() || String.class.equals(type) || Class.class.equals(type);	}
public StringBuffer toStringBuffer() {	    return new StringBuffer(size).append(buffer, 0, size);	}
public int toComparison() {	    return comparison;	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public static String stripEnd(final String str, final String stripChars) {	    int end;	    if (str == null || (end = str.length()) == 0) {	        return str;	    }	    if (stripChars == null) {	        while (end != 0 && Character.isWhitespace(str.charAt(end - 1))) {	            end--;	        }	    } else if (stripChars.isEmpty()) {	        return str;	    } else {	        while (end != 0 && stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND) {	            end--;	        }	    }	    return str.substring(0, end);	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, true);	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public static String appendIfMissing(final String str, final CharSequence suffix, final CharSequence... suffixes) {	    return appendIfMissing(str, suffix, false, suffixes);	}
@Override	public int previousIndex() {	    return tokenPos - 1;	}
public String getNewLineText() {	    return newLine;	}
public static String[] splitByCharacterTypeCamelCase(final String str) {	    return splitByCharacterType(str, true);	}
public int size() {	    return size;	}
private static Date set(final Date date, final int calendarField, final int amount) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final Calendar c = Calendar.getInstance();	    c.setLenient(false);	    c.setTime(date);	    c.set(calendarField, amount);	    return c.getTime();	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static Boolean[] nullToEmpty(final Boolean[] array) {	    if (array == null || array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    return array;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static boolean[] hexDigitToBinary(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return new boolean[] { false, false, false, false };	        case '1':	            return new boolean[] { true, false, false, false };	        case '2':	            return new boolean[] { false, true, false, false };	        case '3':	            return new boolean[] { true, true, false, false };	        case '4':	            return new boolean[] { false, false, true, false };	        case '5':	            return new boolean[] { true, false, true, false };	        case '6':	            return new boolean[] { false, true, true, false };	        case '7':	            return new boolean[] { true, true, true, false };	        case '8':	            return new boolean[] { false, false, false, true };	        case '9':	            return new boolean[] { true, false, false, true };	        case 'a':	        case 'A':	            return new boolean[] { false, true, false, true };	        case 'b':	        case 'B':	            return new boolean[] { true, true, false, true };	        case 'c':	        case 'C':	            return new boolean[] { false, false, true, true };	        case 'd':	        case 'D':	            return new boolean[] { true, false, true, true };	        case 'e':	        case 'E':	            return new boolean[] { false, true, true, true };	        case 'f':	        case 'F':	            return new boolean[] { true, true, true, true };	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public Format getParser() {	    return this.parser;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static int lastOrdinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal) {	    return ordinalIndexOf(str, searchStr, ordinal, true);	}
public static <T extends Iterable<?>> T noNullElements(final T iterable) {	    return noNullElements(iterable, DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE);	}
public String getNewLineText() {	    return newLine;	}
@Override	public int hashCode() {	    return toHashCode();	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass) {	    if (throwable == null || type == null) {	        return -1;	    }	    if (fromIndex < 0) {	        fromIndex = 0;	    }	    final Throwable[] throwables = ExceptionUtils.getThrowables(throwable);	    if (fromIndex >= throwables.length) {	        return -1;	    }	    if (subclass) {	        for (int i = fromIndex; i < throwables.length; i++) {	            if (type.isAssignableFrom(throwables[i].getClass())) {	                return i;	            }	        }	    } else {	        for (int i = fromIndex; i < throwables.length; i++) {	            if (type.equals(throwables[i].getClass())) {	                return i;	            }	        }	    }	    return -1;	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public StrBuilder appendFixedWidthPadRight(final int value, final int width, final char padChar) {	    return appendFixedWidthPadRight(String.valueOf(value), width, padChar);	}
public static <T> T CONST(final T v) {	    return v;	}
public static String swapCase(final String str) {	    if (StringUtils.isEmpty(str)) {	        return str;	    }	    final char[] buffer = str.toCharArray();	    boolean whitespace = true;	    for (int i = 0; i < buffer.length; i++) {	        final char ch = buffer[i];	        if (Character.isUpperCase(ch)) {	            buffer[i] = Character.toLowerCase(ch);	            whitespace = false;	        } else if (Character.isTitleCase(ch)) {	            buffer[i] = Character.toLowerCase(ch);	            whitespace = false;	        } else if (Character.isLowerCase(ch)) {	            if (whitespace) {	                buffer[i] = Character.toTitleCase(ch);	                whitespace = false;	            } else {	                buffer[i] = Character.toUpperCase(ch);	            }	        } else {	            whitespace = Character.isWhitespace(ch);	        }	    }	    return new String(buffer);	}
public static void validState(final boolean expression, final String message, final Object... values) {	    if (expression == false) {	        throw new IllegalStateException(String.format(message, values));	    }	}
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) {	    style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));	    return this;	}
public static String right(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(str.length() - len);	}
public static boolean isAlphanumeric(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetterOrDigit(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
@Override	public TimeZone getTimeZone() {	    return timeZone;	}
public static boolean isSameInstant(final Calendar cal1, final Calendar cal2) {	    if (cal1 == null || cal2 == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    return cal1.getTime().getTime() == cal2.getTime().getTime();	}
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, true);	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
@Override	public int compare(final Object obj1, final Object obj2) {	    return ((Comparable) obj1).compareTo(obj2);	}
public String getNewLineText() {	    return newLine;	}
public static Field[] getAllFields(Class<?> cls) {	    final List<Field> allFieldsList = getAllFieldsList(cls);	    return allFieldsList.toArray(new Field[allFieldsList.size()]);	}
public StrBuilder deleteAll(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, -1);	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) {	    final StringBuilder buffer = new StringBuilder();	    boolean lastOutputSeconds = false;	    final int sz = tokens.length;	    for (int i = 0; i < sz; i++) {	        final Token token = tokens[i];	        final Object value = token.getValue();	        final int count = token.getCount();	        if (value instanceof StringBuilder) {	            buffer.append(value.toString());	        } else {	            if (value == y) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years));	                lastOutputSeconds = false;	            } else if (value == M) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months));	                lastOutputSeconds = false;	            } else if (value == d) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days));	                lastOutputSeconds = false;	            } else if (value == H) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours));	                lastOutputSeconds = false;	            } else if (value == m) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes));	                lastOutputSeconds = false;	            } else if (value == s) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds));	                lastOutputSeconds = true;	            } else if (value == S) {	                if (lastOutputSeconds) {	                    milliseconds += 1000;	                    final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds);	                    buffer.append(str.substring(1));	                } else {	                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds));	                }	                lastOutputSeconds = false;	            }	        }	    }	    return buffer.toString();	}
@Override	public int compareTo(final MutableByte other) {	    final byte anotherVal = other.value;	    return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1);	}
@Override	public boolean isUseClassName() {	    return super.isUseClassName();	}
public static boolean isNotEmpty(final CharSequence cs) {	    return !StringUtils.isEmpty(cs);	}
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, true);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase) {	    if (str == null || prefix == null) {	        return str == null && prefix == null;	    }	    if (prefix.length() > str.length()) {	        return false;	    }	    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());	}
@Override	public boolean isDefaultFullDetail() {	    return super.isDefaultFullDetail();	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static boolean isWhitespace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isWhitespace(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public char getEscapeChar() {	    return this.escapeChar;	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
public static String stripEnd(final String str, final String stripChars) {	    int end;	    if (str == null || (end = str.length()) == 0) {	        return str;	    }	    if (stripChars == null) {	        while (end != 0 && Character.isWhitespace(str.charAt(end - 1))) {	            end--;	        }	    } else if (stripChars.isEmpty()) {	        return str;	    } else {	        while (end != 0 && stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND) {	            end--;	        }	    }	    return str.substring(0, end);	}
public static boolean contains(final boolean[] array, final boolean valueToFind) {	    return indexOf(array, valueToFind) != INDEX_NOT_FOUND;	}
@Override	public BasicThreadFactory build() {	    final BasicThreadFactory factory = new BasicThreadFactory(this);	    reset();	    return factory;	}
public boolean isEquals() {	    return this.isEquals;	}
protected boolean isDefaultFullDetail() {	    return defaultFullDetail;	}
@Override	public int compare(final Object obj1, final Object obj2) {	    return ((Comparable) obj1).compareTo(obj2);	}
public static String removePattern(final String source, final String regex) {	    return replacePattern(source, regex, StringUtils.EMPTY);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
protected boolean isFieldSeparatorAtStart() {	    return fieldSeparatorAtStart;	}
@Override	public boolean isUseShortClassName() {	    return super.isUseShortClassName();	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static float max(final float a, final float b, final float c) {	    return Math.max(Math.max(a, b), c);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static StrMatcher charSetMatcher(final String chars) {	    if (StringUtils.isEmpty(chars)) {	        return NONE_MATCHER;	    }	    if (chars.length() == 1) {	        return new CharMatcher(chars.charAt(0));	    }	    return new CharSetMatcher(chars.toCharArray());	}
public char getEscapeChar() {	    return this.escapeChar;	}
public boolean isEmptyTokenAsNull() {	    return this.emptyAsNull;	}
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) {	    style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));	    return this;	}
@Override	public T get() throws ConcurrentException {	    try {	        return getFuture().get();	    } catch (final ExecutionException execex) {	        ConcurrentUtils.handleCause(execex);	        return null;	    } catch (final InterruptedException iex) {	        Thread.currentThread().interrupt();	        throw new ConcurrentException(iex);	    }	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public StrMatcher getVariableSuffixMatcher() {	    return suffixMatcher;	}
public static String random(final int count, final char... chars) {	    if (chars == null) {	        return random(count, 0, 0, false, false, null, RANDOM);	    }	    return random(count, 0, chars.length, false, false, chars, RANDOM);	}
public static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts) {	    if (0 == nShorts) {	        return dst;	    }	    if ((nShorts - 1) * 16 + srcPos >= 32) {	        throw new IllegalArgumentException("(nShorts-1)*16+srcPos is greather or equal to than 32");	    }	    int shift = 0;	    for (int i = 0; i < nShorts; i++) {	        shift = i * 16 + srcPos;	        dst[dstPos + i] = (short) (0xffff & (src >> shift));	    }	    return dst;	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static int hexDigitMsb0ToInt(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return 0x0;	        case '1':	            return 0x8;	        case '2':	            return 0x4;	        case '3':	            return 0xC;	        case '4':	            return 0x2;	        case '5':	            return 0xA;	        case '6':	            return 0x6;	        case '7':	            return 0xE;	        case '8':	            return 0x1;	        case '9':	            return 0x9;	        case 'a':	        case 'A':	            return 0x5;	        case 'b':	        case 'B':	            return 0xD;	        case 'c':	        case 'C':	            return 0x3;	        case 'd':	        case 'D':	            return 0xB;	        case 'e':	        case 'E':	            return 0x7;	        case 'f':	        case 'F':	            return 0xF;	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public static String stripEnd(final String str, final String stripChars) {	    int end;	    if (str == null || (end = str.length()) == 0) {	        return str;	    }	    if (stripChars == null) {	        while (end != 0 && Character.isWhitespace(str.charAt(end - 1))) {	            end--;	        }	    } else if (stripChars.isEmpty()) {	        return str;	    } else {	        while (end != 0 && stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND) {	            end--;	        }	    }	    return str.substring(0, end);	}
public static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools) {	    if ((src.length == 0 && srcPos == 0) || 0 == nBools) {	        return dstInit;	    }	    if (nBools - 1 + dstPos >= 16) {	        throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 16");	    }	    short out = dstInit;	    int shift = 0;	    for (int i = 0; i < nBools; i++) {	        shift = i * 1 + dstPos;	        final int bits = (src[i + srcPos] ? 1 : 0) << shift;	        final int mask = 0x1 << shift;	        out = (short) ((out & ~mask) | bits);	    }	    return out;	}
public Short toShort() {	    return Short.valueOf(shortValue());	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static final String unescapeCsv(final String input) {	    return UNESCAPE_CSV.translate(input);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static String replacePattern(final String source, final String regex, final String replacement) {	    return Pattern.compile(regex, Pattern.DOTALL).matcher(source).replaceAll(replacement);	}
public static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes) {	    if ((src.length == 0 && srcPos == 0) || 0 == nBytes) {	        return dstInit;	    }	    if ((nBytes - 1) * 8 + dstPos >= 64) {	        throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 64");	    }	    long out = dstInit;	    int shift = 0;	    for (int i = 0; i < nBytes; i++) {	        shift = i * 8 + dstPos;	        final long bits = (0xffL & src[i + srcPos]) << shift;	        final long mask = 0xffL << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
public String getNewLineText() {	    return newLine;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public String getNewLineText() {	    return newLine;	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
static Pair<IDKey, IDKey> getRegisterPair(final Object lhs, final Object rhs) {	    final IDKey left = new IDKey(lhs);	    final IDKey right = new IDKey(rhs);	    return Pair.of(left, right);	}
public static String hex(final int codepoint) {	    return Integer.toHexString(codepoint).toUpperCase(Locale.ENGLISH);	}
public StrTokenizer setQuoteChar(final char quote) {	    return setQuoteMatcher(StrMatcher.charMatcher(quote));	}
public static String formatUTC(final Date date, final String pattern, final Locale locale) {	    return format(date, pattern, UTC_TIME_ZONE, locale);	}
public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {	    if (str == null || searchStr == null) {	        return INDEX_NOT_FOUND;	    }	    if (startPos > str.length() - searchStr.length()) {	        startPos = str.length() - searchStr.length();	    }	    if (startPos < 0) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return startPos;	    }	    for (int i = startPos; i >= 0; i--) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public int capacity() {	    return buffer.length;	}
public char getStart() {	    return this.start;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
@Override	public int compareTo(final MutableLong other) {	    final long anotherVal = other.value;	    return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1);	}
public static String rightPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return rightPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return str.concat(padStr);	    } else if (pads < padLen) {	        return str.concat(padStr.substring(0, pads));	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return str.concat(new String(padding));	    }	}
public int size() {	    return size;	}
public static String leftPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return leftPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return padStr.concat(str);	    } else if (pads < padLen) {	        return padStr.substring(0, pads).concat(str);	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return new String(padding).concat(str);	    }	}
public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale) {	    return cache.getTimeInstance(style, timeZone, locale);	}
@Override	public String lookup(final String key) {	    if (map == null) {	        return null;	    }	    final Object obj = map.get(key);	    if (obj == null) {	        return null;	    }	    return obj.toString();	}
protected String getArrayStart() {	    return arrayStart;	}
protected String getSummaryObjectStartText() {	    return summaryObjectStartText;	}
public void subtract(final Number operand) {	    this.value -= operand.shortValue();	}
public static String substringBetween(final String str, final String open, final String close) {	    if (str == null || open == null || close == null) {	        return null;	    }	    final int start = str.indexOf(open);	    if (start != INDEX_NOT_FOUND) {	        final int end = str.indexOf(close, start + open.length());	        if (end != INDEX_NOT_FOUND) {	            return str.substring(start + open.length(), end);	        }	    }	    return null;	}
public StrBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar) {	    return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);	}
public short setShortValue(final short holder, final short value) {	    return (short) setValue(holder, value);	}
private static boolean endsWith(final CharSequence str, final CharSequence suffix, final boolean ignoreCase) {	    if (str == null || suffix == null) {	        return str == null && suffix == null;	    }	    if (suffix.length() > str.length()) {	        return false;	    }	    final int strOffset = str.length() - suffix.length();	    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, suffix, 0, suffix.length());	}
public static boolean isAlpha(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {	    if (str == null || searchStr == null) {	        return INDEX_NOT_FOUND;	    }	    if (startPos < 0) {	        startPos = 0;	    }	    final int endLimit = str.length() - searchStr.length() + 1;	    if (startPos > endLimit) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return startPos;	    }	    for (int i = startPos; i < endLimit; i++) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public static String random(final int count, final char... chars) {	    if (chars == null) {	        return random(count, 0, 0, false, false, null, RANDOM);	    }	    return random(count, 0, chars.length, false, false, chars, RANDOM);	}
public int capacity() {	    return buffer.length;	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public String getNewLineText() {	    return newLine;	}
public static String capitalize(final String str) {	    int strLen;	    if (str == null || (strLen = str.length()) == 0) {	        return str;	    }	    char firstChar = str.charAt(0);	    if (Character.isTitleCase(firstChar)) {	        return str;	    }	    return new StringBuilder(strLen).append(Character.toTitleCase(firstChar)).append(str.substring(1)).toString();	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
protected boolean isUseShortClassName() {	    return useShortClassName;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
@Override	public int length() {	    return size;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
protected boolean isArrayContentDetail() {	    return arrayContentDetail;	}
private static boolean endsWith(final CharSequence str, final CharSequence suffix, final boolean ignoreCase) {	    if (str == null || suffix == null) {	        return str == null && suffix == null;	    }	    if (suffix.length() > str.length()) {	        return false;	    }	    final int strOffset = str.length() - suffix.length();	    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, suffix, 0, suffix.length());	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
protected String getSummaryObjectEndText() {	    return summaryObjectEndText;	}
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = Integer.MAX_VALUE;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.indexOf(str, search, 0);	        if (tmp == INDEX_NOT_FOUND) {	            continue;	        }	        if (tmp < ret) {	            ret = tmp;	        }	    }	    return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static <T extends CharSequence> T notBlank(final T chars) {	    return notBlank(chars, DEFAULT_NOT_BLANK_EX_MESSAGE);	}
@Override	public TimeZone getTimeZone() {	    return mTimeZone;	}
public static Iterator<?> iterator(final Object focus, final int rangeStyle) {	    if (focus == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (focus instanceof Date) {	        return iterator((Date) focus, rangeStyle);	    } else if (focus instanceof Calendar) {	        return iterator((Calendar) focus, rangeStyle);	    } else {	        throw new ClassCastException("Could not iterate based on " + focus);	    }	}
public static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    final int beSrcPos = src.length - 1 - srcPos;	    final int srcLen = Math.min(4, beSrcPos + 1);	    final boolean[] paddedSrc = new boolean[4];	    System.arraycopy(src, beSrcPos + 1 - srcLen, paddedSrc, 4 - srcLen, srcLen);	    src = paddedSrc;	    srcPos = 0;	    if (src[srcPos]) {	        if (src.length > srcPos + 1 && src[srcPos + 1]) {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 1 && src[srcPos + 1]) {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
static Set<Pair<IDKey, IDKey>> getRegistry() {	    return REGISTRY.get();	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static boolean isAlphaSpace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false && cs.charAt(i) != ' ') {	            return false;	        }	    }	    return true;	}
public static boolean isSameDay(final Calendar cal1, final Calendar cal2) {	    if (cal1 == null || cal2 == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    return (cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR));	}
public String substring(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    return new String(buffer, startIndex, endIndex - startIndex);	}
public StrBuilder appendSeparator(final char separator, final int loopIndex) {	    if (loopIndex > 0) {	        append(separator);	    }	    return this;	}
public boolean isAfterRange(final Range<T> otherRange) {	    if (otherRange == null) {	        return false;	    }	    return isAfter(otherRange.maximum);	}
public Writer asWriter() {	    return new StrBuilderWriter();	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
@Override	public int length() {	    return size;	}
public ReflectionToStringBuilder setExcludeFieldNames(final String... excludeFieldNamesParam) {	    if (excludeFieldNamesParam == null) {	        this.excludeFieldNames = null;	    } else {	        this.excludeFieldNames = toNoNullStringArray(excludeFieldNamesParam);	        Arrays.sort(this.excludeFieldNames);	    }	    return this;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public static boolean isAsciiAlpha(final char ch) {	    return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public static String trimToNull(final String str) {	    final String ts = trim(str);	    return isEmpty(ts) ? null : ts;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static String[] stripAll(final String[] strs, final String stripChars) {	    int strsLen;	    if (strs == null || (strsLen = strs.length) == 0) {	        return strs;	    }	    final String[] newArr = new String[strsLen];	    for (int i = 0; i < strsLen; i++) {	        newArr[i] = strip(strs[i], stripChars);	    }	    return newArr;	}
public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) {	    if (cls == null) {	        throw new IllegalArgumentException("The class must not be null");	    }	    if (fieldName == null) {	        throw new IllegalArgumentException("The field name must not be null");	    }	    for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) {	        try {	            final Field field = acls.getDeclaredField(fieldName);	            if (!Modifier.isPublic(field.getModifiers())) {	                if (forceAccess) {	                    field.setAccessible(true);	                } else {	                    continue;	                }	            }	            return field;	        } catch (final NoSuchFieldException ex) {	        }	    }	    Field match = null;	    for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) {	        try {	            final Field test = ((Class<?>) class1).getField(fieldName);	            if (match != null) {	                throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + "; a matching field exists on two or more implemented interfaces.");	            }	            match = test;	        } catch (final NoSuchFieldException ex) {	        }	    }	    return match;	}
static void register(final Object lhs, final Object rhs) {	    synchronized (EqualsBuilder.class) {	        if (getRegistry() == null) {	            REGISTRY.set(new HashSet<Pair<IDKey, IDKey>>());	        }	    }	    final Set<Pair<IDKey, IDKey>> registry = getRegistry();	    final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);	    registry.add(pair);	}
public static CharRange isNot(final char ch) {	    return new CharRange(ch, ch, true);	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public static String difference(final String str1, final String str2) {	    if (str1 == null) {	        return str2;	    }	    if (str2 == null) {	        return str1;	    }	    final int at = indexOfDifference(str1, str2);	    if (at == INDEX_NOT_FOUND) {	        return EMPTY;	    }	    return str2.substring(at);	}
protected String getSizeStartText() {	    return sizeStartText;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
private static boolean endsWith(final CharSequence str, final CharSequence suffix, final boolean ignoreCase) {	    if (str == null || suffix == null) {	        return str == null && suffix == null;	    }	    if (suffix.length() > str.length()) {	        return false;	    }	    final int strOffset = str.length() - suffix.length();	    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, suffix, 0, suffix.length());	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public boolean isFalse() {	    return value == false;	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
public static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    final int beSrcPos = src.length - 1 - srcPos;	    final int srcLen = Math.min(4, beSrcPos + 1);	    final boolean[] paddedSrc = new boolean[4];	    System.arraycopy(src, beSrcPos + 1 - srcLen, paddedSrc, 4 - srcLen, srcLen);	    src = paddedSrc;	    srcPos = 0;	    if (src[srcPos]) {	        if (src.length > srcPos + 1 && src[srcPos + 1]) {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 1 && src[srcPos + 1]) {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
public StrBuilder deleteCharAt(final int index) {	    if (index < 0 || index >= size) {	        throw new StringIndexOutOfBoundsException(index);	    }	    deleteImpl(index, index + 1, 1);	    return this;	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
@Override	public boolean ready() {	    return pos < StrBuilder.this.size();	}
@Override	public String toString() {	    if (this.getObject() == null) {	        return this.getStyle().getNullText();	    }	    Class<?> clazz = this.getObject().getClass();	    this.appendFieldsIn(clazz);	    while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {	        clazz = clazz.getSuperclass();	        this.appendFieldsIn(clazz);	    }	    return super.toString();	}
public static final String escapeCsv(final String input) {	    return ESCAPE_CSV.translate(input);	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public static String random(final int count, final char... chars) {	    if (chars == null) {	        return random(count, 0, 0, false, false, null, RANDOM);	    }	    return random(count, 0, chars.length, false, false, chars, RANDOM);	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
@Override	public boolean equals(final Object obj) {	    if (this == obj) {	        return true;	    }	    if (!(obj instanceof ConstantInitializer<?>)) {	        return false;	    }	    final ConstantInitializer<?> c = (ConstantInitializer<?>) obj;	    return ObjectUtils.equals(getObject(), c.getObject());	}
public static <L, R> MutablePair<L, R> of(final L left, final R right) {	    return new MutablePair<L, R>(left, right);	}
public static List<Locale> languagesByCountry(final String countryCode) {	    if (countryCode == null) {	        return Collections.emptyList();	    }	    List<Locale> langs = cLanguagesByCountry.get(countryCode);	    if (langs == null) {	        langs = new ArrayList<Locale>();	        final List<Locale> locales = availableLocaleList();	        for (int i = 0; i < locales.size(); i++) {	            final Locale locale = locales.get(i);	            if (countryCode.equals(locale.getCountry()) && locale.getVariant().isEmpty()) {	                langs.add(locale);	            }	        }	        langs = Collections.unmodifiableList(langs);	        cLanguagesByCountry.putIfAbsent(countryCode, langs);	        langs = cLanguagesByCountry.get(countryCode);	    }	    return langs;	}
public int capacity() {	    return buffer.length;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static boolean isEmpty(final boolean[] array) {	    return array == null || array.length == 0;	}
public static int lastIndexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = INDEX_NOT_FOUND;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.lastIndexOf(str, search, str.length());	        if (tmp > ret) {	            ret = tmp;	        }	    }	    return ret;	}
public static boolean[] hexDigitToBinary(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return new boolean[] { false, false, false, false };	        case '1':	            return new boolean[] { true, false, false, false };	        case '2':	            return new boolean[] { false, true, false, false };	        case '3':	            return new boolean[] { true, true, false, false };	        case '4':	            return new boolean[] { false, false, true, false };	        case '5':	            return new boolean[] { true, false, true, false };	        case '6':	            return new boolean[] { false, true, true, false };	        case '7':	            return new boolean[] { true, true, true, false };	        case '8':	            return new boolean[] { false, false, false, true };	        case '9':	            return new boolean[] { true, false, false, true };	        case 'a':	        case 'A':	            return new boolean[] { false, true, false, true };	        case 'b':	        case 'B':	            return new boolean[] { true, true, false, true };	        case 'c':	        case 'C':	            return new boolean[] { false, false, true, true };	        case 'd':	        case 'D':	            return new boolean[] { true, false, true, true };	        case 'e':	        case 'E':	            return new boolean[] { false, true, true, true };	        case 'f':	        case 'F':	            return new boolean[] { true, true, true, true };	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public String getNewLineText() {	    return newLine;	}
@Override	public boolean ready() {	    return pos < StrBuilder.this.size();	}
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) {	    if (str == null) {	        if (trueString == null) {	            return Boolean.TRUE;	        }	        if (falseString == null) {	            return Boolean.FALSE;	        }	        if (nullString == null) {	            return null;	        }	    } else if (str.equals(trueString)) {	        return Boolean.TRUE;	    } else if (str.equals(falseString)) {	        return Boolean.FALSE;	    } else if (str.equals(nullString)) {	        return null;	    }	    throw new IllegalArgumentException("The String did not match any specified value");	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
@Override	public char charAt(final int index) {	    if (index < 0 || index >= length()) {	        throw new StringIndexOutOfBoundsException(index);	    }	    return buffer[index];	}
public String getNullText() {	    return nullText;	}
@Override	public int compareTo(final MutableShort other) {	    final short anotherVal = other.value;	    return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1);	}
public static String formatPeriodISO(final long startMillis, final long endMillis) {	    return formatPeriod(startMillis, endMillis, ISO_EXTENDED_FORMAT_PATTERN, false, TimeZone.getDefault());	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public String getNewLineText() {	    return newLine;	}
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) {	    if (str == null) {	        if (trueString == null) {	            return Boolean.TRUE;	        }	        if (falseString == null) {	            return Boolean.FALSE;	        }	        if (nullString == null) {	            return null;	        }	    } else if (str.equals(trueString)) {	        return Boolean.TRUE;	    } else if (str.equals(falseString)) {	        return Boolean.FALSE;	    } else if (str.equals(nullString)) {	        return null;	    }	    throw new IllegalArgumentException("The String did not match any specified value");	}
@Override	public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) {	    return formatter.format(obj, toAppendTo, pos);	}
public boolean isEmpty() {	    return size == 0;	}
public boolean isAppendTransients() {	    return this.appendTransients;	}
public static int indexOfDifference(final CharSequence... css) {	    if (css == null || css.length <= 1) {	        return INDEX_NOT_FOUND;	    }	    boolean anyStringNull = false;	    boolean allStringsNull = true;	    final int arrayLen = css.length;	    int shortestStrLen = Integer.MAX_VALUE;	    int longestStrLen = 0;	    for (int i = 0; i < arrayLen; i++) {	        if (css[i] == null) {	            anyStringNull = true;	            shortestStrLen = 0;	        } else {	            allStringsNull = false;	            shortestStrLen = Math.min(css[i].length(), shortestStrLen);	            longestStrLen = Math.max(css[i].length(), longestStrLen);	        }	    }	    if (allStringsNull || longestStrLen == 0 && !anyStringNull) {	        return INDEX_NOT_FOUND;	    }	    if (shortestStrLen == 0) {	        return 0;	    }	    int firstDiff = -1;	    for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {	        final char comparisonChar = css[0].charAt(stringPos);	        for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {	            if (css[arrayPos].charAt(stringPos) != comparisonChar) {	                firstDiff = stringPos;	                break;	            }	        }	        if (firstDiff != -1) {	            break;	        }	    }	    if (firstDiff == -1 && shortestStrLen != longestStrLen) {	        return shortestStrLen;	    }	    return firstDiff;	}
public String getNewLineText() {	    return newLine;	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public int size() {	    return size;	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public static String substringBefore(final String str, final String separator) {	    if (isEmpty(str) || separator == null) {	        return str;	    }	    if (separator.isEmpty()) {	        return EMPTY;	    }	    final int pos = str.indexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return str;	    }	    return str.substring(0, pos);	}
public boolean isNegated() {	    return negated;	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public static short toShort(final String str, final short defaultValue) {	    if (str == null) {	        return defaultValue;	    }	    try {	        return Short.parseShort(str);	    } catch (final NumberFormatException nfe) {	        return defaultValue;	    }	}
Object getValue() {	    return value;	}
@Override	public boolean ready() {	    return pos < StrBuilder.this.size();	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static String chop(final String str) {	    if (str == null) {	        return null;	    }	    final int strLen = str.length();	    if (strLen < 2) {	        return EMPTY;	    }	    final int lastIdx = strLen - 1;	    final String ret = str.substring(0, lastIdx);	    final char last = str.charAt(lastIdx);	    if (last == CharUtils.LF && ret.charAt(lastIdx - 1) == CharUtils.CR) {	        return ret.substring(0, lastIdx - 1);	    }	    return ret;	}
@Override	public int length() {	    return size;	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public static boolean endsWithAny(final CharSequence string, final CharSequence... searchStrings) {	    if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {	        return false;	    }	    for (final CharSequence searchString : searchStrings) {	        if (StringUtils.endsWith(string, searchString)) {	            return true;	        }	    }	    return false;	}
public static <T extends CharSequence> T validIndex(final T chars, final int index) {	    return validIndex(chars, index, DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE, Integer.valueOf(index));	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
@Override	public String toString() {	    return "FastDatePrinter[" + mPattern + "," + mLocale + "," + mTimeZone.getID() + "]";	}
public StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, 1);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    buffer.append(arrayStart);	    for (int i = 0; i < array.length; i++) {	        if (i > 0) {	            buffer.append(arraySeparator);	        }	        appendDetail(buffer, fieldName, array[i]);	    }	    buffer.append(arrayEnd);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
protected List<String> tokenize(final char[] chars, final int offset, final int count) {	    if (chars == null || count == 0) {	        return Collections.emptyList();	    }	    final StrBuilder buf = new StrBuilder();	    final List<String> tokens = new ArrayList<String>();	    int pos = offset;	    while (pos >= 0 && pos < count) {	        pos = readNextToken(chars, pos, count, buf, tokens);	        if (pos >= count) {	            addToken(tokens, "");	        }	    }	    return tokens;	}
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) {	    return new Range<T>(fromInclusive, toInclusive, comparator);	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
@Override	public int compareTo(final MutableByte other) {	    final byte anotherVal = other.value;	    return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1);	}
@Override	public int length() {	    return size;	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public StrBuilder deleteAll(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, -1);	}
public boolean contains(final StrMatcher matcher) {	    return indexOf(matcher, 0) >= 0;	}
protected String getSummaryObjectStartText() {	    return summaryObjectStartText;	}
public static void writeField(final Object target, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException {	    if (target == null) {	        throw new IllegalArgumentException("target object must not be null");	    }	    final Class<?> cls = target.getClass();	    final Field field = getField(cls, fieldName, forceAccess);	    if (field == null) {	        throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName);	    }	    writeField(field, target, value);	}
public static <T extends Comparable<? super T>> int compare(final T c1, final T c2, final boolean nullGreater) {	    if (c1 == c2) {	        return 0;	    } else if (c1 == null) {	        return nullGreater ? 1 : -1;	    } else if (c2 == null) {	        return nullGreater ? -1 : 1;	    }	    return c1.compareTo(c2);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public String getNewLineText() {	    return newLine;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
static boolean isRegistered(final Object lhs, final Object rhs) {	    final Set<Pair<IDKey, IDKey>> registry = getRegistry();	    final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);	    final Pair<IDKey, IDKey> swappedPair = Pair.of(pair.getLeft(), pair.getRight());	    return registry != null && (registry.contains(pair) || registry.contains(swappedPair));	}
public static String lowerCase(final String str, final Locale locale) {	    if (str == null) {	        return null;	    }	    return str.toLowerCase(locale);	}
@Override	public int length() {	    return size;	}
public boolean isEmpty() {	    return size == 0;	}
public boolean isEquals() {	    return this.isEquals;	}
@Override	public StringBuffer format(final Calendar calendar, final StringBuffer buf) {	    return applyRules(calendar, buf);	}
public static <L, M, R> MutableTriple<L, M, R> of(final L left, final M middle, final R right) {	    return new MutableTriple<L, M, R>(left, middle, right);	}
public static void handleCauseUnchecked(final ExecutionException ex) {	    final ConcurrentRuntimeException crex = extractCauseUnchecked(ex);	    if (crex != null) {	        throw crex;	    }	}
protected boolean isUseFieldNames() {	    return useFieldNames;	}
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {	    if (array == null) {	        if (index != 0) {	            throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0");	        }	        final Object joinedArray = Array.newInstance(clss, 1);	        Array.set(joinedArray, 0, element);	        return joinedArray;	    }	    final int length = Array.getLength(array);	    if (index > length || index < 0) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(clss, length + 1);	    System.arraycopy(array, 0, result, 0, index);	    Array.set(result, index, element);	    if (index < length) {	        System.arraycopy(array, index, result, index + 1, length - index);	    }	    return result;	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public String midString(int index, final int length) {	    if (index < 0) {	        index = 0;	    }	    if (length <= 0 || index >= size) {	        return "";	    }	    if (size <= index + length) {	        return new String(buffer, index, size - index);	    }	    return new String(buffer, index, length);	}
protected String getSummaryObjectStartText() {	    return summaryObjectStartText;	}
private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase) {	    if (str == null || prefix == null) {	        return str == null && prefix == null;	    }	    if (prefix.length() > str.length()) {	        return false;	    }	    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());	}
public int capacity() {	    return buffer.length;	}
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException {	    return charsetName == null ? new String(bytes) : new String(bytes, charsetName);	}
public int toHashCode() {	    return iTotal;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static String[] splitByWholeSeparatorPreserveAllTokens(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, true);	}
public static String abbreviate(final String str, int offset, final int maxWidth) {	    if (str == null) {	        return null;	    }	    if (maxWidth < 4) {	        throw new IllegalArgumentException("Minimum abbreviation width is 4");	    }	    if (str.length() <= maxWidth) {	        return str;	    }	    if (offset > str.length()) {	        offset = str.length();	    }	    if (str.length() - offset < maxWidth - 3) {	        offset = str.length() - (maxWidth - 3);	    }	    final String abrevMarker = "...";	    if (offset <= 4) {	        return str.substring(0, maxWidth - 3) + abrevMarker;	    }	    if (maxWidth < 7) {	        throw new IllegalArgumentException("Minimum abbreviation width with offset is 7");	    }	    if (offset + maxWidth - 3 < str.length()) {	        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);	    }	    return abrevMarker + str.substring(str.length() - (maxWidth - 3));	}
public boolean isBefore(final T element) {	    if (element == null) {	        return false;	    }	    return comparator.compare(element, maximum) > 0;	}
@Override	public boolean equals(final Object obj) {	    if (obj == this) {	        return true;	    }	    if (obj instanceof Fraction == false) {	        return false;	    }	    final Fraction other = (Fraction) obj;	    return getNumerator() == other.getNumerator() && getDenominator() == other.getDenominator();	}
protected boolean isArrayContentDetail() {	    return arrayContentDetail;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher) {	    if (prefixMatcher == null) {	        throw new IllegalArgumentException("Variable prefix matcher must not be null!");	    }	    this.prefixMatcher = prefixMatcher;	    return this;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static UnicodeEscaper above(final int codepoint) {	    return outsideOf(0, codepoint);	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public void getChars(final int startIndex, final int endIndex, final char[] destination, final int destinationIndex) {	    if (startIndex < 0) {	        throw new StringIndexOutOfBoundsException(startIndex);	    }	    if (endIndex < 0 || endIndex > length()) {	        throw new StringIndexOutOfBoundsException(endIndex);	    }	    if (startIndex > endIndex) {	        throw new StringIndexOutOfBoundsException("end < start");	    }	    System.arraycopy(buffer, startIndex, destination, destinationIndex, endIndex - startIndex);	}
@Override	public int length() {	    return size;	}
public static String right(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(str.length() - len);	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
public boolean booleanValue() {	    return value;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public String toString(final String format) {	    return String.format(format, minimum, maximum, comparator);	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public boolean isNegated() {	    return negated;	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public short setShort(final short holder) {	    return (short) set(holder);	}
public static int indexOfDifference(final CharSequence... css) {	    if (css == null || css.length <= 1) {	        return INDEX_NOT_FOUND;	    }	    boolean anyStringNull = false;	    boolean allStringsNull = true;	    final int arrayLen = css.length;	    int shortestStrLen = Integer.MAX_VALUE;	    int longestStrLen = 0;	    for (int i = 0; i < arrayLen; i++) {	        if (css[i] == null) {	            anyStringNull = true;	            shortestStrLen = 0;	        } else {	            allStringsNull = false;	            shortestStrLen = Math.min(css[i].length(), shortestStrLen);	            longestStrLen = Math.max(css[i].length(), longestStrLen);	        }	    }	    if (allStringsNull || longestStrLen == 0 && !anyStringNull) {	        return INDEX_NOT_FOUND;	    }	    if (shortestStrLen == 0) {	        return 0;	    }	    int firstDiff = -1;	    for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {	        final char comparisonChar = css[0].charAt(stringPos);	        for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {	            if (css[arrayPos].charAt(stringPos) != comparisonChar) {	                firstDiff = stringPos;	                break;	            }	        }	        if (firstDiff != -1) {	            break;	        }	    }	    if (firstDiff == -1 && shortestStrLen != longestStrLen) {	        return shortestStrLen;	    }	    return firstDiff;	}
protected String getFieldSeparator() {	    return fieldSeparator;	}
public boolean isEmpty() {	    return size == 0;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
protected ScheduledFuture<?> startTimer() {	    return getExecutorService().scheduleAtFixedRate(new Runnable() {		        @Override	        public void run() {	            endOfPeriod();	        }	    }, getPeriod(), getPeriod(), getUnit());	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static float min(final float a, final float b, final float c) {	    return Math.min(Math.min(a, b), c);	}
public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale) {	    return cache.getTimeInstance(style, timeZone, locale);	}
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) {	    if (bool == null) {	        return nullValue;	    }	    return bool.booleanValue() ? trueValue : falseValue;	}
public static Map<TypeVariable<?>, Type> determineTypeArguments(final Class<?> cls, final ParameterizedType superType) {	    final Class<?> superClass = getRawType(superType);	    if (!isAssignable(cls, superClass)) {	        return null;	    }	    if (cls.equals(superClass)) {	        return getTypeArguments(superType, superClass, null);	    }	    final Type midType = getClosestParentType(cls, superClass);	    if (midType instanceof Class<?>) {	        return determineTypeArguments((Class<?>) midType, superType);	    }	    final ParameterizedType midParameterizedType = (ParameterizedType) midType;	    final Class<?> midClass = getRawType(midParameterizedType);	    final Map<TypeVariable<?>, Type> typeVarAssigns = determineTypeArguments(midClass, superType);	    mapTypeVariablesToArguments(cls, midParameterizedType, typeVarAssigns);	    return typeVarAssigns;	}
public boolean isEmpty() {	    return size == 0;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
protected void setDefaultFullDetail(final boolean defaultFullDetail) {	    this.defaultFullDetail = defaultFullDetail;	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
public int size() {	    return size;	}
public static Boolean or(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
public static void isInstanceOf(final Class<?> type, final Object obj, final String message, final Object... values) {	    if (type.isInstance(obj) == false) {	        throw new IllegalArgumentException(String.format(message, values));	    }	}
protected boolean isUseClassName() {	    return useClassName;	}
public String getNewLineText() {	    return newLine;	}
@Deprecated	public static String chomp(final String str, final String separator) {	    return removeEnd(str, separator);	}
public static float max(final float a, final float b, final float c) {	    return Math.max(Math.max(a, b), c);	}
public static <T> T CONST(final T v) {	    return v;	}
static boolean isRegistered(final Object lhs, final Object rhs) {	    final Set<Pair<IDKey, IDKey>> registry = getRegistry();	    final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);	    final Pair<IDKey, IDKey> swappedPair = Pair.of(pair.getLeft(), pair.getRight());	    return registry != null && (registry.contains(pair) || registry.contains(swappedPair));	}
public int capacity() {	    return buffer.length;	}
public StrBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar) {	    return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public static String replaceChars(final String str, final String searchChars, String replaceChars) {	    if (isEmpty(str) || isEmpty(searchChars)) {	        return str;	    }	    if (replaceChars == null) {	        replaceChars = EMPTY;	    }	    boolean modified = false;	    final int replaceCharsLength = replaceChars.length();	    final int strLength = str.length();	    final StringBuilder buf = new StringBuilder(strLength);	    for (int i = 0; i < strLength; i++) {	        final char ch = str.charAt(i);	        final int index = searchChars.indexOf(ch);	        if (index >= 0) {	            modified = true;	            if (index < replaceCharsLength) {	                buf.append(replaceChars.charAt(index));	            }	        } else {	            buf.append(ch);	        }	    }	    if (modified) {	        return buf.toString();	    }	    return str;	}
public static String prependIfMissing(final String str, final CharSequence prefix, final CharSequence... prefixes) {	    return prependIfMissing(str, prefix, false, prefixes);	}
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) {	    if (str == null) {	        if (trueString == null) {	            return Boolean.TRUE;	        }	        if (falseString == null) {	            return Boolean.FALSE;	        }	        if (nullString == null) {	            return null;	        }	    } else if (str.equals(trueString)) {	        return Boolean.TRUE;	    } else if (str.equals(falseString)) {	        return Boolean.FALSE;	    } else if (str.equals(nullString)) {	        return null;	    }	    throw new IllegalArgumentException("The String did not match any specified value");	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public int capacity() {	    return buffer.length;	}
public static String substringBefore(final String str, final String separator) {	    if (isEmpty(str) || separator == null) {	        return str;	    }	    if (separator.isEmpty()) {	        return EMPTY;	    }	    final int pos = str.indexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return str;	    }	    return str.substring(0, pos);	}
public static <T> T CONST(final T v) {	    return v;	}
public int capacity() {	    return buffer.length;	}
@Override	public M getMiddle() {	    return middle;	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public static String removeEnd(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.endsWith(remove)) {	        return str.substring(0, str.length() - remove.length());	    }	    return str;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public int capacity() {	    return buffer.length;	}
@Override	public T get() throws ConcurrentException {	    return getObject();	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public String getNullText() {	    return nullText;	}
@Override	public int compare(final Object obj1, final Object obj2) {	    return ((Comparable) obj1).compareTo(obj2);	}
public char getEscapeChar() {	    return this.escapeChar;	}
public StrTokenizer setDelimiterChar(final char delim) {	    return setDelimiterMatcher(StrMatcher.charMatcher(delim));	}
public boolean isIgnoreEmptyTokens() {	    return ignoreEmptyTokens;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public static String rightPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return rightPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return str.concat(padStr);	    } else if (pads < padLen) {	        return str.concat(padStr.substring(0, pads));	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return str.concat(new String(padding));	    }	}
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = Integer.MAX_VALUE;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.indexOf(str, search, 0);	        if (tmp == INDEX_NOT_FOUND) {	            continue;	        }	        if (tmp < ret) {	            ret = tmp;	        }	    }	    return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;	}
public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException {	    return parseDateWithLeniency(str, locale, parsePatterns, true);	}
protected String getSizeEndText() {	    return sizeEndText;	}
public static List<Class<?>> convertClassNamesToClasses(final List<String> classNames) {	    if (classNames == null) {	        return null;	    }	    final List<Class<?>> classes = new ArrayList<Class<?>>(classNames.size());	    for (final String className : classNames) {	        try {	            classes.add(Class.forName(className));	        } catch (final Exception ex) {	            classes.add(null);	        }	    }	    return classes;	}
public String getNullText() {	    return nullText;	}
@Deprecated	public static String chomp(final String str, final String separator) {	    return removeEnd(str, separator);	}
public Long toLong() {	    return Long.valueOf(longValue());	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static Number createNumber(final String str) throws NumberFormatException {	    if (str == null) {	        return null;	    }	    if (StringUtils.isBlank(str)) {	        throw new NumberFormatException("A blank string is not a valid number");	    }	    final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" };	    int pfxLen = 0;	    for (final String pfx : hex_prefixes) {	        if (str.startsWith(pfx)) {	            pfxLen += pfx.length();	            break;	        }	    }	    if (pfxLen > 0) {	        final int hexDigits = str.length() - pfxLen;	        if (hexDigits > 16) {	            return createBigInteger(str);	        }	        if (hexDigits > 8) {	            return createLong(str);	        }	        return createInteger(str);	    }	    final char lastChar = str.charAt(str.length() - 1);	    String mant;	    String dec;	    String exp;	    final int decPos = str.indexOf('.');	    final int expPos = str.indexOf('e') + str.indexOf('E') + 1;	    int numDecimals = 0;	    if (decPos > -1) {	        if (expPos > -1) {	            if (expPos < decPos || expPos > str.length()) {	                throw new NumberFormatException(str + " is not a valid number.");	            }	            dec = str.substring(decPos + 1, expPos);	        } else {	            dec = str.substring(decPos + 1);	        }	        mant = str.substring(0, decPos);	        numDecimals = dec.length();	    } else {	        if (expPos > -1) {	            if (expPos > str.length()) {	                throw new NumberFormatException(str + " is not a valid number.");	            }	            mant = str.substring(0, expPos);	        } else {	            mant = str;	        }	        dec = null;	    }	    if (!Character.isDigit(lastChar) && lastChar != '.') {	        if (expPos > -1 && expPos < str.length() - 1) {	            exp = str.substring(expPos + 1, str.length() - 1);	        } else {	            exp = null;	        }	        final String numeric = str.substring(0, str.length() - 1);	        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);	        switch(lastChar) {	            case 'l':	            case 'L':	                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {	                    try {	                        return createLong(numeric);	                    } catch (final NumberFormatException nfe) {	                    }	                    return createBigInteger(numeric);	                }	                throw new NumberFormatException(str + " is not a valid number.");	            case 'f':	            case 'F':	                try {	                    final Float f = NumberUtils.createFloat(numeric);	                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {	                        return f;	                    }	                } catch (final NumberFormatException nfe) {	                }	            case 'd':	            case 'D':	                try {	                    final Double d = NumberUtils.createDouble(numeric);	                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {	                        return d;	                    }	                } catch (final NumberFormatException nfe) {	                }	                try {	                    return createBigDecimal(numeric);	                } catch (final NumberFormatException e) {	                }	            default:	                throw new NumberFormatException(str + " is not a valid number.");	        }	    }	    if (expPos > -1 && expPos < str.length() - 1) {	        exp = str.substring(expPos + 1, str.length());	    } else {	        exp = null;	    }	    if (dec == null && exp == null) {	        try {	            return createInteger(str);	        } catch (final NumberFormatException nfe) {	        }	        try {	            return createLong(str);	        } catch (final NumberFormatException nfe) {	        }	        return createBigInteger(str);	    }	    final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);	    try {	        if (numDecimals <= 7) {	            final Float f = createFloat(str);	            if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {	                return f;	            }	        }	    } catch (final NumberFormatException nfe) {	    }	    try {	        if (numDecimals <= 16) {	            final Double d = createDouble(str);	            if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {	                return d;	            }	        }	    } catch (final NumberFormatException nfe) {	    }	    return createBigDecimal(str);	}
@Override	public String toString() {	    if (this.getObject() == null) {	        return this.getStyle().getNullText();	    }	    Class<?> clazz = this.getObject().getClass();	    this.appendFieldsIn(clazz);	    while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {	        clazz = clazz.getSuperclass();	        this.appendFieldsIn(clazz);	    }	    return super.toString();	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static String reverseDelimited(final String str, final char separatorChar) {	    if (str == null) {	        return null;	    }	    final String[] strs = split(str, separatorChar);	    ArrayUtils.reverse(strs);	    return join(strs, separatorChar);	}
public String getNullText() {	    return nullText;	}
public boolean isEmpty() {	    return size == 0;	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public void appendStart(final StringBuffer buffer, final Object object) {	    if (object != null) {	        appendClassName(buffer, object);	        appendIdentityHashCode(buffer, object);	        appendContentStart(buffer);	        if (fieldSeparatorAtStart) {	            appendFieldSeparator(buffer);	        }	    }	}
@Override	public int hashCode() {	    return getObject() != null ? getObject().hashCode() : 0;	}
public static String reverseDelimited(final String str, final char separatorChar) {	    if (str == null) {	        return null;	    }	    final String[] strs = split(str, separatorChar);	    ArrayUtils.reverse(strs);	    return join(strs, separatorChar);	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
@Override	public int length() {	    return size;	}
public String previousToken() {	    if (hasPrevious()) {	        return tokens[--tokenPos];	    }	    return null;	}
@Override	public String getArraySeparator() {	    return super.getArraySeparator();	}
public StrBuilder setNullText(String nullText) {	    if (nullText != null && nullText.isEmpty()) {	        nullText = null;	    }	    this.nullText = nullText;	    return this;	}
@Override	public boolean markSupported() {	    return true;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
protected ScheduledFuture<?> startTimer() {	    return getExecutorService().scheduleAtFixedRate(new Runnable() {		        @Override	        public void run() {	            endOfPeriod();	        }	    }, getPeriod(), getPeriod(), getUnit());	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
@Override	public String build() {	    return toString();	}
protected synchronized final ExecutorService getActiveExecutor() {	    return executor;	}
public static String removeEndIgnoreCase(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (endsWithIgnoreCase(str, remove)) {	        return str.substring(0, str.length() - remove.length());	    }	    return str;	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
public static String substringBefore(final String str, final String separator) {	    if (isEmpty(str) || separator == null) {	        return str;	    }	    if (separator.isEmpty()) {	        return EMPTY;	    }	    final int pos = str.indexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return str;	    }	    return str.substring(0, pos);	}
public boolean isEmpty() {	    return size == 0;	}
public static ConcurrentException extractCause(final ExecutionException ex) {	    if (ex == null || ex.getCause() == null) {	        return null;	    }	    throwCause(ex);	    return new ConcurrentException(ex.getMessage(), ex.getCause());	}
public Fraction subtract(final Fraction fraction) {	    return addSub(fraction, false);	}
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, true);	}
public int set(final int holder) {	    return holder | _mask;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public short getShortValue(final short holder) {	    return (short) getValue(holder);	}
public static String substringBeforeLast(final String str, final String separator) {	    if (isEmpty(str) || isEmpty(separator)) {	        return str;	    }	    final int pos = str.lastIndexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return str;	    }	    return str.substring(0, pos);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
@Override	public boolean equals(final Object obj) {	    return obj instanceof MutableFloat && Float.floatToIntBits(((MutableFloat) obj).value) == Float.floatToIntBits(value);	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public char getEscapeChar() {	    return this.escapeChar;	}
public static void writeDeclaredStaticField(final Class<?> cls, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException {	    final Field field = getDeclaredField(cls, fieldName, forceAccess);	    if (field == null) {	        throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName);	    }	    writeField(field, (Object) null, value);	}
public String getNewLineText() {	    return newLine;	}
@Override	public int length() {	    return size;	}
public StrBuilder deleteAll(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, -1);	}
public boolean isNegated() {	    return negated;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static String right(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(str.length() - len);	}
private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass) {	    if (throwable == null || type == null) {	        return -1;	    }	    if (fromIndex < 0) {	        fromIndex = 0;	    }	    final Throwable[] throwables = ExceptionUtils.getThrowables(throwable);	    if (fromIndex >= throwables.length) {	        return -1;	    }	    if (subclass) {	        for (int i = fromIndex; i < throwables.length; i++) {	            if (type.isAssignableFrom(throwables[i].getClass())) {	                return i;	            }	        }	    } else {	        for (int i = fromIndex; i < throwables.length; i++) {	            if (type.equals(throwables[i].getClass())) {	                return i;	            }	        }	    }	    return -1;	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public synchronized boolean isShutdown() {	    return shutdown;	}
@Override	public int length() {	    return size;	}
protected String getArrayStart() {	    return arrayStart;	}
public String getNullText() {	    return nullText;	}
public static boolean isSameInstant(final Calendar cal1, final Calendar cal2) {	    if (cal1 == null || cal2 == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    return cal1.getTime().getTime() == cal2.getTime().getTime();	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static StrLookup<?> noneLookup() {	    return NONE_LOOKUP;	}
public static Object invokeExactMethod(final Object object, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {	    if (args == null) {	        args = ArrayUtils.EMPTY_OBJECT_ARRAY;	    }	    if (parameterTypes == null) {	        parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;	    }	    final Method method = getAccessibleMethod(object.getClass(), methodName, parameterTypes);	    if (method == null) {	        throw new NoSuchMethodException("No such accessible method: " + methodName + "() on object: " + object.getClass().getName());	    }	    return method.invoke(object, args);	}
public static String[] stripAll(final String[] strs, final String stripChars) {	    int strsLen;	    if (strs == null || (strsLen = strs.length) == 0) {	        return strs;	    }	    final String[] newArr = new String[strsLen];	    for (int i = 0; i < strsLen; i++) {	        newArr[i] = strip(strs[i], stripChars);	    }	    return newArr;	}
public static String defaultString(final String str, final String defaultStr) {	    return str == null ? defaultStr : str;	}
public EqualsBuilder appendSuper(final boolean superEquals) {	    if (isEquals == false) {	        return this;	    }	    isEquals = superEquals;	    return this;	}
@Override	public float floatValue() {	    return value;	}
public static String lowerCase(final String str, final Locale locale) {	    if (str == null) {	        return null;	    }	    return str.toLowerCase(locale);	}
public static boolean containsNone(final CharSequence cs, final String invalidChars) {	    if (cs == null || invalidChars == null) {	        return true;	    }	    return containsNone(cs, invalidChars.toCharArray());	}
public byte setByte(final byte holder) {	    return (byte) set(holder);	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
@Override	public Double getValue() {	    return Double.valueOf(this.value);	}
public static String repeat(final char ch, final int repeat) {	    final char[] buf = new char[repeat];	    for (int i = repeat - 1; i >= 0; i--) {	        buf[i] = ch;	    }	    return new String(buf);	}
public static String repeat(final char ch, final int repeat) {	    final char[] buf = new char[repeat];	    for (int i = repeat - 1; i >= 0; i--) {	        buf[i] = ch;	    }	    return new String(buf);	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
protected String getNullText() {	    return nullText;	}
@Override	public int hashCode() {	    return toHashCode();	}
public String toString(final String format) {	    return String.format(format, minimum, maximum, comparator);	}
@Override	public float floatValue() {	    return (float) value;	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
@Override	public String getFormattedExceptionMessage(final String baseMessage) {	    final StringBuilder buffer = new StringBuilder(256);	    if (baseMessage != null) {	        buffer.append(baseMessage);	    }	    if (contextValues.size() > 0) {	        if (buffer.length() > 0) {	            buffer.append('\n');	        }	        buffer.append("Exception Context:\n");	        int i = 0;	        for (final Pair<String, Object> pair : contextValues) {	            buffer.append("\t[");	            buffer.append(++i);	            buffer.append(':');	            buffer.append(pair.getKey());	            buffer.append("=");	            final Object value = pair.getValue();	            if (value == null) {	                buffer.append("null");	            } else {	                String valueStr;	                try {	                    valueStr = value.toString();	                } catch (final Exception e) {	                    valueStr = "Exception thrown on toString(): " + ExceptionUtils.getStackTrace(e);	                }	                buffer.append(valueStr);	            }	            buffer.append("]\n");	        }	        buffer.append("---------------------------------");	    }	    return buffer.toString();	}
private static Date add(final Date date, final int calendarField, final int amount) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final Calendar c = Calendar.getInstance();	    c.setTime(date);	    c.add(calendarField, amount);	    return c.getTime();	}
public static float min(final float a, final float b, final float c) {	    return Math.min(Math.min(a, b), c);	}
public static CharRange is(final char ch) {	    return new CharRange(ch, ch, false);	}
public String getNullText() {	    return nullText;	}
public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) {	    final Token[] tokens = lexx(format);	    final Calendar start = Calendar.getInstance(timezone);	    start.setTime(new Date(startMillis));	    final Calendar end = Calendar.getInstance(timezone);	    end.setTime(new Date(endMillis));	    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);	    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);	    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);	    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);	    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);	    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);	    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);	    while (milliseconds < 0) {	        milliseconds += 1000;	        seconds -= 1;	    }	    while (seconds < 0) {	        seconds += 60;	        minutes -= 1;	    }	    while (minutes < 0) {	        minutes += 60;	        hours -= 1;	    }	    while (hours < 0) {	        hours += 24;	        days -= 1;	    }	    if (Token.containsTokenWithValue(tokens, M)) {	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	        while (months < 0) {	            months += 12;	            years -= 1;	        }	        if (!Token.containsTokenWithValue(tokens, y) && years != 0) {	            while (years != 0) {	                months += 12 * years;	                years = 0;	            }	        }	    } else {	        if (!Token.containsTokenWithValue(tokens, y)) {	            int target = end.get(Calendar.YEAR);	            if (months < 0) {	                target -= 1;	            }	            while (start.get(Calendar.YEAR) != target) {	                days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);	                if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) {	                    days += 1;	                }	                start.add(Calendar.YEAR, 1);	                days += start.get(Calendar.DAY_OF_YEAR);	            }	            years = 0;	        }	        while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            start.add(Calendar.MONTH, 1);	        }	        months = 0;	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	    }	    if (!Token.containsTokenWithValue(tokens, d)) {	        hours += 24 * days;	        days = 0;	    }	    if (!Token.containsTokenWithValue(tokens, H)) {	        minutes += 60 * hours;	        hours = 0;	    }	    if (!Token.containsTokenWithValue(tokens, m)) {	        seconds += 60 * minutes;	        minutes = 0;	    }	    if (!Token.containsTokenWithValue(tokens, s)) {	        milliseconds += 1000 * seconds;	        seconds = 0;	    }	    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
public static String replaceChars(final String str, final String searchChars, String replaceChars) {	    if (isEmpty(str) || isEmpty(searchChars)) {	        return str;	    }	    if (replaceChars == null) {	        replaceChars = EMPTY;	    }	    boolean modified = false;	    final int replaceCharsLength = replaceChars.length();	    final int strLength = str.length();	    final StringBuilder buf = new StringBuilder(strLength);	    for (int i = 0; i < strLength; i++) {	        final char ch = str.charAt(i);	        final int index = searchChars.indexOf(ch);	        if (index >= 0) {	            modified = true;	            if (index < replaceCharsLength) {	                buf.append(replaceChars.charAt(index));	            }	        } else {	            buf.append(ch);	        }	    }	    if (modified) {	        return buf.toString();	    }	    return str;	}
public static Boolean xor(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return xor(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
public static boolean isAsciiPrintable(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {	    if (array == null) {	        if (index != 0) {	            throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0");	        }	        final Object joinedArray = Array.newInstance(clss, 1);	        Array.set(joinedArray, 0, element);	        return joinedArray;	    }	    final int length = Array.getLength(array);	    if (index > length || index < 0) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(clss, length + 1);	    System.arraycopy(array, 0, result, 0, index);	    Array.set(result, index, element);	    if (index < length) {	        System.arraycopy(array, index, result, index + 1, length - index);	    }	    return result;	}
public static double[] addAll(final double[] array1, final double... array2) {	    if (array1 == null) {	        return clone(array2);	    } else if (array2 == null) {	        return clone(array1);	    }	    final double[] joinedArray = new double[array1.length + array2.length];	    System.arraycopy(array1, 0, joinedArray, 0, array1.length);	    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);	    return joinedArray;	}
public void subtract(final Number operand) {	    this.value -= operand.floatValue();	}
public String getNewLineText() {	    return newLine;	}
public static String removeStart(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.startsWith(remove)) {	        return str.substring(remove.length());	    }	    return str;	}
@Override	public T get(final long timeout, final TimeUnit unit) {	    return value;	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    int max = longest;	    if (index + longest > input.length()) {	        max = input.length() - index;	    }	    for (int i = max; i >= shortest; i--) {	        final CharSequence subSeq = input.subSequence(index, index + i);	        final CharSequence result = lookupMap.get(subSeq.toString());	        if (result != null) {	            out.write(result.toString());	            return i;	        }	    }	    return 0;	}
public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException {	    return parseDateWithLeniency(str, null, parsePatterns, false);	}
public StringBuilder toStringBuilder() {	    return new StringBuilder(size).append(buffer, 0, size);	}
public static <T> Range<T> is(final T element, final Comparator<T> comparator) {	    return between(element, element, comparator);	}
public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer) {	    if (throwable == null) {	        return;	    }	    if (writer == null) {	        throw new IllegalArgumentException("The PrintWriter must not be null");	    }	    final String[] trace = getRootCauseStackTrace(throwable);	    for (final String element : trace) {	        writer.println(element);	    }	    writer.flush();	}
public final void translate(final CharSequence input, final Writer out) throws IOException {	    if (out == null) {	        throw new IllegalArgumentException("The Writer must not be null");	    }	    if (input == null) {	        return;	    }	    int pos = 0;	    final int len = input.length();	    while (pos < len) {	        final int consumed = translate(input, pos, out);	        if (consumed == 0) {	            final char[] c = Character.toChars(Character.codePointAt(input, pos));	            out.write(c);	            pos += c.length;	            continue;	        }	        for (int pt = 0; pt < consumed; pt++) {	            pos += Character.charCount(Character.codePointAt(input, pt));	        }	    }	}
public static <T extends CharSequence> T defaultIfBlank(final T str, final T defaultStr) {	    return StringUtils.isBlank(str) ? defaultStr : str;	}
public static <T> T firstNonNull(final T... values) {	    if (values != null) {	        for (final T val : values) {	            if (val != null) {	                return val;	            }	        }	    }	    return null;	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException {	    return charsetName == null ? new String(bytes) : new String(bytes, charsetName);	}
public static <T> String reflectionToString(final T object, final ToStringStyle style, final boolean outputTransients, final Class<? super T> reflectUpToClass) {	    return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass);	}
public static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) {	    if (0 == nHexs) {	        return dstInit;	    }	    if ((nHexs - 1) * 4 + srcPos >= 64) {	        throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 64");	    }	    final StringBuilder sb = new StringBuilder(dstInit);	    int shift = 0;	    int append = sb.length();	    for (int i = 0; i < nHexs; i++) {	        shift = i * 4 + srcPos;	        final int bits = (int) (0xF & (src >> shift));	        if (dstPos + i == append) {	            ++append;	            sb.append(intToHexDigit(bits));	        } else {	            sb.setCharAt(dstPos + i, intToHexDigit(bits));	        }	    }	    return sb.toString();	}
public HashCodeBuilder appendSuper(final int superHashCode) {	    iTotal = iTotal * iConstant + superHashCode;	    return this;	}
public static Field[] getAllFields(Class<?> cls) {	    final List<Field> allFieldsList = getAllFieldsList(cls);	    return allFieldsList.toArray(new Field[allFieldsList.size()]);	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
protected boolean isUseIdentityHashCode() {	    return useIdentityHashCode;	}
public TimeUnit getUnit() {	    return unit;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof MutableLong) {	        return value == ((MutableLong) obj).longValue();	    }	    return false;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
static Object removeAll(final Object array, final BitSet indices) {	    final int srcLength = ArrayUtils.getLength(array);	    final int removals = indices.cardinality();	    final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals);	    int srcIndex = 0;	    int destIndex = 0;	    int count;	    int set;	    while ((set = indices.nextSetBit(srcIndex)) != -1) {	        count = set - srcIndex;	        if (count > 0) {	            System.arraycopy(array, srcIndex, result, destIndex, count);	            destIndex += count;	        }	        srcIndex = indices.nextClearBit(set);	    }	    count = srcLength - srcIndex;	    if (count > 0) {	        System.arraycopy(array, srcIndex, result, destIndex, count);	    }	    return result;	}
public int size() {	    return size;	}
private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) {	    if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {	        return text;	    }	    if (timeToLive < 0) {	        throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another");	    }	    final int searchLength = searchList.length;	    final int replacementLength = replacementList.length;	    if (searchLength != replacementLength) {	        throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength);	    }	    final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];	    int textIndex = -1;	    int replaceIndex = -1;	    int tempIndex = -1;	    for (int i = 0; i < searchLength; i++) {	        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {	            continue;	        }	        tempIndex = text.indexOf(searchList[i]);	        if (tempIndex == -1) {	            noMoreMatchesForReplIndex[i] = true;	        } else {	            if (textIndex == -1 || tempIndex < textIndex) {	                textIndex = tempIndex;	                replaceIndex = i;	            }	        }	    }	    if (textIndex == -1) {	        return text;	    }	    int start = 0;	    int increase = 0;	    for (int i = 0; i < searchList.length; i++) {	        if (searchList[i] == null || replacementList[i] == null) {	            continue;	        }	        final int greater = replacementList[i].length() - searchList[i].length();	        if (greater > 0) {	            increase += 3 * greater;	        }	    }	    increase = Math.min(increase, text.length() / 5);	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (textIndex != -1) {	        for (int i = start; i < textIndex; i++) {	            buf.append(text.charAt(i));	        }	        buf.append(replacementList[replaceIndex]);	        start = textIndex + searchList[replaceIndex].length();	        textIndex = -1;	        replaceIndex = -1;	        tempIndex = -1;	        for (int i = 0; i < searchLength; i++) {	            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {	                continue;	            }	            tempIndex = text.indexOf(searchList[i], start);	            if (tempIndex == -1) {	                noMoreMatchesForReplIndex[i] = true;	            } else {	                if (textIndex == -1 || tempIndex < textIndex) {	                    textIndex = tempIndex;	                    replaceIndex = i;	                }	            }	        }	    }	    final int textLength = text.length();	    for (int i = start; i < textLength; i++) {	        buf.append(text.charAt(i));	    }	    final String result = buf.toString();	    if (!repeat) {	        return result;	    }	    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);	}
public static String difference(final String str1, final String str2) {	    if (str1 == null) {	        return str2;	    }	    if (str2 == null) {	        return str1;	    }	    final int at = indexOfDifference(str1, str2);	    if (at == INDEX_NOT_FOUND) {	        return EMPTY;	    }	    return str2.substring(at);	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    buffer.append(arrayStart);	    for (int i = 0; i < array.length; i++) {	        if (i > 0) {	            buffer.append(arraySeparator);	        }	        appendDetail(buffer, fieldName, array[i]);	    }	    buffer.append(arrayEnd);	}
public static String trim(final String str) {	    return str == null ? null : str.trim();	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
private static Date set(final Date date, final int calendarField, final int amount) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final Calendar c = Calendar.getInstance();	    c.setLenient(false);	    c.setTime(date);	    c.set(calendarField, amount);	    return c.getTime();	}
protected boolean isUseShortClassName() {	    return useShortClassName;	}
protected String getFieldSeparator() {	    return fieldSeparator;	}
public String getNullText() {	    return nullText;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public static boolean[] hexDigitToBinary(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return new boolean[] { false, false, false, false };	        case '1':	            return new boolean[] { true, false, false, false };	        case '2':	            return new boolean[] { false, true, false, false };	        case '3':	            return new boolean[] { true, true, false, false };	        case '4':	            return new boolean[] { false, false, true, false };	        case '5':	            return new boolean[] { true, false, true, false };	        case '6':	            return new boolean[] { false, true, true, false };	        case '7':	            return new boolean[] { true, true, true, false };	        case '8':	            return new boolean[] { false, false, false, true };	        case '9':	            return new boolean[] { true, false, false, true };	        case 'a':	        case 'A':	            return new boolean[] { false, true, false, true };	        case 'b':	        case 'B':	            return new boolean[] { true, true, false, true };	        case 'c':	        case 'C':	            return new boolean[] { false, false, true, true };	        case 'd':	        case 'D':	            return new boolean[] { true, false, true, true };	        case 'e':	        case 'E':	            return new boolean[] { false, true, true, true };	        case 'f':	        case 'F':	            return new boolean[] { true, true, true, true };	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] result = new boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        final Boolean b = array[i];	        result[i] = (b == null ? valueForNull : b.booleanValue());	    }	    return result;	}
@Override	public String getFieldNameValueSeparator() {	    return super.getFieldNameValueSeparator();	}
public static boolean endsWithIgnoreCase(final CharSequence str, final CharSequence suffix) {	    return endsWith(str, suffix, true);	}
@Override	public int length() {	    return size;	}
static void register(final Object lhs, final Object rhs) {	    synchronized (EqualsBuilder.class) {	        if (getRegistry() == null) {	            REGISTRY.set(new HashSet<Pair<IDKey, IDKey>>());	        }	    }	    final Set<Pair<IDKey, IDKey>> registry = getRegistry();	    final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);	    registry.add(pair);	}
public static int indexOfDifference(final CharSequence... css) {	    if (css == null || css.length <= 1) {	        return INDEX_NOT_FOUND;	    }	    boolean anyStringNull = false;	    boolean allStringsNull = true;	    final int arrayLen = css.length;	    int shortestStrLen = Integer.MAX_VALUE;	    int longestStrLen = 0;	    for (int i = 0; i < arrayLen; i++) {	        if (css[i] == null) {	            anyStringNull = true;	            shortestStrLen = 0;	        } else {	            allStringsNull = false;	            shortestStrLen = Math.min(css[i].length(), shortestStrLen);	            longestStrLen = Math.max(css[i].length(), longestStrLen);	        }	    }	    if (allStringsNull || longestStrLen == 0 && !anyStringNull) {	        return INDEX_NOT_FOUND;	    }	    if (shortestStrLen == 0) {	        return 0;	    }	    int firstDiff = -1;	    for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {	        final char comparisonChar = css[0].charAt(stringPos);	        for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {	            if (css[arrayPos].charAt(stringPos) != comparisonChar) {	                firstDiff = stringPos;	                break;	            }	        }	        if (firstDiff != -1) {	            break;	        }	    }	    if (firstDiff == -1 && shortestStrLen != longestStrLen) {	        return shortestStrLen;	    }	    return firstDiff;	}
public static short[] removeElement(final short[] array, final short element) {	    final int index = indexOf(array, element);	    if (index == INDEX_NOT_FOUND) {	        return clone(array);	    }	    return remove(array, index);	}
public static String removeEndIgnoreCase(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (endsWithIgnoreCase(str, remove)) {	        return str.substring(0, str.length() - remove.length());	    }	    return str;	}
public static String trimToNull(final String str) {	    final String ts = trim(str);	    return isEmpty(ts) ? null : ts;	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public boolean isEndedBy(final T element) {	    if (element == null) {	        return false;	    }	    return comparator.compare(element, maximum) == 0;	}
@Override	public int intValue() {	    return (int) value;	}
public static Date setMinutes(final Date date, final int amount) {	    return set(date, Calendar.MINUTE, amount);	}
public StrBuilder deleteCharAt(final int index) {	    if (index < 0 || index >= size) {	        throw new StringIndexOutOfBoundsException(index);	    }	    deleteImpl(index, index + 1, 1);	    return this;	}
public String getNullText() {	    return nullText;	}
public static boolean isEmpty(final boolean[] array) {	    return array == null || array.length == 0;	}
@Override	public int length() {	    return size;	}
public static <T extends CharSequence> T validIndex(final T chars, final int index) {	    return validIndex(chars, index, DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE, Integer.valueOf(index));	}
protected String getFieldSeparator() {	    return fieldSeparator;	}
public static Method getAccessibleMethod(Method method) {	    if (!MemberUtils.isAccessible(method)) {	        return null;	    }	    final Class<?> cls = method.getDeclaringClass();	    if (Modifier.isPublic(cls.getModifiers())) {	        return method;	    }	    final String methodName = method.getName();	    final Class<?>[] parameterTypes = method.getParameterTypes();	    method = getAccessibleMethodFromInterfaceNest(cls, methodName, parameterTypes);	    if (method == null) {	        method = getAccessibleMethodFromSuperclass(cls, methodName, parameterTypes);	    }	    return method;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
protected boolean isUseFieldNames() {	    return useFieldNames;	}
protected String getArrayStart() {	    return arrayStart;	}
public static boolean isAsciiPrintable(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static boolean isBlank(final CharSequence cs) {	    int strLen;	    if (cs == null || (strLen = cs.length()) == 0) {	        return true;	    }	    for (int i = 0; i < strLen; i++) {	        if (Character.isWhitespace(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public String getNullText() {	    return nullText;	}
static Throwable checkedException(final Throwable ex) {	    if (ex != null && !(ex instanceof RuntimeException) && !(ex instanceof Error)) {	        return ex;	    } else {	        throw new IllegalArgumentException("Not a checked exception: " + ex);	    }	}
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) {	    final StringBuilder buffer = new StringBuilder();	    boolean lastOutputSeconds = false;	    final int sz = tokens.length;	    for (int i = 0; i < sz; i++) {	        final Token token = tokens[i];	        final Object value = token.getValue();	        final int count = token.getCount();	        if (value instanceof StringBuilder) {	            buffer.append(value.toString());	        } else {	            if (value == y) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years));	                lastOutputSeconds = false;	            } else if (value == M) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months));	                lastOutputSeconds = false;	            } else if (value == d) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days));	                lastOutputSeconds = false;	            } else if (value == H) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours));	                lastOutputSeconds = false;	            } else if (value == m) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes));	                lastOutputSeconds = false;	            } else if (value == s) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds));	                lastOutputSeconds = true;	            } else if (value == S) {	                if (lastOutputSeconds) {	                    milliseconds += 1000;	                    final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds);	                    buffer.append(str.substring(1));	                } else {	                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds));	                }	                lastOutputSeconds = false;	            }	        }	    }	    return buffer.toString();	}
static String[] getStackFrames(final String stackTrace) {	    final String linebreak = SystemUtils.LINE_SEPARATOR;	    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);	    final List<String> list = new ArrayList<String>();	    while (frames.hasMoreTokens()) {	        list.add(frames.nextToken());	    }	    return list.toArray(new String[list.size()]);	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public StrBuilder ensureCapacity(final int capacity) {	    if (capacity > buffer.length) {	        final char[] old = buffer;	        buffer = new char[capacity * 2];	        System.arraycopy(old, 0, buffer, 0, size);	    }	    return this;	}
public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer) {	    if (throwable == null) {	        return;	    }	    if (writer == null) {	        throw new IllegalArgumentException("The PrintWriter must not be null");	    }	    final String[] trace = getRootCauseStackTrace(throwable);	    for (final String element : trace) {	        writer.println(element);	    }	    writer.flush();	}
public static CharRange is(final char ch) {	    return new CharRange(ch, ch, false);	}
@Override	public void setArraySeparator(final String arraySeparator) {	    super.setArraySeparator(arraySeparator);	}
public int size() {	    return size;	}
public static Field[] getAllFields(Class<?> cls) {	    final List<Field> allFieldsList = getAllFieldsList(cls);	    return allFieldsList.toArray(new Field[allFieldsList.size()]);	}
protected String getSizeStartText() {	    return sizeStartText;	}
public static boolean isAlphanumeric(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetterOrDigit(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public String midString(int index, final int length) {	    if (index < 0) {	        index = 0;	    }	    if (length <= 0 || index >= size) {	        return "";	    }	    if (size <= index + length) {	        return new String(buffer, index, size - index);	    }	    return new String(buffer, index, length);	}
public abstract boolean translate(int codepoint, Writer out) throws IOException;
public static String substringAfter(final String str, final String separator) {	    if (isEmpty(str)) {	        return str;	    }	    if (separator == null) {	        return EMPTY;	    }	    final int pos = str.indexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return EMPTY;	    }	    return str.substring(pos + separator.length());	}
public int size() {	    return size;	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {	    if (array == null) {	        if (index != 0) {	            throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0");	        }	        final Object joinedArray = Array.newInstance(clss, 1);	        Array.set(joinedArray, 0, element);	        return joinedArray;	    }	    final int length = Array.getLength(array);	    if (index > length || index < 0) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(clss, length + 1);	    System.arraycopy(array, 0, result, 0, index);	    Array.set(result, index, element);	    if (index < length) {	        System.arraycopy(array, index, result, index + 1, length - index);	    }	    return result;	}
@Override	public Date parse(final String source, final ParsePosition pos) {	    final int offset = pos.getIndex();	    final Matcher matcher = parsePattern.matcher(source.substring(offset));	    if (!matcher.lookingAt()) {	        return null;	    }	    final Calendar cal = Calendar.getInstance(timeZone, locale);	    cal.clear();	    for (int i = 0; i < strategies.length; ) {	        final Strategy strategy = strategies[i++];	        strategy.setCalendar(this, cal, matcher.group(i));	    }	    pos.setIndex(offset + matcher.end());	    return cal.getTime();	}
public String getNullText() {	    return nullText;	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
@Override	public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) {	    return formatter.format(obj, toAppendTo, pos);	}
public String getNewLineText() {	    return newLine;	}
public StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, 1);	}
public static void isTrue(final boolean expression) {	    if (expression == false) {	        throw new IllegalArgumentException(DEFAULT_IS_TRUE_EX_MESSAGE);	    }	}
public static String substringBetween(final String str, final String open, final String close) {	    if (str == null || open == null || close == null) {	        return null;	    }	    final int start = str.indexOf(open);	    if (start != INDEX_NOT_FOUND) {	        final int end = str.indexOf(close, start + open.length());	        if (end != INDEX_NOT_FOUND) {	            return str.substring(start + open.length(), end);	        }	    }	    return null;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
@Override	public String getPattern() {	    return pattern;	}
public char getEnd() {	    return this.end;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) {	    final StringBuilder buffer = new StringBuilder();	    boolean lastOutputSeconds = false;	    final int sz = tokens.length;	    for (int i = 0; i < sz; i++) {	        final Token token = tokens[i];	        final Object value = token.getValue();	        final int count = token.getCount();	        if (value instanceof StringBuilder) {	            buffer.append(value.toString());	        } else {	            if (value == y) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years));	                lastOutputSeconds = false;	            } else if (value == M) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months));	                lastOutputSeconds = false;	            } else if (value == d) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days));	                lastOutputSeconds = false;	            } else if (value == H) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours));	                lastOutputSeconds = false;	            } else if (value == m) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes));	                lastOutputSeconds = false;	            } else if (value == s) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds));	                lastOutputSeconds = true;	            } else if (value == S) {	                if (lastOutputSeconds) {	                    milliseconds += 1000;	                    final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds);	                    buffer.append(str.substring(1));	                } else {	                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds));	                }	                lastOutputSeconds = false;	            }	        }	    }	    return buffer.toString();	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public boolean isEmpty() {	    return size == 0;	}
public static boolean isAlphanumericSpace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetterOrDigit(cs.charAt(i)) == false && cs.charAt(i) != ' ') {	            return false;	        }	    }	    return true;	}
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] result = new boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        final Boolean b = array[i];	        result[i] = (b == null ? valueForNull : b.booleanValue());	    }	    return result;	}
public static String toStringTrueFalse(final boolean bool) {	    return toString(bool, "true", "false");	}
public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException {	    return parseDateWithLeniency(str, locale, parsePatterns, true);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static boolean isAllUpperCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isUpperCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static void matchesPattern(final CharSequence input, final String pattern, final String message, final Object... values) {	    if (Pattern.matches(pattern, input) == false) {	        throw new IllegalArgumentException(String.format(message, values));	    }	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public int size() {	    return size;	}
public static String random(final int count, final char... chars) {	    if (chars == null) {	        return random(count, 0, 0, false, false, null, RANDOM);	    }	    return random(count, 0, chars.length, false, false, chars, RANDOM);	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static <T> T[] toArray(final T... items) {	    return items;	}
@Override	public boolean equals(final Object obj) {	    if (obj == this) {	        return true;	    } else if (obj == null || obj.getClass() != getClass()) {	        return false;	    } else {	        @SuppressWarnings("unchecked")	        final Range<T> range = (Range<T>) obj;	        return minimum.equals(range.minimum) && maximum.equals(range.maximum);	    }	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static String formatPeriodISO(final long startMillis, final long endMillis) {	    return formatPeriod(startMillis, endMillis, ISO_EXTENDED_FORMAT_PATTERN, false, TimeZone.getDefault());	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
protected String getContentStart() {	    return contentStart;	}
@Override	public double doubleValue() {	    return value;	}
@Override	public int length() {	    return size;	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
@Override	public long longValue() {	    return value;	}
public String toString(final String format) {	    return String.format(format, getLeft(), getRight());	}
public static BigDecimal createBigDecimal(final String str) {	    if (str == null) {	        return null;	    }	    if (StringUtils.isBlank(str)) {	        throw new NumberFormatException("A blank string is not a valid number");	    }	    if (str.trim().startsWith("--")) {	        throw new NumberFormatException(str + " is not a valid number.");	    }	    return new BigDecimal(str);	}
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) {	    return new Range<T>(fromInclusive, toInclusive, comparator);	}
public static String substringAfter(final String str, final String separator) {	    if (isEmpty(str)) {	        return str;	    }	    if (separator == null) {	        return EMPTY;	    }	    final int pos = str.indexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return EMPTY;	    }	    return str.substring(pos + separator.length());	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
@Override	public String toString() {	    if (this.getObject() == null) {	        return this.getStyle().getNullText();	    }	    Class<?> clazz = this.getObject().getClass();	    this.appendFieldsIn(clazz);	    while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {	        clazz = clazz.getSuperclass();	        this.appendFieldsIn(clazz);	    }	    return super.toString();	}
@Override	public boolean isUseFieldNames() {	    return super.isUseFieldNames();	}
@Deprecated	public static String chomp(final String str, final String separator) {	    return removeEnd(str, separator);	}
public String getNullText() {	    return nullText;	}
static Object removeAll(final Object array, final BitSet indices) {	    final int srcLength = ArrayUtils.getLength(array);	    final int removals = indices.cardinality();	    final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals);	    int srcIndex = 0;	    int destIndex = 0;	    int count;	    int set;	    while ((set = indices.nextSetBit(srcIndex)) != -1) {	        count = set - srcIndex;	        if (count > 0) {	            System.arraycopy(array, srcIndex, result, destIndex, count);	            destIndex += count;	        }	        srcIndex = indices.nextClearBit(set);	    }	    count = srcLength - srcIndex;	    if (count > 0) {	        System.arraycopy(array, srcIndex, result, destIndex, count);	    }	    return result;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public int getDenominator() {	    return denominator;	}
public int capacity() {	    return buffer.length;	}
@Override	public final void applyPattern(final String pattern) {	    if (registry == null) {	        super.applyPattern(pattern);	        toPattern = super.toPattern();	        return;	    }	    final ArrayList<Format> foundFormats = new ArrayList<Format>();	    final ArrayList<String> foundDescriptions = new ArrayList<String>();	    final StringBuilder stripCustom = new StringBuilder(pattern.length());	    final ParsePosition pos = new ParsePosition(0);	    final char[] c = pattern.toCharArray();	    int fmtCount = 0;	    while (pos.getIndex() < pattern.length()) {	        switch(c[pos.getIndex()]) {	            case QUOTE:	                appendQuotedString(pattern, pos, stripCustom, true);	                break;	            case START_FE:	                fmtCount++;	                seekNonWs(pattern, pos);	                final int start = pos.getIndex();	                final int index = readArgumentIndex(pattern, next(pos));	                stripCustom.append(START_FE).append(index);	                seekNonWs(pattern, pos);	                Format format = null;	                String formatDescription = null;	                if (c[pos.getIndex()] == START_FMT) {	                    formatDescription = parseFormatDescription(pattern, next(pos));	                    format = getFormat(formatDescription);	                    if (format == null) {	                        stripCustom.append(START_FMT).append(formatDescription);	                    }	                }	                foundFormats.add(format);	                foundDescriptions.add(format == null ? null : formatDescription);	                Validate.isTrue(foundFormats.size() == fmtCount);	                Validate.isTrue(foundDescriptions.size() == fmtCount);	                if (c[pos.getIndex()] != END_FE) {	                    throw new IllegalArgumentException("Unreadable format element at position " + start);	                }	            default:	                stripCustom.append(c[pos.getIndex()]);	                next(pos);	        }	    }	    super.applyPattern(stripCustom.toString());	    toPattern = insertFormats(super.toPattern(), foundDescriptions);	    if (containsElements(foundFormats)) {	        final Format[] origFormats = getFormats();	        int i = 0;	        for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) {	            final Format f = it.next();	            if (f != null) {	                origFormats[i] = f;	            }	        }	        super.setFormats(origFormats);	    }	}
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return true;	    }	    if (lhs == null || rhs == null) {	        return false;	    }	    final Class<?> lhsClass = lhs.getClass();	    final Class<?> rhsClass = rhs.getClass();	    Class<?> testClass;	    if (lhsClass.isInstance(rhs)) {	        testClass = lhsClass;	        if (!rhsClass.isInstance(lhs)) {	            testClass = rhsClass;	        }	    } else if (rhsClass.isInstance(lhs)) {	        testClass = rhsClass;	        if (!lhsClass.isInstance(rhs)) {	            testClass = lhsClass;	        }	    } else {	        return false;	    }	    final EqualsBuilder equalsBuilder = new EqualsBuilder();	    try {	        reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {	            testClass = testClass.getSuperclass();	            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        }	    } catch (final IllegalArgumentException e) {	        return false;	    }	    return equalsBuilder.isEquals();	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public static String squeeze(final String str, final String... set) {	    if (StringUtils.isEmpty(str) || deepEmpty(set)) {	        return str;	    }	    final CharSet chars = CharSet.getInstance(set);	    final StringBuilder buffer = new StringBuilder(str.length());	    final char[] chrs = str.toCharArray();	    final int sz = chrs.length;	    char lastChar = ' ';	    char ch = ' ';	    for (int i = 0; i < sz; i++) {	        ch = chrs[i];	        if (ch == lastChar && i != 0 && chars.contains(ch)) {	            continue;	        }	        buffer.append(ch);	        lastChar = ch;	    }	    return buffer.toString();	}
protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd) {	    this.fieldSeparatorAtEnd = fieldSeparatorAtEnd;	}
public int set(final int holder) {	    return holder | _mask;	}
public static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {	    if (str == null || searchStr == null) {	        return INDEX_NOT_FOUND;	    }	    if (startPos < 0) {	        startPos = 0;	    }	    final int endLimit = str.length() - searchStr.length() + 1;	    if (startPos > endLimit) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return startPos;	    }	    for (int i = startPos; i < endLimit; i++) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
static int indexOf(final CharSequence cs, final CharSequence searchChar, final int start) {	    return cs.toString().indexOf(searchChar.toString(), start);	}
public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) {	    if (src.length > 8) {	        throw new IllegalArgumentException("src.length>8: src.length=" + src.length);	    }	    if (src.length - srcPos < 4) {	        throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos);	    }	    if (src[srcPos + 3]) {	        if (src[srcPos + 2]) {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return '7';	                }	            } else {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return '3';	                }	            }	        } else {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return '5';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '1';	                }	            }	        }	    } else {	        if (src[srcPos + 2]) {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'e';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return 'a';	                } else {	                    return '2';	                }	            }	        } else {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'c';	                } else {	                    return '4';	                }	            } else {	                if (src[srcPos]) {	                    return '8';	                } else {	                    return '0';	                }	            }	        }	    }	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public StrBuilder deleteCharAt(final int index) {	    if (index < 0 || index >= size) {	        throw new StringIndexOutOfBoundsException(index);	    }	    deleteImpl(index, index + 1, 1);	    return this;	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public static boolean isEmpty(final CharSequence cs) {	    return cs == null || cs.length() == 0;	}
public static String formatDuration(long durationMillis, final String format, final boolean padWithZeros) {	    final Token[] tokens = lexx(format);	    int days = 0;	    int hours = 0;	    int minutes = 0;	    int seconds = 0;	    int milliseconds = 0;	    if (Token.containsTokenWithValue(tokens, d)) {	        days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY);	        durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY);	    }	    if (Token.containsTokenWithValue(tokens, H)) {	        hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR);	        durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR);	    }	    if (Token.containsTokenWithValue(tokens, m)) {	        minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE);	        durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE);	    }	    if (Token.containsTokenWithValue(tokens, s)) {	        seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND);	        durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND);	    }	    if (Token.containsTokenWithValue(tokens, S)) {	        milliseconds = (int) durationMillis;	    }	    return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) {	    if (str == null) {	        if (trueString == null) {	            return Boolean.TRUE;	        }	        if (falseString == null) {	            return Boolean.FALSE;	        }	        if (nullString == null) {	            return null;	        }	    } else if (str.equals(trueString)) {	        return Boolean.TRUE;	    } else if (str.equals(falseString)) {	        return Boolean.FALSE;	    } else if (str.equals(nullString)) {	        return null;	    }	    throw new IllegalArgumentException("The String did not match any specified value");	}
public void increment() {	    value++;	}
private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase) {	    if (str == null || prefix == null) {	        return str == null && prefix == null;	    }	    if (prefix.length() > str.length()) {	        return false;	    }	    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());	}
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = Integer.MAX_VALUE;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.indexOf(str, search, 0);	        if (tmp == INDEX_NOT_FOUND) {	            continue;	        }	        if (tmp < ret) {	            ret = tmp;	        }	    }	    return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;	}
static Token[] lexx(final String format) {	    final char[] array = format.toCharArray();	    final ArrayList<Token> list = new ArrayList<Token>(array.length);	    boolean inLiteral = false;	    StringBuilder buffer = null;	    Token previous = null;	    final int sz = array.length;	    for (int i = 0; i < sz; i++) {	        final char ch = array[i];	        if (inLiteral && ch != '\'') {	            buffer.append(ch);	            continue;	        }	        Object value = null;	        switch(ch) {	            case '\'':	                if (inLiteral) {	                    buffer = null;	                    inLiteral = false;	                } else {	                    buffer = new StringBuilder();	                    list.add(new Token(buffer));	                    inLiteral = true;	                }	                break;	            case 'y':	                value = y;	                break;	            case 'M':	                value = M;	                break;	            case 'd':	                value = d;	                break;	            case 'H':	                value = H;	                break;	            case 'm':	                value = m;	                break;	            case 's':	                value = s;	                break;	            case 'S':	                value = S;	                break;	            default:	                if (buffer == null) {	                    buffer = new StringBuilder();	                    list.add(new Token(buffer));	                }	                buffer.append(ch);	        }	        if (value != null) {	            if (previous != null && previous.getValue() == value) {	                previous.increment();	            } else {	                final Token token = new Token(value);	                list.add(token);	                previous = token;	            }	            buffer = null;	        }	    }	    return list.toArray(new Token[list.size()]);	}
@Override	public int compareTo(final Fraction other) {	    if (this == other) {	        return 0;	    }	    if (numerator == other.numerator && denominator == other.denominator) {	        return 0;	    }	    final long first = (long) numerator * (long) other.denominator;	    final long second = (long) other.numerator * (long) denominator;	    if (first == second) {	        return 0;	    } else if (first < second) {	        return -1;	    } else {	        return 1;	    }	}
protected String getSummaryObjectEndText() {	    return summaryObjectEndText;	}
public static String center(String str, final int size, String padStr) {	    if (str == null || size <= 0) {	        return str;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    str = leftPad(str, strLen + pads / 2, padStr);	    str = rightPad(str, size, padStr);	    return str;	}
public static String[][] invert(final String[][] array) {	    final String[][] newarray = new String[array.length][2];	    for (int i = 0; i < array.length; i++) {	        newarray[i][0] = array[i][1];	        newarray[i][1] = array[i][0];	    }	    return newarray;	}
@Override	public boolean isDefaultFullDetail() {	    return super.isDefaultFullDetail();	}
public int size() {	    return size;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static char binaryToHexDigit(final boolean[] src, final int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    if (src.length > srcPos + 3 && src[srcPos + 3]) {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src[srcPos]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static String formatDuration(long durationMillis, final String format, final boolean padWithZeros) {	    final Token[] tokens = lexx(format);	    int days = 0;	    int hours = 0;	    int minutes = 0;	    int seconds = 0;	    int milliseconds = 0;	    if (Token.containsTokenWithValue(tokens, d)) {	        days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY);	        durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY);	    }	    if (Token.containsTokenWithValue(tokens, H)) {	        hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR);	        durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR);	    }	    if (Token.containsTokenWithValue(tokens, m)) {	        minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE);	        durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE);	    }	    if (Token.containsTokenWithValue(tokens, s)) {	        seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND);	        durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND);	    }	    if (Token.containsTokenWithValue(tokens, S)) {	        milliseconds = (int) durationMillis;	    }	    return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
@Override	public T call() throws Exception {	    try {	        return initialize();	    } finally {	        if (execFinally != null) {	            execFinally.shutdown();	        }	    }	}
public static ConcurrentRuntimeException extractCauseUnchecked(final ExecutionException ex) {	    if (ex == null || ex.getCause() == null) {	        return null;	    }	    throwCause(ex);	    return new ConcurrentRuntimeException(ex.getMessage(), ex.getCause());	}
@Override	public int length() {	    return size;	}
public static boolean isNumeric(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isDigit(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static JavaUnicodeEscaper between(final int codepointLow, final int codepointHigh) {	    return new JavaUnicodeEscaper(codepointLow, codepointHigh, true);	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
public char getEnd() {	    return this.end;	}
public int capacity() {	    return buffer.length;	}
public String getNewLineText() {	    return newLine;	}
public static String repeat(final char ch, final int repeat) {	    final char[] buf = new char[repeat];	    for (int i = repeat - 1; i >= 0; i--) {	        buf[i] = ch;	    }	    return new String(buf);	}
public static float min(final float a, final float b, final float c) {	    return Math.min(Math.min(a, b), c);	}
public boolean isEmpty() {	    return size == 0;	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public static boolean isAlpha(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
@Override	public double doubleValue() {	    return value;	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
static char[] toCharArray(final CharSequence cs) {	    if (cs instanceof String) {	        return ((String) cs).toCharArray();	    } else {	        final int sz = cs.length();	        final char[] array = new char[cs.length()];	        for (int i = 0; i < sz; i++) {	            array[i] = cs.charAt(i);	        }	        return array;	    }	}
public boolean isEmpty() {	    return size == 0;	}
protected boolean isFieldSeparatorAtStart() {	    return fieldSeparatorAtStart;	}
public boolean isEquals() {	    return this.isEquals;	}
public int size() {	    return size;	}
public void reset() {	    this.isEquals = true;	}
public static String getMessage(final Throwable th) {	    if (th == null) {	        return "";	    }	    final String clsName = ClassUtils.getShortClassName(th, null);	    final String msg = th.getMessage();	    return clsName + ": " + StringUtils.defaultString(msg);	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public StrBuilder reverse() {	    if (size == 0) {	        return this;	    }	    final int half = size / 2;	    final char[] buf = buffer;	    for (int leftIdx = 0, rightIdx = size - 1; leftIdx < half; leftIdx++, rightIdx--) {	        final char swap = buf[leftIdx];	        buf[leftIdx] = buf[rightIdx];	        buf[rightIdx] = swap;	    }	    return this;	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public static String substringBefore(final String str, final String separator) {	    if (isEmpty(str) || separator == null) {	        return str;	    }	    if (separator.isEmpty()) {	        return EMPTY;	    }	    final int pos = str.indexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return str;	    }	    return str.substring(0, pos);	}
public static UnicodeEscaper between(final int codepointLow, final int codepointHigh) {	    return new UnicodeEscaper(codepointLow, codepointHigh, true);	}
@Override	public Date parse(final String source, final ParsePosition pos) {	    final int offset = pos.getIndex();	    final Matcher matcher = parsePattern.matcher(source.substring(offset));	    if (!matcher.lookingAt()) {	        return null;	    }	    final Calendar cal = Calendar.getInstance(timeZone, locale);	    cal.clear();	    for (int i = 0; i < strategies.length; ) {	        final Strategy strategy = strategies[i++];	        strategy.setCalendar(this, cal, matcher.group(i));	    }	    pos.setIndex(offset + matcher.end());	    return cal.getTime();	}
public int capacity() {	    return buffer.length;	}
public static String formatUTC(final Date date, final String pattern, final Locale locale) {	    return format(date, pattern, UTC_TIME_ZONE, locale);	}
public static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) {	    if (0 == nBools) {	        return dst;	    }	    if (nBools - 1 + srcPos >= 8) {	        throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 8");	    }	    int shift = 0;	    for (int i = 0; i < nBools; i++) {	        shift = i * 1 + srcPos;	        dst[dstPos + i] = ((0x1 & (src >> shift)) != 0);	    }	    return dst;	}
public int getNumerator() {	    return numerator;	}
protected boolean isFieldSeparatorAtEnd() {	    return fieldSeparatorAtEnd;	}
public static Date setDays(final Date date, final int amount) {	    return set(date, Calendar.DAY_OF_MONTH, amount);	}
@Override	public int hashCode() {	    return toHashCode();	}
public final T getObject() {	    return object;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static String prependIfMissing(final String str, final CharSequence prefix, final CharSequence... prefixes) {	    return prependIfMissing(str, prefix, false, prefixes);	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public static boolean isNumericSpace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isDigit(cs.charAt(i)) == false && cs.charAt(i) != ' ') {	            return false;	        }	    }	    return true;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale) {	    return cache.getInstance(pattern, timeZone, locale);	}
public static <T> Range<T> is(final T element, final Comparator<T> comparator) {	    return between(element, element, comparator);	}
@Override	public int length() {	    return size;	}
public static <T> T CONST(final T v) {	    return v;	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static boolean containsAny(final CharSequence cs, final CharSequence searchChars) {	    if (searchChars == null) {	        return false;	    }	    return containsAny(cs, CharSequenceUtils.toCharArray(searchChars));	}
public StrBuilder appendFixedWidthPadRight(final int value, final int width, final char padChar) {	    return appendFixedWidthPadRight(String.valueOf(value), width, padChar);	}
public static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts) {	    if ((src.length == 0 && srcPos == 0) || 0 == nInts) {	        return dstInit;	    }	    if ((nInts - 1) * 32 + dstPos >= 64) {	        throw new IllegalArgumentException("(nInts-1)*32+dstPos is greather or equal to than 64");	    }	    long out = dstInit;	    int shift = 0;	    for (int i = 0; i < nInts; i++) {	        shift = i * 32 + dstPos;	        final long bits = ((0xffffffffL & src[i + srcPos]) << shift);	        final long mask = 0xffffffffL << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
@Override	public int compare(final Object obj1, final Object obj2) {	    return ((Comparable) obj1).compareTo(obj2);	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public StrBuilder setLength(final int length) {	    if (length < 0) {	        throw new StringIndexOutOfBoundsException(length);	    }	    if (length < size) {	        size = length;	    } else if (length > size) {	        ensureCapacity(length);	        final int oldEnd = size;	        final int newEnd = length;	        size = length;	        for (int i = oldEnd; i < newEnd; i++) {	            buffer[i] = '\0';	        }	    }	    return this;	}
public StrTokenizer setEmptyTokenAsNull(final boolean emptyAsNull) {	    this.emptyAsNull = emptyAsNull;	    return this;	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
protected boolean isFieldSeparatorAtStart() {	    return fieldSeparatorAtStart;	}
public static String appendIfMissingIgnoreCase(final String str, final CharSequence suffix, final CharSequence... suffixes) {	    return appendIfMissing(str, suffix, true, suffixes);	}
public static <L, M, R> MutableTriple<L, M, R> of(final L left, final M middle, final R right) {	    return new MutableTriple<L, M, R>(left, middle, right);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
@Override	public String next() {	    if (hasNext()) {	        return tokens[tokenPos++];	    }	    throw new NoSuchElementException();	}
@Override	public boolean markSupported() {	    return true;	}
public static String prependIfMissing(final String str, final CharSequence prefix, final CharSequence... prefixes) {	    return prependIfMissing(str, prefix, false, prefixes);	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static float max(final float a, final float b, final float c) {	    return Math.max(Math.max(a, b), c);	}
public static String capitalize(final String str) {	    int strLen;	    if (str == null || (strLen = str.length()) == 0) {	        return str;	    }	    char firstChar = str.charAt(0);	    if (Character.isTitleCase(firstChar)) {	        return str;	    }	    return new StringBuilder(strLen).append(Character.toTitleCase(firstChar)).append(str.substring(1)).toString();	}
public static <T> T deserialize(final byte[] objectData) {	    if (objectData == null) {	        throw new IllegalArgumentException("The byte[] must not be null");	    }	    return SerializationUtils.<T>deserialize(new ByteArrayInputStream(objectData));	}
public char getStart() {	    return this.start;	}
static Set<Pair<IDKey, IDKey>> getRegistry() {	    return REGISTRY.get();	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return true;	    }	    if (lhs == null || rhs == null) {	        return false;	    }	    final Class<?> lhsClass = lhs.getClass();	    final Class<?> rhsClass = rhs.getClass();	    Class<?> testClass;	    if (lhsClass.isInstance(rhs)) {	        testClass = lhsClass;	        if (!rhsClass.isInstance(lhs)) {	            testClass = rhsClass;	        }	    } else if (rhsClass.isInstance(lhs)) {	        testClass = rhsClass;	        if (!lhsClass.isInstance(rhs)) {	            testClass = lhsClass;	        }	    } else {	        return false;	    }	    final EqualsBuilder equalsBuilder = new EqualsBuilder();	    try {	        reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {	            testClass = testClass.getSuperclass();	            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        }	    } catch (final IllegalArgumentException e) {	        return false;	    }	    return equalsBuilder.isEquals();	}
public int size() {	    return size;	}
public String toString(final String format) {	    return String.format(format, minimum, maximum, comparator);	}
public static CharRange isNotIn(final char start, final char end) {	    return new CharRange(start, end, true);	}
static String[] toNoNullStringArray(final Object[] array) {	    final List<String> list = new ArrayList<String>(array.length);	    for (final Object e : array) {	        if (e != null) {	            list.add(e.toString());	        }	    }	    return list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);	}
public static boolean[] removeElements(final boolean[] array, final boolean... values) {	    if (isEmpty(array) || isEmpty(values)) {	        return clone(array);	    }	    final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2);	    for (final boolean v : values) {	        final Boolean boxed = Boolean.valueOf(v);	        final MutableInt count = occurrences.get(boxed);	        if (count == null) {	            occurrences.put(boxed, new MutableInt(1));	        } else {	            count.increment();	        }	    }	    final BitSet toRemove = new BitSet();	    for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) {	        final Boolean v = e.getKey();	        int found = 0;	        for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {	            found = indexOf(array, v.booleanValue(), found);	            if (found < 0) {	                break;	            }	            toRemove.set(found++);	        }	    }	    return (boolean[]) removeAll(array, toRemove);	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static String[] splitByCharacterTypeCamelCase(final String str) {	    return splitByCharacterType(str, true);	}
public String toProperString() {	    if (toProperString == null) {	        if (numerator == 0) {	            toProperString = "0";	        } else if (numerator == denominator) {	            toProperString = "1";	        } else if (numerator == -1 * denominator) {	            toProperString = "-1";	        } else if ((numerator > 0 ? -numerator : numerator) < -denominator) {	            final int properNumerator = getProperNumerator();	            if (properNumerator == 0) {	                toProperString = Integer.toString(getProperWhole());	            } else {	                toProperString = new StringBuilder(32).append(getProperWhole()).append(' ').append(properNumerator).append('/').append(getDenominator()).toString();	            }	        } else {	            toProperString = new StringBuilder(32).append(getNumerator()).append('/').append(getDenominator()).toString();	        }	    }	    return toProperString;	}
public boolean isEquals() {	    return this.isEquals;	}
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] result = new boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        final Boolean b = array[i];	        result[i] = (b == null ? valueForNull : b.booleanValue());	    }	    return result;	}
public static StrMatcher doubleQuoteMatcher() {	    return DOUBLE_QUOTE_MATCHER;	}
public String getNullText() {	    return nullText;	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static CharRange is(final char ch) {	    return new CharRange(ch, ch, false);	}
public static String stripEnd(final String str, final String stripChars) {	    int end;	    if (str == null || (end = str.length()) == 0) {	        return str;	    }	    if (stripChars == null) {	        while (end != 0 && Character.isWhitespace(str.charAt(end - 1))) {	            end--;	        }	    } else if (stripChars.isEmpty()) {	        return str;	    } else {	        while (end != 0 && stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND) {	            end--;	        }	    }	    return str.substring(0, end);	}
@Override	public Date parse(final String source, final ParsePosition pos) {	    final int offset = pos.getIndex();	    final Matcher matcher = parsePattern.matcher(source.substring(offset));	    if (!matcher.lookingAt()) {	        return null;	    }	    final Calendar cal = Calendar.getInstance(timeZone, locale);	    cal.clear();	    for (int i = 0; i < strategies.length; ) {	        final Strategy strategy = strategies[i++];	        strategy.setCalendar(this, cal, matcher.group(i));	    }	    pos.setIndex(offset + matcher.end());	    return cal.getTime();	}
@Override	public TimeZone getTimeZone() {	    return timeZone;	}
public static String right(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(str.length() - len);	}
@Override	public int length() {	    return size;	}
public Comparator<T> getComparator() {	    return comparator;	}
public StrBuilder deleteAll(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, -1);	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public String getNullText() {	    return nullText;	}
public static boolean containsAny(final String str, final String... set) {	    if (StringUtils.isEmpty(str) || deepEmpty(set)) {	        return false;	    }	    final CharSet chars = CharSet.getInstance(set);	    for (final char c : str.toCharArray()) {	        if (chars.contains(c)) {	            return true;	        }	    }	    return false;	}
public int getDenominator() {	    return denominator;	}
public static String[][] ISO8859_1_ESCAPE() {	    return ISO8859_1_ESCAPE.clone();	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) {	    if (toClass == null) {	        return false;	    }	    if (cls == null) {	        return !toClass.isPrimitive();	    }	    if (autoboxing) {	        if (cls.isPrimitive() && !toClass.isPrimitive()) {	            cls = primitiveToWrapper(cls);	            if (cls == null) {	                return false;	            }	        }	        if (toClass.isPrimitive() && !cls.isPrimitive()) {	            cls = wrapperToPrimitive(cls);	            if (cls == null) {	                return false;	            }	        }	    }	    if (cls.equals(toClass)) {	        return true;	    }	    if (cls.isPrimitive()) {	        if (toClass.isPrimitive() == false) {	            return false;	        }	        if (Integer.TYPE.equals(cls)) {	            return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Long.TYPE.equals(cls)) {	            return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Boolean.TYPE.equals(cls)) {	            return false;	        }	        if (Double.TYPE.equals(cls)) {	            return false;	        }	        if (Float.TYPE.equals(cls)) {	            return Double.TYPE.equals(toClass);	        }	        if (Character.TYPE.equals(cls)) {	            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Short.TYPE.equals(cls)) {	            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Byte.TYPE.equals(cls)) {	            return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        return false;	    }	    return toClass.isAssignableFrom(cls);	}
public static String random(final int count, final char... chars) {	    if (chars == null) {	        return random(count, 0, 0, false, false, null, RANDOM);	    }	    return random(count, 0, chars.length, false, false, chars, RANDOM);	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
static Throwable checkedException(final Throwable ex) {	    if (ex != null && !(ex instanceof RuntimeException) && !(ex instanceof Error)) {	        return ex;	    } else {	        throw new IllegalArgumentException("Not a checked exception: " + ex);	    }	}
@Override	public int length() {	    return size;	}
static boolean isOSNameMatch(final String osName, final String osNamePrefix) {	    if (osName == null) {	        return false;	    }	    return osName.startsWith(osNamePrefix);	}
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] result = new boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        final Boolean b = array[i];	        result[i] = (b == null ? valueForNull : b.booleanValue());	    }	    return result;	}
public static String unicodeEscaped(final Character ch) {	    if (ch == null) {	        return null;	    }	    return unicodeEscaped(ch.charValue());	}
public static int reflectionHashCode(final Object object, final String... excludeFields) {	    return reflectionHashCode(17, 37, object, false, null, excludeFields);	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
public static boolean equals(final Annotation a1, final Annotation a2) {	    if (a1 == a2) {	        return true;	    }	    if (a1 == null || a2 == null) {	        return false;	    }	    final Class<? extends Annotation> type = a1.annotationType();	    final Class<? extends Annotation> type2 = a2.annotationType();	    Validate.notNull(type, "Annotation %s with null annotationType()", a1);	    Validate.notNull(type2, "Annotation %s with null annotationType()", a2);	    if (!type.equals(type2)) {	        return false;	    }	    try {	        for (final Method m : type.getDeclaredMethods()) {	            if (m.getParameterTypes().length == 0 && isValidAnnotationMemberType(m.getReturnType())) {	                final Object v1 = m.invoke(a1);	                final Object v2 = m.invoke(a2);	                if (!memberEquals(m.getReturnType(), v1, v2)) {	                    return false;	                }	            }	        }	    } catch (final IllegalAccessException ex) {	        return false;	    } catch (final InvocationTargetException ex) {	        return false;	    }	    return true;	}
protected void setSummaryObjectStartText(String summaryObjectStartText) {	    if (summaryObjectStartText == null) {	        summaryObjectStartText = "";	    }	    this.summaryObjectStartText = summaryObjectStartText;	}
public static boolean endsWithIgnoreCase(final CharSequence str, final CharSequence suffix) {	    return endsWith(str, suffix, true);	}
public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) {	    if (it != null) {	        separator = ObjectUtils.toString(separator);	        while (it.hasNext()) {	            append(it.next());	            if (it.hasNext()) {	                append(separator);	            }	        }	    }	    return this;	}
public static ConcurrentRuntimeException extractCauseUnchecked(final ExecutionException ex) {	    if (ex == null || ex.getCause() == null) {	        return null;	    }	    throwCause(ex);	    return new ConcurrentRuntimeException(ex.getMessage(), ex.getCause());	}
protected boolean isUseClassName() {	    return useClassName;	}
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) {	    style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));	    return this;	}
@Override	public T get(final long timeout, final TimeUnit unit) {	    return value;	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static boolean equalsIgnoreCase(final CharSequence str1, final CharSequence str2) {	    if (str1 == null || str2 == null) {	        return str1 == str2;	    } else if (str1 == str2) {	        return true;	    } else if (str1.length() != str2.length()) {	        return false;	    } else {	        return CharSequenceUtils.regionMatches(str1, true, 0, str2, 0, str1.length());	    }	}
protected String getFieldSeparator() {	    return fieldSeparator;	}
public static String getCommonPrefix(final String... strs) {	    if (strs == null || strs.length == 0) {	        return EMPTY;	    }	    final int smallestIndexOfDiff = indexOfDifference(strs);	    if (smallestIndexOfDiff == INDEX_NOT_FOUND) {	        if (strs[0] == null) {	            return EMPTY;	        }	        return strs[0];	    } else if (smallestIndexOfDiff == 0) {	        return EMPTY;	    } else {	        return strs[0].substring(0, smallestIndexOfDiff);	    }	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static Date ceiling(final Object date, final int field) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (date instanceof Date) {	        return ceiling((Date) date, field);	    } else if (date instanceof Calendar) {	        return ceiling((Calendar) date, field).getTime();	    } else {	        throw new ClassCastException("Could not find ceiling of for type: " + date.getClass());	    }	}
public static String prependIfMissing(final String str, final CharSequence prefix, final CharSequence... prefixes) {	    return prependIfMissing(str, prefix, false, prefixes);	}
public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale) {	    return cache.getInstance(pattern, timeZone, locale);	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public synchronized boolean start() {	    if (!isStarted()) {	        ExecutorService tempExec;	        executor = getExternalExecutor();	        if (executor == null) {	            executor = tempExec = createExecutor();	        } else {	            tempExec = null;	        }	        future = executor.submit(createTask(tempExec));	        return true;	    }	    return false;	}
public char getEscapeChar() {	    return this.escapeChar;	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
public int toComparison() {	    return comparison;	}
public int size() {	    return size;	}
@Override	public Integer build() {	    return Integer.valueOf(toHashCode());	}
public static boolean equalsIgnoreCase(final CharSequence str1, final CharSequence str2) {	    if (str1 == null || str2 == null) {	        return str1 == str2;	    } else if (str1 == str2) {	        return true;	    } else if (str1.length() != str2.length()) {	        return false;	    } else {	        return CharSequenceUtils.regionMatches(str1, true, 0, str2, 0, str1.length());	    }	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
@Override	public int nextIndex() {	    return tokenPos;	}
public static StrTokenizer getTSVInstance(final char[] input) {	    final StrTokenizer tok = getTSVClone();	    tok.reset(input);	    return tok;	}
public boolean isEmpty() {	    return size == 0;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public boolean contains(final T element) {	    if (element == null) {	        return false;	    }	    return comparator.compare(element, minimum) > -1 && comparator.compare(element, maximum) < 1;	}
public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {	    if (str == null || searchStr == null) {	        return INDEX_NOT_FOUND;	    }	    if (startPos > str.length() - searchStr.length()) {	        startPos = str.length() - searchStr.length();	    }	    if (startPos < 0) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return startPos;	    }	    for (int i = startPos; i >= 0; i--) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public void appendToString(final StringBuffer buffer, final String toString) {	    if (toString != null) {	        final int pos1 = toString.indexOf(contentStart) + contentStart.length();	        final int pos2 = toString.lastIndexOf(contentEnd);	        if (pos1 != pos2 && pos1 >= 0 && pos2 >= 0) {	            final String data = toString.substring(pos1, pos2);	            if (fieldSeparatorAtStart) {	                removeLastFieldSeparator(buffer);	            }	            buffer.append(data);	            appendFieldSeparator(buffer);	        }	    }	}
@Override	public int compareTo(final MutableDouble other) {	    final double anotherVal = other.value;	    return Double.compare(value, anotherVal);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
@Override	public void write(final String str, final int off, final int len) {	    StrBuilder.this.append(str, off, len);	}
private static Date set(final Date date, final int calendarField, final int amount) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final Calendar c = Calendar.getInstance();	    c.setLenient(false);	    c.setTime(date);	    c.set(calendarField, amount);	    return c.getTime();	}
public static String reverse(final String str) {	    if (str == null) {	        return null;	    }	    return new StringBuilder(str).reverse().toString();	}
public boolean contains(final StrMatcher matcher) {	    return indexOf(matcher, 0) >= 0;	}
public static String trimToEmpty(final String str) {	    return str == null ? EMPTY : str.trim();	}
public String getNewLineText() {	    return newLine;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static String getPackageName(String className) {	    if (StringUtils.isEmpty(className)) {	        return StringUtils.EMPTY;	    }	    while (className.charAt(0) == '[') {	        className = className.substring(1);	    }	    if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {	        className = className.substring(1);	    }	    final int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);	    if (i == -1) {	        return StringUtils.EMPTY;	    }	    return className.substring(0, i);	}
public static boolean[] hexDigitToBinary(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return new boolean[] { false, false, false, false };	        case '1':	            return new boolean[] { true, false, false, false };	        case '2':	            return new boolean[] { false, true, false, false };	        case '3':	            return new boolean[] { true, true, false, false };	        case '4':	            return new boolean[] { false, false, true, false };	        case '5':	            return new boolean[] { true, false, true, false };	        case '6':	            return new boolean[] { false, true, true, false };	        case '7':	            return new boolean[] { true, true, true, false };	        case '8':	            return new boolean[] { false, false, false, true };	        case '9':	            return new boolean[] { true, false, false, true };	        case 'a':	        case 'A':	            return new boolean[] { false, true, false, true };	        case 'b':	        case 'B':	            return new boolean[] { true, true, false, true };	        case 'c':	        case 'C':	            return new boolean[] { false, false, true, true };	        case 'd':	        case 'D':	            return new boolean[] { true, false, true, true };	        case 'e':	        case 'E':	            return new boolean[] { false, true, true, true };	        case 'f':	        case 'F':	            return new boolean[] { true, true, true, true };	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
@Override	public DefaultExceptionContext setContextValue(final String label, final Object value) {	    for (final Iterator<Pair<String, Object>> iter = contextValues.iterator(); iter.hasNext(); ) {	        final Pair<String, Object> p = iter.next();	        if (StringUtils.equals(label, p.getKey())) {	            iter.remove();	        }	    }	    addContextValue(label, value);	    return this;	}
protected String getSizeStartText() {	    return sizeStartText;	}
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) {	    if (bool == null) {	        return nullValue;	    }	    return bool.booleanValue() ? trueValue : falseValue;	}
public static String substringBefore(final String str, final String separator) {	    if (isEmpty(str) || separator == null) {	        return str;	    }	    if (separator.isEmpty()) {	        return EMPTY;	    }	    final int pos = str.indexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return str;	    }	    return str.substring(0, pos);	}
public int size() {	    return size;	}
public static StrTokenizer getCSVInstance(final char[] input) {	    final StrTokenizer tok = getCSVClone();	    tok.reset(input);	    return tok;	}
public static String trimToNull(final String str) {	    final String ts = trim(str);	    return isEmpty(ts) ? null : ts;	}
public int size() {	    return size;	}
public static Class<?> getClass(final String className, final boolean initialize) throws ClassNotFoundException {	    final ClassLoader contextCL = Thread.currentThread().getContextClassLoader();	    final ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL;	    return getClass(loader, className, initialize);	}
protected String getArraySeparator() {	    return arraySeparator;	}
public static Date truncate(final Object date, final int field) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (date instanceof Date) {	        return truncate((Date) date, field);	    } else if (date instanceof Calendar) {	        return truncate((Calendar) date, field).getTime();	    } else {	        throw new ClassCastException("Could not truncate " + date);	    }	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof MutableShort) {	        return value == ((MutableShort) obj).shortValue();	    }	    return false;	}
public static CharRange is(final char ch) {	    return new CharRange(ch, ch, false);	}
public static String upperCase(final String str, final Locale locale) {	    if (str == null) {	        return null;	    }	    return str.toUpperCase(locale);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) {	    final Token[] tokens = lexx(format);	    final Calendar start = Calendar.getInstance(timezone);	    start.setTime(new Date(startMillis));	    final Calendar end = Calendar.getInstance(timezone);	    end.setTime(new Date(endMillis));	    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);	    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);	    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);	    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);	    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);	    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);	    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);	    while (milliseconds < 0) {	        milliseconds += 1000;	        seconds -= 1;	    }	    while (seconds < 0) {	        seconds += 60;	        minutes -= 1;	    }	    while (minutes < 0) {	        minutes += 60;	        hours -= 1;	    }	    while (hours < 0) {	        hours += 24;	        days -= 1;	    }	    if (Token.containsTokenWithValue(tokens, M)) {	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	        while (months < 0) {	            months += 12;	            years -= 1;	        }	        if (!Token.containsTokenWithValue(tokens, y) && years != 0) {	            while (years != 0) {	                months += 12 * years;	                years = 0;	            }	        }	    } else {	        if (!Token.containsTokenWithValue(tokens, y)) {	            int target = end.get(Calendar.YEAR);	            if (months < 0) {	                target -= 1;	            }	            while (start.get(Calendar.YEAR) != target) {	                days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);	                if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) {	                    days += 1;	                }	                start.add(Calendar.YEAR, 1);	                days += start.get(Calendar.DAY_OF_YEAR);	            }	            years = 0;	        }	        while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            start.add(Calendar.MONTH, 1);	        }	        months = 0;	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	    }	    if (!Token.containsTokenWithValue(tokens, d)) {	        hours += 24 * days;	        days = 0;	    }	    if (!Token.containsTokenWithValue(tokens, H)) {	        minutes += 60 * hours;	        hours = 0;	    }	    if (!Token.containsTokenWithValue(tokens, m)) {	        seconds += 60 * minutes;	        minutes = 0;	    }	    if (!Token.containsTokenWithValue(tokens, s)) {	        milliseconds += 1000 * seconds;	        seconds = 0;	    }	    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
protected boolean isFieldSeparatorAtEnd() {	    return fieldSeparatorAtEnd;	}
public boolean isSet(final OPTION option) {	    return options == null ? false : options.contains(option);	}
public HashCodeBuilder append(final short[] array) {	    if (array == null) {	        iTotal = iTotal * iConstant;	    } else {	        for (final short element : array) {	            append(element);	        }	    }	    return this;	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer) {	    if (throwable == null) {	        return;	    }	    if (writer == null) {	        throw new IllegalArgumentException("The PrintWriter must not be null");	    }	    final String[] trace = getRootCauseStackTrace(throwable);	    for (final String element : trace) {	        writer.println(element);	    }	    writer.flush();	}
public static int indexOfDifference(final CharSequence... css) {	    if (css == null || css.length <= 1) {	        return INDEX_NOT_FOUND;	    }	    boolean anyStringNull = false;	    boolean allStringsNull = true;	    final int arrayLen = css.length;	    int shortestStrLen = Integer.MAX_VALUE;	    int longestStrLen = 0;	    for (int i = 0; i < arrayLen; i++) {	        if (css[i] == null) {	            anyStringNull = true;	            shortestStrLen = 0;	        } else {	            allStringsNull = false;	            shortestStrLen = Math.min(css[i].length(), shortestStrLen);	            longestStrLen = Math.max(css[i].length(), longestStrLen);	        }	    }	    if (allStringsNull || longestStrLen == 0 && !anyStringNull) {	        return INDEX_NOT_FOUND;	    }	    if (shortestStrLen == 0) {	        return 0;	    }	    int firstDiff = -1;	    for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {	        final char comparisonChar = css[0].charAt(stringPos);	        for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {	            if (css[arrayPos].charAt(stringPos) != comparisonChar) {	                firstDiff = stringPos;	                break;	            }	        }	        if (firstDiff != -1) {	            break;	        }	    }	    if (firstDiff == -1 && shortestStrLen != longestStrLen) {	        return shortestStrLen;	    }	    return firstDiff;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
protected boolean isFieldSeparatorAtEnd() {	    return fieldSeparatorAtEnd;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) {	    if (s == null || t == null) {	        throw new IllegalArgumentException("Strings must not be null");	    }	    if (threshold < 0) {	        throw new IllegalArgumentException("Threshold must not be negative");	    }	    int n = s.length();	    int m = t.length();	    if (n == 0) {	        return m <= threshold ? m : -1;	    } else if (m == 0) {	        return n <= threshold ? n : -1;	    }	    if (n > m) {	        final CharSequence tmp = s;	        s = t;	        t = tmp;	        n = m;	        m = t.length();	    }	    int[] p = new int[n + 1];	    int[] d = new int[n + 1];	    int[] _d;	    final int boundary = Math.min(n, threshold) + 1;	    for (int i = 0; i < boundary; i++) {	        p[i] = i;	    }	    Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);	    Arrays.fill(d, Integer.MAX_VALUE);	    for (int j = 1; j <= m; j++) {	        final char t_j = t.charAt(j - 1);	        d[0] = j;	        final int min = Math.max(1, j - threshold);	        final int max = Math.min(n, j + threshold);	        if (min > max) {	            return -1;	        }	        if (min > 1) {	            d[min - 1] = Integer.MAX_VALUE;	        }	        for (int i = min; i <= max; i++) {	            if (s.charAt(i - 1) == t_j) {	                d[i] = p[i - 1];	            } else {	                d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);	            }	        }	        _d = p;	        p = d;	        d = _d;	    }	    if (p[n] <= threshold) {	        return p[n];	    }	    return -1;	}
public StrBuilder trim() {	    if (size == 0) {	        return this;	    }	    int len = size;	    final char[] buf = buffer;	    int pos = 0;	    while (pos < len && buf[pos] <= ' ') {	        pos++;	    }	    while (pos < len && buf[len - 1] <= ' ') {	        len--;	    }	    if (len < size) {	        delete(len, size);	    }	    if (pos > 0) {	        delete(0, pos);	    }	    return this;	}
@Override	public TimeZone getTimeZone() {	    return timeZone;	}
public static String removeStart(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.startsWith(remove)) {	        return str.substring(remove.length());	    }	    return str;	}
public void setVariableResolver(final StrLookup<?> variableResolver) {	    this.variableResolver = variableResolver;	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
public String getNewLineText() {	    return newLine;	}
public static <T extends CharSequence> T validIndex(final T chars, final int index) {	    return validIndex(chars, index, DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE, Integer.valueOf(index));	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static boolean isNumericSpace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isDigit(cs.charAt(i)) == false && cs.charAt(i) != ' ') {	            return false;	        }	    }	    return true;	}
public int capacity() {	    return buffer.length;	}
public int capacity() {	    return buffer.length;	}
public static String repeat(final char ch, final int repeat) {	    final char[] buf = new char[repeat];	    for (int i = repeat - 1; i >= 0; i--) {	        buf[i] = ch;	    }	    return new String(buf);	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
protected String getSizeStartText() {	    return sizeStartText;	}
public static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes) {	    if ((src.length == 0 && srcPos == 0) || 0 == nBytes) {	        return dstInit;	    }	    if ((nBytes - 1) * 8 + dstPos >= 16) {	        throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 16");	    }	    short out = dstInit;	    int shift = 0;	    for (int i = 0; i < nBytes; i++) {	        shift = i * 8 + dstPos;	        final int bits = (0xff & src[i + srcPos]) << shift;	        final int mask = 0xff << shift;	        out = (short) ((out & ~mask) | bits);	    }	    return out;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static String toString(final boolean bool, final String trueString, final String falseString) {	    return bool ? trueString : falseString;	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
public ToStringBuilder appendToString(final String toString) {	    if (toString != null) {	        style.appendToString(buffer, toString);	    }	    return this;	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
@Override	public int length() {	    return size;	}
public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale) {	    return cache.getTimeInstance(style, timeZone, locale);	}
public static StrMatcher stringMatcher(final String str) {	    if (StringUtils.isEmpty(str)) {	        return NONE_MATCHER;	    }	    return new StringMatcher(str);	}
@Override	public List<Object> getContextValues(final String label) {	    return this.exceptionContext.getContextValues(label);	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    if (index != 0) {	        throw new IllegalStateException("CsvUnescaper should never reach the [1] index");	    }	    if (input.charAt(0) != CSV_QUOTE || input.charAt(input.length() - 1) != CSV_QUOTE) {	        out.write(input.toString());	        return input.length();	    }	    final String quoteless = input.subSequence(1, input.length() - 1).toString();	    if (StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS)) {	        out.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR));	    } else {	        out.write(input.toString());	    }	    return input.length();	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static boolean isNumericSpace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isDigit(cs.charAt(i)) == false && cs.charAt(i) != ' ') {	            return false;	        }	    }	    return true;	}
public boolean isEmpty() {	    return size == 0;	}
public static boolean[] hexDigitToBinary(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return new boolean[] { false, false, false, false };	        case '1':	            return new boolean[] { true, false, false, false };	        case '2':	            return new boolean[] { false, true, false, false };	        case '3':	            return new boolean[] { true, true, false, false };	        case '4':	            return new boolean[] { false, false, true, false };	        case '5':	            return new boolean[] { true, false, true, false };	        case '6':	            return new boolean[] { false, true, true, false };	        case '7':	            return new boolean[] { true, true, true, false };	        case '8':	            return new boolean[] { false, false, false, true };	        case '9':	            return new boolean[] { true, false, false, true };	        case 'a':	        case 'A':	            return new boolean[] { false, true, false, true };	        case 'b':	        case 'B':	            return new boolean[] { true, true, false, true };	        case 'c':	        case 'C':	            return new boolean[] { false, false, true, true };	        case 'd':	        case 'D':	            return new boolean[] { true, false, true, true };	        case 'e':	        case 'E':	            return new boolean[] { false, true, true, true };	        case 'f':	        case 'F':	            return new boolean[] { true, true, true, true };	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public static boolean isAsciiAlpha(final char ch) {	    return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');	}
protected String getSizeEndText() {	    return sizeEndText;	}
public static <T extends CharSequence> T validIndex(final T chars, final int index) {	    return validIndex(chars, index, DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE, Integer.valueOf(index));	}
protected String getFieldSeparator() {	    return fieldSeparator;	}
public static boolean containsAny(final CharSequence cs, final CharSequence searchChars) {	    if (searchChars == null) {	        return false;	    }	    return containsAny(cs, CharSequenceUtils.toCharArray(searchChars));	}
public static String substringBefore(final String str, final String separator) {	    if (isEmpty(str) || separator == null) {	        return str;	    }	    if (separator.isEmpty()) {	        return EMPTY;	    }	    final int pos = str.indexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return str;	    }	    return str.substring(0, pos);	}
protected boolean isDefaultFullDetail() {	    return defaultFullDetail;	}
public StringBuilder toStringBuilder() {	    return new StringBuilder(size).append(buffer, 0, size);	}
public static ConcurrentRuntimeException extractCauseUnchecked(final ExecutionException ex) {	    if (ex == null || ex.getCause() == null) {	        return null;	    }	    throwCause(ex);	    return new ConcurrentRuntimeException(ex.getMessage(), ex.getCause());	}
public static String mid(final String str, int pos, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0 || pos > str.length()) {	        return EMPTY;	    }	    if (pos < 0) {	        pos = 0;	    }	    if (str.length() <= pos + len) {	        return str.substring(pos);	    }	    return str.substring(pos, pos + len);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
protected String getSizeEndText() {	    return sizeEndText;	}
@Override	public TimeZone getTimeZone() {	    return timeZone;	}
public int toComparison() {	    return comparison;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static String normalizeSpace(final String str) {	    if (str == null) {	        return null;	    }	    return WHITESPACE_PATTERN.matcher(trim(str)).replaceAll(SPACE);	}
@Override	public void flush() {	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static boolean isAscii(final char ch) {	    return ch < 128;	}
public int capacity() {	    return buffer.length;	}
public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale) {	    return cache.getDateInstance(style, timeZone, locale);	}
public static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex) {	    if (0 == nHex) {	        return dstInit;	    }	    if ((nHex - 1) * 4 + dstPos >= 64) {	        throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 64");	    }	    long out = dstInit;	    int shift = 0;	    for (int i = 0; i < nHex; i++) {	        shift = i * 4 + dstPos;	        final long bits = (0xfL & hexDigitToInt(src.charAt(i + srcPos))) << shift;	        final long mask = 0xfL << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static Date truncate(final Object date, final int field) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (date instanceof Date) {	        return truncate((Date) date, field);	    } else if (date instanceof Calendar) {	        return truncate((Calendar) date, field).getTime();	    } else {	        throw new ClassCastException("Could not truncate " + date);	    }	}
protected boolean isArrayContentDetail() {	    return arrayContentDetail;	}
public static void isInstanceOf(final Class<?> type, final Object obj, final String message, final Object... values) {	    if (type.isInstance(obj) == false) {	        throw new IllegalArgumentException(String.format(message, values));	    }	}
@Override	public final void applyPattern(final String pattern) {	    if (registry == null) {	        super.applyPattern(pattern);	        toPattern = super.toPattern();	        return;	    }	    final ArrayList<Format> foundFormats = new ArrayList<Format>();	    final ArrayList<String> foundDescriptions = new ArrayList<String>();	    final StringBuilder stripCustom = new StringBuilder(pattern.length());	    final ParsePosition pos = new ParsePosition(0);	    final char[] c = pattern.toCharArray();	    int fmtCount = 0;	    while (pos.getIndex() < pattern.length()) {	        switch(c[pos.getIndex()]) {	            case QUOTE:	                appendQuotedString(pattern, pos, stripCustom, true);	                break;	            case START_FE:	                fmtCount++;	                seekNonWs(pattern, pos);	                final int start = pos.getIndex();	                final int index = readArgumentIndex(pattern, next(pos));	                stripCustom.append(START_FE).append(index);	                seekNonWs(pattern, pos);	                Format format = null;	                String formatDescription = null;	                if (c[pos.getIndex()] == START_FMT) {	                    formatDescription = parseFormatDescription(pattern, next(pos));	                    format = getFormat(formatDescription);	                    if (format == null) {	                        stripCustom.append(START_FMT).append(formatDescription);	                    }	                }	                foundFormats.add(format);	                foundDescriptions.add(format == null ? null : formatDescription);	                Validate.isTrue(foundFormats.size() == fmtCount);	                Validate.isTrue(foundDescriptions.size() == fmtCount);	                if (c[pos.getIndex()] != END_FE) {	                    throw new IllegalArgumentException("Unreadable format element at position " + start);	                }	            default:	                stripCustom.append(c[pos.getIndex()]);	                next(pos);	        }	    }	    super.applyPattern(stripCustom.toString());	    toPattern = insertFormats(super.toPattern(), foundDescriptions);	    if (containsElements(foundFormats)) {	        final Format[] origFormats = getFormats();	        int i = 0;	        for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) {	            final Format f = it.next();	            if (f != null) {	                origFormats[i] = f;	            }	        }	        super.setFormats(origFormats);	    }	}
public String getNewLineText() {	    return newLine;	}
public static String getCommonPrefix(final String... strs) {	    if (strs == null || strs.length == 0) {	        return EMPTY;	    }	    final int smallestIndexOfDiff = indexOfDifference(strs);	    if (smallestIndexOfDiff == INDEX_NOT_FOUND) {	        if (strs[0] == null) {	            return EMPTY;	        }	        return strs[0];	    } else if (smallestIndexOfDiff == 0) {	        return EMPTY;	    } else {	        return strs[0].substring(0, smallestIndexOfDiff);	    }	}
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = Integer.MAX_VALUE;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.indexOf(str, search, 0);	        if (tmp == INDEX_NOT_FOUND) {	            continue;	        }	        if (tmp < ret) {	            ret = tmp;	        }	    }	    return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public String midString(int index, final int length) {	    if (index < 0) {	        index = 0;	    }	    if (length <= 0 || index >= size) {	        return "";	    }	    if (size <= index + length) {	        return new String(buffer, index, size - index);	    }	    return new String(buffer, index, length);	}
public boolean isEmpty() {	    return size == 0;	}
public static Date setDays(final Date date, final int amount) {	    return set(date, Calendar.DAY_OF_MONTH, amount);	}
public String getNewLineText() {	    return newLine;	}
public static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes) {	    if ((src.length == 0 && srcPos == 0) || 0 == nBytes) {	        return dstInit;	    }	    if ((nBytes - 1) * 8 + dstPos >= 16) {	        throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 16");	    }	    short out = dstInit;	    int shift = 0;	    for (int i = 0; i < nBytes; i++) {	        shift = i * 8 + dstPos;	        final int bits = (0xff & src[i + srcPos]) << shift;	        final int mask = 0xff << shift;	        out = (short) ((out & ~mask) | bits);	    }	    return out;	}
public StrBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar) {	    return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static boolean isAvailableLocale(final Locale locale) {	    return availableLocaleList().contains(locale);	}
public static <T extends CharSequence> T defaultIfEmpty(final T str, final T defaultStr) {	    return StringUtils.isEmpty(str) ? defaultStr : str;	}
public boolean isEmpty() {	    return size == 0;	}
public char getEscapeChar() {	    return this.escapeChar;	}
protected boolean isUseShortClassName() {	    return useShortClassName;	}
public static <T> Constructor<T> getAccessibleConstructor(final Constructor<T> ctor) {	    return MemberUtils.isAccessible(ctor) && Modifier.isPublic(ctor.getDeclaringClass().getModifiers()) ? ctor : null;	}
public static String replaceEachRepeatedly(final String text, final String[] searchList, final String[] replacementList) {	    final int timeToLive = searchList == null ? 0 : searchList.length;	    return replaceEach(text, searchList, replacementList, true, timeToLive);	}
@Override	public String toString() {	    return String.format(FMT_TO_STRING, Integer.valueOf(System.identityHashCode(this)), String.valueOf(getObject()));	}
public static boolean[] clone(final boolean[] array) {	    if (array == null) {	        return null;	    }	    return array.clone();	}
public int getNumerator() {	    return numerator;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public int capacity() {	    return buffer.length;	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    int max = longest;	    if (index + longest > input.length()) {	        max = input.length() - index;	    }	    for (int i = max; i >= shortest; i--) {	        final CharSequence subSeq = input.subSequence(index, index + i);	        final CharSequence result = lookupMap.get(subSeq.toString());	        if (result != null) {	            out.write(result.toString());	            return i;	        }	    }	    return 0;	}
public EqualsBuilder appendSuper(final boolean superEquals) {	    if (isEquals == false) {	        return this;	    }	    isEquals = superEquals;	    return this;	}
public static String formatDurationHMS(final long durationMillis) {	    return formatDuration(durationMillis, "H:mm:ss.SSS");	}
public static StrTokenizer getCSVInstance(final char[] input) {	    final StrTokenizer tok = getCSVClone();	    tok.reset(input);	    return tok;	}
public static String removeEnd(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.endsWith(remove)) {	        return str.substring(0, str.length() - remove.length());	    }	    return str;	}
public static String stripToEmpty(final String str) {	    return str == null ? EMPTY : strip(str, null);	}
public String getNullText() {	    return nullText;	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
public int capacity() {	    return buffer.length;	}
public static <L, M, R> Triple<L, M, R> of(final L left, final M middle, final R right) {	    return new ImmutableTriple<L, M, R>(left, middle, right);	}
static Object removeAll(final Object array, final BitSet indices) {	    final int srcLength = ArrayUtils.getLength(array);	    final int removals = indices.cardinality();	    final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals);	    int srcIndex = 0;	    int destIndex = 0;	    int count;	    int set;	    while ((set = indices.nextSetBit(srcIndex)) != -1) {	        count = set - srcIndex;	        if (count > 0) {	            System.arraycopy(array, srcIndex, result, destIndex, count);	            destIndex += count;	        }	        srcIndex = indices.nextClearBit(set);	    }	    count = srcLength - srcIndex;	    if (count > 0) {	        System.arraycopy(array, srcIndex, result, destIndex, count);	    }	    return result;	}
public static Boolean[] nullToEmpty(final Boolean[] array) {	    if (array == null || array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    return array;	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static String getShortClassName(String className) {	    if (StringUtils.isEmpty(className)) {	        return StringUtils.EMPTY;	    }	    final StringBuilder arrayPrefix = new StringBuilder();	    if (className.startsWith("[")) {	        while (className.charAt(0) == '[') {	            className = className.substring(1);	            arrayPrefix.append("[]");	        }	        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {	            className = className.substring(1, className.length() - 1);	        }	        if (reverseAbbreviationMap.containsKey(className)) {	            className = reverseAbbreviationMap.get(className);	        }	    }	    final int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);	    final int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);	    String out = className.substring(lastDotIdx + 1);	    if (innerIdx != -1) {	        out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);	    }	    return out + arrayPrefix;	}
@Override	public int previousIndex() {	    return tokenPos - 1;	}
static Token[] lexx(final String format) {	    final char[] array = format.toCharArray();	    final ArrayList<Token> list = new ArrayList<Token>(array.length);	    boolean inLiteral = false;	    StringBuilder buffer = null;	    Token previous = null;	    final int sz = array.length;	    for (int i = 0; i < sz; i++) {	        final char ch = array[i];	        if (inLiteral && ch != '\'') {	            buffer.append(ch);	            continue;	        }	        Object value = null;	        switch(ch) {	            case '\'':	                if (inLiteral) {	                    buffer = null;	                    inLiteral = false;	                } else {	                    buffer = new StringBuilder();	                    list.add(new Token(buffer));	                    inLiteral = true;	                }	                break;	            case 'y':	                value = y;	                break;	            case 'M':	                value = M;	                break;	            case 'd':	                value = d;	                break;	            case 'H':	                value = H;	                break;	            case 'm':	                value = m;	                break;	            case 's':	                value = s;	                break;	            case 'S':	                value = S;	                break;	            default:	                if (buffer == null) {	                    buffer = new StringBuilder();	                    list.add(new Token(buffer));	                }	                buffer.append(ch);	        }	        if (value != null) {	            if (previous != null && previous.getValue() == value) {	                previous.increment();	            } else {	                final Token token = new Token(value);	                list.add(token);	                previous = token;	            }	            buffer = null;	        }	    }	    return list.toArray(new Token[list.size()]);	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static String mid(final String str, int pos, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0 || pos > str.length()) {	        return EMPTY;	    }	    if (pos < 0) {	        pos = 0;	    }	    if (str.length() <= pos + len) {	        return str.substring(pos);	    }	    return str.substring(pos, pos + len);	}
public StrBuilder reverse() {	    if (size == 0) {	        return this;	    }	    final int half = size / 2;	    final char[] buf = buffer;	    for (int leftIdx = 0, rightIdx = size - 1; leftIdx < half; leftIdx++, rightIdx--) {	        final char swap = buf[leftIdx];	        buf[leftIdx] = buf[rightIdx];	        buf[rightIdx] = swap;	    }	    return this;	}
public int capacity() {	    return buffer.length;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public boolean contains(final CharRange range) {	    if (range == null) {	        throw new IllegalArgumentException("The Range must not be null");	    }	    if (negated) {	        if (range.negated) {	            return start >= range.start && end <= range.end;	        }	        return range.end < start || range.start > end;	    }	    if (range.negated) {	        return start == 0 && end == Character.MAX_VALUE;	    }	    return start <= range.start && end >= range.end;	}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    buffer.append(arrayStart);	    for (int i = 0; i < array.length; i++) {	        if (i > 0) {	            buffer.append(arraySeparator);	        }	        appendDetail(buffer, fieldName, array[i]);	    }	    buffer.append(arrayEnd);	}
@Override	public long longValue() {	    return (long) value;	}
protected String getSizeEndText() {	    return sizeEndText;	}
@Override	public Date parse(final String source, final ParsePosition pos) {	    final int offset = pos.getIndex();	    final Matcher matcher = parsePattern.matcher(source.substring(offset));	    if (!matcher.lookingAt()) {	        return null;	    }	    final Calendar cal = Calendar.getInstance(timeZone, locale);	    cal.clear();	    for (int i = 0; i < strategies.length; ) {	        final Strategy strategy = strategies[i++];	        strategy.setCalendar(this, cal, matcher.group(i));	    }	    pos.setIndex(offset + matcher.end());	    return cal.getTime();	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static void writeField(final Object target, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException {	    if (target == null) {	        throw new IllegalArgumentException("target object must not be null");	    }	    final Class<?> cls = target.getClass();	    final Field field = getField(cls, fieldName, forceAccess);	    if (field == null) {	        throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName);	    }	    writeField(field, target, value);	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static String delete(final String str, final String... set) {	    if (StringUtils.isEmpty(str) || deepEmpty(set)) {	        return str;	    }	    return modify(str, set, false);	}
@Override	public void setValue(final T value) {	    this.value = value;	}
@Override	public boolean isCancelled() {	    return false;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public int size() {	    return size;	}
public static boolean containsOnly(final CharSequence cs, final String validChars) {	    if (cs == null || validChars == null) {	        return false;	    }	    return containsOnly(cs, validChars.toCharArray());	}
public static boolean containsAny(final String str, final String... set) {	    if (StringUtils.isEmpty(str) || deepEmpty(set)) {	        return false;	    }	    final CharSet chars = CharSet.getInstance(set);	    for (final char c : str.toCharArray()) {	        if (chars.contains(c)) {	            return true;	        }	    }	    return false;	}
public static String lowerCase(final String str, final Locale locale) {	    if (str == null) {	        return null;	    }	    return str.toLowerCase(locale);	}
@Override	public int read(final char[] b, final int off, int len) {	    if (off < 0 || len < 0 || off > b.length || (off + len) > b.length || (off + len) < 0) {	        throw new IndexOutOfBoundsException();	    }	    if (len == 0) {	        return 0;	    }	    if (pos >= StrBuilder.this.size()) {	        return -1;	    }	    if (pos + len > size()) {	        len = StrBuilder.this.size() - pos;	    }	    StrBuilder.this.getChars(pos, pos + len, b, off);	    pos += len;	    return len;	}
public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) {	    if (src.length > 8) {	        throw new IllegalArgumentException("src.length>8: src.length=" + src.length);	    }	    if (src.length - srcPos < 4) {	        throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos);	    }	    if (src[srcPos + 3]) {	        if (src[srcPos + 2]) {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return '7';	                }	            } else {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return '3';	                }	            }	        } else {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return '5';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '1';	                }	            }	        }	    } else {	        if (src[srcPos + 2]) {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'e';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return 'a';	                } else {	                    return '2';	                }	            }	        } else {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'c';	                } else {	                    return '4';	                }	            } else {	                if (src[srcPos]) {	                    return '8';	                } else {	                    return '0';	                }	            }	        }	    }	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
@Override	public String toString() {	    return StringUtils.repeat(this.value.toString(), this.count);	}
public static String uncapitalize(final String str, final char... delimiters) {	    final int delimLen = delimiters == null ? -1 : delimiters.length;	    if (StringUtils.isEmpty(str) || delimLen == 0) {	        return str;	    }	    final char[] buffer = str.toCharArray();	    boolean uncapitalizeNext = true;	    for (int i = 0; i < buffer.length; i++) {	        final char ch = buffer[i];	        if (isDelimiter(ch, delimiters)) {	            uncapitalizeNext = true;	        } else if (uncapitalizeNext) {	            buffer[i] = Character.toLowerCase(ch);	            uncapitalizeNext = false;	        }	    }	    return new String(buffer);	}
public static Boolean or(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
public String getNewLineText() {	    return newLine;	}
public int size() {	    return size;	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public StrTokenizer setQuoteChar(final char quote) {	    return setQuoteMatcher(StrMatcher.charMatcher(quote));	}
public static String trim(final String str) {	    return str == null ? null : str.trim();	}
public static boolean[] removeElements(final boolean[] array, final boolean... values) {	    if (isEmpty(array) || isEmpty(values)) {	        return clone(array);	    }	    final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2);	    for (final boolean v : values) {	        final Boolean boxed = Boolean.valueOf(v);	        final MutableInt count = occurrences.get(boxed);	        if (count == null) {	            occurrences.put(boxed, new MutableInt(1));	        } else {	            count.increment();	        }	    }	    final BitSet toRemove = new BitSet();	    for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) {	        final Boolean v = e.getKey();	        int found = 0;	        for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {	            found = indexOf(array, v.booleanValue(), found);	            if (found < 0) {	                break;	            }	            toRemove.set(found++);	        }	    }	    return (boolean[]) removeAll(array, toRemove);	}
@Override	public String toString() {	    if (this.getObject() == null) {	        return this.getStyle().getNullText();	    }	    Class<?> clazz = this.getObject().getClass();	    this.appendFieldsIn(clazz);	    while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {	        clazz = clazz.getSuperclass();	        this.appendFieldsIn(clazz);	    }	    return super.toString();	}
protected String getSummaryObjectStartText() {	    return summaryObjectStartText;	}
public static String unicodeEscaped(final Character ch) {	    if (ch == null) {	        return null;	    }	    return unicodeEscaped(ch.charValue());	}
public boolean isEmptyTokenAsNull() {	    return this.emptyAsNull;	}
public int capacity() {	    return buffer.length;	}
public boolean booleanValue() {	    return value;	}
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) {	    return new Range<T>(fromInclusive, toInclusive, comparator);	}
public StrBuilder replaceAll(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, -1);	}
public StrBuilder trim() {	    if (size == 0) {	        return this;	    }	    int len = size;	    final char[] buf = buffer;	    int pos = 0;	    while (pos < len && buf[pos] <= ' ') {	        pos++;	    }	    while (pos < len && buf[len - 1] <= ' ') {	        len--;	    }	    if (len < size) {	        delete(len, size);	    }	    if (pos > 0) {	        delete(0, pos);	    }	    return this;	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
@Override	public double doubleValue() {	    return value;	}
public boolean isEquals() {	    return this.isEquals;	}
public char getStart() {	    return this.start;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public boolean isEmpty() {	    return size == 0;	}
public static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {	    if (str == null || searchStr == null) {	        return INDEX_NOT_FOUND;	    }	    if (startPos < 0) {	        startPos = 0;	    }	    final int endLimit = str.length() - searchStr.length() + 1;	    if (startPos > endLimit) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return startPos;	    }	    for (int i = startPos; i < endLimit; i++) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
public static void handleCause(final ExecutionException ex) throws ConcurrentException {	    final ConcurrentException cex = extractCause(ex);	    if (cex != null) {	        throw cex;	    }	}
public static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) {	    if (0 == nHexs) {	        return dstInit;	    }	    if ((nHexs - 1) * 4 + srcPos >= 32) {	        throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 32");	    }	    final StringBuilder sb = new StringBuilder(dstInit);	    int shift = 0;	    int append = sb.length();	    for (int i = 0; i < nHexs; i++) {	        shift = i * 4 + srcPos;	        final int bits = 0xF & (src >> shift);	        if (dstPos + i == append) {	            ++append;	            sb.append(intToHexDigit(bits));	        } else {	            sb.setCharAt(dstPos + i, intToHexDigit(bits));	        }	    }	    return sb.toString();	}
@Override	public boolean markSupported() {	    return true;	}
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = Integer.MAX_VALUE;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.indexOf(str, search, 0);	        if (tmp == INDEX_NOT_FOUND) {	            continue;	        }	        if (tmp < ret) {	            ret = tmp;	        }	    }	    return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static String unicodeEscaped(final Character ch) {	    if (ch == null) {	        return null;	    }	    return unicodeEscaped(ch.charValue());	}
public static String uncapitalize(final String str) {	    int strLen;	    if (str == null || (strLen = str.length()) == 0) {	        return str;	    }	    char firstChar = str.charAt(0);	    if (Character.isLowerCase(firstChar)) {	        return str;	    }	    return new StringBuilder(strLen).append(Character.toLowerCase(firstChar)).append(str.substring(1)).toString();	}
public static String wrap(final String str, int wrapLength, String newLineStr, final boolean wrapLongWords) {	    if (str == null) {	        return null;	    }	    if (newLineStr == null) {	        newLineStr = SystemUtils.LINE_SEPARATOR;	    }	    if (wrapLength < 1) {	        wrapLength = 1;	    }	    final int inputLineLength = str.length();	    int offset = 0;	    final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32);	    while (inputLineLength - offset > wrapLength) {	        if (str.charAt(offset) == ' ') {	            offset++;	            continue;	        }	        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);	        if (spaceToWrapAt >= offset) {	            wrappedLine.append(str.substring(offset, spaceToWrapAt));	            wrappedLine.append(newLineStr);	            offset = spaceToWrapAt + 1;	        } else {	            if (wrapLongWords) {	                wrappedLine.append(str.substring(offset, wrapLength + offset));	                wrappedLine.append(newLineStr);	                offset += wrapLength;	            } else {	                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);	                if (spaceToWrapAt >= 0) {	                    wrappedLine.append(str.substring(offset, spaceToWrapAt));	                    wrappedLine.append(newLineStr);	                    offset = spaceToWrapAt + 1;	                } else {	                    wrappedLine.append(str.substring(offset));	                    offset = inputLineLength;	                }	            }	        }	    }	    wrappedLine.append(str.substring(offset));	    return wrappedLine.toString();	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public int size() {	    return size;	}
public StrBuilder appendSeparator(final char separator, final int loopIndex) {	    if (loopIndex > 0) {	        append(separator);	    }	    return this;	}
@Override	public boolean markSupported() {	    return true;	}
public static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess) {	    if (cls == null) {	        throw new IllegalArgumentException("The class must not be null");	    }	    if (fieldName == null) {	        throw new IllegalArgumentException("The field name must not be null");	    }	    try {	        final Field field = cls.getDeclaredField(fieldName);	        if (!MemberUtils.isAccessible(field)) {	            if (forceAccess) {	                field.setAccessible(true);	            } else {	                return null;	            }	        }	        return field;	    } catch (final NoSuchFieldException e) {	    }	    return null;	}
public String getNewLineText() {	    return newLine;	}
public static String stripToNull(String str) {	    if (str == null) {	        return null;	    }	    str = strip(str, null);	    return str.isEmpty() ? null : str;	}
public static UUID byteArrayToUuid(final byte[] src, final int srcPos) {	    if (src.length - srcPos < 16) {	        throw new IllegalArgumentException("Need at least 16 bytes for UUID");	    }	    return new UUID(byteArrayToLong(src, srcPos, 0, 0, 8), byteArrayToLong(src, srcPos + 8, 0, 0, 8));	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
@Override	public float floatValue() {	    return (float) value;	}
protected String getFieldNameValueSeparator() {	    return fieldNameValueSeparator;	}
@Override	public boolean equals(final Object obj2) {	    if (obj2 instanceof Token) {	        final Token tok2 = (Token) obj2;	        if (this.value.getClass() != tok2.value.getClass()) {	            return false;	        }	        if (this.count != tok2.count) {	            return false;	        }	        if (this.value instanceof StringBuilder) {	            return this.value.toString().equals(tok2.value.toString());	        } else if (this.value instanceof Number) {	            return this.value.equals(tok2.value);	        } else {	            return this.value == tok2.value;	        }	    }	    return false;	}
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException {	    return charsetName == null ? new String(bytes) : new String(bytes, charsetName);	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public StrMatcher getVariablePrefixMatcher() {	    return prefixMatcher;	}
protected String getArrayEnd() {	    return arrayEnd;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
public int toHashCode() {	    return iTotal;	}
protected String getContentEnd() {	    return contentEnd;	}
public static short[] removeElement(final short[] array, final short element) {	    final int index = indexOf(array, element);	    if (index == INDEX_NOT_FOUND) {	        return clone(array);	    }	    return remove(array, index);	}
public static String removeStart(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.startsWith(remove)) {	        return str.substring(remove.length());	    }	    return str;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public int capacity() {	    return buffer.length;	}
public boolean isSet(final OPTION option) {	    return options == null ? false : options.contains(option);	}
public static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts) {	    if (0 == nInts) {	        return dst;	    }	    if ((nInts - 1) * 32 + srcPos >= 64) {	        throw new IllegalArgumentException("(nInts-1)*32+srcPos is greather or equal to than 64");	    }	    int shift = 0;	    for (int i = 0; i < nInts; i++) {	        shift = i * 32 + srcPos;	        dst[dstPos + i] = (int) (0xffffffff & (src >> shift));	    }	    return dst;	}
public static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes) {	    if ((src.length == 0 && srcPos == 0) || 0 == nBytes) {	        return dstInit;	    }	    if ((nBytes - 1) * 8 + dstPos >= 64) {	        throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 64");	    }	    long out = dstInit;	    int shift = 0;	    for (int i = 0; i < nBytes; i++) {	        shift = i * 8 + dstPos;	        final long bits = (0xffL & src[i + srcPos]) << shift;	        final long mask = 0xffL << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
public static Map<TypeVariable<?>, Type> determineTypeArguments(final Class<?> cls, final ParameterizedType superType) {	    final Class<?> superClass = getRawType(superType);	    if (!isAssignable(cls, superClass)) {	        return null;	    }	    if (cls.equals(superClass)) {	        return getTypeArguments(superType, superClass, null);	    }	    final Type midType = getClosestParentType(cls, superClass);	    if (midType instanceof Class<?>) {	        return determineTypeArguments((Class<?>) midType, superType);	    }	    final ParameterizedType midParameterizedType = (ParameterizedType) midType;	    final Class<?> midClass = getRawType(midParameterizedType);	    final Map<TypeVariable<?>, Type> typeVarAssigns = determineTypeArguments(midClass, superType);	    mapTypeVariablesToArguments(cls, midParameterizedType, typeVarAssigns);	    return typeVarAssigns;	}
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {	    if (array == null) {	        if (index != 0) {	            throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0");	        }	        final Object joinedArray = Array.newInstance(clss, 1);	        Array.set(joinedArray, 0, element);	        return joinedArray;	    }	    final int length = Array.getLength(array);	    if (index > length || index < 0) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(clss, length + 1);	    System.arraycopy(array, 0, result, 0, index);	    Array.set(result, index, element);	    if (index < length) {	        System.arraycopy(array, index, result, index + 1, length - index);	    }	    return result;	}
public String getNewLineText() {	    return newLine;	}
public boolean contains(final CharRange range) {	    if (range == null) {	        throw new IllegalArgumentException("The Range must not be null");	    }	    if (negated) {	        if (range.negated) {	            return start >= range.start && end <= range.end;	        }	        return range.end < start || range.start > end;	    }	    if (range.negated) {	        return start == 0 && end == Character.MAX_VALUE;	    }	    return start <= range.start && end >= range.end;	}
public static Boolean xor(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return xor(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
public static String lowerCase(final String str, final Locale locale) {	    if (str == null) {	        return null;	    }	    return str.toLowerCase(locale);	}
public String getNullText() {	    return nullText;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public StrBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar) {	    return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);	}
@Override	public String build() {	    return toString();	}
public static String getCommonPrefix(final String... strs) {	    if (strs == null || strs.length == 0) {	        return EMPTY;	    }	    final int smallestIndexOfDiff = indexOfDifference(strs);	    if (smallestIndexOfDiff == INDEX_NOT_FOUND) {	        if (strs[0] == null) {	            return EMPTY;	        }	        return strs[0];	    } else if (smallestIndexOfDiff == 0) {	        return EMPTY;	    } else {	        return strs[0].substring(0, smallestIndexOfDiff);	    }	}
public static String getShortClassName(String className) {	    if (StringUtils.isEmpty(className)) {	        return StringUtils.EMPTY;	    }	    final StringBuilder arrayPrefix = new StringBuilder();	    if (className.startsWith("[")) {	        while (className.charAt(0) == '[') {	            className = className.substring(1);	            arrayPrefix.append("[]");	        }	        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {	            className = className.substring(1, className.length() - 1);	        }	        if (reverseAbbreviationMap.containsKey(className)) {	            className = reverseAbbreviationMap.get(className);	        }	    }	    final int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);	    final int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);	    String out = className.substring(lastDotIdx + 1);	    if (innerIdx != -1) {	        out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);	    }	    return out + arrayPrefix;	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static String prependIfMissingIgnoreCase(final String str, final CharSequence prefix, final CharSequence... prefixes) {	    return prependIfMissing(str, prefix, true, prefixes);	}
protected boolean isUseFieldNames() {	    return useFieldNames;	}
public static Boolean[] nullToEmpty(final Boolean[] array) {	    if (array == null || array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    return array;	}
public static <K, V> V putIfAbsent(final ConcurrentMap<K, V> map, final K key, final V value) {	    if (map == null) {	        return null;	    }	    final V result = map.putIfAbsent(key, value);	    return result != null ? result : value;	}
public String getNewLineText() {	    return newLine;	}
public int size() {	    return size;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public boolean isEmpty() {	    return size == 0;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
@Override	public String toString() {	    return String.valueOf(value);	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public String getNewLineText() {	    return newLine;	}
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] result = new boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        final Boolean b = array[i];	        result[i] = (b == null ? valueForNull : b.booleanValue());	    }	    return result;	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
public static String removeStart(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.startsWith(remove)) {	        return str.substring(remove.length());	    }	    return str;	}
@Override	public T get(final long timeout, final TimeUnit unit) {	    return value;	}
public static String difference(final String str1, final String str2) {	    if (str1 == null) {	        return str2;	    }	    if (str2 == null) {	        return str1;	    }	    final int at = indexOfDifference(str1, str2);	    if (at == INDEX_NOT_FOUND) {	        return EMPTY;	    }	    return str2.substring(at);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static float min(final float a, final float b, final float c) {	    return Math.min(Math.min(a, b), c);	}
@Override	public void write(final String str, final int off, final int len) {	    StrBuilder.this.append(str, off, len);	}
public static String removeStart(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.startsWith(remove)) {	        return str.substring(remove.length());	    }	    return str;	}
public static File getJavaHome() {	    return new File(System.getProperty(JAVA_HOME_KEY));	}
public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale) {	    return cache.getDateTimeInstance(dateStyle, timeStyle, timeZone, locale);	}
private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) {	    final StrMatcher prefixMatcher = getVariablePrefixMatcher();	    final StrMatcher suffixMatcher = getVariableSuffixMatcher();	    final char escape = getEscapeChar();	    final boolean top = priorVariables == null;	    boolean altered = false;	    int lengthChange = 0;	    char[] chars = buf.buffer;	    int bufEnd = offset + length;	    int pos = offset;	    while (pos < bufEnd) {	        final int startMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd);	        if (startMatchLen == 0) {	            pos++;	        } else {	            if (pos > offset && chars[pos - 1] == escape) {	                buf.deleteCharAt(pos - 1);	                chars = buf.buffer;	                lengthChange--;	                altered = true;	                bufEnd--;	            } else {	                final int startPos = pos;	                pos += startMatchLen;	                int endMatchLen = 0;	                int nestedVarCount = 0;	                while (pos < bufEnd) {	                    if (isEnableSubstitutionInVariables() && (endMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd)) != 0) {	                        nestedVarCount++;	                        pos += endMatchLen;	                        continue;	                    }	                    endMatchLen = suffixMatcher.isMatch(chars, pos, offset, bufEnd);	                    if (endMatchLen == 0) {	                        pos++;	                    } else {	                        if (nestedVarCount == 0) {	                            String varName = new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen);	                            if (isEnableSubstitutionInVariables()) {	                                final StrBuilder bufName = new StrBuilder(varName);	                                substitute(bufName, 0, bufName.length());	                                varName = bufName.toString();	                            }	                            pos += endMatchLen;	                            final int endPos = pos;	                            if (priorVariables == null) {	                                priorVariables = new ArrayList<String>();	                                priorVariables.add(new String(chars, offset, length));	                            }	                            checkCyclicSubstitution(varName, priorVariables);	                            priorVariables.add(varName);	                            final String varValue = resolveVariable(varName, buf, startPos, endPos);	                            if (varValue != null) {	                                final int varLen = varValue.length();	                                buf.replace(startPos, endPos, varValue);	                                altered = true;	                                int change = substitute(buf, startPos, varLen, priorVariables);	                                change = change + varLen - (endPos - startPos);	                                pos += change;	                                bufEnd += change;	                                lengthChange += change;	                                chars = buf.buffer;	                            }	                            priorVariables.remove(priorVariables.size() - 1);	                            break;	                        } else {	                            nestedVarCount--;	                            pos += endMatchLen;	                        }	                    }	                }	            }	        }	    }	    if (top) {	        return altered ? 1 : 0;	    }	    return lengthChange;	}
public void subtract(final Number operand) {	    this.value -= operand.doubleValue();	}
static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {	    final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);	    String pattern = cDateTimeInstanceCache.get(key);	    if (pattern == null) {	        try {	            DateFormat formatter;	            if (dateStyle == null) {	                formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);	            } else if (timeStyle == null) {	                formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);	            } else {	                formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);	            }	            pattern = ((SimpleDateFormat) formatter).toPattern();	            final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);	            if (previous != null) {	                pattern = previous;	            }	        } catch (final ClassCastException ex) {	            throw new IllegalArgumentException("No date time pattern for locale: " + locale);	        }	    }	    return pattern;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public static boolean isAlphanumeric(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetterOrDigit(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
@Override	public float floatValue() {	    return value;	}
public static int reflectionHashCode(final Object object, final String... excludeFields) {	    return reflectionHashCode(17, 37, object, false, null, excludeFields);	}
public static byte toByte(final String str, final byte defaultValue) {	    if (str == null) {	        return defaultValue;	    }	    try {	        return Byte.parseByte(str);	    } catch (final NumberFormatException nfe) {	        return defaultValue;	    }	}
@Override	public int length() {	    return size;	}
public static String getSimpleName(final Object object, final String valueIfNull) {	    if (object == null) {	        return valueIfNull;	    }	    return getSimpleName(object.getClass());	}
public int size() {	    return size;	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
@Override	public int read(final char[] b, final int off, int len) {	    if (off < 0 || len < 0 || off > b.length || (off + len) > b.length || (off + len) < 0) {	        throw new IndexOutOfBoundsException();	    }	    if (len == 0) {	        return 0;	    }	    if (pos >= StrBuilder.this.size()) {	        return -1;	    }	    if (pos + len > size()) {	        len = StrBuilder.this.size() - pos;	    }	    StrBuilder.this.getChars(pos, pos + len, b, off);	    pos += len;	    return len;	}
public String getNewLineText() {	    return newLine;	}
public static Integer toIntegerObject(final Boolean bool, final Integer trueValue, final Integer falseValue, final Integer nullValue) {	    if (bool == null) {	        return nullValue;	    }	    return bool.booleanValue() ? trueValue : falseValue;	}
@Override	public boolean equals(final Object other) {	    if (!(other instanceof IDKey)) {	        return false;	    }	    final IDKey idKey = (IDKey) other;	    if (id != idKey.id) {	        return false;	    }	    return value == idKey.value;	}
public int getDenominator() {	    return denominator;	}
@Override	public int length() {	    return size;	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
private static Date set(final Date date, final int calendarField, final int amount) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final Calendar c = Calendar.getInstance();	    c.setLenient(false);	    c.setTime(date);	    c.set(calendarField, amount);	    return c.getTime();	}
public short getShortValue(final short holder) {	    return (short) getValue(holder);	}
static Token[] lexx(final String format) {	    final char[] array = format.toCharArray();	    final ArrayList<Token> list = new ArrayList<Token>(array.length);	    boolean inLiteral = false;	    StringBuilder buffer = null;	    Token previous = null;	    final int sz = array.length;	    for (int i = 0; i < sz; i++) {	        final char ch = array[i];	        if (inLiteral && ch != '\'') {	            buffer.append(ch);	            continue;	        }	        Object value = null;	        switch(ch) {	            case '\'':	                if (inLiteral) {	                    buffer = null;	                    inLiteral = false;	                } else {	                    buffer = new StringBuilder();	                    list.add(new Token(buffer));	                    inLiteral = true;	                }	                break;	            case 'y':	                value = y;	                break;	            case 'M':	                value = M;	                break;	            case 'd':	                value = d;	                break;	            case 'H':	                value = H;	                break;	            case 'm':	                value = m;	                break;	            case 's':	                value = s;	                break;	            case 'S':	                value = S;	                break;	            default:	                if (buffer == null) {	                    buffer = new StringBuilder();	                    list.add(new Token(buffer));	                }	                buffer.append(ch);	        }	        if (value != null) {	            if (previous != null && previous.getValue() == value) {	                previous.increment();	            } else {	                final Token token = new Token(value);	                list.add(token);	                previous = token;	            }	            buffer = null;	        }	    }	    return list.toArray(new Token[list.size()]);	}
protected boolean isUseIdentityHashCode() {	    return useIdentityHashCode;	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public static int hexDigitMsb0ToInt(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return 0x0;	        case '1':	            return 0x8;	        case '2':	            return 0x4;	        case '3':	            return 0xC;	        case '4':	            return 0x2;	        case '5':	            return 0xA;	        case '6':	            return 0x6;	        case '7':	            return 0xE;	        case '8':	            return 0x1;	        case '9':	            return 0x9;	        case 'a':	        case 'A':	            return 0x5;	        case 'b':	        case 'B':	            return 0xD;	        case 'c':	        case 'C':	            return 0x3;	        case 'd':	        case 'D':	            return 0xB;	        case 'e':	        case 'E':	            return 0x7;	        case 'f':	        case 'F':	            return 0xF;	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public void setUpToClass(final Class<?> clazz) {	    if (clazz != null) {	        final Object object = getObject();	        if (object != null && clazz.isInstance(object) == false) {	            throw new IllegalArgumentException("Specified class is not a superclass of the object");	        }	    }	    this.upToClass = clazz;	}
public boolean isEquals() {	    return this.isEquals;	}
@Override	public StringBuffer format(final Calendar calendar, final StringBuffer buf) {	    return applyRules(calendar, buf);	}
@Override	public String getSizeEndText() {	    return super.getSizeEndText();	}
public static String substringAfter(final String str, final String separator) {	    if (isEmpty(str)) {	        return str;	    }	    if (separator == null) {	        return EMPTY;	    }	    final int pos = str.indexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return EMPTY;	    }	    return str.substring(pos + separator.length());	}
public int capacity() {	    return buffer.length;	}
public boolean contains(final T element) {	    if (element == null) {	        return false;	    }	    return comparator.compare(element, minimum) > -1 && comparator.compare(element, maximum) < 1;	}
public void decrement() {	    value--;	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public StrBuilder appendSeparator(final char separator, final int loopIndex) {	    if (loopIndex > 0) {	        append(separator);	    }	    return this;	}
@Override	public BasicThreadFactory build() {	    final BasicThreadFactory factory = new BasicThreadFactory(this);	    reset();	    return factory;	}
protected String toUtf16Escape(final int codepoint) {	    return "\\u" + hex(codepoint);	}
protected void appendFieldEnd(final StringBuffer buffer, final String fieldName) {	    appendFieldSeparator(buffer);	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public static String uncapitalize(final String str) {	    int strLen;	    if (str == null || (strLen = str.length()) == 0) {	        return str;	    }	    char firstChar = str.charAt(0);	    if (Character.isLowerCase(firstChar)) {	        return str;	    }	    return new StringBuilder(strLen).append(Character.toLowerCase(firstChar)).append(str.substring(1)).toString();	}
public static ConcurrentRuntimeException extractCauseUnchecked(final ExecutionException ex) {	    if (ex == null || ex.getCause() == null) {	        return null;	    }	    throwCause(ex);	    return new ConcurrentRuntimeException(ex.getMessage(), ex.getCause());	}
public StrBuilder clear() {	    size = 0;	    return this;	}
public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width, final int precision, final char padChar, final CharSequence ellipsis) {	    Validate.isTrue(ellipsis == null || precision < 0 || ellipsis.length() <= precision, "Specified ellipsis '%1$s' exceeds precision of %2$s", ellipsis, Integer.valueOf(precision));	    final StringBuilder buf = new StringBuilder(seq);	    if (precision >= 0 && precision < seq.length()) {	        final CharSequence _ellipsis = ObjectUtils.defaultIfNull(ellipsis, StringUtils.EMPTY);	        buf.replace(precision - _ellipsis.length(), seq.length(), _ellipsis.toString());	    }	    final boolean leftJustify = (flags & LEFT_JUSTIFY) == LEFT_JUSTIFY;	    for (int i = buf.length(); i < width; i++) {	        buf.insert(leftJustify ? i : 0, padChar);	    }	    formatter.format(buf.toString());	    return formatter;	}
protected String getNullText() {	    return nullText;	}
public boolean replaceIn(final StrBuilder source, final int offset, final int length) {	    if (source == null) {	        return false;	    }	    return substitute(source, offset, length);	}
@Override	public int read(final char[] b, final int off, int len) {	    if (off < 0 || len < 0 || off > b.length || (off + len) > b.length || (off + len) < 0) {	        throw new IndexOutOfBoundsException();	    }	    if (len == 0) {	        return 0;	    }	    if (pos >= StrBuilder.this.size()) {	        return -1;	    }	    if (pos + len > size()) {	        len = StrBuilder.this.size() - pos;	    }	    StrBuilder.this.getChars(pos, pos + len, b, off);	    pos += len;	    return len;	}
public static <T> T notNull(final T object, final String message, final Object... values) {	    if (object == null) {	        throw new NullPointerException(String.format(message, values));	    }	    return object;	}
public String getNewLineText() {	    return newLine;	}
public static boolean containsOnly(final CharSequence cs, final String validChars) {	    if (cs == null || validChars == null) {	        return false;	    }	    return containsOnly(cs, validChars.toCharArray());	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static <L, M, R> MutableTriple<L, M, R> of(final L left, final M middle, final R right) {	    return new MutableTriple<L, M, R>(left, middle, right);	}
public static short[] removeElement(final short[] array, final short element) {	    final int index = indexOf(array, element);	    if (index == INDEX_NOT_FOUND) {	        return clone(array);	    }	    return remove(array, index);	}
@Override	public int length() {	    return size;	}
public static <L> void bindEventsToMethod(final Object target, final String methodName, final Object eventSource, final Class<L> listenerType, final String... eventTypes) {	    final L listener = listenerType.cast(Proxy.newProxyInstance(target.getClass().getClassLoader(), new Class[] { listenerType }, new EventBindingInvocationHandler(target, methodName, eventTypes)));	    addEventListener(eventSource, listenerType, listener);	}
public boolean isEmpty() {	    return size == 0;	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public boolean isEquals() {	    return this.isEquals;	}
public static byte[] serialize(final Serializable obj) {	    final ByteArrayOutputStream baos = new ByteArrayOutputStream(512);	    serialize(obj, baos);	    return baos.toByteArray();	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    final int seqEnd = input.length();	    if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') {	        int start = index + 2;	        boolean isHex = false;	        final char firstChar = input.charAt(start);	        if (firstChar == 'x' || firstChar == 'X') {	            start++;	            isHex = true;	            if (start == seqEnd) {	                return 0;	            }	        }	        int end = start;	        while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) {	            end++;	        }	        final boolean semiNext = end != seqEnd && input.charAt(end) == ';';	        if (!semiNext) {	            if (isSet(OPTION.semiColonRequired)) {	                return 0;	            } else if (isSet(OPTION.errorIfNoSemiColon)) {	                throw new IllegalArgumentException("Semi-colon required at end of numeric entity");	            }	        }	        int entityValue;	        try {	            if (isHex) {	                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);	            } else {	                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);	            }	        } catch (final NumberFormatException nfe) {	            return 0;	        }	        if (entityValue > 0xFFFF) {	            final char[] chrs = Character.toChars(entityValue);	            out.write(chrs[0]);	            out.write(chrs[1]);	        } else {	            out.write(entityValue);	        }	        return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0);	    }	    return 0;	}
public String getNewLineText() {	    return newLine;	}
public char getEnd() {	    return this.end;	}
protected void setSummaryObjectStartText(String summaryObjectStartText) {	    if (summaryObjectStartText == null) {	        summaryObjectStartText = "";	    }	    this.summaryObjectStartText = summaryObjectStartText;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return new boolean[] { false, false, false, false };	        case '1':	            return new boolean[] { false, false, false, true };	        case '2':	            return new boolean[] { false, false, true, false };	        case '3':	            return new boolean[] { false, false, true, true };	        case '4':	            return new boolean[] { false, true, false, false };	        case '5':	            return new boolean[] { false, true, false, true };	        case '6':	            return new boolean[] { false, true, true, false };	        case '7':	            return new boolean[] { false, true, true, true };	        case '8':	            return new boolean[] { true, false, false, false };	        case '9':	            return new boolean[] { true, false, false, true };	        case 'a':	        case 'A':	            return new boolean[] { true, false, true, false };	        case 'b':	        case 'B':	            return new boolean[] { true, false, true, true };	        case 'c':	        case 'C':	            return new boolean[] { true, true, false, false };	        case 'd':	        case 'D':	            return new boolean[] { true, true, false, true };	        case 'e':	        case 'E':	            return new boolean[] { true, true, true, false };	        case 'f':	        case 'F':	            return new boolean[] { true, true, true, true };	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
@Override	public int length() {	    return size;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {	    if (str == null || searchStr == null) {	        return INDEX_NOT_FOUND;	    }	    if (startPos < 0) {	        startPos = 0;	    }	    final int endLimit = str.length() - searchStr.length() + 1;	    if (startPos > endLimit) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return startPos;	    }	    for (int i = startPos; i < endLimit; i++) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public long getNanoTime() {	    if (this.runningState == STATE_STOPPED || this.runningState == STATE_SUSPENDED) {	        return this.stopTime - this.startTime;	    } else if (this.runningState == STATE_UNSTARTED) {	        return 0;	    } else if (this.runningState == STATE_RUNNING) {	        return System.nanoTime() - this.startTime;	    }	    throw new RuntimeException("Illegal running state has occurred.");	}
protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    appendSummarySize(buffer, fieldName, array.length);	}
public synchronized void shutdown() {	    if (!shutdown) {	        if (ownExecutor) {	            getExecutorService().shutdownNow();	        }	        if (task != null) {	            task.cancel(false);	        }	        shutdown = true;	    }	}
@Override	public int intValue() {	    return (int) value;	}
public static Date setYears(final Date date, final int amount) {	    return set(date, Calendar.YEAR, amount);	}
@Override	public int nextIndex() {	    return tokenPos;	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public void start() {	    if (this.runningState == STATE_STOPPED) {	        throw new IllegalStateException("Stopwatch must be reset before being restarted. ");	    }	    if (this.runningState != STATE_UNSTARTED) {	        throw new IllegalStateException("Stopwatch already started. ");	    }	    this.startTime = System.nanoTime();	    this.startTimeMillis = System.currentTimeMillis();	    this.runningState = STATE_RUNNING;	}
public int size() {	    return size;	}
public int lastIndexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex >= size ? size - 1 : startIndex);	    if (matcher == null || startIndex < 0) {	        return -1;	    }	    final char[] buf = buffer;	    final int endIndex = startIndex + 1;	    for (int i = startIndex; i >= 0; i--) {	        if (matcher.isMatch(buf, i, 0, endIndex) > 0) {	            return i;	        }	    }	    return -1;	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, true);	}
public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher) {	    if (suffixMatcher == null) {	        throw new IllegalArgumentException("Variable suffix matcher must not be null!");	    }	    this.suffixMatcher = suffixMatcher;	    return this;	}
protected String getContentStart() {	    return contentStart;	}
public static String rightPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return rightPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return str.concat(padStr);	    } else if (pads < padLen) {	        return str.concat(padStr.substring(0, pads));	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return str.concat(new String(padding));	    }	}
public char getEscapeChar() {	    return this.escapeChar;	}
public int capacity() {	    return buffer.length;	}
public static <T> T invokeConstructor(final Class<T> cls, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {	    if (parameterTypes == null) {	        parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;	    }	    if (args == null) {	        args = ArrayUtils.EMPTY_OBJECT_ARRAY;	    }	    final Constructor<T> ctor = getMatchingAccessibleConstructor(cls, parameterTypes);	    if (ctor == null) {	        throw new NoSuchMethodException("No such accessible constructor on object: " + cls.getName());	    }	    return ctor.newInstance(args);	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
@Override	public int length() {	    return size;	}
@Override	public int compare(final Object obj1, final Object obj2) {	    return ((Comparable) obj1).compareTo(obj2);	}
public String getNullText() {	    return nullText;	}
protected boolean isArrayContentDetail() {	    return arrayContentDetail;	}
@Override	public String toString() {	    return set.toString();	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public int size() {	    return size;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public String reformat(final String input) throws ParseException {	    return format(parseObject(input));	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException {	    return charsetName == null ? new String(bytes) : new String(bytes, charsetName);	}
public static String replaceOnce(final String text, final String searchString, final String replacement) {	    return replace(text, searchString, replacement, 1);	}
@Override	public Object parseObject(final String source, final ParsePosition pos) {	    return parser.parseObject(source, pos);	}
public boolean isException(final String name) {	    checkName(name);	    return exceptions.containsKey(name);	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
@Override	public int read(final char[] b, final int off, int len) {	    if (off < 0 || len < 0 || off > b.length || (off + len) > b.length || (off + len) < 0) {	        throw new IndexOutOfBoundsException();	    }	    if (len == 0) {	        return 0;	    }	    if (pos >= StrBuilder.this.size()) {	        return -1;	    }	    if (pos + len > size()) {	        len = StrBuilder.this.size() - pos;	    }	    StrBuilder.this.getChars(pos, pos + len, b, off);	    pos += len;	    return len;	}
public int getNumerator() {	    return numerator;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static Throwable getRootCause(final Throwable throwable) {	    final List<Throwable> list = getThrowableList(throwable);	    return list.size() < 2 ? null : (Throwable) list.get(list.size() - 1);	}
public static String appendIfMissingIgnoreCase(final String str, final CharSequence suffix, final CharSequence... suffixes) {	    return appendIfMissing(str, suffix, true, suffixes);	}
@Override	public int read(final char[] b, final int off, int len) {	    if (off < 0 || len < 0 || off > b.length || (off + len) > b.length || (off + len) < 0) {	        throw new IndexOutOfBoundsException();	    }	    if (len == 0) {	        return 0;	    }	    if (pos >= StrBuilder.this.size()) {	        return -1;	    }	    if (pos + len > size()) {	        len = StrBuilder.this.size() - pos;	    }	    StrBuilder.this.getChars(pos, pos + len, b, off);	    pos += len;	    return len;	}
static int indexOf(final CharSequence cs, final CharSequence searchChar, final int start) {	    return cs.toString().indexOf(searchChar.toString(), start);	}
static int indexOf(final CharSequence cs, final CharSequence searchChar, final int start) {	    return cs.toString().indexOf(searchChar.toString(), start);	}
public char getEscapeChar() {	    return this.escapeChar;	}
public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) {	    if (src.length > 8) {	        throw new IllegalArgumentException("src.length>8: src.length=" + src.length);	    }	    if (src.length - srcPos < 4) {	        throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos);	    }	    if (src[srcPos + 3]) {	        if (src[srcPos + 2]) {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return '7';	                }	            } else {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return '3';	                }	            }	        } else {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return '5';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '1';	                }	            }	        }	    } else {	        if (src[srcPos + 2]) {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'e';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return 'a';	                } else {	                    return '2';	                }	            }	        } else {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'c';	                } else {	                    return '4';	                }	            } else {	                if (src[srcPos]) {	                    return '8';	                } else {	                    return '0';	                }	            }	        }	    }	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
@Override	public int compare(final Object obj1, final Object obj2) {	    return ((Comparable) obj1).compareTo(obj2);	}
protected String getSummaryObjectEndText() {	    return summaryObjectEndText;	}
public static float min(final float a, final float b, final float c) {	    return Math.min(Math.min(a, b), c);	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
protected boolean isUseIdentityHashCode() {	    return useIdentityHashCode;	}
public static Date round(final Object date, final int field) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (date instanceof Date) {	        return round((Date) date, field);	    } else if (date instanceof Calendar) {	        return round((Calendar) date, field).getTime();	    } else {	        throw new ClassCastException("Could not round " + date);	    }	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static void setDefaultStyle(final ToStringStyle style) {	    if (style == null) {	        throw new IllegalArgumentException("The style must not be null");	    }	    defaultStyle = style;	}
public static float max(final float a, final float b, final float c) {	    return Math.max(Math.max(a, b), c);	}
public synchronized void shutdown() {	    if (!shutdown) {	        if (ownExecutor) {	            getExecutorService().shutdownNow();	        }	        if (task != null) {	            task.cancel(false);	        }	        shutdown = true;	    }	}
public static int indexOfDifference(final CharSequence... css) {	    if (css == null || css.length <= 1) {	        return INDEX_NOT_FOUND;	    }	    boolean anyStringNull = false;	    boolean allStringsNull = true;	    final int arrayLen = css.length;	    int shortestStrLen = Integer.MAX_VALUE;	    int longestStrLen = 0;	    for (int i = 0; i < arrayLen; i++) {	        if (css[i] == null) {	            anyStringNull = true;	            shortestStrLen = 0;	        } else {	            allStringsNull = false;	            shortestStrLen = Math.min(css[i].length(), shortestStrLen);	            longestStrLen = Math.max(css[i].length(), longestStrLen);	        }	    }	    if (allStringsNull || longestStrLen == 0 && !anyStringNull) {	        return INDEX_NOT_FOUND;	    }	    if (shortestStrLen == 0) {	        return 0;	    }	    int firstDiff = -1;	    for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {	        final char comparisonChar = css[0].charAt(stringPos);	        for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {	            if (css[arrayPos].charAt(stringPos) != comparisonChar) {	                firstDiff = stringPos;	                break;	            }	        }	        if (firstDiff != -1) {	            break;	        }	    }	    if (firstDiff == -1 && shortestStrLen != longestStrLen) {	        return shortestStrLen;	    }	    return firstDiff;	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
private static long getFragment(final Calendar calendar, final int fragment, final int unit) {	    if (calendar == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final long millisPerUnit = getMillisPerUnit(unit);	    long result = 0;	    switch(fragment) {	        case Calendar.YEAR:	            result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit;	            break;	        case Calendar.MONTH:	            result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit;	            break;	    }	    switch(fragment) {	        case Calendar.YEAR:	        case Calendar.MONTH:	        case Calendar.DAY_OF_YEAR:	        case Calendar.DATE:	            result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit;	        case Calendar.HOUR_OF_DAY:	            result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit;	        case Calendar.MINUTE:	            result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit;	        case Calendar.SECOND:	            result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit;	            break;	        case Calendar.MILLISECOND:	            break;	        default:	            throw new IllegalArgumentException("The fragment " + fragment + " is not supported");	    }	    return result;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public int size() {	    return size;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
@Override	public L getLeft() {	    return left;	}
public static String toStringOnOff(final boolean bool) {	    return toString(bool, "on", "off");	}
@Override	public String getContent() {	    final String str = super.getContent();	    if (str == null) {	        return StrBuilder.this.toString();	    }	    return str;	}
public int capacity() {	    return buffer.length;	}
@Override	public String getPattern() {	    return printer.getPattern();	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static Throwable getRootCause(final Throwable throwable) {	    final List<Throwable> list = getThrowableList(throwable);	    return list.size() < 2 ? null : (Throwable) list.get(list.size() - 1);	}
@Override	public int compareTo(final MutableFloat other) {	    final float anotherVal = other.value;	    return Float.compare(value, anotherVal);	}
public T getMaximum() {	    return maximum;	}
@Override	public long longValue() {	    return value;	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException {	    return charsetName == null ? new String(bytes) : new String(bytes, charsetName);	}
public static boolean isNotEmpty(final boolean[] array) {	    return (array != null && array.length != 0);	}
public String getNullText() {	    return nullText;	}
public static String repeat(final char ch, final int repeat) {	    final char[] buf = new char[repeat];	    for (int i = repeat - 1; i >= 0; i--) {	        buf[i] = ch;	    }	    return new String(buf);	}
protected String getContentEnd() {	    return contentEnd;	}
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] result = new boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        final Boolean b = array[i];	        result[i] = (b == null ? valueForNull : b.booleanValue());	    }	    return result;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public boolean contains(final StrMatcher matcher) {	    return indexOf(matcher, 0) >= 0;	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public int size() {	    return size;	}
public int size() {	    return size;	}
public StrBuilder deleteAll(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, -1);	}
@Override	public int length() {	    return size;	}
protected String getContentEnd() {	    return contentEnd;	}
protected String getSizeStartText() {	    return sizeStartText;	}
public String substring(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    return new String(buffer, startIndex, endIndex - startIndex);	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
static Object removeAll(final Object array, final BitSet indices) {	    final int srcLength = ArrayUtils.getLength(array);	    final int removals = indices.cardinality();	    final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals);	    int srcIndex = 0;	    int destIndex = 0;	    int count;	    int set;	    while ((set = indices.nextSetBit(srcIndex)) != -1) {	        count = set - srcIndex;	        if (count > 0) {	            System.arraycopy(array, srcIndex, result, destIndex, count);	            destIndex += count;	        }	        srcIndex = indices.nextClearBit(set);	    }	    count = srcLength - srcIndex;	    if (count > 0) {	        System.arraycopy(array, srcIndex, result, destIndex, count);	    }	    return result;	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) {	    final StrMatcher prefixMatcher = getVariablePrefixMatcher();	    final StrMatcher suffixMatcher = getVariableSuffixMatcher();	    final char escape = getEscapeChar();	    final boolean top = priorVariables == null;	    boolean altered = false;	    int lengthChange = 0;	    char[] chars = buf.buffer;	    int bufEnd = offset + length;	    int pos = offset;	    while (pos < bufEnd) {	        final int startMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd);	        if (startMatchLen == 0) {	            pos++;	        } else {	            if (pos > offset && chars[pos - 1] == escape) {	                buf.deleteCharAt(pos - 1);	                chars = buf.buffer;	                lengthChange--;	                altered = true;	                bufEnd--;	            } else {	                final int startPos = pos;	                pos += startMatchLen;	                int endMatchLen = 0;	                int nestedVarCount = 0;	                while (pos < bufEnd) {	                    if (isEnableSubstitutionInVariables() && (endMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd)) != 0) {	                        nestedVarCount++;	                        pos += endMatchLen;	                        continue;	                    }	                    endMatchLen = suffixMatcher.isMatch(chars, pos, offset, bufEnd);	                    if (endMatchLen == 0) {	                        pos++;	                    } else {	                        if (nestedVarCount == 0) {	                            String varName = new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen);	                            if (isEnableSubstitutionInVariables()) {	                                final StrBuilder bufName = new StrBuilder(varName);	                                substitute(bufName, 0, bufName.length());	                                varName = bufName.toString();	                            }	                            pos += endMatchLen;	                            final int endPos = pos;	                            if (priorVariables == null) {	                                priorVariables = new ArrayList<String>();	                                priorVariables.add(new String(chars, offset, length));	                            }	                            checkCyclicSubstitution(varName, priorVariables);	                            priorVariables.add(varName);	                            final String varValue = resolveVariable(varName, buf, startPos, endPos);	                            if (varValue != null) {	                                final int varLen = varValue.length();	                                buf.replace(startPos, endPos, varValue);	                                altered = true;	                                int change = substitute(buf, startPos, varLen, priorVariables);	                                change = change + varLen - (endPos - startPos);	                                pos += change;	                                bufEnd += change;	                                lengthChange += change;	                                chars = buf.buffer;	                            }	                            priorVariables.remove(priorVariables.size() - 1);	                            break;	                        } else {	                            nestedVarCount--;	                            pos += endMatchLen;	                        }	                    }	                }	            }	        }	    }	    if (top) {	        return altered ? 1 : 0;	    }	    return lengthChange;	}
public static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) {	    if (0 == nBools) {	        return dst;	    }	    if (nBools - 1 + srcPos >= 64) {	        throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 64");	    }	    int shift = 0;	    for (int i = 0; i < nBools; i++) {	        shift = i * 1 + srcPos;	        dst[dstPos + i] = ((0x1 & (src >> shift)) != 0);	    }	    return dst;	}
public static final String unescapeXml(final String input) {	    return UNESCAPE_XML.translate(input);	}
public boolean isEquals() {	    return this.isEquals;	}
public static UnicodeEscaper outsideOf(final int codepointLow, final int codepointHigh) {	    return new UnicodeEscaper(codepointLow, codepointHigh, false);	}
public static int getLength(final Object array) {	    if (array == null) {	        return 0;	    }	    return Array.getLength(array);	}
public boolean isEmpty() {	    return size == 0;	}
@Override	public int compare(final Object obj1, final Object obj2) {	    return ((Comparable) obj1).compareTo(obj2);	}
public static String getShortClassName(String className) {	    if (StringUtils.isEmpty(className)) {	        return StringUtils.EMPTY;	    }	    final StringBuilder arrayPrefix = new StringBuilder();	    if (className.startsWith("[")) {	        while (className.charAt(0) == '[') {	            className = className.substring(1);	            arrayPrefix.append("[]");	        }	        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {	            className = className.substring(1, className.length() - 1);	        }	        if (reverseAbbreviationMap.containsKey(className)) {	            className = reverseAbbreviationMap.get(className);	        }	    }	    final int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);	    final int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);	    String out = className.substring(lastDotIdx + 1);	    if (innerIdx != -1) {	        out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);	    }	    return out + arrayPrefix;	}
@Override	public int length() {	    return size;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public Fraction abs() {	    if (numerator >= 0) {	        return this;	    }	    return negate();	}
public static String squeeze(final String str, final String... set) {	    if (StringUtils.isEmpty(str) || deepEmpty(set)) {	        return str;	    }	    final CharSet chars = CharSet.getInstance(set);	    final StringBuilder buffer = new StringBuilder(str.length());	    final char[] chrs = str.toCharArray();	    final int sz = chrs.length;	    char lastChar = ' ';	    char ch = ' ';	    for (int i = 0; i < sz; i++) {	        ch = chrs[i];	        if (ch == lastChar && i != 0 && chars.contains(ch)) {	            continue;	        }	        buffer.append(ch);	        lastChar = ch;	    }	    return buffer.toString();	}
public StrBuilder clear() {	    size = 0;	    return this;	}
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return true;	    }	    if (lhs == null || rhs == null) {	        return false;	    }	    final Class<?> lhsClass = lhs.getClass();	    final Class<?> rhsClass = rhs.getClass();	    Class<?> testClass;	    if (lhsClass.isInstance(rhs)) {	        testClass = lhsClass;	        if (!rhsClass.isInstance(lhs)) {	            testClass = rhsClass;	        }	    } else if (rhsClass.isInstance(lhs)) {	        testClass = rhsClass;	        if (!lhsClass.isInstance(rhs)) {	            testClass = lhsClass;	        }	    } else {	        return false;	    }	    final EqualsBuilder equalsBuilder = new EqualsBuilder();	    try {	        reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {	            testClass = testClass.getSuperclass();	            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        }	    } catch (final IllegalArgumentException e) {	        return false;	    }	    return equalsBuilder.isEquals();	}
protected String getNullText() {	    return nullText;	}
@Override	public ContextedRuntimeException setContextValue(final String label, final Object value) {	    exceptionContext.setContextValue(label, value);	    return this;	}
public static String substringBeforeLast(final String str, final String separator) {	    if (isEmpty(str) || isEmpty(separator)) {	        return str;	    }	    final int pos = str.lastIndexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return str;	    }	    return str.substring(0, pos);	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
protected String getArraySeparator() {	    return arraySeparator;	}
public static Date addMonths(final Date date, final int amount) {	    return add(date, Calendar.MONTH, amount);	}
public static String prependIfMissing(final String str, final CharSequence prefix, final CharSequence... prefixes) {	    return prependIfMissing(str, prefix, false, prefixes);	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) {	    final StringBuilder buffer = new StringBuilder();	    boolean lastOutputSeconds = false;	    final int sz = tokens.length;	    for (int i = 0; i < sz; i++) {	        final Token token = tokens[i];	        final Object value = token.getValue();	        final int count = token.getCount();	        if (value instanceof StringBuilder) {	            buffer.append(value.toString());	        } else {	            if (value == y) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years));	                lastOutputSeconds = false;	            } else if (value == M) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months));	                lastOutputSeconds = false;	            } else if (value == d) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days));	                lastOutputSeconds = false;	            } else if (value == H) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours));	                lastOutputSeconds = false;	            } else if (value == m) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes));	                lastOutputSeconds = false;	            } else if (value == s) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds));	                lastOutputSeconds = true;	            } else if (value == S) {	                if (lastOutputSeconds) {	                    milliseconds += 1000;	                    final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds);	                    buffer.append(str.substring(1));	                } else {	                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds));	                }	                lastOutputSeconds = false;	            }	        }	    }	    return buffer.toString();	}
public static String stripEnd(final String str, final String stripChars) {	    int end;	    if (str == null || (end = str.length()) == 0) {	        return str;	    }	    if (stripChars == null) {	        while (end != 0 && Character.isWhitespace(str.charAt(end - 1))) {	            end--;	        }	    } else if (stripChars.isEmpty()) {	        return str;	    } else {	        while (end != 0 && stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND) {	            end--;	        }	    }	    return str.substring(0, end);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static boolean isNumeric(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isDigit(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static NumericEntityEscaper above(final int codepoint) {	    return outsideOf(0, codepoint);	}
public static String rightPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return rightPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return str.concat(padStr);	    } else if (pads < padLen) {	        return str.concat(padStr.substring(0, pads));	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return str.concat(new String(padding));	    }	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
protected Object getValue(final Field field) throws IllegalArgumentException, IllegalAccessException {	    return field.get(this.getObject());	}
public static boolean isAsciiAlpha(final char ch) {	    return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');	}
protected boolean isFieldSeparatorAtStart() {	    return fieldSeparatorAtStart;	}
protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd) {	    this.fieldSeparatorAtEnd = fieldSeparatorAtEnd;	}
public Float toFloat() {	    return Float.valueOf(floatValue());	}
@Override	public boolean equals(final Object obj) {	    return obj instanceof MutableDouble && Double.doubleToLongBits(((MutableDouble) obj).value) == Double.doubleToLongBits(value);	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
protected boolean isUseFieldNames() {	    return useFieldNames;	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
protected String getContentStart() {	    return contentStart;	}
protected String getArrayEnd() {	    return arrayEnd;	}
public static final String escapeCsv(final String input) {	    return ESCAPE_CSV.translate(input);	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
@Override	public String toString() {	    return String.valueOf(value);	}
public static String leftPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return leftPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return padStr.concat(str);	    } else if (pads < padLen) {	        return padStr.substring(0, pads).concat(str);	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return new String(padding).concat(str);	    }	}
protected boolean isFieldSeparatorAtEnd() {	    return fieldSeparatorAtEnd;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public static char binaryToHexDigit(final boolean[] src, final int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    if (src.length > srcPos + 3 && src[srcPos + 3]) {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src[srcPos]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
public static short[] removeElement(final short[] array, final short element) {	    final int index = indexOf(array, element);	    if (index == INDEX_NOT_FOUND) {	        return clone(array);	    }	    return remove(array, index);	}
public static String uncapitalize(final String str, final char... delimiters) {	    final int delimLen = delimiters == null ? -1 : delimiters.length;	    if (StringUtils.isEmpty(str) || delimLen == 0) {	        return str;	    }	    final char[] buffer = str.toCharArray();	    boolean uncapitalizeNext = true;	    for (int i = 0; i < buffer.length; i++) {	        final char ch = buffer[i];	        if (isDelimiter(ch, delimiters)) {	            uncapitalizeNext = true;	        } else if (uncapitalizeNext) {	            buffer[i] = Character.toLowerCase(ch);	            uncapitalizeNext = false;	        }	    }	    return new String(buffer);	}
public static final String unescapeEcmaScript(final String input) {	    return UNESCAPE_ECMASCRIPT.translate(input);	}
int getCount() {	    return count;	}
public boolean isEmpty() {	    return size == 0;	}
@Override	public boolean ready() {	    return pos < StrBuilder.this.size();	}
public static int indexOfDifference(final CharSequence... css) {	    if (css == null || css.length <= 1) {	        return INDEX_NOT_FOUND;	    }	    boolean anyStringNull = false;	    boolean allStringsNull = true;	    final int arrayLen = css.length;	    int shortestStrLen = Integer.MAX_VALUE;	    int longestStrLen = 0;	    for (int i = 0; i < arrayLen; i++) {	        if (css[i] == null) {	            anyStringNull = true;	            shortestStrLen = 0;	        } else {	            allStringsNull = false;	            shortestStrLen = Math.min(css[i].length(), shortestStrLen);	            longestStrLen = Math.max(css[i].length(), longestStrLen);	        }	    }	    if (allStringsNull || longestStrLen == 0 && !anyStringNull) {	        return INDEX_NOT_FOUND;	    }	    if (shortestStrLen == 0) {	        return 0;	    }	    int firstDiff = -1;	    for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {	        final char comparisonChar = css[0].charAt(stringPos);	        for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {	            if (css[arrayPos].charAt(stringPos) != comparisonChar) {	                firstDiff = stringPos;	                break;	            }	        }	        if (firstDiff != -1) {	            break;	        }	    }	    if (firstDiff == -1 && shortestStrLen != longestStrLen) {	        return shortestStrLen;	    }	    return firstDiff;	}
public static String capitalizeFully(String str, final char... delimiters) {	    final int delimLen = delimiters == null ? -1 : delimiters.length;	    if (StringUtils.isEmpty(str) || delimLen == 0) {	        return str;	    }	    str = str.toLowerCase();	    return capitalize(str, delimiters);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) {	    if (str == null) {	        if (trueString == null) {	            return Boolean.TRUE;	        }	        if (falseString == null) {	            return Boolean.FALSE;	        }	        if (nullString == null) {	            return null;	        }	    } else if (str.equals(trueString)) {	        return Boolean.TRUE;	    } else if (str.equals(falseString)) {	        return Boolean.FALSE;	    } else if (str.equals(nullString)) {	        return null;	    }	    throw new IllegalArgumentException("The String did not match any specified value");	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
@Override	public Integer build() {	    return Integer.valueOf(toHashCode());	}
public int toComparison() {	    return comparison;	}
Object getValue() {	    return value;	}
@Override	public double doubleValue() {	    return value;	}
protected boolean isUseFieldNames() {	    return useFieldNames;	}
public static String stripToNull(String str) {	    if (str == null) {	        return null;	    }	    str = strip(str, null);	    return str.isEmpty() ? null : str;	}
public StrSubstitutor setVariablePrefix(final String prefix) {	    if (prefix == null) {	        throw new IllegalArgumentException("Variable prefix must not be null!");	    }	    return setVariablePrefixMatcher(StrMatcher.stringMatcher(prefix));	}
public StrBuilder appendPadding(final int length, final char padChar) {	    if (length >= 0) {	        ensureCapacity(size + length);	        for (int i = 0; i < length; i++) {	            buffer[size++] = padChar;	        }	    }	    return this;	}
protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size) {	    buffer.append(sizeStartText);	    buffer.append(size);	    buffer.append(sizeEndText);	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public String getNewLineText() {	    return newLine;	}
protected String getContentEnd() {	    return contentEnd;	}
public Builder wrappedFactory(final ThreadFactory factory) {	    if (factory == null) {	        throw new NullPointerException("Wrapped ThreadFactory must not be null!");	    }	    wrappedFactory = factory;	    return this;	}
protected boolean isUseShortClassName() {	    return useShortClassName;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public static String reverse(final String str) {	    if (str == null) {	        return null;	    }	    return new StringBuilder(str).reverse().toString();	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
protected boolean isUseFieldNames() {	    return useFieldNames;	}
public boolean isEmpty() {	    return size == 0;	}
@Override	public void mark(final int readAheadLimit) {	    mark = pos;	}
public static Boolean or(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
public static Object readStaticField(final Class<?> cls, final String fieldName, final boolean forceAccess) throws IllegalAccessException {	    final Field field = getField(cls, fieldName, forceAccess);	    if (field == null) {	        throw new IllegalArgumentException("Cannot locate field " + fieldName + " on " + cls);	    }	    return readStaticField(field, false);	}
public Fraction add(final Fraction fraction) {	    return addSub(fraction, true);	}
@Override	public boolean isFieldSeparatorAtEnd() {	    return super.isFieldSeparatorAtEnd();	}
public final void translate(final CharSequence input, final Writer out) throws IOException {	    if (out == null) {	        throw new IllegalArgumentException("The Writer must not be null");	    }	    if (input == null) {	        return;	    }	    int pos = 0;	    final int len = input.length();	    while (pos < len) {	        final int consumed = translate(input, pos, out);	        if (consumed == 0) {	            final char[] c = Character.toChars(Character.codePointAt(input, pos));	            out.write(c);	            pos += c.length;	            continue;	        }	        for (int pt = 0; pt < consumed; pt++) {	            pos += Character.charCount(Character.codePointAt(input, pt));	        }	    }	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static void handleCauseUnchecked(final ExecutionException ex) {	    final ConcurrentRuntimeException crex = extractCauseUnchecked(ex);	    if (crex != null) {	        throw crex;	    }	}
public final synchronized void setLimit(final int limit) {	    this.limit = limit;	}
public long getThreadCount() {	    return threadCounter.get();	}
public int getMaxLengthEstimate() {	    return printer.getMaxLengthEstimate();	}
public static Class<?> getClass(final String className, final boolean initialize) throws ClassNotFoundException {	    final ClassLoader contextCL = Thread.currentThread().getContextClassLoader();	    final ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL;	    return getClass(loader, className, initialize);	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
public static String capitalize(final String str) {	    int strLen;	    if (str == null || (strLen = str.length()) == 0) {	        return str;	    }	    char firstChar = str.charAt(0);	    if (Character.isTitleCase(firstChar)) {	        return str;	    }	    return new StringBuilder(strLen).append(Character.toTitleCase(firstChar)).append(str.substring(1)).toString();	}
@Override	public int hashCode() {	    return getObject() != null ? getObject().hashCode() : 0;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public static boolean[] clone(final boolean[] array) {	    if (array == null) {	        return null;	    }	    return array.clone();	}
@Override	public int hashCode() {	    return toHashCode();	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) {	    if (array == null) {	        return null;	    }	    if (startIndexInclusive < 0) {	        startIndexInclusive = 0;	    }	    if (endIndexExclusive > array.length) {	        endIndexExclusive = array.length;	    }	    final int newSize = endIndexExclusive - startIndexInclusive;	    if (newSize <= 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] subarray = new boolean[newSize];	    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);	    return subarray;	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
public static <L, M, R> Triple<L, M, R> of(final L left, final M middle, final R right) {	    return new ImmutableTriple<L, M, R>(left, middle, right);	}
protected boolean isFieldSeparatorAtStart() {	    return fieldSeparatorAtStart;	}
public char getEnd() {	    return this.end;	}
public String nextToken() {	    if (hasNext()) {	        return tokens[tokenPos++];	    }	    return null;	}
protected String getSizeEndText() {	    return sizeEndText;	}
public static String repeat(final char ch, final int repeat) {	    final char[] buf = new char[repeat];	    for (int i = repeat - 1; i >= 0; i--) {	        buf[i] = ch;	    }	    return new String(buf);	}
public boolean isSet(final int holder) {	    return (holder & _mask) != 0;	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
public String getNullText() {	    return nullText;	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    final int seqEnd = input.length();	    if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') {	        int start = index + 2;	        boolean isHex = false;	        final char firstChar = input.charAt(start);	        if (firstChar == 'x' || firstChar == 'X') {	            start++;	            isHex = true;	            if (start == seqEnd) {	                return 0;	            }	        }	        int end = start;	        while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) {	            end++;	        }	        final boolean semiNext = end != seqEnd && input.charAt(end) == ';';	        if (!semiNext) {	            if (isSet(OPTION.semiColonRequired)) {	                return 0;	            } else if (isSet(OPTION.errorIfNoSemiColon)) {	                throw new IllegalArgumentException("Semi-colon required at end of numeric entity");	            }	        }	        int entityValue;	        try {	            if (isHex) {	                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);	            } else {	                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);	            }	        } catch (final NumberFormatException nfe) {	            return 0;	        }	        if (entityValue > 0xFFFF) {	            final char[] chrs = Character.toChars(entityValue);	            out.write(chrs[0]);	            out.write(chrs[1]);	        } else {	            out.write(entityValue);	        }	        return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0);	    }	    return 0;	}
public String toString(final String format) {	    return String.format(format, minimum, maximum, comparator);	}
public static <T> T mode(final T... items) {	    if (ArrayUtils.isNotEmpty(items)) {	        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(items.length);	        for (final T t : items) {	            final MutableInt count = occurrences.get(t);	            if (count == null) {	                occurrences.put(t, new MutableInt(1));	            } else {	                count.increment();	            }	        }	        T result = null;	        int max = 0;	        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {	            final int cmp = e.getValue().intValue();	            if (cmp == max) {	                result = null;	            } else if (cmp > max) {	                max = cmp;	                result = e.getKey();	            }	        }	        return result;	    }	    return null;	}
@Override	public int length() {	    return size;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public int toHashCode() {	    return iTotal;	}
protected String getSummaryObjectEndText() {	    return summaryObjectEndText;	}
void increment() {	    count++;	}
public int size() {	    return size;	}
public boolean isEmpty() {	    return size == 0;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static String chop(final String str) {	    if (str == null) {	        return null;	    }	    final int strLen = str.length();	    if (strLen < 2) {	        return EMPTY;	    }	    final int lastIdx = strLen - 1;	    final String ret = str.substring(0, lastIdx);	    final char last = str.charAt(lastIdx);	    if (last == CharUtils.LF && ret.charAt(lastIdx - 1) == CharUtils.CR) {	        return ret.substring(0, lastIdx - 1);	    }	    return ret;	}
static Token[] lexx(final String format) {	    final char[] array = format.toCharArray();	    final ArrayList<Token> list = new ArrayList<Token>(array.length);	    boolean inLiteral = false;	    StringBuilder buffer = null;	    Token previous = null;	    final int sz = array.length;	    for (int i = 0; i < sz; i++) {	        final char ch = array[i];	        if (inLiteral && ch != '\'') {	            buffer.append(ch);	            continue;	        }	        Object value = null;	        switch(ch) {	            case '\'':	                if (inLiteral) {	                    buffer = null;	                    inLiteral = false;	                } else {	                    buffer = new StringBuilder();	                    list.add(new Token(buffer));	                    inLiteral = true;	                }	                break;	            case 'y':	                value = y;	                break;	            case 'M':	                value = M;	                break;	            case 'd':	                value = d;	                break;	            case 'H':	                value = H;	                break;	            case 'm':	                value = m;	                break;	            case 's':	                value = s;	                break;	            case 'S':	                value = S;	                break;	            default:	                if (buffer == null) {	                    buffer = new StringBuilder();	                    list.add(new Token(buffer));	                }	                buffer.append(ch);	        }	        if (value != null) {	            if (previous != null && previous.getValue() == value) {	                previous.increment();	            } else {	                final Token token = new Token(value);	                list.add(token);	                previous = token;	            }	            buffer = null;	        }	    }	    return list.toArray(new Token[list.size()]);	}
private static Date add(final Date date, final int calendarField, final int amount) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final Calendar c = Calendar.getInstance();	    c.setTime(date);	    c.add(calendarField, amount);	    return c.getTime();	}
public static <E extends Enum<E>> List<E> getEnumList(final Class<E> enumClass) {	    return new ArrayList<E>(Arrays.asList(enumClass.getEnumConstants()));	}
public static boolean isEmpty(final CharSequence cs) {	    return cs == null || cs.length() == 0;	}
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return 0;	    }	    if (lhs == null || rhs == null) {	        throw new NullPointerException();	    }	    Class<?> lhsClazz = lhs.getClass();	    if (!lhsClazz.isInstance(rhs)) {	        throw new ClassCastException();	    }	    final CompareToBuilder compareToBuilder = new CompareToBuilder();	    reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);	    while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) {	        lhsClazz = lhsClazz.getSuperclass();	        reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);	    }	    return compareToBuilder.toComparison();	}
public static boolean isAsciiAlpha(final char ch) {	    return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');	}
public static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts) {	    if ((src.length == 0 && srcPos == 0) || 0 == nShorts) {	        return dstInit;	    }	    if ((nShorts - 1) * 16 + dstPos >= 32) {	        throw new IllegalArgumentException("(nShorts-1)*16+dstPos is greather or equal to than 32");	    }	    int out = dstInit;	    int shift = 0;	    for (int i = 0; i < nShorts; i++) {	        shift = i * 16 + dstPos;	        final int bits = (0xffff & src[i + srcPos]) << shift;	        final int mask = 0xffff << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
@Override	public float floatValue() {	    return (float) numerator / (float) denominator;	}
public static Object readDeclaredStaticField(final Class<?> cls, final String fieldName, final boolean forceAccess) throws IllegalAccessException {	    final Field field = getDeclaredField(cls, fieldName, forceAccess);	    if (field == null) {	        throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName);	    }	    return readStaticField(field, false);	}
protected void setContentEnd(String contentEnd) {	    if (contentEnd == null) {	        contentEnd = "";	    }	    this.contentEnd = contentEnd;	}
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) {	    if (str == null) {	        if (trueString == null) {	            return Boolean.TRUE;	        }	        if (falseString == null) {	            return Boolean.FALSE;	        }	        if (nullString == null) {	            return null;	        }	    } else if (str.equals(trueString)) {	        return Boolean.TRUE;	    } else if (str.equals(falseString)) {	        return Boolean.FALSE;	    } else if (str.equals(nullString)) {	        return null;	    }	    throw new IllegalArgumentException("The String did not match any specified value");	}
public static int hexDigitMsb0ToInt(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return 0x0;	        case '1':	            return 0x8;	        case '2':	            return 0x4;	        case '3':	            return 0xC;	        case '4':	            return 0x2;	        case '5':	            return 0xA;	        case '6':	            return 0x6;	        case '7':	            return 0xE;	        case '8':	            return 0x1;	        case '9':	            return 0x9;	        case 'a':	        case 'A':	            return 0x5;	        case 'b':	        case 'B':	            return 0xD;	        case 'c':	        case 'C':	            return 0x3;	        case 'd':	        case 'D':	            return 0xB;	        case 'e':	        case 'E':	            return 0x7;	        case 'f':	        case 'F':	            return 0xF;	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public static String uncapitalize(final String str, final char... delimiters) {	    final int delimLen = delimiters == null ? -1 : delimiters.length;	    if (StringUtils.isEmpty(str) || delimLen == 0) {	        return str;	    }	    final char[] buffer = str.toCharArray();	    boolean uncapitalizeNext = true;	    for (int i = 0; i < buffer.length; i++) {	        final char ch = buffer[i];	        if (isDelimiter(ch, delimiters)) {	            uncapitalizeNext = true;	        } else if (uncapitalizeNext) {	            buffer[i] = Character.toLowerCase(ch);	            uncapitalizeNext = false;	        }	    }	    return new String(buffer);	}
public static String chop(final String str) {	    if (str == null) {	        return null;	    }	    final int strLen = str.length();	    if (strLen < 2) {	        return EMPTY;	    }	    final int lastIdx = strLen - 1;	    final String ret = str.substring(0, lastIdx);	    final char last = str.charAt(lastIdx);	    if (last == CharUtils.LF && ret.charAt(lastIdx - 1) == CharUtils.CR) {	        return ret.substring(0, lastIdx - 1);	    }	    return ret;	}
@Override	public boolean markSupported() {	    return true;	}
public static boolean isNotEmpty(final boolean[] array) {	    return (array != null && array.length != 0);	}
public static NumericEntityEscaper above(final int codepoint) {	    return outsideOf(0, codepoint);	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
@Override	public double doubleValue() {	    return value;	}
@Override	public int length() {	    return size;	}
public boolean isEmptyTokenAsNull() {	    return this.emptyAsNull;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static byte toByte(final String str, final byte defaultValue) {	    if (str == null) {	        return defaultValue;	    }	    try {	        return Byte.parseByte(str);	    } catch (final NumberFormatException nfe) {	        return defaultValue;	    }	}
public static boolean isWhitespace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isWhitespace(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public int size() {	    return size;	}
public Fraction add(final Fraction fraction) {	    return addSub(fraction, true);	}
public boolean isEmpty() {	    return size == 0;	}
public boolean isEmpty() {	    return size == 0;	}
public StrBuilder clear() {	    size = 0;	    return this;	}
public static String getMessage(final Throwable th) {	    if (th == null) {	        return "";	    }	    final String clsName = ClassUtils.getShortClassName(th, null);	    final String msg = th.getMessage();	    return clsName + ": " + StringUtils.defaultString(msg);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static boolean isEmpty(final CharSequence cs) {	    return cs == null || cs.length() == 0;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf) {	    for (final Rule rule : mRules) {	        rule.appendTo(buf, calendar);	    }	    return buf;	}
public static boolean isAllLowerCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLowerCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public int capacity() {	    return buffer.length;	}
public Fraction subtract(final Fraction fraction) {	    return addSub(fraction, false);	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
@Override	public String getContentEnd() {	    return super.getContentEnd();	}
protected String getNullText() {	    return nullText;	}
public int capacity() {	    return buffer.length;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static boolean startsWithAny(final CharSequence string, final CharSequence... searchStrings) {	    if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {	        return false;	    }	    for (final CharSequence searchString : searchStrings) {	        if (StringUtils.startsWith(string, searchString)) {	            return true;	        }	    }	    return false;	}
@Override	public long longValue() {	    return (long) value;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException {	    return charsetName == null ? new String(bytes) : new String(bytes, charsetName);	}
public String getNewLineText() {	    return newLine;	}
@Override	public boolean equals(final Object obj) {	    return obj instanceof MutableFloat && Float.floatToIntBits(((MutableFloat) obj).value) == Float.floatToIntBits(value);	}
public boolean isStartedBy(final T element) {	    if (element == null) {	        return false;	    }	    return comparator.compare(element, minimum) == 0;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public String getNullText() {	    return nullText;	}
public static boolean isNumeric(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isDigit(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static boolean equalsIgnoreCase(final CharSequence str1, final CharSequence str2) {	    if (str1 == null || str2 == null) {	        return str1 == str2;	    } else if (str1 == str2) {	        return true;	    } else if (str1.length() != str2.length()) {	        return false;	    } else {	        return CharSequenceUtils.regionMatches(str1, true, 0, str2, 0, str1.length());	    }	}
public static Boolean[] nullToEmpty(final Boolean[] array) {	    if (array == null || array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    return array;	}
@Override	public Short getValue() {	    return Short.valueOf(this.value);	}
public String getNewLineText() {	    return newLine;	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public String getNullText() {	    return nullText;	}
public static List<Throwable> getThrowableList(Throwable throwable) {	    final List<Throwable> list = new ArrayList<Throwable>();	    while (throwable != null && list.contains(throwable) == false) {	        list.add(throwable);	        throwable = ExceptionUtils.getCause(throwable);	    }	    return list;	}
public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) {	    if (src.length > 8) {	        throw new IllegalArgumentException("src.length>8: src.length=" + src.length);	    }	    if (src.length - srcPos < 4) {	        throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos);	    }	    if (src[srcPos + 3]) {	        if (src[srcPos + 2]) {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return '7';	                }	            } else {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return '3';	                }	            }	        } else {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return '5';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '1';	                }	            }	        }	    } else {	        if (src[srcPos + 2]) {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'e';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return 'a';	                } else {	                    return '2';	                }	            }	        } else {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'c';	                } else {	                    return '4';	                }	            } else {	                if (src[srcPos]) {	                    return '8';	                } else {	                    return '0';	                }	            }	        }	    }	}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    buffer.append(arrayStart);	    for (int i = 0; i < array.length; i++) {	        if (i > 0) {	            buffer.append(arraySeparator);	        }	        appendDetail(buffer, fieldName, array[i]);	    }	    buffer.append(arrayEnd);	}
@Override	public int read(final char[] b, final int off, int len) {	    if (off < 0 || len < 0 || off > b.length || (off + len) > b.length || (off + len) < 0) {	        throw new IndexOutOfBoundsException();	    }	    if (len == 0) {	        return 0;	    }	    if (pos >= StrBuilder.this.size()) {	        return -1;	    }	    if (pos + len > size()) {	        len = StrBuilder.this.size() - pos;	    }	    StrBuilder.this.getChars(pos, pos + len, b, off);	    pos += len;	    return len;	}
public int size() {	    return size;	}
public static Object invokeStaticMethod(final Class<?> cls, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {	    if (parameterTypes == null) {	        parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;	    }	    if (args == null) {	        args = ArrayUtils.EMPTY_OBJECT_ARRAY;	    }	    final Method method = getMatchingAccessibleMethod(cls, methodName, parameterTypes);	    if (method == null) {	        throw new NoSuchMethodException("No such accessible method: " + methodName + "() on class: " + cls.getName());	    }	    return method.invoke(null, args);	}
public StrBuilder setNullText(String nullText) {	    if (nullText != null && nullText.isEmpty()) {	        nullText = null;	    }	    this.nullText = nullText;	    return this;	}
public static int reflectionHashCode(final Object object, final String... excludeFields) {	    return reflectionHashCode(17, 37, object, false, null, excludeFields);	}
public char getStart() {	    return this.start;	}
@Override	public void setValue(final Number value) {	    this.value = value.byteValue();	}
@Override	public String toPattern() {	    return toPattern;	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public boolean isEmpty() {	    return size == 0;	}
public static String toString(final Character ch) {	    if (ch == null) {	        return null;	    }	    return toString(ch.charValue());	}
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return new boolean[] { false, false, false, false };	        case '1':	            return new boolean[] { false, false, false, true };	        case '2':	            return new boolean[] { false, false, true, false };	        case '3':	            return new boolean[] { false, false, true, true };	        case '4':	            return new boolean[] { false, true, false, false };	        case '5':	            return new boolean[] { false, true, false, true };	        case '6':	            return new boolean[] { false, true, true, false };	        case '7':	            return new boolean[] { false, true, true, true };	        case '8':	            return new boolean[] { true, false, false, false };	        case '9':	            return new boolean[] { true, false, false, true };	        case 'a':	        case 'A':	            return new boolean[] { true, false, true, false };	        case 'b':	        case 'B':	            return new boolean[] { true, false, true, true };	        case 'c':	        case 'C':	            return new boolean[] { true, true, false, false };	        case 'd':	        case 'D':	            return new boolean[] { true, true, false, true };	        case 'e':	        case 'E':	            return new boolean[] { true, true, true, false };	        case 'f':	        case 'F':	            return new boolean[] { true, true, true, true };	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return 0;	    }	    if (lhs == null || rhs == null) {	        throw new NullPointerException();	    }	    Class<?> lhsClazz = lhs.getClass();	    if (!lhsClazz.isInstance(rhs)) {	        throw new ClassCastException();	    }	    final CompareToBuilder compareToBuilder = new CompareToBuilder();	    reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);	    while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) {	        lhsClazz = lhsClazz.getSuperclass();	        reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);	    }	    return compareToBuilder.toComparison();	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) {	    if (s == null || t == null) {	        throw new IllegalArgumentException("Strings must not be null");	    }	    if (threshold < 0) {	        throw new IllegalArgumentException("Threshold must not be negative");	    }	    int n = s.length();	    int m = t.length();	    if (n == 0) {	        return m <= threshold ? m : -1;	    } else if (m == 0) {	        return n <= threshold ? n : -1;	    }	    if (n > m) {	        final CharSequence tmp = s;	        s = t;	        t = tmp;	        n = m;	        m = t.length();	    }	    int[] p = new int[n + 1];	    int[] d = new int[n + 1];	    int[] _d;	    final int boundary = Math.min(n, threshold) + 1;	    for (int i = 0; i < boundary; i++) {	        p[i] = i;	    }	    Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);	    Arrays.fill(d, Integer.MAX_VALUE);	    for (int j = 1; j <= m; j++) {	        final char t_j = t.charAt(j - 1);	        d[0] = j;	        final int min = Math.max(1, j - threshold);	        final int max = Math.min(n, j + threshold);	        if (min > max) {	            return -1;	        }	        if (min > 1) {	            d[min - 1] = Integer.MAX_VALUE;	        }	        for (int i = min; i <= max; i++) {	            if (s.charAt(i - 1) == t_j) {	                d[i] = p[i - 1];	            } else {	                d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);	            }	        }	        _d = p;	        p = d;	        d = _d;	    }	    if (p[n] <= threshold) {	        return p[n];	    }	    return -1;	}
public static boolean isNumeric(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isDigit(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public int size() {	    return size;	}
protected boolean isArrayContentDetail() {	    return arrayContentDetail;	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale) {	    return cache.getDateTimeInstance(dateStyle, timeStyle, timeZone, locale);	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static <T extends Iterable<?>> T noNullElements(final T iterable) {	    return noNullElements(iterable, DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE);	}
public int toHashCode() {	    return iTotal;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public boolean isEndedBy(final T element) {	    if (element == null) {	        return false;	    }	    return comparator.compare(element, maximum) == 0;	}
public static String repeat(final char ch, final int repeat) {	    final char[] buf = new char[repeat];	    for (int i = repeat - 1; i >= 0; i--) {	        buf[i] = ch;	    }	    return new String(buf);	}
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, true);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) {	    style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));	    return this;	}
public static boolean isInnerClass(final Class<?> cls) {	    return cls != null && cls.getEnclosingClass() != null;	}
public Reader asReader() {	    return new StrBuilderReader();	}
public static String center(String str, final int size, String padStr) {	    if (str == null || size <= 0) {	        return str;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    str = leftPad(str, strLen + pads / 2, padStr);	    str = rightPad(str, size, padStr);	    return str;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public boolean isEmpty() {	    return size == 0;	}
public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width, final int precision, final char padChar, final CharSequence ellipsis) {	    Validate.isTrue(ellipsis == null || precision < 0 || ellipsis.length() <= precision, "Specified ellipsis '%1$s' exceeds precision of %2$s", ellipsis, Integer.valueOf(precision));	    final StringBuilder buf = new StringBuilder(seq);	    if (precision >= 0 && precision < seq.length()) {	        final CharSequence _ellipsis = ObjectUtils.defaultIfNull(ellipsis, StringUtils.EMPTY);	        buf.replace(precision - _ellipsis.length(), seq.length(), _ellipsis.toString());	    }	    final boolean leftJustify = (flags & LEFT_JUSTIFY) == LEFT_JUSTIFY;	    for (int i = buf.length(); i < width; i++) {	        buf.insert(leftJustify ? i : 0, padChar);	    }	    formatter.format(buf.toString());	    return formatter;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public String getNewLineText() {	    return newLine;	}
public boolean isOverlappedBy(final Range<T> otherRange) {	    if (otherRange == null) {	        return false;	    }	    return otherRange.contains(minimum) || otherRange.contains(maximum) || contains(otherRange.minimum);	}
public static String formatDurationHMS(final long durationMillis) {	    return formatDuration(durationMillis, "H:mm:ss.SSS");	}
@Override	public T get(final long timeout, final TimeUnit unit) {	    return value;	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public boolean isOverlappedBy(final Range<T> otherRange) {	    if (otherRange == null) {	        return false;	    }	    return otherRange.contains(minimum) || otherRange.contains(maximum) || contains(otherRange.minimum);	}
private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase) {	    if (str == null || prefix == null) {	        return str == null && prefix == null;	    }	    if (prefix.length() > str.length()) {	        return false;	    }	    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());	}
public boolean isEmpty() {	    return size == 0;	}
public int capacity() {	    return buffer.length;	}
public StrBuilder appendFixedWidthPadRight(final int value, final int width, final char padChar) {	    return appendFixedWidthPadRight(String.valueOf(value), width, padChar);	}
public String getNewLineText() {	    return newLine;	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
public static String capitalize(final String str) {	    int strLen;	    if (str == null || (strLen = str.length()) == 0) {	        return str;	    }	    char firstChar = str.charAt(0);	    if (Character.isTitleCase(firstChar)) {	        return str;	    }	    return new StringBuilder(strLen).append(Character.toTitleCase(firstChar)).append(str.substring(1)).toString();	}
public static int indexOfDifference(final CharSequence... css) {	    if (css == null || css.length <= 1) {	        return INDEX_NOT_FOUND;	    }	    boolean anyStringNull = false;	    boolean allStringsNull = true;	    final int arrayLen = css.length;	    int shortestStrLen = Integer.MAX_VALUE;	    int longestStrLen = 0;	    for (int i = 0; i < arrayLen; i++) {	        if (css[i] == null) {	            anyStringNull = true;	            shortestStrLen = 0;	        } else {	            allStringsNull = false;	            shortestStrLen = Math.min(css[i].length(), shortestStrLen);	            longestStrLen = Math.max(css[i].length(), longestStrLen);	        }	    }	    if (allStringsNull || longestStrLen == 0 && !anyStringNull) {	        return INDEX_NOT_FOUND;	    }	    if (shortestStrLen == 0) {	        return 0;	    }	    int firstDiff = -1;	    for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {	        final char comparisonChar = css[0].charAt(stringPos);	        for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {	            if (css[arrayPos].charAt(stringPos) != comparisonChar) {	                firstDiff = stringPos;	                break;	            }	        }	        if (firstDiff != -1) {	            break;	        }	    }	    if (firstDiff == -1 && shortestStrLen != longestStrLen) {	        return shortestStrLen;	    }	    return firstDiff;	}
public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) {	    final Token[] tokens = lexx(format);	    final Calendar start = Calendar.getInstance(timezone);	    start.setTime(new Date(startMillis));	    final Calendar end = Calendar.getInstance(timezone);	    end.setTime(new Date(endMillis));	    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);	    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);	    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);	    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);	    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);	    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);	    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);	    while (milliseconds < 0) {	        milliseconds += 1000;	        seconds -= 1;	    }	    while (seconds < 0) {	        seconds += 60;	        minutes -= 1;	    }	    while (minutes < 0) {	        minutes += 60;	        hours -= 1;	    }	    while (hours < 0) {	        hours += 24;	        days -= 1;	    }	    if (Token.containsTokenWithValue(tokens, M)) {	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	        while (months < 0) {	            months += 12;	            years -= 1;	        }	        if (!Token.containsTokenWithValue(tokens, y) && years != 0) {	            while (years != 0) {	                months += 12 * years;	                years = 0;	            }	        }	    } else {	        if (!Token.containsTokenWithValue(tokens, y)) {	            int target = end.get(Calendar.YEAR);	            if (months < 0) {	                target -= 1;	            }	            while (start.get(Calendar.YEAR) != target) {	                days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);	                if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) {	                    days += 1;	                }	                start.add(Calendar.YEAR, 1);	                days += start.get(Calendar.DAY_OF_YEAR);	            }	            years = 0;	        }	        while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            start.add(Calendar.MONTH, 1);	        }	        months = 0;	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	    }	    if (!Token.containsTokenWithValue(tokens, d)) {	        hours += 24 * days;	        days = 0;	    }	    if (!Token.containsTokenWithValue(tokens, H)) {	        minutes += 60 * hours;	        hours = 0;	    }	    if (!Token.containsTokenWithValue(tokens, m)) {	        seconds += 60 * minutes;	        minutes = 0;	    }	    if (!Token.containsTokenWithValue(tokens, s)) {	        milliseconds += 1000 * seconds;	        seconds = 0;	    }	    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public static String removeEnd(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.endsWith(remove)) {	        return str.substring(0, str.length() - remove.length());	    }	    return str;	}
protected boolean isDefaultFullDetail() {	    return defaultFullDetail;	}
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) {	    style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));	    return this;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
@Override	public boolean hasPrevious() {	    checkTokenized();	    return tokenPos > 0;	}
@Override	public Integer build() {	    return Integer.valueOf(toHashCode());	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException {	    return parseDateWithLeniency(str, null, parsePatterns, false);	}
@Override	public int compare(final Object obj1, final Object obj2) {	    return ((Comparable) obj1).compareTo(obj2);	}
public static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess) {	    if (cls == null) {	        throw new IllegalArgumentException("The class must not be null");	    }	    if (fieldName == null) {	        throw new IllegalArgumentException("The field name must not be null");	    }	    try {	        final Field field = cls.getDeclaredField(fieldName);	        if (!MemberUtils.isAccessible(field)) {	            if (forceAccess) {	                field.setAccessible(true);	            } else {	                return null;	            }	        }	        return field;	    } catch (final NoSuchFieldException e) {	    }	    return null;	}
public boolean isEmpty() {	    return size == 0;	}
@Override	public String toString() {	    if (this.getObject() == null) {	        return this.getStyle().getNullText();	    }	    Class<?> clazz = this.getObject().getClass();	    this.appendFieldsIn(clazz);	    while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {	        clazz = clazz.getSuperclass();	        this.appendFieldsIn(clazz);	    }	    return super.toString();	}
protected String getSizeEndText() {	    return sizeEndText;	}
public static boolean containsNone(final CharSequence cs, final String invalidChars) {	    if (cs == null || invalidChars == null) {	        return true;	    }	    return containsNone(cs, invalidChars.toCharArray());	}
protected String getFieldNameValueSeparator() {	    return fieldNameValueSeparator;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public int size() {	    return size;	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
protected String getFieldSeparator() {	    return fieldSeparator;	}
public String getNewLineText() {	    return newLine;	}
public static String repeat(final char ch, final int repeat) {	    final char[] buf = new char[repeat];	    for (int i = repeat - 1; i >= 0; i--) {	        buf[i] = ch;	    }	    return new String(buf);	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static final String escapeCsv(final String input) {	    return ESCAPE_CSV.translate(input);	}
public static String formatDurationHMS(final long durationMillis) {	    return formatDuration(durationMillis, "H:mm:ss.SSS");	}
protected String getSummaryObjectEndText() {	    return summaryObjectEndText;	}
public static Object invokeMethod(final Object object, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {	    if (parameterTypes == null) {	        parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;	    }	    if (args == null) {	        args = ArrayUtils.EMPTY_OBJECT_ARRAY;	    }	    final Method method = getMatchingAccessibleMethod(object.getClass(), methodName, parameterTypes);	    if (method == null) {	        throw new NoSuchMethodException("No such accessible method: " + methodName + "() on object: " + object.getClass().getName());	    }	    return method.invoke(object, args);	}
protected String getSummaryObjectStartText() {	    return summaryObjectStartText;	}
public StrBuilder deleteAll(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, -1);	}
protected boolean isUseShortClassName() {	    return useShortClassName;	}
public synchronized void shutdown() {	    if (!shutdown) {	        if (ownExecutor) {	            getExecutorService().shutdownNow();	        }	        if (task != null) {	            task.cancel(false);	        }	        shutdown = true;	    }	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
public static <T> T[] toArray(final T... items) {	    return items;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public boolean isNegated() {	    return negated;	}
public int toComparison() {	    return comparison;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
@Override	public T call() throws Exception {	    try {	        return initialize();	    } finally {	        if (execFinally != null) {	            execFinally.shutdown();	        }	    }	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public static boolean isAlphaSpace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false && cs.charAt(i) != ' ') {	            return false;	        }	    }	    return true;	}
public static boolean equals(final Annotation a1, final Annotation a2) {	    if (a1 == a2) {	        return true;	    }	    if (a1 == null || a2 == null) {	        return false;	    }	    final Class<? extends Annotation> type = a1.annotationType();	    final Class<? extends Annotation> type2 = a2.annotationType();	    Validate.notNull(type, "Annotation %s with null annotationType()", a1);	    Validate.notNull(type2, "Annotation %s with null annotationType()", a2);	    if (!type.equals(type2)) {	        return false;	    }	    try {	        for (final Method m : type.getDeclaredMethods()) {	            if (m.getParameterTypes().length == 0 && isValidAnnotationMemberType(m.getReturnType())) {	                final Object v1 = m.invoke(a1);	                final Object v2 = m.invoke(a2);	                if (!memberEquals(m.getReturnType(), v1, v2)) {	                    return false;	                }	            }	        }	    } catch (final IllegalAccessException ex) {	        return false;	    } catch (final InvocationTargetException ex) {	        return false;	    }	    return true;	}
protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    appendSummarySize(buffer, fieldName, array.length);	}
public static String stripToNull(String str) {	    if (str == null) {	        return null;	    }	    str = strip(str, null);	    return str.isEmpty() ? null : str;	}
public static float min(final float a, final float b) {	    if (Float.isNaN(a)) {	        return b;	    } else if (Float.isNaN(b)) {	        return a;	    } else {	        return Math.min(a, b);	    }	}
public static boolean isAlphanumericSpace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetterOrDigit(cs.charAt(i)) == false && cs.charAt(i) != ' ') {	            return false;	        }	    }	    return true;	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale) {	    return cache.getDateInstance(style, timeZone, locale);	}
public static boolean equalsIgnoreCase(final CharSequence str1, final CharSequence str2) {	    if (str1 == null || str2 == null) {	        return str1 == str2;	    } else if (str1 == str2) {	        return true;	    } else if (str1.length() != str2.length()) {	        return false;	    } else {	        return CharSequenceUtils.regionMatches(str1, true, 0, str2, 0, str1.length());	    }	}
@Override	public void setValue(final Number value) {	    this.value = value.longValue();	}
@Override	public TimeZone getTimeZone() {	    return mTimeZone;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public StrBuilder deleteFirst(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, 1);	}
public static String center(String str, final int size, String padStr) {	    if (str == null || size <= 0) {	        return str;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    str = leftPad(str, strLen + pads / 2, padStr);	    str = rightPad(str, size, padStr);	    return str;	}
static String[] getStackFrames(final String stackTrace) {	    final String linebreak = SystemUtils.LINE_SEPARATOR;	    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);	    final List<String> list = new ArrayList<String>();	    while (frames.hasMoreTokens()) {	        list.add(frames.nextToken());	    }	    return list.toArray(new String[list.size()]);	}
protected String getFieldSeparator() {	    return fieldSeparator;	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public StrBuilder setLength(final int length) {	    if (length < 0) {	        throw new StringIndexOutOfBoundsException(length);	    }	    if (length < size) {	        size = length;	    } else if (length > size) {	        ensureCapacity(length);	        final int oldEnd = size;	        final int newEnd = length;	        size = length;	        for (int i = oldEnd; i < newEnd; i++) {	            buffer[i] = '\0';	        }	    }	    return this;	}
public Fraction reduce() {	    if (numerator == 0) {	        return equals(ZERO) ? this : ZERO;	    }	    final int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);	    if (gcd == 1) {	        return this;	    }	    return Fraction.getFraction(numerator / gcd, denominator / gcd);	}
protected boolean isFieldSeparatorAtStart() {	    return fieldSeparatorAtStart;	}
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) {	    if (str == null) {	        if (trueString == null) {	            return Boolean.TRUE;	        }	        if (falseString == null) {	            return Boolean.FALSE;	        }	        if (nullString == null) {	            return null;	        }	    } else if (str.equals(trueString)) {	        return Boolean.TRUE;	    } else if (str.equals(falseString)) {	        return Boolean.FALSE;	    } else if (str.equals(nullString)) {	        return null;	    }	    throw new IllegalArgumentException("The String did not match any specified value");	}
static String[] getStackFrames(final String stackTrace) {	    final String linebreak = SystemUtils.LINE_SEPARATOR;	    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);	    final List<String> list = new ArrayList<String>();	    while (frames.hasMoreTokens()) {	        list.add(frames.nextToken());	    }	    return list.toArray(new String[list.size()]);	}
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return true;	    }	    if (lhs == null || rhs == null) {	        return false;	    }	    final Class<?> lhsClass = lhs.getClass();	    final Class<?> rhsClass = rhs.getClass();	    Class<?> testClass;	    if (lhsClass.isInstance(rhs)) {	        testClass = lhsClass;	        if (!rhsClass.isInstance(lhs)) {	            testClass = rhsClass;	        }	    } else if (rhsClass.isInstance(lhs)) {	        testClass = rhsClass;	        if (!lhsClass.isInstance(rhs)) {	            testClass = lhsClass;	        }	    } else {	        return false;	    }	    final EqualsBuilder equalsBuilder = new EqualsBuilder();	    try {	        reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {	            testClass = testClass.getSuperclass();	            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        }	    } catch (final IllegalArgumentException e) {	        return false;	    }	    return equalsBuilder.isEquals();	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public abstract boolean translate(int codepoint, Writer out) throws IOException;
public static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools) {	    if ((src.length == 0 && srcPos == 0) || 0 == nBools) {	        return dstInit;	    }	    if (nBools - 1 + dstPos >= 64) {	        throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 64");	    }	    long out = dstInit;	    int shift = 0;	    for (int i = 0; i < nBools; i++) {	        shift = i * 1 + dstPos;	        final long bits = (src[i + srcPos] ? 1L : 0) << shift;	        final long mask = 0x1L << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
@Override	public TimeZone getTimeZone() {	    return printer.getTimeZone();	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public char getEscapeChar() {	    return this.escapeChar;	}
public int capacity() {	    return buffer.length;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
@Override	public T get(final long timeout, final TimeUnit unit) {	    return value;	}
public static String chop(final String str) {	    if (str == null) {	        return null;	    }	    final int strLen = str.length();	    if (strLen < 2) {	        return EMPTY;	    }	    final int lastIdx = strLen - 1;	    final String ret = str.substring(0, lastIdx);	    final char last = str.charAt(lastIdx);	    if (last == CharUtils.LF && ret.charAt(lastIdx - 1) == CharUtils.CR) {	        return ret.substring(0, lastIdx - 1);	    }	    return ret;	}
@Override	public int previousIndex() {	    return tokenPos - 1;	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
protected String getArraySeparator() {	    return arraySeparator;	}
public static Boolean or(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
@Override	public StringBuffer format(final Calendar calendar, final StringBuffer buf) {	    return printer.format(calendar, buf);	}
public final synchronized void setExternalExecutor(final ExecutorService externalExecutor) {	    if (isStarted()) {	        throw new IllegalStateException("Cannot set ExecutorService after start()!");	    }	    this.externalExecutor = externalExecutor;	}
public static Boolean[] toObject(final boolean[] array) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    final Boolean[] result = new Boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        result[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE);	    }	    return result;	}
public static boolean isNotTrue(final Boolean bool) {	    return !isTrue(bool);	}
public static ConcurrentRuntimeException extractCauseUnchecked(final ExecutionException ex) {	    if (ex == null || ex.getCause() == null) {	        return null;	    }	    throwCause(ex);	    return new ConcurrentRuntimeException(ex.getMessage(), ex.getCause());	}
@Override	public float floatValue() {	    return (float) numerator / (float) denominator;	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) {	    if (it != null) {	        separator = ObjectUtils.toString(separator);	        while (it.hasNext()) {	            append(it.next());	            if (it.hasNext()) {	                append(separator);	            }	        }	    }	    return this;	}
public int size() {	    return size;	}
public int size() {	    return size;	}
protected boolean isFieldSeparatorAtEnd() {	    return fieldSeparatorAtEnd;	}
public String getNewLineText() {	    return newLine;	}
public int lastIndexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex >= size ? size - 1 : startIndex);	    if (matcher == null || startIndex < 0) {	        return -1;	    }	    final char[] buf = buffer;	    final int endIndex = startIndex + 1;	    for (int i = startIndex; i >= 0; i--) {	        if (matcher.isMatch(buf, i, 0, endIndex) > 0) {	            return i;	        }	    }	    return -1;	}
public String getNullText() {	    return nullText;	}
public static boolean[] clone(final boolean[] array) {	    if (array == null) {	        return null;	    }	    return array.clone();	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public synchronized boolean start() {	    if (!isStarted()) {	        ExecutorService tempExec;	        executor = getExternalExecutor();	        if (executor == null) {	            executor = tempExec = createExecutor();	        } else {	            tempExec = null;	        }	        future = executor.submit(createTask(tempExec));	        return true;	    }	    return false;	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public int indexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex < 0 ? 0 : startIndex);	    if (matcher == null || startIndex >= size) {	        return -1;	    }	    final int len = size;	    final char[] buf = buffer;	    for (int i = startIndex; i < len; i++) {	        if (matcher.isMatch(buf, i, startIndex, len) > 0) {	            return i;	        }	    }	    return -1;	}
public static String substringBetween(final String str, final String open, final String close) {	    if (str == null || open == null || close == null) {	        return null;	    }	    final int start = str.indexOf(open);	    if (start != INDEX_NOT_FOUND) {	        final int end = str.indexOf(close, start + open.length());	        if (end != INDEX_NOT_FOUND) {	            return str.substring(start + open.length(), end);	        }	    }	    return null;	}
public static char binaryToHexDigit(final boolean[] src, final int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    if (src.length > srcPos + 3 && src[srcPos + 3]) {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src[srcPos]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
@Deprecated	public static String chomp(final String str, final String separator) {	    return removeEnd(str, separator);	}
protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    appendSummarySize(buffer, fieldName, array.length);	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public StrBuilder replaceAll(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, -1);	}
public int size() {	    return size;	}
public StrBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar) {	    return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);	}
@Override	public void mark(final int readAheadLimit) {	    mark = pos;	}
protected boolean isFieldSeparatorAtEnd() {	    return fieldSeparatorAtEnd;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
@Override	public List<Object> getContextValues(final String label) {	    return this.exceptionContext.getContextValues(label);	}
@Override	public int hashCode() {	    return value;	}
public String midString(int index, final int length) {	    if (index < 0) {	        index = 0;	    }	    if (length <= 0 || index >= size) {	        return "";	    }	    if (size <= index + length) {	        return new String(buffer, index, size - index);	    }	    return new String(buffer, index, length);	}
public static boolean containsIgnoreCase(final CharSequence str, final CharSequence searchStr) {	    if (str == null || searchStr == null) {	        return false;	    }	    final int len = searchStr.length();	    final int max = str.length() - len;	    for (int i = 0; i <= max; i++) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, len)) {	            return true;	        }	    }	    return false;	}
public boolean contains(final StrMatcher matcher) {	    return indexOf(matcher, 0) >= 0;	}
public char getStart() {	    return this.start;	}
public static boolean startsWithIgnoreCase(final CharSequence str, final CharSequence prefix) {	    return startsWith(str, prefix, true);	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
public String getNullText() {	    return nullText;	}
@Override	public void flush() {	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public String getNewLineText() {	    return newLine;	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer) {	    if (throwable == null) {	        return;	    }	    if (writer == null) {	        throw new IllegalArgumentException("The PrintWriter must not be null");	    }	    final String[] trace = getRootCauseStackTrace(throwable);	    for (final String element : trace) {	        writer.println(element);	    }	    writer.flush();	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
protected int getTaskCount() {	    return 1;	}
public static String replaceChars(final String str, final String searchChars, String replaceChars) {	    if (isEmpty(str) || isEmpty(searchChars)) {	        return str;	    }	    if (replaceChars == null) {	        replaceChars = EMPTY;	    }	    boolean modified = false;	    final int replaceCharsLength = replaceChars.length();	    final int strLength = str.length();	    final StringBuilder buf = new StringBuilder(strLength);	    for (int i = 0; i < strLength; i++) {	        final char ch = str.charAt(i);	        final int index = searchChars.indexOf(ch);	        if (index >= 0) {	            modified = true;	            if (index < replaceCharsLength) {	                buf.append(replaceChars.charAt(index));	            }	        } else {	            buf.append(ch);	        }	    }	    if (modified) {	        return buf.toString();	    }	    return str;	}
public static String chop(final String str) {	    if (str == null) {	        return null;	    }	    final int strLen = str.length();	    if (strLen < 2) {	        return EMPTY;	    }	    final int lastIdx = strLen - 1;	    final String ret = str.substring(0, lastIdx);	    final char last = str.charAt(lastIdx);	    if (last == CharUtils.LF && ret.charAt(lastIdx - 1) == CharUtils.CR) {	        return ret.substring(0, lastIdx - 1);	    }	    return ret;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
protected boolean isFieldSeparatorAtStart() {	    return fieldSeparatorAtStart;	}
public static String removeStart(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.startsWith(remove)) {	        return str.substring(remove.length());	    }	    return str;	}
public static String trim(final String str) {	    return str == null ? null : str.trim();	}
public static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) {	    if (0 == nBools) {	        return dst;	    }	    if (nBools - 1 + srcPos >= 64) {	        throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 64");	    }	    int shift = 0;	    for (int i = 0; i < nBools; i++) {	        shift = i * 1 + srcPos;	        dst[dstPos + i] = ((0x1 & (src >> shift)) != 0);	    }	    return dst;	}
public void add(final Number operand) {	    this.value += operand.floatValue();	}
@Override	public String toPattern() {	    return toPattern;	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
static boolean isRegistered(final Object lhs, final Object rhs) {	    final Set<Pair<IDKey, IDKey>> registry = getRegistry();	    final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);	    final Pair<IDKey, IDKey> swappedPair = Pair.of(pair.getLeft(), pair.getRight());	    return registry != null && (registry.contains(pair) || registry.contains(swappedPair));	}
public StrBuilder appendPadding(final int length, final char padChar) {	    if (length >= 0) {	        ensureCapacity(size + length);	        for (int i = 0; i < length; i++) {	            buffer[size++] = padChar;	        }	    }	    return this;	}
public boolean isBefore(final T element) {	    if (element == null) {	        return false;	    }	    return comparator.compare(element, maximum) > 0;	}
protected String getSizeEndText() {	    return sizeEndText;	}
public StringBuilder toStringBuilder() {	    return new StringBuilder(size).append(buffer, 0, size);	}
public int capacity() {	    return buffer.length;	}
public String getNewLineText() {	    return newLine;	}
@Override	public String getPattern() {	    return pattern;	}
public synchronized boolean start() {	    if (!isStarted()) {	        ExecutorService tempExec;	        executor = getExternalExecutor();	        if (executor == null) {	            executor = tempExec = createExecutor();	        } else {	            tempExec = null;	        }	        future = executor.submit(createTask(tempExec));	        return true;	    }	    return false;	}
public static <T> Range<T> is(final T element, final Comparator<T> comparator) {	    return between(element, element, comparator);	}
public StringBuilder toStringBuilder() {	    return new StringBuilder(size).append(buffer, 0, size);	}
public static boolean isEmpty(final CharSequence cs) {	    return cs == null || cs.length() == 0;	}
public void add(final Number operand) {	    this.value += operand.byteValue();	}
public String getNullText() {	    return nullText;	}
public static float min(final float a, final float b, final float c) {	    return Math.min(Math.min(a, b), c);	}
public static double[] addAll(final double[] array1, final double... array2) {	    if (array1 == null) {	        return clone(array2);	    } else if (array2 == null) {	        return clone(array1);	    }	    final double[] joinedArray = new double[array1.length + array2.length];	    System.arraycopy(array1, 0, joinedArray, 0, array1.length);	    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);	    return joinedArray;	}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    buffer.append(arrayStart);	    for (int i = 0; i < array.length; i++) {	        if (i > 0) {	            buffer.append(arraySeparator);	        }	        appendDetail(buffer, fieldName, array[i]);	    }	    buffer.append(arrayEnd);	}
private static String[] splitByCharacterType(final String str, final boolean camelCase) {	    if (str == null) {	        return null;	    }	    if (str.isEmpty()) {	        return ArrayUtils.EMPTY_STRING_ARRAY;	    }	    final char[] c = str.toCharArray();	    final List<String> list = new ArrayList<String>();	    int tokenStart = 0;	    int currentType = Character.getType(c[tokenStart]);	    for (int pos = tokenStart + 1; pos < c.length; pos++) {	        final int type = Character.getType(c[pos]);	        if (type == currentType) {	            continue;	        }	        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {	            final int newTokenStart = pos - 1;	            if (newTokenStart != tokenStart) {	                list.add(new String(c, tokenStart, newTokenStart - tokenStart));	                tokenStart = newTokenStart;	            }	        } else {	            list.add(new String(c, tokenStart, pos - tokenStart));	            tokenStart = pos;	        }	        currentType = type;	    }	    list.add(new String(c, tokenStart, c.length - tokenStart));	    return list.toArray(new String[list.size()]);	}
static Token[] lexx(final String format) {	    final char[] array = format.toCharArray();	    final ArrayList<Token> list = new ArrayList<Token>(array.length);	    boolean inLiteral = false;	    StringBuilder buffer = null;	    Token previous = null;	    final int sz = array.length;	    for (int i = 0; i < sz; i++) {	        final char ch = array[i];	        if (inLiteral && ch != '\'') {	            buffer.append(ch);	            continue;	        }	        Object value = null;	        switch(ch) {	            case '\'':	                if (inLiteral) {	                    buffer = null;	                    inLiteral = false;	                } else {	                    buffer = new StringBuilder();	                    list.add(new Token(buffer));	                    inLiteral = true;	                }	                break;	            case 'y':	                value = y;	                break;	            case 'M':	                value = M;	                break;	            case 'd':	                value = d;	                break;	            case 'H':	                value = H;	                break;	            case 'm':	                value = m;	                break;	            case 's':	                value = s;	                break;	            case 'S':	                value = S;	                break;	            default:	                if (buffer == null) {	                    buffer = new StringBuilder();	                    list.add(new Token(buffer));	                }	                buffer.append(ch);	        }	        if (value != null) {	            if (previous != null && previous.getValue() == value) {	                previous.increment();	            } else {	                final Token token = new Token(value);	                list.add(token);	                previous = token;	            }	            buffer = null;	        }	    }	    return list.toArray(new Token[list.size()]);	}
public static boolean isEquals(final Object array1, final Object array2) {	    return new EqualsBuilder().append(array1, array2).isEquals();	}
public int capacity() {	    return buffer.length;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public boolean endsWith(final String str) {	    if (str == null) {	        return false;	    }	    final int len = str.length();	    if (len == 0) {	        return true;	    }	    if (len > size) {	        return false;	    }	    int pos = size - len;	    for (int i = 0; i < len; i++, pos++) {	        if (buffer[pos] != str.charAt(i)) {	            return false;	        }	    }	    return true;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public int toComparison() {	    return comparison;	}
protected String getContentStart() {	    return contentStart;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array) {	    buffer.append(arrayStart);	    final int length = Array.getLength(array);	    for (int i = 0; i < length; i++) {	        final Object item = Array.get(array, i);	        if (i > 0) {	            buffer.append(arraySeparator);	        }	        if (item == null) {	            appendNullText(buffer, fieldName);	        } else {	            appendInternal(buffer, fieldName, item, arrayContentDetail);	        }	    }	    buffer.append(arrayEnd);	}
@Override	public TimeZone getTimeZone() {	    return timeZone;	}
public static Type[] getImplicitUpperBounds(final WildcardType wildcardType) {	    final Type[] bounds = wildcardType.getUpperBounds();	    return bounds.length == 0 ? new Type[] { Object.class } : normalizeUpperBounds(bounds);	}
public HashCodeBuilder append(final short[] array) {	    if (array == null) {	        iTotal = iTotal * iConstant;	    } else {	        for (final short element : array) {	            append(element);	        }	    }	    return this;	}
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] result = new boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        final Boolean b = array[i];	        result[i] = (b == null ? valueForNull : b.booleanValue());	    }	    return result;	}
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) {	    style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));	    return this;	}
@Override	public boolean equals(final Object obj) {	    return obj instanceof MutableDouble && Double.doubleToLongBits(((MutableDouble) obj).value) == Double.doubleToLongBits(value);	}
public static Object invokeMethod(final Object object, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {	    if (parameterTypes == null) {	        parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;	    }	    if (args == null) {	        args = ArrayUtils.EMPTY_OBJECT_ARRAY;	    }	    final Method method = getMatchingAccessibleMethod(object.getClass(), methodName, parameterTypes);	    if (method == null) {	        throw new NoSuchMethodException("No such accessible method: " + methodName + "() on object: " + object.getClass().getName());	    }	    return method.invoke(object, args);	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public static int toIntValue(final Character ch, final int defaultValue) {	    if (ch == null) {	        return defaultValue;	    }	    return toIntValue(ch.charValue(), defaultValue);	}
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) {	    style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));	    return this;	}
public static <T extends CharSequence> T validIndex(final T chars, final int index) {	    return validIndex(chars, index, DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE, Integer.valueOf(index));	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
@Override	public int compare(final Object obj1, final Object obj2) {	    return ((Comparable) obj1).compareTo(obj2);	}
public StrBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar) {	    return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);	}
public StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, 1);	}
public StrBuilder minimizeCapacity() {	    if (buffer.length > length()) {	        final char[] old = buffer;	        buffer = new char[length()];	        System.arraycopy(old, 0, buffer, 0, size);	    }	    return this;	}
public static boolean isAsciiPrintable(final char ch) {	    return ch >= 32 && ch < 127;	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {	    if (array == null) {	        if (index != 0) {	            throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0");	        }	        final Object joinedArray = Array.newInstance(clss, 1);	        Array.set(joinedArray, 0, element);	        return joinedArray;	    }	    final int length = Array.getLength(array);	    if (index > length || index < 0) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(clss, length + 1);	    System.arraycopy(array, 0, result, 0, index);	    Array.set(result, index, element);	    if (index < length) {	        System.arraycopy(array, index, result, index + 1, length - index);	    }	    return result;	}
public static String center(String str, final int size, String padStr) {	    if (str == null || size <= 0) {	        return str;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    str = leftPad(str, strLen + pads / 2, padStr);	    str = rightPad(str, size, padStr);	    return str;	}
public boolean contains(final StrMatcher matcher) {	    return indexOf(matcher, 0) >= 0;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static String unicodeEscaped(final Character ch) {	    if (ch == null) {	        return null;	    }	    return unicodeEscaped(ch.charValue());	}
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) {	    final StringBuilder buffer = new StringBuilder();	    boolean lastOutputSeconds = false;	    final int sz = tokens.length;	    for (int i = 0; i < sz; i++) {	        final Token token = tokens[i];	        final Object value = token.getValue();	        final int count = token.getCount();	        if (value instanceof StringBuilder) {	            buffer.append(value.toString());	        } else {	            if (value == y) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years));	                lastOutputSeconds = false;	            } else if (value == M) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months));	                lastOutputSeconds = false;	            } else if (value == d) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days));	                lastOutputSeconds = false;	            } else if (value == H) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours));	                lastOutputSeconds = false;	            } else if (value == m) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes));	                lastOutputSeconds = false;	            } else if (value == s) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds));	                lastOutputSeconds = true;	            } else if (value == S) {	                if (lastOutputSeconds) {	                    milliseconds += 1000;	                    final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds);	                    buffer.append(str.substring(1));	                } else {	                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds));	                }	                lastOutputSeconds = false;	            }	        }	    }	    return buffer.toString();	}
public static String wrap(final String str, int wrapLength, String newLineStr, final boolean wrapLongWords) {	    if (str == null) {	        return null;	    }	    if (newLineStr == null) {	        newLineStr = SystemUtils.LINE_SEPARATOR;	    }	    if (wrapLength < 1) {	        wrapLength = 1;	    }	    final int inputLineLength = str.length();	    int offset = 0;	    final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32);	    while (inputLineLength - offset > wrapLength) {	        if (str.charAt(offset) == ' ') {	            offset++;	            continue;	        }	        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);	        if (spaceToWrapAt >= offset) {	            wrappedLine.append(str.substring(offset, spaceToWrapAt));	            wrappedLine.append(newLineStr);	            offset = spaceToWrapAt + 1;	        } else {	            if (wrapLongWords) {	                wrappedLine.append(str.substring(offset, wrapLength + offset));	                wrappedLine.append(newLineStr);	                offset += wrapLength;	            } else {	                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);	                if (spaceToWrapAt >= 0) {	                    wrappedLine.append(str.substring(offset, spaceToWrapAt));	                    wrappedLine.append(newLineStr);	                    offset = spaceToWrapAt + 1;	                } else {	                    wrappedLine.append(str.substring(offset));	                    offset = inputLineLength;	                }	            }	        }	    }	    wrappedLine.append(str.substring(offset));	    return wrappedLine.toString();	}
@Override	public String getFormattedExceptionMessage(final String baseMessage) {	    return exceptionContext.getFormattedExceptionMessage(baseMessage);	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public boolean isEmpty() {	    return size == 0;	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static boolean isTrue(final Boolean bool) {	    return Boolean.TRUE.equals(bool);	}
private static Date set(final Date date, final int calendarField, final int amount) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final Calendar c = Calendar.getInstance();	    c.setLenient(false);	    c.setTime(date);	    c.set(calendarField, amount);	    return c.getTime();	}
public static String repeat(final char ch, final int repeat) {	    final char[] buf = new char[repeat];	    for (int i = repeat - 1; i >= 0; i--) {	        buf[i] = ch;	    }	    return new String(buf);	}
public boolean contains(final StrMatcher matcher) {	    return indexOf(matcher, 0) >= 0;	}
public static int indexOfAnyBut(final CharSequence seq, final CharSequence searchChars) {	    if (isEmpty(seq) || isEmpty(searchChars)) {	        return INDEX_NOT_FOUND;	    }	    final int strLen = seq.length();	    for (int i = 0; i < strLen; i++) {	        final char ch = seq.charAt(i);	        final boolean chFound = CharSequenceUtils.indexOf(searchChars, ch, 0) >= 0;	        if (i + 1 < strLen && Character.isHighSurrogate(ch)) {	            final char ch2 = seq.charAt(i + 1);	            if (chFound && CharSequenceUtils.indexOf(searchChars, ch2, 0) < 0) {	                return i;	            }	        } else {	            if (!chFound) {	                return i;	            }	        }	    }	    return INDEX_NOT_FOUND;	}
public static int hexDigitMsb0ToInt(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return 0x0;	        case '1':	            return 0x8;	        case '2':	            return 0x4;	        case '3':	            return 0xC;	        case '4':	            return 0x2;	        case '5':	            return 0xA;	        case '6':	            return 0x6;	        case '7':	            return 0xE;	        case '8':	            return 0x1;	        case '9':	            return 0x9;	        case 'a':	        case 'A':	            return 0x5;	        case 'b':	        case 'B':	            return 0xD;	        case 'c':	        case 'C':	            return 0x3;	        case 'd':	        case 'D':	            return 0xB;	        case 'e':	        case 'E':	            return 0x7;	        case 'f':	        case 'F':	            return 0xF;	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
@Override	protected MultiBackgroundInitializerResults initialize() throws Exception {	    Map<String, BackgroundInitializer<?>> inits;	    synchronized (this) {	        inits = new HashMap<String, BackgroundInitializer<?>>(childInitializers);	    }	    final ExecutorService exec = getActiveExecutor();	    for (final BackgroundInitializer<?> bi : inits.values()) {	        if (bi.getExternalExecutor() == null) {	            bi.setExternalExecutor(exec);	        }	        bi.start();	    }	    final Map<String, Object> results = new HashMap<String, Object>();	    final Map<String, ConcurrentException> excepts = new HashMap<String, ConcurrentException>();	    for (final Map.Entry<String, BackgroundInitializer<?>> e : inits.entrySet()) {	        try {	            results.put(e.getKey(), e.getValue().get());	        } catch (final ConcurrentException cex) {	            excepts.put(e.getKey(), cex);	        }	    }	    return new MultiBackgroundInitializerResults(inits, results, excepts);	}
public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) {	    if (it != null) {	        separator = ObjectUtils.toString(separator);	        while (it.hasNext()) {	            append(it.next());	            if (it.hasNext()) {	                append(separator);	            }	        }	    }	    return this;	}
public static boolean isAscii(final char ch) {	    return ch < 128;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
@Override	public void write(final String str, final int off, final int len) {	    StrBuilder.this.append(str, off, len);	}
protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    appendSummarySize(buffer, fieldName, array.length);	}
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] result = new boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        final Boolean b = array[i];	        result[i] = (b == null ? valueForNull : b.booleanValue());	    }	    return result;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public StrBuilder setLength(final int length) {	    if (length < 0) {	        throw new StringIndexOutOfBoundsException(length);	    }	    if (length < size) {	        size = length;	    } else if (length > size) {	        ensureCapacity(length);	        final int oldEnd = size;	        final int newEnd = length;	        size = length;	        for (int i = oldEnd; i < newEnd; i++) {	            buffer[i] = '\0';	        }	    }	    return this;	}
public StrBuilder deleteFirst(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, 1);	}
public static boolean isAlphaSpace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false && cs.charAt(i) != ' ') {	            return false;	        }	    }	    return true;	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
@Override	public void write(final String str, final int off, final int len) {	    StrBuilder.this.append(str, off, len);	}
@Override	public int length() {	    return size;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public String leftString(final int length) {	    if (length <= 0) {	        return "";	    } else if (length >= size) {	        return new String(buffer, 0, size);	    } else {	        return new String(buffer, 0, length);	    }	}
@Override	public void write(final String str, final int off, final int len) {	    StrBuilder.this.append(str, off, len);	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
protected boolean isUseIdentityHashCode() {	    return useIdentityHashCode;	}
public static String leftPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return leftPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return padStr.concat(str);	    } else if (pads < padLen) {	        return padStr.substring(0, pads).concat(str);	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return new String(padding).concat(str);	    }	}
public synchronized boolean isShutdown() {	    return shutdown;	}
public long getTime() {	    return getNanoTime() / NANO_2_MILLIS;	}
public static String replacePattern(final String source, final String regex, final String replacement) {	    return Pattern.compile(regex, Pattern.DOTALL).matcher(source).replaceAll(replacement);	}
@Override	public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) {	    return buffer[pos] <= 32 ? 1 : 0;	}
public boolean isSet(final int holder) {	    return (holder & _mask) != 0;	}
public int capacity() {	    return buffer.length;	}
public int size() {	    return size;	}
@Override	public String next() {	    if (hasNext()) {	        return tokens[tokenPos++];	    }	    throw new NoSuchElementException();	}
public static String right(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(str.length() - len);	}
public int size() {	    return size;	}
public int lastIndexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex >= size ? size - 1 : startIndex);	    if (matcher == null || startIndex < 0) {	        return -1;	    }	    final char[] buf = buffer;	    final int endIndex = startIndex + 1;	    for (int i = startIndex; i >= 0; i--) {	        if (matcher.isMatch(buf, i, 0, endIndex) > 0) {	            return i;	        }	    }	    return -1;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static boolean isSameLength(final boolean[] array1, final boolean[] array2) {	    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {	        return false;	    }	    return true;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public void add(final Number operand) {	    this.value += operand.intValue();	}
protected String getArrayStart() {	    return arrayStart;	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
public static final String escapeCsv(final String input) {	    return ESCAPE_CSV.translate(input);	}
public static String toString(final boolean bool, final String trueString, final String falseString) {	    return bool ? trueString : falseString;	}
public static CharRange is(final char ch) {	    return new CharRange(ch, ch, false);	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
@Override	public int previousIndex() {	    return tokenPos - 1;	}
private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase) {	    if (str == null || prefix == null) {	        return str == null && prefix == null;	    }	    if (prefix.length() > str.length()) {	        return false;	    }	    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());	}
protected String getSummaryObjectStartText() {	    return summaryObjectStartText;	}
public boolean isEquals() {	    return this.isEquals;	}
@Override	public int compare(final Object obj1, final Object obj2) {	    return ((Comparable) obj1).compareTo(obj2);	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static int indexOfDifference(final CharSequence... css) {	    if (css == null || css.length <= 1) {	        return INDEX_NOT_FOUND;	    }	    boolean anyStringNull = false;	    boolean allStringsNull = true;	    final int arrayLen = css.length;	    int shortestStrLen = Integer.MAX_VALUE;	    int longestStrLen = 0;	    for (int i = 0; i < arrayLen; i++) {	        if (css[i] == null) {	            anyStringNull = true;	            shortestStrLen = 0;	        } else {	            allStringsNull = false;	            shortestStrLen = Math.min(css[i].length(), shortestStrLen);	            longestStrLen = Math.max(css[i].length(), longestStrLen);	        }	    }	    if (allStringsNull || longestStrLen == 0 && !anyStringNull) {	        return INDEX_NOT_FOUND;	    }	    if (shortestStrLen == 0) {	        return 0;	    }	    int firstDiff = -1;	    for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {	        final char comparisonChar = css[0].charAt(stringPos);	        for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {	            if (css[arrayPos].charAt(stringPos) != comparisonChar) {	                firstDiff = stringPos;	                break;	            }	        }	        if (firstDiff != -1) {	            break;	        }	    }	    if (firstDiff == -1 && shortestStrLen != longestStrLen) {	        return shortestStrLen;	    }	    return firstDiff;	}
public static <T extends CharSequence> T notEmpty(final T chars) {	    return notEmpty(chars, DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE);	}
public static String repeat(final char ch, final int repeat) {	    final char[] buf = new char[repeat];	    for (int i = repeat - 1; i >= 0; i--) {	        buf[i] = ch;	    }	    return new String(buf);	}
public boolean isEquals() {	    return this.isEquals;	}
public String getNewLineText() {	    return newLine;	}
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException {	    return charsetName == null ? new String(bytes) : new String(bytes, charsetName);	}
public static String abbreviateMiddle(final String str, final String middle, final int length) {	    if (isEmpty(str) || isEmpty(middle)) {	        return str;	    }	    if (length >= str.length() || length < middle.length() + 2) {	        return str;	    }	    final int targetSting = length - middle.length();	    final int startOffset = targetSting / 2 + targetSting % 2;	    final int endOffset = str.length() - targetSting / 2;	    final StringBuilder builder = new StringBuilder(length);	    builder.append(str.substring(0, startOffset));	    builder.append(middle);	    builder.append(str.substring(endOffset));	    return builder.toString();	}
public void increment() {	    value++;	}
public String getNullText() {	    return nullText;	}
public static boolean isAlphanumeric(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetterOrDigit(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) {	    if (str == null) {	        if (trueString == null) {	            return Boolean.TRUE;	        }	        if (falseString == null) {	            return Boolean.FALSE;	        }	        if (nullString == null) {	            return null;	        }	    } else if (str.equals(trueString)) {	        return Boolean.TRUE;	    } else if (str.equals(falseString)) {	        return Boolean.FALSE;	    } else if (str.equals(nullString)) {	        return null;	    }	    throw new IllegalArgumentException("The String did not match any specified value");	}
public boolean isAppendStatics() {	    return this.appendStatics;	}
public static void reverse(final boolean[] array) {	    if (array == null) {	        return;	    }	    int i = 0;	    int j = array.length - 1;	    boolean tmp;	    while (j > i) {	        tmp = array[j];	        array[j] = array[i];	        array[i] = tmp;	        j--;	        i++;	    }	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public int indexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex < 0 ? 0 : startIndex);	    if (matcher == null || startIndex >= size) {	        return -1;	    }	    final int len = size;	    final char[] buf = buffer;	    for (int i = startIndex; i < len; i++) {	        if (matcher.isMatch(buf, i, startIndex, len) > 0) {	            return i;	        }	    }	    return -1;	}
public static Boolean or(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
public static char binaryToHexDigit(final boolean[] src, final int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    if (src.length > srcPos + 3 && src[srcPos + 3]) {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src[srcPos]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
protected void validateIndex(final int index) {	    if (index < 0 || index > size) {	        throw new StringIndexOutOfBoundsException(index);	    }	}
public static String substringBefore(final String str, final String separator) {	    if (isEmpty(str) || separator == null) {	        return str;	    }	    if (separator.isEmpty()) {	        return EMPTY;	    }	    final int pos = str.indexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return str;	    }	    return str.substring(0, pos);	}
public static <T> String reflectionToString(final T object, final ToStringStyle style, final boolean outputTransients, final Class<? super T> reflectUpToClass) {	    return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass);	}
public static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts) {	    if ((src.length == 0 && srcPos == 0) || 0 == nShorts) {	        return dstInit;	    }	    if ((nShorts - 1) * 16 + dstPos >= 64) {	        throw new IllegalArgumentException("(nShorts-1)*16+dstPos is greather or equal to than 64");	    }	    long out = dstInit;	    int shift = 0;	    for (int i = 0; i < nShorts; i++) {	        shift = i * 16 + dstPos;	        final long bits = (0xffffL & src[i + srcPos]) << shift;	        final long mask = 0xffffL << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
private static String[] splitByCharacterType(final String str, final boolean camelCase) {	    if (str == null) {	        return null;	    }	    if (str.isEmpty()) {	        return ArrayUtils.EMPTY_STRING_ARRAY;	    }	    final char[] c = str.toCharArray();	    final List<String> list = new ArrayList<String>();	    int tokenStart = 0;	    int currentType = Character.getType(c[tokenStart]);	    for (int pos = tokenStart + 1; pos < c.length; pos++) {	        final int type = Character.getType(c[pos]);	        if (type == currentType) {	            continue;	        }	        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {	            final int newTokenStart = pos - 1;	            if (newTokenStart != tokenStart) {	                list.add(new String(c, tokenStart, newTokenStart - tokenStart));	                tokenStart = newTokenStart;	            }	        } else {	            list.add(new String(c, tokenStart, pos - tokenStart));	            tokenStart = pos;	        }	        currentType = type;	    }	    list.add(new String(c, tokenStart, c.length - tokenStart));	    return list.toArray(new String[list.size()]);	}
public char getStart() {	    return this.start;	}
public StrBuilder appendSeparator(final char separator, final int loopIndex) {	    if (loopIndex > 0) {	        append(separator);	    }	    return this;	}
@Override	public BasicThreadFactory build() {	    final BasicThreadFactory factory = new BasicThreadFactory(this);	    reset();	    return factory;	}
public static boolean isEmpty(final CharSequence cs) {	    return cs == null || cs.length() == 0;	}
public int indexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex < 0 ? 0 : startIndex);	    if (matcher == null || startIndex >= size) {	        return -1;	    }	    final int len = size;	    final char[] buf = buffer;	    for (int i = startIndex; i < len; i++) {	        if (matcher.isMatch(buf, i, startIndex, len) > 0) {	            return i;	        }	    }	    return -1;	}
public static boolean isBlank(final CharSequence cs) {	    int strLen;	    if (cs == null || (strLen = cs.length()) == 0) {	        return true;	    }	    for (int i = 0; i < strLen; i++) {	        if (Character.isWhitespace(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
@Override	public String build() {	    return toString();	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException {	    return parseDateWithLeniency(str, null, parsePatterns, false);	}
@Override	public TimeZone getTimeZone() {	    return mTimeZone;	}
@Override	public boolean isDone() {	    return true;	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public boolean isEmpty() {	    return size == 0;	}
public StrTokenizer setDelimiterChar(final char delim) {	    return setDelimiterMatcher(StrMatcher.charMatcher(delim));	}
public static String substringBetween(final String str, final String open, final String close) {	    if (str == null || open == null || close == null) {	        return null;	    }	    final int start = str.indexOf(open);	    if (start != INDEX_NOT_FOUND) {	        final int end = str.indexOf(close, start + open.length());	        if (end != INDEX_NOT_FOUND) {	            return str.substring(start + open.length(), end);	        }	    }	    return null;	}
public String getNewLineText() {	    return newLine;	}
static JavaVersion get(final String nom) {	    if ("0.9".equals(nom)) {	        return JAVA_0_9;	    } else if ("1.1".equals(nom)) {	        return JAVA_1_1;	    } else if ("1.2".equals(nom)) {	        return JAVA_1_2;	    } else if ("1.3".equals(nom)) {	        return JAVA_1_3;	    } else if ("1.4".equals(nom)) {	        return JAVA_1_4;	    } else if ("1.5".equals(nom)) {	        return JAVA_1_5;	    } else if ("1.6".equals(nom)) {	        return JAVA_1_6;	    } else if ("1.7".equals(nom)) {	        return JAVA_1_7;	    } else if ("1.8".equals(nom)) {	        return JAVA_1_8;	    } else {	        return null;	    }	}
@Override	public float floatValue() {	    return value;	}
public int size() {	    return size;	}
public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) {	    final Token[] tokens = lexx(format);	    final Calendar start = Calendar.getInstance(timezone);	    start.setTime(new Date(startMillis));	    final Calendar end = Calendar.getInstance(timezone);	    end.setTime(new Date(endMillis));	    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);	    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);	    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);	    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);	    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);	    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);	    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);	    while (milliseconds < 0) {	        milliseconds += 1000;	        seconds -= 1;	    }	    while (seconds < 0) {	        seconds += 60;	        minutes -= 1;	    }	    while (minutes < 0) {	        minutes += 60;	        hours -= 1;	    }	    while (hours < 0) {	        hours += 24;	        days -= 1;	    }	    if (Token.containsTokenWithValue(tokens, M)) {	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	        while (months < 0) {	            months += 12;	            years -= 1;	        }	        if (!Token.containsTokenWithValue(tokens, y) && years != 0) {	            while (years != 0) {	                months += 12 * years;	                years = 0;	            }	        }	    } else {	        if (!Token.containsTokenWithValue(tokens, y)) {	            int target = end.get(Calendar.YEAR);	            if (months < 0) {	                target -= 1;	            }	            while (start.get(Calendar.YEAR) != target) {	                days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);	                if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) {	                    days += 1;	                }	                start.add(Calendar.YEAR, 1);	                days += start.get(Calendar.DAY_OF_YEAR);	            }	            years = 0;	        }	        while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            start.add(Calendar.MONTH, 1);	        }	        months = 0;	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	    }	    if (!Token.containsTokenWithValue(tokens, d)) {	        hours += 24 * days;	        days = 0;	    }	    if (!Token.containsTokenWithValue(tokens, H)) {	        minutes += 60 * hours;	        hours = 0;	    }	    if (!Token.containsTokenWithValue(tokens, m)) {	        seconds += 60 * minutes;	        minutes = 0;	    }	    if (!Token.containsTokenWithValue(tokens, s)) {	        milliseconds += 1000 * seconds;	        seconds = 0;	    }	    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
public String getNewLineText() {	    return newLine;	}
public static String center(String str, final int size, String padStr) {	    if (str == null || size <= 0) {	        return str;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    str = leftPad(str, strLen + pads / 2, padStr);	    str = rightPad(str, size, padStr);	    return str;	}
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) {	    style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));	    return this;	}
protected String getFieldSeparator() {	    return fieldSeparator;	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
public String midString(int index, final int length) {	    if (index < 0) {	        index = 0;	    }	    if (length <= 0 || index >= size) {	        return "";	    }	    if (size <= index + length) {	        return new String(buffer, index, size - index);	    }	    return new String(buffer, index, length);	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
Object getValue() {	    return value;	}
@Override	public int length() {	    return size;	}
protected String getArrayEnd() {	    return arrayEnd;	}
protected String getArraySeparator() {	    return arraySeparator;	}
public static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {	    if (str == null || searchStr == null) {	        return INDEX_NOT_FOUND;	    }	    if (startPos < 0) {	        startPos = 0;	    }	    final int endLimit = str.length() - searchStr.length() + 1;	    if (startPos > endLimit) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return startPos;	    }	    for (int i = startPos; i < endLimit; i++) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
public int size() {	    return size;	}
public StrBuilder reverse() {	    if (size == 0) {	        return this;	    }	    final int half = size / 2;	    final char[] buf = buffer;	    for (int leftIdx = 0, rightIdx = size - 1; leftIdx < half; leftIdx++, rightIdx--) {	        final char swap = buf[leftIdx];	        buf[leftIdx] = buf[rightIdx];	        buf[rightIdx] = swap;	    }	    return this;	}
public int size() {	    return size;	}
public boolean isEmpty() {	    return size == 0;	}
public static String toString(final Character ch) {	    if (ch == null) {	        return null;	    }	    return toString(ch.charValue());	}
public static <T> void exclusiveBetween(final T start, final T end, final Comparable<T> value, final String message, final Object... values) {	    if (value.compareTo(start) <= 0 || value.compareTo(end) >= 0) {	        throw new IllegalArgumentException(String.format(message, values));	    }	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public static boolean[] removeElements(final boolean[] array, final boolean... values) {	    if (isEmpty(array) || isEmpty(values)) {	        return clone(array);	    }	    final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2);	    for (final boolean v : values) {	        final Boolean boxed = Boolean.valueOf(v);	        final MutableInt count = occurrences.get(boxed);	        if (count == null) {	            occurrences.put(boxed, new MutableInt(1));	        } else {	            count.increment();	        }	    }	    final BitSet toRemove = new BitSet();	    for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) {	        final Boolean v = e.getKey();	        int found = 0;	        for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {	            found = indexOf(array, v.booleanValue(), found);	            if (found < 0) {	                break;	            }	            toRemove.set(found++);	        }	    }	    return (boolean[]) removeAll(array, toRemove);	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
public static String capitalize(final String str) {	    int strLen;	    if (str == null || (strLen = str.length()) == 0) {	        return str;	    }	    char firstChar = str.charAt(0);	    if (Character.isTitleCase(firstChar)) {	        return str;	    }	    return new StringBuilder(strLen).append(Character.toTitleCase(firstChar)).append(str.substring(1)).toString();	}
public static <T extends CharSequence> T defaultIfBlank(final T str, final T defaultStr) {	    return StringUtils.isBlank(str) ? defaultStr : str;	}
public static Fraction getReducedFraction(int numerator, int denominator) {	    if (denominator == 0) {	        throw new ArithmeticException("The denominator must not be zero");	    }	    if (numerator == 0) {	        return ZERO;	    }	    if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) {	        numerator /= 2;	        denominator /= 2;	    }	    if (denominator < 0) {	        if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {	            throw new ArithmeticException("overflow: can't negate");	        }	        numerator = -numerator;	        denominator = -denominator;	    }	    final int gcd = greatestCommonDivisor(numerator, denominator);	    numerator /= gcd;	    denominator /= gcd;	    return new Fraction(numerator, denominator);	}
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) {	    if (str == null) {	        if (trueString == null) {	            return Boolean.TRUE;	        }	        if (falseString == null) {	            return Boolean.FALSE;	        }	        if (nullString == null) {	            return null;	        }	    } else if (str.equals(trueString)) {	        return Boolean.TRUE;	    } else if (str.equals(falseString)) {	        return Boolean.FALSE;	    } else if (str.equals(nullString)) {	        return null;	    }	    throw new IllegalArgumentException("The String did not match any specified value");	}
@Override	public int length() {	    return size;	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
protected boolean isUseClassName() {	    return useClassName;	}
protected boolean isArrayContentDetail() {	    return arrayContentDetail;	}
public static int hexDigitMsb0ToInt(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return 0x0;	        case '1':	            return 0x8;	        case '2':	            return 0x4;	        case '3':	            return 0xC;	        case '4':	            return 0x2;	        case '5':	            return 0xA;	        case '6':	            return 0x6;	        case '7':	            return 0xE;	        case '8':	            return 0x1;	        case '9':	            return 0x9;	        case 'a':	        case 'A':	            return 0x5;	        case 'b':	        case 'B':	            return 0xD;	        case 'c':	        case 'C':	            return 0x3;	        case 'd':	        case 'D':	            return 0xB;	        case 'e':	        case 'E':	            return 0x7;	        case 'f':	        case 'F':	            return 0xF;	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public String getNullText() {	    return nullText;	}
public int capacity() {	    return buffer.length;	}
public synchronized void acquire() throws InterruptedException {	    if (isShutdown()) {	        throw new IllegalStateException("TimedSemaphore is shut down!");	    }	    if (task == null) {	        task = startTimer();	    }	    boolean canPass = false;	    do {	        canPass = getLimit() <= NO_LIMIT || acquireCount < getLimit();	        if (!canPass) {	            wait();	        } else {	            acquireCount++;	        }	    } while (!canPass);	}
public static String stripEnd(final String str, final String stripChars) {	    int end;	    if (str == null || (end = str.length()) == 0) {	        return str;	    }	    if (stripChars == null) {	        while (end != 0 && Character.isWhitespace(str.charAt(end - 1))) {	            end--;	        }	    } else if (stripChars.isEmpty()) {	        return str;	    } else {	        while (end != 0 && stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND) {	            end--;	        }	    }	    return str.substring(0, end);	}
public void start() {	    if (this.runningState == STATE_STOPPED) {	        throw new IllegalStateException("Stopwatch must be reset before being restarted. ");	    }	    if (this.runningState != STATE_UNSTARTED) {	        throw new IllegalStateException("Stopwatch already started. ");	    }	    this.startTime = System.nanoTime();	    this.startTimeMillis = System.currentTimeMillis();	    this.runningState = STATE_RUNNING;	}
@Override	public int length() {	    return size;	}
public void appendEnd(final StringBuffer buffer, final Object object) {	    if (this.fieldSeparatorAtEnd == false) {	        removeLastFieldSeparator(buffer);	    }	    appendContentEnd(buffer);	    unregister(object);	}
public String getNullText() {	    return nullText;	}
public void add(final Number operand) {	    this.value += operand.byteValue();	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
@Override	public int length() {	    return size;	}
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException {	    return charsetName == null ? new String(bytes) : new String(bytes, charsetName);	}
protected List<String> tokenize(final char[] chars, final int offset, final int count) {	    if (chars == null || count == 0) {	        return Collections.emptyList();	    }	    final StrBuilder buf = new StrBuilder();	    final List<String> tokens = new ArrayList<String>();	    int pos = offset;	    while (pos >= 0 && pos < count) {	        pos = readNextToken(chars, pos, count, buf, tokens);	        if (pos >= count) {	            addToken(tokens, "");	        }	    }	    return tokens;	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public static int reflectionHashCode(final Object object, final String... excludeFields) {	    return reflectionHashCode(17, 37, object, false, null, excludeFields);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public int size() {	    return size;	}
public static NumericEntityEscaper above(final int codepoint) {	    return outsideOf(0, codepoint);	}
public static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes) {	    if ((src.length == 0 && srcPos == 0) || 0 == nBytes) {	        return dstInit;	    }	    if ((nBytes - 1) * 8 + dstPos >= 32) {	        throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 32");	    }	    int out = dstInit;	    int shift = 0;	    for (int i = 0; i < nBytes; i++) {	        shift = i * 8 + dstPos;	        final int bits = (0xff & src[i + srcPos]) << shift;	        final int mask = 0xff << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
protected boolean isUseIdentityHashCode() {	    return useIdentityHashCode;	}
public void reset() {	    this.isEquals = true;	}
public static boolean startsWithIgnoreCase(final CharSequence str, final CharSequence prefix) {	    return startsWith(str, prefix, true);	}
public static float max(final float a, final float b, final float c) {	    return Math.max(Math.max(a, b), c);	}
static int lastIndexOf(final CharSequence cs, final CharSequence searchChar, final int start) {	    return cs.toString().lastIndexOf(searchChar.toString(), start);	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public boolean isIgnoreEmptyTokens() {	    return ignoreEmptyTokens;	}
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = Integer.MAX_VALUE;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.indexOf(str, search, 0);	        if (tmp == INDEX_NOT_FOUND) {	            continue;	        }	        if (tmp < ret) {	            ret = tmp;	        }	    }	    return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;	}
public boolean isEmpty() {	    return size == 0;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static Date truncate(final Object date, final int field) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (date instanceof Date) {	        return truncate((Date) date, field);	    } else if (date instanceof Calendar) {	        return truncate((Calendar) date, field).getTime();	    } else {	        throw new ClassCastException("Could not truncate " + date);	    }	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static int lastOrdinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal) {	    return ordinalIndexOf(str, searchStr, ordinal, true);	}
@Override	public boolean markSupported() {	    return true;	}
@Override	public boolean equals(final Object obj) {	    if (obj == this) {	        return true;	    } else if (obj == null || obj.getClass() != getClass()) {	        return false;	    } else {	        @SuppressWarnings("unchecked")	        final Range<T> range = (Range<T>) obj;	        return minimum.equals(range.minimum) && maximum.equals(range.maximum);	    }	}
public static String deleteWhitespace(final String str) {	    if (isEmpty(str)) {	        return str;	    }	    final int sz = str.length();	    final char[] chs = new char[sz];	    int count = 0;	    for (int i = 0; i < sz; i++) {	        if (!Character.isWhitespace(str.charAt(i))) {	            chs[count++] = str.charAt(i);	        }	    }	    if (count == sz) {	        return str;	    }	    return new String(chs, 0, count);	}
public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) {	    if (it != null) {	        separator = ObjectUtils.toString(separator);	        while (it.hasNext()) {	            append(it.next());	            if (it.hasNext()) {	                append(separator);	            }	        }	    }	    return this;	}
public static String replaceChars(final String str, final String searchChars, String replaceChars) {	    if (isEmpty(str) || isEmpty(searchChars)) {	        return str;	    }	    if (replaceChars == null) {	        replaceChars = EMPTY;	    }	    boolean modified = false;	    final int replaceCharsLength = replaceChars.length();	    final int strLength = str.length();	    final StringBuilder buf = new StringBuilder(strLength);	    for (int i = 0; i < strLength; i++) {	        final char ch = str.charAt(i);	        final int index = searchChars.indexOf(ch);	        if (index >= 0) {	            modified = true;	            if (index < replaceCharsLength) {	                buf.append(replaceChars.charAt(index));	            }	        } else {	            buf.append(ch);	        }	    }	    if (modified) {	        return buf.toString();	    }	    return str;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public static String difference(final String str1, final String str2) {	    if (str1 == null) {	        return str2;	    }	    if (str2 == null) {	        return str1;	    }	    final int at = indexOfDifference(str1, str2);	    if (at == INDEX_NOT_FOUND) {	        return EMPTY;	    }	    return str2.substring(at);	}
public static void reverse(final boolean[] array) {	    if (array == null) {	        return;	    }	    int i = 0;	    int j = array.length - 1;	    boolean tmp;	    while (j > i) {	        tmp = array[j];	        array[j] = array[i];	        array[i] = tmp;	        j--;	        i++;	    }	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public int indexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex < 0 ? 0 : startIndex);	    if (matcher == null || startIndex >= size) {	        return -1;	    }	    final int len = size;	    final char[] buf = buffer;	    for (int i = startIndex; i < len; i++) {	        if (matcher.isMatch(buf, i, startIndex, len) > 0) {	            return i;	        }	    }	    return -1;	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public StrBuilder setLength(final int length) {	    if (length < 0) {	        throw new StringIndexOutOfBoundsException(length);	    }	    if (length < size) {	        size = length;	    } else if (length > size) {	        ensureCapacity(length);	        final int oldEnd = size;	        final int newEnd = length;	        size = length;	        for (int i = oldEnd; i < newEnd; i++) {	            buffer[i] = '\0';	        }	    }	    return this;	}
public static boolean startsWithAny(final CharSequence string, final CharSequence... searchStrings) {	    if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {	        return false;	    }	    for (final CharSequence searchString : searchStrings) {	        if (StringUtils.startsWith(string, searchString)) {	            return true;	        }	    }	    return false;	}
public static Class<?> primitiveToWrapper(final Class<?> cls) {	    Class<?> convertedClass = cls;	    if (cls != null && cls.isPrimitive()) {	        convertedClass = primitiveWrapperMap.get(cls);	    }	    return convertedClass;	}
public static boolean isAlpha(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public static String defaultString(final String str, final String defaultStr) {	    return str == null ? defaultStr : str;	}
public boolean isEmpty() {	    return size == 0;	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public StrBuilder replaceAll(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, -1);	}
protected boolean isUseShortClassName() {	    return useShortClassName;	}
public static <T> T cloneIfPossible(final T obj) {	    final T clone = clone(obj);	    return clone == null ? obj : clone;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
@Override	protected List<String> tokenize(final char[] chars, final int offset, final int count) {	    if (chars == null) {	        return super.tokenize(StrBuilder.this.buffer, 0, StrBuilder.this.size());	    }	    return super.tokenize(chars, offset, count);	}
@Override	public Integer build() {	    return Integer.valueOf(toHashCode());	}
public static Integer toIntegerObject(final Boolean bool, final Integer trueValue, final Integer falseValue, final Integer nullValue) {	    if (bool == null) {	        return nullValue;	    }	    return bool.booleanValue() ? trueValue : falseValue;	}
public int size() {	    return size;	}
public int capacity() {	    return buffer.length;	}
public static Number createNumber(final String str) throws NumberFormatException {	    if (str == null) {	        return null;	    }	    if (StringUtils.isBlank(str)) {	        throw new NumberFormatException("A blank string is not a valid number");	    }	    final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" };	    int pfxLen = 0;	    for (final String pfx : hex_prefixes) {	        if (str.startsWith(pfx)) {	            pfxLen += pfx.length();	            break;	        }	    }	    if (pfxLen > 0) {	        final int hexDigits = str.length() - pfxLen;	        if (hexDigits > 16) {	            return createBigInteger(str);	        }	        if (hexDigits > 8) {	            return createLong(str);	        }	        return createInteger(str);	    }	    final char lastChar = str.charAt(str.length() - 1);	    String mant;	    String dec;	    String exp;	    final int decPos = str.indexOf('.');	    final int expPos = str.indexOf('e') + str.indexOf('E') + 1;	    int numDecimals = 0;	    if (decPos > -1) {	        if (expPos > -1) {	            if (expPos < decPos || expPos > str.length()) {	                throw new NumberFormatException(str + " is not a valid number.");	            }	            dec = str.substring(decPos + 1, expPos);	        } else {	            dec = str.substring(decPos + 1);	        }	        mant = str.substring(0, decPos);	        numDecimals = dec.length();	    } else {	        if (expPos > -1) {	            if (expPos > str.length()) {	                throw new NumberFormatException(str + " is not a valid number.");	            }	            mant = str.substring(0, expPos);	        } else {	            mant = str;	        }	        dec = null;	    }	    if (!Character.isDigit(lastChar) && lastChar != '.') {	        if (expPos > -1 && expPos < str.length() - 1) {	            exp = str.substring(expPos + 1, str.length() - 1);	        } else {	            exp = null;	        }	        final String numeric = str.substring(0, str.length() - 1);	        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);	        switch(lastChar) {	            case 'l':	            case 'L':	                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {	                    try {	                        return createLong(numeric);	                    } catch (final NumberFormatException nfe) {	                    }	                    return createBigInteger(numeric);	                }	                throw new NumberFormatException(str + " is not a valid number.");	            case 'f':	            case 'F':	                try {	                    final Float f = NumberUtils.createFloat(numeric);	                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {	                        return f;	                    }	                } catch (final NumberFormatException nfe) {	                }	            case 'd':	            case 'D':	                try {	                    final Double d = NumberUtils.createDouble(numeric);	                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {	                        return d;	                    }	                } catch (final NumberFormatException nfe) {	                }	                try {	                    return createBigDecimal(numeric);	                } catch (final NumberFormatException e) {	                }	            default:	                throw new NumberFormatException(str + " is not a valid number.");	        }	    }	    if (expPos > -1 && expPos < str.length() - 1) {	        exp = str.substring(expPos + 1, str.length());	    } else {	        exp = null;	    }	    if (dec == null && exp == null) {	        try {	            return createInteger(str);	        } catch (final NumberFormatException nfe) {	        }	        try {	            return createLong(str);	        } catch (final NumberFormatException nfe) {	        }	        return createBigInteger(str);	    }	    final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);	    try {	        if (numDecimals <= 7) {	            final Float f = createFloat(str);	            if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {	                return f;	            }	        }	    } catch (final NumberFormatException nfe) {	    }	    try {	        if (numDecimals <= 16) {	            final Double d = createDouble(str);	            if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {	                return d;	            }	        }	    } catch (final NumberFormatException nfe) {	    }	    return createBigDecimal(str);	}
public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) {	    if (src.length > 8) {	        throw new IllegalArgumentException("src.length>8: src.length=" + src.length);	    }	    if (src.length - srcPos < 4) {	        throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos);	    }	    if (src[srcPos + 3]) {	        if (src[srcPos + 2]) {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return '7';	                }	            } else {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return '3';	                }	            }	        } else {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return '5';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '1';	                }	            }	        }	    } else {	        if (src[srcPos + 2]) {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'e';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return 'a';	                } else {	                    return '2';	                }	            }	        } else {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'c';	                } else {	                    return '4';	                }	            } else {	                if (src[srcPos]) {	                    return '8';	                } else {	                    return '0';	                }	            }	        }	    }	}
public static boolean isAsciiControl(final char ch) {	    return ch < 32 || ch == 127;	}
protected boolean isDefaultFullDetail() {	    return defaultFullDetail;	}
public char getStart() {	    return this.start;	}
public static boolean isNumeric(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isDigit(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static boolean isAllUpperCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isUpperCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public StrBuilder appendNull() {	    if (nullText == null) {	        return this;	    }	    return append(nullText);	}
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException {	    return charsetName == null ? new String(bytes) : new String(bytes, charsetName);	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    if (input.charAt(index) == '\\' && index + 1 < input.length() && input.charAt(index + 1) == 'u') {	        int i = 2;	        while (index + i < input.length() && input.charAt(index + i) == 'u') {	            i++;	        }	        if (index + i < input.length() && input.charAt(index + i) == '+') {	            i++;	        }	        if (index + i + 4 <= input.length()) {	            final CharSequence unicode = input.subSequence(index + i, index + i + 4);	            try {	                final int value = Integer.parseInt(unicode.toString(), 16);	                out.write((char) value);	            } catch (final NumberFormatException nfe) {	                throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe);	            }	            return i + 4;	        } else {	            throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + input.subSequence(index, input.length()) + "' due to end of CharSequence");	        }	    }	    return 0;	}
@Override	public void mark(final int readAheadLimit) {	    mark = pos;	}
public final Thread.UncaughtExceptionHandler getUncaughtExceptionHandler() {	    return uncaughtExceptionHandler;	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static <K, V> V createIfAbsent(final ConcurrentMap<K, V> map, final K key, final ConcurrentInitializer<V> init) throws ConcurrentException {	    if (map == null || init == null) {	        return null;	    }	    final V value = map.get(key);	    if (value == null) {	        return putIfAbsent(map, key, init.get());	    }	    return value;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public int capacity() {	    return buffer.length;	}
public static int countMatches(final CharSequence str, final CharSequence sub) {	    if (isEmpty(str) || isEmpty(sub)) {	        return 0;	    }	    int count = 0;	    int idx = 0;	    while ((idx = CharSequenceUtils.indexOf(str, sub, idx)) != INDEX_NOT_FOUND) {	        count++;	        idx += sub.length();	    }	    return count;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) {	    style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));	    return this;	}
public static void handleCause(final ExecutionException ex) throws ConcurrentException {	    final ConcurrentException cex = extractCause(ex);	    if (cex != null) {	        throw cex;	    }	}
public boolean isEmpty() {	    return size == 0;	}
private static boolean endsWith(final CharSequence str, final CharSequence suffix, final boolean ignoreCase) {	    if (str == null || suffix == null) {	        return str == null && suffix == null;	    }	    if (suffix.length() > str.length()) {	        return false;	    }	    final int strOffset = str.length() - suffix.length();	    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, suffix, 0, suffix.length());	}
public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) {	    if (s == null || t == null) {	        throw new IllegalArgumentException("Strings must not be null");	    }	    if (threshold < 0) {	        throw new IllegalArgumentException("Threshold must not be negative");	    }	    int n = s.length();	    int m = t.length();	    if (n == 0) {	        return m <= threshold ? m : -1;	    } else if (m == 0) {	        return n <= threshold ? n : -1;	    }	    if (n > m) {	        final CharSequence tmp = s;	        s = t;	        t = tmp;	        n = m;	        m = t.length();	    }	    int[] p = new int[n + 1];	    int[] d = new int[n + 1];	    int[] _d;	    final int boundary = Math.min(n, threshold) + 1;	    for (int i = 0; i < boundary; i++) {	        p[i] = i;	    }	    Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);	    Arrays.fill(d, Integer.MAX_VALUE);	    for (int j = 1; j <= m; j++) {	        final char t_j = t.charAt(j - 1);	        d[0] = j;	        final int min = Math.max(1, j - threshold);	        final int max = Math.min(n, j + threshold);	        if (min > max) {	            return -1;	        }	        if (min > 1) {	            d[min - 1] = Integer.MAX_VALUE;	        }	        for (int i = min; i <= max; i++) {	            if (s.charAt(i - 1) == t_j) {	                d[i] = p[i - 1];	            } else {	                d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);	            }	        }	        _d = p;	        p = d;	        d = _d;	    }	    if (p[n] <= threshold) {	        return p[n];	    }	    return -1;	}
protected boolean isDefaultFullDetail() {	    return defaultFullDetail;	}
public StrTokenizer setQuoteMatcher(final StrMatcher quote) {	    if (quote != null) {	        this.quoteMatcher = quote;	    }	    return this;	}
public static String mid(final String str, int pos, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0 || pos > str.length()) {	        return EMPTY;	    }	    if (pos < 0) {	        pos = 0;	    }	    if (str.length() <= pos + len) {	        return str.substring(pos);	    }	    return str.substring(pos, pos + len);	}
public static String upperCase(final String str, final Locale locale) {	    if (str == null) {	        return null;	    }	    return str.toUpperCase(locale);	}
public static boolean isWhitespace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isWhitespace(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static String center(String str, final int size, String padStr) {	    if (str == null || size <= 0) {	        return str;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    str = leftPad(str, strLen + pads / 2, padStr);	    str = rightPad(str, size, padStr);	    return str;	}
public static boolean isSameLength(final boolean[] array1, final boolean[] array2) {	    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {	        return false;	    }	    return true;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static String removeStart(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.startsWith(remove)) {	        return str.substring(remove.length());	    }	    return str;	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
protected String getArrayEnd() {	    return arrayEnd;	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
public boolean isEmpty() {	    return size == 0;	}
public int size() {	    return size;	}
public static String removeStart(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.startsWith(remove)) {	        return str.substring(remove.length());	    }	    return str;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public String rightString(final int length) {	    if (length <= 0) {	        return "";	    } else if (length >= size) {	        return new String(buffer, 0, size);	    } else {	        return new String(buffer, size - length, length);	    }	}
public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) {	    if (it != null) {	        separator = ObjectUtils.toString(separator);	        while (it.hasNext()) {	            append(it.next());	            if (it.hasNext()) {	                append(separator);	            }	        }	    }	    return this;	}
public static boolean notEqual(final Object object1, final Object object2) {	    return ObjectUtils.equals(object1, object2) == false;	}
static boolean isAccessible(final Member m) {	    return m != null && Modifier.isPublic(m.getModifiers()) && !m.isSynthetic();	}
public static float max(final float a, final float b) {	    if (Float.isNaN(a)) {	        return b;	    } else if (Float.isNaN(b)) {	        return a;	    } else {	        return Math.max(a, b);	    }	}
public String getNullText() {	    return nullText;	}
public static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts) {	    if (0 == nShorts) {	        return dst;	    }	    if ((nShorts - 1) * 16 + srcPos >= 32) {	        throw new IllegalArgumentException("(nShorts-1)*16+srcPos is greather or equal to than 32");	    }	    int shift = 0;	    for (int i = 0; i < nShorts; i++) {	        shift = i * 16 + srcPos;	        dst[dstPos + i] = (short) (0xffff & (src >> shift));	    }	    return dst;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
@Override	public String getSizeStartText() {	    return super.getSizeStartText();	}
public static String rightPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return rightPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return str.concat(padStr);	    } else if (pads < padLen) {	        return str.concat(padStr.substring(0, pads));	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return str.concat(new String(padding));	    }	}
@Override	public boolean ready() {	    return pos < StrBuilder.this.size();	}
public static final String unescapeCsv(final String input) {	    return UNESCAPE_CSV.translate(input);	}
public static String appendIfMissing(final String str, final CharSequence suffix, final CharSequence... suffixes) {	    return appendIfMissing(str, suffix, false, suffixes);	}
public static final String escapeHtml3(final String input) {	    return ESCAPE_HTML3.translate(input);	}
public String getNewLineText() {	    return newLine;	}
protected String getSizeStartText() {	    return sizeStartText;	}
public static String prependIfMissing(final String str, final CharSequence prefix, final CharSequence... prefixes) {	    return prependIfMissing(str, prefix, false, prefixes);	}
@Override	public Date parse(final String source, final ParsePosition pos) {	    final int offset = pos.getIndex();	    final Matcher matcher = parsePattern.matcher(source.substring(offset));	    if (!matcher.lookingAt()) {	        return null;	    }	    final Calendar cal = Calendar.getInstance(timeZone, locale);	    cal.clear();	    for (int i = 0; i < strategies.length; ) {	        final Strategy strategy = strategies[i++];	        strategy.setCalendar(this, cal, matcher.group(i));	    }	    pos.setIndex(offset + matcher.end());	    return cal.getTime();	}
public static boolean containsWhitespace(final CharSequence seq) {	    if (isEmpty(seq)) {	        return false;	    }	    final int strLen = seq.length();	    for (int i = 0; i < strLen; i++) {	        if (Character.isWhitespace(seq.charAt(i))) {	            return true;	        }	    }	    return false;	}
public StrBuilder deleteAll(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, -1);	}
public static boolean isEmpty(final boolean[] array) {	    return array == null || array.length == 0;	}
public int size() {	    return size;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    appendSummarySize(buffer, fieldName, array.length);	}
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = Integer.MAX_VALUE;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.indexOf(str, search, 0);	        if (tmp == INDEX_NOT_FOUND) {	            continue;	        }	        if (tmp < ret) {	            ret = tmp;	        }	    }	    return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;	}
@Override	public String getMessage() {	    return getFormattedExceptionMessage(super.getMessage());	}
public String toString(final String format) {	    return String.format(format, getLeft(), getRight());	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
@Override	public double doubleValue() {	    return (double) numerator / (double) denominator;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
@Override	public String getArrayStart() {	    return super.getArrayStart();	}
public static String removeStart(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.startsWith(remove)) {	        return str.substring(remove.length());	    }	    return str;	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase) {	    if (str == null || prefix == null) {	        return str == null && prefix == null;	    }	    if (prefix.length() > str.length()) {	        return false;	    }	    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());	}
public int indexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex < 0 ? 0 : startIndex);	    if (matcher == null || startIndex >= size) {	        return -1;	    }	    final int len = size;	    final char[] buf = buffer;	    for (int i = startIndex; i < len; i++) {	        if (matcher.isMatch(buf, i, startIndex, len) > 0) {	            return i;	        }	    }	    return -1;	}
public static String rightPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return rightPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return str.concat(padStr);	    } else if (pads < padLen) {	        return str.concat(padStr.substring(0, pads));	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return str.concat(new String(padding));	    }	}
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) {	    return new Range<T>(fromInclusive, toInclusive, comparator);	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
protected String getContentEnd() {	    return contentEnd;	}
public int capacity() {	    return buffer.length;	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    final int seqEnd = input.length();	    if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') {	        int start = index + 2;	        boolean isHex = false;	        final char firstChar = input.charAt(start);	        if (firstChar == 'x' || firstChar == 'X') {	            start++;	            isHex = true;	            if (start == seqEnd) {	                return 0;	            }	        }	        int end = start;	        while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) {	            end++;	        }	        final boolean semiNext = end != seqEnd && input.charAt(end) == ';';	        if (!semiNext) {	            if (isSet(OPTION.semiColonRequired)) {	                return 0;	            } else if (isSet(OPTION.errorIfNoSemiColon)) {	                throw new IllegalArgumentException("Semi-colon required at end of numeric entity");	            }	        }	        int entityValue;	        try {	            if (isHex) {	                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);	            } else {	                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);	            }	        } catch (final NumberFormatException nfe) {	            return 0;	        }	        if (entityValue > 0xFFFF) {	            final char[] chrs = Character.toChars(entityValue);	            out.write(chrs[0]);	            out.write(chrs[1]);	        } else {	            out.write(entityValue);	        }	        return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0);	    }	    return 0;	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public boolean isEmpty() {	    return size == 0;	}
public StrBuilder deleteAll(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, -1);	}
@Override	public TimeZone getTimeZone() {	    return timeZone;	}
protected String getArrayEnd() {	    return arrayEnd;	}
public static Object invokeMethod(final Object object, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {	    if (parameterTypes == null) {	        parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;	    }	    if (args == null) {	        args = ArrayUtils.EMPTY_OBJECT_ARRAY;	    }	    final Method method = getMatchingAccessibleMethod(object.getClass(), methodName, parameterTypes);	    if (method == null) {	        throw new NoSuchMethodException("No such accessible method: " + methodName + "() on object: " + object.getClass().getName());	    }	    return method.invoke(object, args);	}
protected String getFieldNameValueSeparator() {	    return fieldNameValueSeparator;	}
@Override	public int hashCode() {	    return toHashCode();	}
public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {	    if (str == null || searchStr == null) {	        return INDEX_NOT_FOUND;	    }	    if (startPos > str.length() - searchStr.length()) {	        startPos = str.length() - searchStr.length();	    }	    if (startPos < 0) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return startPos;	    }	    for (int i = startPos; i >= 0; i--) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width, final int precision, final char padChar, final CharSequence ellipsis) {	    Validate.isTrue(ellipsis == null || precision < 0 || ellipsis.length() <= precision, "Specified ellipsis '%1$s' exceeds precision of %2$s", ellipsis, Integer.valueOf(precision));	    final StringBuilder buf = new StringBuilder(seq);	    if (precision >= 0 && precision < seq.length()) {	        final CharSequence _ellipsis = ObjectUtils.defaultIfNull(ellipsis, StringUtils.EMPTY);	        buf.replace(precision - _ellipsis.length(), seq.length(), _ellipsis.toString());	    }	    final boolean leftJustify = (flags & LEFT_JUSTIFY) == LEFT_JUSTIFY;	    for (int i = buf.length(); i < width; i++) {	        buf.insert(leftJustify ? i : 0, padChar);	    }	    formatter.format(buf.toString());	    return formatter;	}
public String getNewLineText() {	    return newLine;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
protected String getNullText() {	    return nullText;	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
public StrBuilder replaceAll(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, -1);	}
public int capacity() {	    return buffer.length;	}
public boolean isEmpty() {	    return size == 0;	}
public static String removeStart(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.startsWith(remove)) {	        return str.substring(remove.length());	    }	    return str;	}
public String getNewLineText() {	    return newLine;	}
public static boolean isAlpha(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public String getNullText() {	    return nullText;	}
public String getNullText() {	    return nullText;	}
protected String getSizeEndText() {	    return sizeEndText;	}
public boolean isEmpty() {	    return size == 0;	}
public static CharSet getInstance(final String... setStrs) {	    if (setStrs == null) {	        return null;	    }	    if (setStrs.length == 1) {	        final CharSet common = COMMON.get(setStrs[0]);	        if (common != null) {	            return common;	        }	    }	    return new CharSet(setStrs);	}
@Override	public T get(final long timeout, final TimeUnit unit) {	    return value;	}
public int lastIndexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex >= size ? size - 1 : startIndex);	    if (matcher == null || startIndex < 0) {	        return -1;	    }	    final char[] buf = buffer;	    final int endIndex = startIndex + 1;	    for (int i = startIndex; i >= 0; i--) {	        if (matcher.isMatch(buf, i, 0, endIndex) > 0) {	            return i;	        }	    }	    return -1;	}
protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos) {	    final StrLookup<?> resolver = getVariableResolver();	    if (resolver == null) {	        return null;	    }	    return resolver.lookup(variableName);	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
public static String substringAfterLast(final String str, final String separator) {	    if (isEmpty(str)) {	        return str;	    }	    if (isEmpty(separator)) {	        return EMPTY;	    }	    final int pos = str.lastIndexOf(separator);	    if (pos == INDEX_NOT_FOUND || pos == str.length() - separator.length()) {	        return EMPTY;	    }	    return str.substring(pos + separator.length());	}
public int lastIndexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex >= size ? size - 1 : startIndex);	    if (matcher == null || startIndex < 0) {	        return -1;	    }	    final char[] buf = buffer;	    final int endIndex = startIndex + 1;	    for (int i = startIndex; i >= 0; i--) {	        if (matcher.isMatch(buf, i, 0, endIndex) > 0) {	            return i;	        }	    }	    return -1;	}
public static boolean startsWithAny(final CharSequence string, final CharSequence... searchStrings) {	    if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {	        return false;	    }	    for (final CharSequence searchString : searchStrings) {	        if (StringUtils.startsWith(string, searchString)) {	            return true;	        }	    }	    return false;	}
public int indexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex < 0 ? 0 : startIndex);	    if (matcher == null || startIndex >= size) {	        return -1;	    }	    final int len = size;	    final char[] buf = buffer;	    for (int i = startIndex; i < len; i++) {	        if (matcher.isMatch(buf, i, startIndex, len) > 0) {	            return i;	        }	    }	    return -1;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public static Date setMinutes(final Date date, final int amount) {	    return set(date, Calendar.MINUTE, amount);	}
public static <T extends Comparable<? super T>> int compare(final T c1, final T c2, final boolean nullGreater) {	    if (c1 == c2) {	        return 0;	    } else if (c1 == null) {	        return nullGreater ? 1 : -1;	    } else if (c2 == null) {	        return nullGreater ? -1 : 1;	    }	    return c1.compareTo(c2);	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static void matchesPattern(final CharSequence input, final String pattern, final String message, final Object... values) {	    if (Pattern.matches(pattern, input) == false) {	        throw new IllegalArgumentException(String.format(message, values));	    }	}
public Double toDouble() {	    return Double.valueOf(doubleValue());	}
@Override	public R getRight() {	    return right;	}
static Pair<IDKey, IDKey> getRegisterPair(final Object lhs, final Object rhs) {	    final IDKey left = new IDKey(lhs);	    final IDKey right = new IDKey(rhs);	    return Pair.of(left, right);	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {	    if (str == null || searchStr == null) {	        return INDEX_NOT_FOUND;	    }	    if (startPos < 0) {	        startPos = 0;	    }	    final int endLimit = str.length() - searchStr.length() + 1;	    if (startPos > endLimit) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return startPos;	    }	    for (int i = startPos; i < endLimit; i++) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException {	    return charsetName == null ? new String(bytes) : new String(bytes, charsetName);	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
protected boolean isUseIdentityHashCode() {	    return useIdentityHashCode;	}
@Override	public String toString() {	    if (this.getObject() == null) {	        return this.getStyle().getNullText();	    }	    Class<?> clazz = this.getObject().getClass();	    this.appendFieldsIn(clazz);	    while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {	        clazz = clazz.getSuperclass();	        this.appendFieldsIn(clazz);	    }	    return super.toString();	}
public static boolean isAlpha(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
public Fraction reduce() {	    if (numerator == 0) {	        return equals(ZERO) ? this : ZERO;	    }	    final int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);	    if (gcd == 1) {	        return this;	    }	    return Fraction.getFraction(numerator / gcd, denominator / gcd);	}
public static int countMatches(final CharSequence str, final CharSequence sub) {	    if (isEmpty(str) || isEmpty(sub)) {	        return 0;	    }	    int count = 0;	    int idx = 0;	    while ((idx = CharSequenceUtils.indexOf(str, sub, idx)) != INDEX_NOT_FOUND) {	        count++;	        idx += sub.length();	    }	    return count;	}
public static String reverse(final String str) {	    if (str == null) {	        return null;	    }	    return new StringBuilder(str).reverse().toString();	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public static void isTrue(final boolean expression) {	    if (expression == false) {	        throw new IllegalArgumentException(DEFAULT_IS_TRUE_EX_MESSAGE);	    }	}
public int capacity() {	    return buffer.length;	}
public char getStart() {	    return this.start;	}
public static long toLong(final String str, final long defaultValue) {	    if (str == null) {	        return defaultValue;	    }	    try {	        return Long.parseLong(str);	    } catch (final NumberFormatException nfe) {	        return defaultValue;	    }	}
protected int getTaskCount() {	    return 1;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer) {	    if (throwable == null) {	        return;	    }	    if (writer == null) {	        throw new IllegalArgumentException("The PrintWriter must not be null");	    }	    final String[] trace = getRootCauseStackTrace(throwable);	    for (final String element : trace) {	        writer.println(element);	    }	    writer.flush();	}
public static NumericEntityEscaper outsideOf(final int codepointLow, final int codepointHigh) {	    return new NumericEntityEscaper(codepointLow, codepointHigh, false);	}
public StrBuilder setLength(final int length) {	    if (length < 0) {	        throw new StringIndexOutOfBoundsException(length);	    }	    if (length < size) {	        size = length;	    } else if (length > size) {	        ensureCapacity(length);	        final int oldEnd = size;	        final int newEnd = length;	        size = length;	        for (int i = oldEnd; i < newEnd; i++) {	            buffer[i] = '\0';	        }	    }	    return this;	}
void increment() {	    count++;	}
static int indexOf(final CharSequence cs, final CharSequence searchChar, final int start) {	    return cs.toString().indexOf(searchChar.toString(), start);	}
public static int indexOfDifference(final CharSequence... css) {	    if (css == null || css.length <= 1) {	        return INDEX_NOT_FOUND;	    }	    boolean anyStringNull = false;	    boolean allStringsNull = true;	    final int arrayLen = css.length;	    int shortestStrLen = Integer.MAX_VALUE;	    int longestStrLen = 0;	    for (int i = 0; i < arrayLen; i++) {	        if (css[i] == null) {	            anyStringNull = true;	            shortestStrLen = 0;	        } else {	            allStringsNull = false;	            shortestStrLen = Math.min(css[i].length(), shortestStrLen);	            longestStrLen = Math.max(css[i].length(), longestStrLen);	        }	    }	    if (allStringsNull || longestStrLen == 0 && !anyStringNull) {	        return INDEX_NOT_FOUND;	    }	    if (shortestStrLen == 0) {	        return 0;	    }	    int firstDiff = -1;	    for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {	        final char comparisonChar = css[0].charAt(stringPos);	        for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {	            if (css[arrayPos].charAt(stringPos) != comparisonChar) {	                firstDiff = stringPos;	                break;	            }	        }	        if (firstDiff != -1) {	            break;	        }	    }	    if (firstDiff == -1 && shortestStrLen != longestStrLen) {	        return shortestStrLen;	    }	    return firstDiff;	}
protected String getFieldSeparator() {	    return fieldSeparator;	}
public int size() {	    return size;	}
public static boolean isAlpha(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public void add(final Number operand) {	    this.value += operand.shortValue();	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
protected String getContentEnd() {	    return contentEnd;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static byte[] serialize(final Serializable obj) {	    final ByteArrayOutputStream baos = new ByteArrayOutputStream(512);	    serialize(obj, baos);	    return baos.toByteArray();	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = Integer.MAX_VALUE;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.indexOf(str, search, 0);	        if (tmp == INDEX_NOT_FOUND) {	            continue;	        }	        if (tmp < ret) {	            ret = tmp;	        }	    }	    return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;	}
public ReflectionToStringBuilder reflectionAppendArray(final Object array) {	    this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);	    return this;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static void isTrue(final boolean expression) {	    if (expression == false) {	        throw new IllegalArgumentException(DEFAULT_IS_TRUE_EX_MESSAGE);	    }	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
static Token[] lexx(final String format) {	    final char[] array = format.toCharArray();	    final ArrayList<Token> list = new ArrayList<Token>(array.length);	    boolean inLiteral = false;	    StringBuilder buffer = null;	    Token previous = null;	    final int sz = array.length;	    for (int i = 0; i < sz; i++) {	        final char ch = array[i];	        if (inLiteral && ch != '\'') {	            buffer.append(ch);	            continue;	        }	        Object value = null;	        switch(ch) {	            case '\'':	                if (inLiteral) {	                    buffer = null;	                    inLiteral = false;	                } else {	                    buffer = new StringBuilder();	                    list.add(new Token(buffer));	                    inLiteral = true;	                }	                break;	            case 'y':	                value = y;	                break;	            case 'M':	                value = M;	                break;	            case 'd':	                value = d;	                break;	            case 'H':	                value = H;	                break;	            case 'm':	                value = m;	                break;	            case 's':	                value = s;	                break;	            case 'S':	                value = S;	                break;	            default:	                if (buffer == null) {	                    buffer = new StringBuilder();	                    list.add(new Token(buffer));	                }	                buffer.append(ch);	        }	        if (value != null) {	            if (previous != null && previous.getValue() == value) {	                previous.increment();	            } else {	                final Token token = new Token(value);	                list.add(token);	                previous = token;	            }	            buffer = null;	        }	    }	    return list.toArray(new Token[list.size()]);	}
public final ThreadFactory getWrappedFactory() {	    return wrappedFactory;	}
protected boolean isUseIdentityHashCode() {	    return useIdentityHashCode;	}
@Override	public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) {	    return buffer[pos] <= 32 ? 1 : 0;	}
@Override	public int length() {	    return size;	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
@Override	public String toString() {	    return StringUtils.repeat(this.value.toString(), this.count);	}
public static String substringAfterLast(final String str, final String separator) {	    if (isEmpty(str)) {	        return str;	    }	    if (isEmpty(separator)) {	        return EMPTY;	    }	    final int pos = str.lastIndexOf(separator);	    if (pos == INDEX_NOT_FOUND || pos == str.length() - separator.length()) {	        return EMPTY;	    }	    return str.substring(pos + separator.length());	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
protected String getArrayStart() {	    return arrayStart;	}
@Override	public float floatValue() {	    return (float) numerator / (float) denominator;	}
@Override	public Integer build() {	    return Integer.valueOf(toHashCode());	}
public static String center(String str, final int size, String padStr) {	    if (str == null || size <= 0) {	        return str;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    str = leftPad(str, strLen + pads / 2, padStr);	    str = rightPad(str, size, padStr);	    return str;	}
public static byte toByte(final String str, final byte defaultValue) {	    if (str == null) {	        return defaultValue;	    }	    try {	        return Byte.parseByte(str);	    } catch (final NumberFormatException nfe) {	        return defaultValue;	    }	}
@Override	public T getValue() {	    return this.value;	}
public int size() {	    return size;	}
public static boolean isAsciiAlphaLower(final char ch) {	    return ch >= 'a' && ch <= 'z';	}
public boolean isAppendTransients() {	    return this.appendTransients;	}
public int capacity() {	    return buffer.length;	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
protected String getContentStart() {	    return contentStart;	}
public static int reflectionHashCode(final Object object, final String... excludeFields) {	    return reflectionHashCode(17, 37, object, false, null, excludeFields);	}
public static Float createFloat(final String str) {	    if (str == null) {	        return null;	    }	    return Float.valueOf(str);	}
public static Boolean[] nullToEmpty(final Boolean[] array) {	    if (array == null || array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    return array;	}
public int size() {	    return size;	}
public static String repeat(final char ch, final int repeat) {	    final char[] buf = new char[repeat];	    for (int i = repeat - 1; i >= 0; i--) {	        buf[i] = ch;	    }	    return new String(buf);	}
public static boolean containsOnly(final CharSequence cs, final String validChars) {	    if (cs == null || validChars == null) {	        return false;	    }	    return containsOnly(cs, validChars.toCharArray());	}
public static String repeat(final char ch, final int repeat) {	    final char[] buf = new char[repeat];	    for (int i = repeat - 1; i >= 0; i--) {	        buf[i] = ch;	    }	    return new String(buf);	}
@Override	public int nextIndex() {	    return tokenPos;	}
protected String getSizeEndText() {	    return sizeEndText;	}
public boolean startsWith(final String str) {	    if (str == null) {	        return false;	    }	    final int len = str.length();	    if (len == 0) {	        return true;	    }	    if (len > size) {	        return false;	    }	    for (int i = 0; i < len; i++) {	        if (buffer[i] != str.charAt(i)) {	            return false;	        }	    }	    return true;	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    final int seqEnd = input.length();	    if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') {	        int start = index + 2;	        boolean isHex = false;	        final char firstChar = input.charAt(start);	        if (firstChar == 'x' || firstChar == 'X') {	            start++;	            isHex = true;	            if (start == seqEnd) {	                return 0;	            }	        }	        int end = start;	        while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) {	            end++;	        }	        final boolean semiNext = end != seqEnd && input.charAt(end) == ';';	        if (!semiNext) {	            if (isSet(OPTION.semiColonRequired)) {	                return 0;	            } else if (isSet(OPTION.errorIfNoSemiColon)) {	                throw new IllegalArgumentException("Semi-colon required at end of numeric entity");	            }	        }	        int entityValue;	        try {	            if (isHex) {	                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);	            } else {	                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);	            }	        } catch (final NumberFormatException nfe) {	            return 0;	        }	        if (entityValue > 0xFFFF) {	            final char[] chrs = Character.toChars(entityValue);	            out.write(chrs[0]);	            out.write(chrs[1]);	        } else {	            out.write(entityValue);	        }	        return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0);	    }	    return 0;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
@Override	public L getLeft() {	    return left;	}
private static long getFragment(final Calendar calendar, final int fragment, final int unit) {	    if (calendar == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final long millisPerUnit = getMillisPerUnit(unit);	    long result = 0;	    switch(fragment) {	        case Calendar.YEAR:	            result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit;	            break;	        case Calendar.MONTH:	            result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit;	            break;	    }	    switch(fragment) {	        case Calendar.YEAR:	        case Calendar.MONTH:	        case Calendar.DAY_OF_YEAR:	        case Calendar.DATE:	            result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit;	        case Calendar.HOUR_OF_DAY:	            result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit;	        case Calendar.MINUTE:	            result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit;	        case Calendar.SECOND:	            result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit;	            break;	        case Calendar.MILLISECOND:	            break;	        default:	            throw new IllegalArgumentException("The fragment " + fragment + " is not supported");	    }	    return result;	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
@Override	public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) {	    return formatter.format(obj, toAppendTo, pos);	}
@Override	public boolean ready() {	    return pos < StrBuilder.this.size();	}
static int indexOf(final CharSequence cs, final CharSequence searchChar, final int start) {	    return cs.toString().indexOf(searchChar.toString(), start);	}
public static String right(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(str.length() - len);	}
@Override	public double doubleValue() {	    return value;	}
public static String toString(final boolean bool, final String trueString, final String falseString) {	    return bool ? trueString : falseString;	}
protected String getSummaryObjectEndText() {	    return summaryObjectEndText;	}
public static boolean containsOnly(final CharSequence cs, final String validChars) {	    if (cs == null || validChars == null) {	        return false;	    }	    return containsOnly(cs, validChars.toCharArray());	}
@Override	public int compareTo(final MutableShort other) {	    final short anotherVal = other.value;	    return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1);	}
protected boolean isDefaultFullDetail() {	    return defaultFullDetail;	}
public static boolean isEmpty(final CharSequence cs) {	    return cs == null || cs.length() == 0;	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public static List<Locale> localeLookupList(final Locale locale, final Locale defaultLocale) {	    final List<Locale> list = new ArrayList<Locale>(4);	    if (locale != null) {	        list.add(locale);	        if (locale.getVariant().length() > 0) {	            list.add(new Locale(locale.getLanguage(), locale.getCountry()));	        }	        if (locale.getCountry().length() > 0) {	            list.add(new Locale(locale.getLanguage(), ""));	        }	        if (list.contains(defaultLocale) == false) {	            list.add(defaultLocale);	        }	    }	    return Collections.unmodifiableList(list);	}
@Override	public Short getValue() {	    return Short.valueOf(this.value);	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
protected boolean isFieldSeparatorAtStart() {	    return fieldSeparatorAtStart;	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
protected String getSummaryObjectEndText() {	    return summaryObjectEndText;	}
@Override	public T get(final long timeout, final TimeUnit unit) {	    return value;	}
public static String randomAlphanumeric(final int count) {	    return random(count, true, true);	}
public static final String unescapeCsv(final String input) {	    return UNESCAPE_CSV.translate(input);	}
public static String right(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(str.length() - len);	}
public static String randomAlphanumeric(final int count) {	    return random(count, true, true);	}
public static boolean isSameLength(final boolean[] array1, final boolean[] array2) {	    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {	        return false;	    }	    return true;	}
@Override	public void mark(final int readAheadLimit) {	    mark = pos;	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) {	    if (s == null || t == null) {	        throw new IllegalArgumentException("Strings must not be null");	    }	    if (threshold < 0) {	        throw new IllegalArgumentException("Threshold must not be negative");	    }	    int n = s.length();	    int m = t.length();	    if (n == 0) {	        return m <= threshold ? m : -1;	    } else if (m == 0) {	        return n <= threshold ? n : -1;	    }	    if (n > m) {	        final CharSequence tmp = s;	        s = t;	        t = tmp;	        n = m;	        m = t.length();	    }	    int[] p = new int[n + 1];	    int[] d = new int[n + 1];	    int[] _d;	    final int boundary = Math.min(n, threshold) + 1;	    for (int i = 0; i < boundary; i++) {	        p[i] = i;	    }	    Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);	    Arrays.fill(d, Integer.MAX_VALUE);	    for (int j = 1; j <= m; j++) {	        final char t_j = t.charAt(j - 1);	        d[0] = j;	        final int min = Math.max(1, j - threshold);	        final int max = Math.min(n, j + threshold);	        if (min > max) {	            return -1;	        }	        if (min > 1) {	            d[min - 1] = Integer.MAX_VALUE;	        }	        for (int i = min; i <= max; i++) {	            if (s.charAt(i - 1) == t_j) {	                d[i] = p[i - 1];	            } else {	                d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);	            }	        }	        _d = p;	        p = d;	        d = _d;	    }	    if (p[n] <= threshold) {	        return p[n];	    }	    return -1;	}
public static double[] addAll(final double[] array1, final double... array2) {	    if (array1 == null) {	        return clone(array2);	    } else if (array2 == null) {	        return clone(array1);	    }	    final double[] joinedArray = new double[array1.length + array2.length];	    System.arraycopy(array1, 0, joinedArray, 0, array1.length);	    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);	    return joinedArray;	}
public void split() {	    if (this.runningState != STATE_RUNNING) {	        throw new IllegalStateException("Stopwatch is not running. ");	    }	    this.stopTime = System.nanoTime();	    this.splitState = STATE_SPLIT;	}
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) {	    final StringBuilder buffer = new StringBuilder();	    boolean lastOutputSeconds = false;	    final int sz = tokens.length;	    for (int i = 0; i < sz; i++) {	        final Token token = tokens[i];	        final Object value = token.getValue();	        final int count = token.getCount();	        if (value instanceof StringBuilder) {	            buffer.append(value.toString());	        } else {	            if (value == y) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years));	                lastOutputSeconds = false;	            } else if (value == M) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months));	                lastOutputSeconds = false;	            } else if (value == d) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days));	                lastOutputSeconds = false;	            } else if (value == H) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours));	                lastOutputSeconds = false;	            } else if (value == m) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes));	                lastOutputSeconds = false;	            } else if (value == s) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds));	                lastOutputSeconds = true;	            } else if (value == S) {	                if (lastOutputSeconds) {	                    milliseconds += 1000;	                    final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds);	                    buffer.append(str.substring(1));	                } else {	                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds));	                }	                lastOutputSeconds = false;	            }	        }	    }	    return buffer.toString();	}
public boolean isIgnoreEmptyTokens() {	    return ignoreEmptyTokens;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
protected String getArrayStart() {	    return arrayStart;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
@Override	public void setValue(final Number value) {	    this.value = value.byteValue();	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public boolean isEmpty() {	    return size == 0;	}
public static int toIntValue(final Character ch, final int defaultValue) {	    if (ch == null) {	        return defaultValue;	    }	    return toIntValue(ch.charValue(), defaultValue);	}
public static float max(final float a, final float b, final float c) {	    return Math.max(Math.max(a, b), c);	}
public static String chop(final String str) {	    if (str == null) {	        return null;	    }	    final int strLen = str.length();	    if (strLen < 2) {	        return EMPTY;	    }	    final int lastIdx = strLen - 1;	    final String ret = str.substring(0, lastIdx);	    final char last = str.charAt(lastIdx);	    if (last == CharUtils.LF && ret.charAt(lastIdx - 1) == CharUtils.CR) {	        return ret.substring(0, lastIdx - 1);	    }	    return ret;	}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    buffer.append(arrayStart);	    for (int i = 0; i < array.length; i++) {	        if (i > 0) {	            buffer.append(arraySeparator);	        }	        appendDetail(buffer, fieldName, array[i]);	    }	    buffer.append(arrayEnd);	}
public static String toString(final boolean bool, final String trueString, final String falseString) {	    return bool ? trueString : falseString;	}
public boolean isEmpty() {	    return size == 0;	}
public static byte CONST_BYTE(final int v) throws IllegalArgumentException {	    if (v < Byte.MIN_VALUE || v > Byte.MAX_VALUE) {	        throw new IllegalArgumentException("Supplied value must be a valid byte literal between -128 and 127: [" + v + "]");	    }	    return (byte) v;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public static void identityToString(final StringBuilder builder, final Object object) {	    if (object == null) {	        throw new NullPointerException("Cannot get the toString of a null identity");	    }	    builder.append(object.getClass().getName()).append('@').append(Integer.toHexString(System.identityHashCode(object)));	}
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) {	    final StringBuilder buffer = new StringBuilder();	    boolean lastOutputSeconds = false;	    final int sz = tokens.length;	    for (int i = 0; i < sz; i++) {	        final Token token = tokens[i];	        final Object value = token.getValue();	        final int count = token.getCount();	        if (value instanceof StringBuilder) {	            buffer.append(value.toString());	        } else {	            if (value == y) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years));	                lastOutputSeconds = false;	            } else if (value == M) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months));	                lastOutputSeconds = false;	            } else if (value == d) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days));	                lastOutputSeconds = false;	            } else if (value == H) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours));	                lastOutputSeconds = false;	            } else if (value == m) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes));	                lastOutputSeconds = false;	            } else if (value == s) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds));	                lastOutputSeconds = true;	            } else if (value == S) {	                if (lastOutputSeconds) {	                    milliseconds += 1000;	                    final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds);	                    buffer.append(str.substring(1));	                } else {	                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds));	                }	                lastOutputSeconds = false;	            }	        }	    }	    return buffer.toString();	}
public boolean isEmpty() {	    return size == 0;	}
public StrBuilder setLength(final int length) {	    if (length < 0) {	        throw new StringIndexOutOfBoundsException(length);	    }	    if (length < size) {	        size = length;	    } else if (length > size) {	        ensureCapacity(length);	        final int oldEnd = size;	        final int newEnd = length;	        size = length;	        for (int i = oldEnd; i < newEnd; i++) {	            buffer[i] = '\0';	        }	    }	    return this;	}
public String getNullText() {	    return nullText;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public static String leftPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return leftPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return padStr.concat(str);	    } else if (pads < padLen) {	        return padStr.substring(0, pads).concat(str);	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return new String(padding).concat(str);	    }	}
public static <L, M, R> ImmutableTriple<L, M, R> of(final L left, final M middle, final R right) {	    return new ImmutableTriple<L, M, R>(left, middle, right);	}
public char getEscapeChar() {	    return this.escapeChar;	}
public static CharRange is(final char ch) {	    return new CharRange(ch, ch, false);	}
public int capacity() {	    return buffer.length;	}
public static Locale toLocale(final String str) {	    if (str == null) {	        return null;	    }	    if (str.contains("#")) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final int len = str.length();	    if (len < 2) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final char ch0 = str.charAt(0);	    if (ch0 == '_') {	        if (len < 3) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        final char ch1 = str.charAt(1);	        final char ch2 = str.charAt(2);	        if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        if (len == 3) {	            return new Locale("", str.substring(1, 3));	        }	        if (len < 5) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        if (str.charAt(3) != '_') {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        return new Locale("", str.substring(1, 3), str.substring(4));	    }	    final char ch1 = str.charAt(1);	    if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (len == 2) {	        return new Locale(str);	    }	    if (len < 5) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (str.charAt(2) != '_') {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final char ch3 = str.charAt(3);	    if (ch3 == '_') {	        return new Locale(str.substring(0, 2), "", str.substring(4));	    }	    final char ch4 = str.charAt(4);	    if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (len == 5) {	        return new Locale(str.substring(0, 2), str.substring(3, 5));	    }	    if (len < 7) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (str.charAt(5) != '_') {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));	}
public boolean isEmpty() {	    return size == 0;	}
@Override	public int hashCode() {	    return 83 + start + 7 * end + (negated ? 1 : 0);	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static boolean isNumericSpace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isDigit(cs.charAt(i)) == false && cs.charAt(i) != ' ') {	            return false;	        }	    }	    return true;	}
public static boolean isAscii(final char ch) {	    return ch < 128;	}
public String reformat(final String input) throws ParseException {	    return format(parseObject(input));	}
public boolean isEmpty() {	    return size == 0;	}
protected String getNullText() {	    return nullText;	}
@Override	public int length() {	    return size;	}
public static String replaceOnce(final String text, final String searchString, final String replacement) {	    return replace(text, searchString, replacement, 1);	}
public static <T> T mode(final T... items) {	    if (ArrayUtils.isNotEmpty(items)) {	        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(items.length);	        for (final T t : items) {	            final MutableInt count = occurrences.get(t);	            if (count == null) {	                occurrences.put(t, new MutableInt(1));	            } else {	                count.increment();	            }	        }	        T result = null;	        int max = 0;	        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {	            final int cmp = e.getValue().intValue();	            if (cmp == max) {	                result = null;	            } else if (cmp > max) {	                max = cmp;	                result = e.getKey();	            }	        }	        return result;	    }	    return null;	}
@Override	public boolean hasNext() {	    checkTokenized();	    return tokenPos < tokens.length;	}
protected boolean isUseClassName() {	    return useClassName;	}
protected void setUseShortClassName(final boolean useShortClassName) {	    this.useShortClassName = useShortClassName;	}
@Override	public String previous() {	    if (hasPrevious()) {	        return tokens[--tokenPos];	    }	    throw new NoSuchElementException();	}
public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) {	    if (it != null) {	        separator = ObjectUtils.toString(separator);	        while (it.hasNext()) {	            append(it.next());	            if (it.hasNext()) {	                append(separator);	            }	        }	    }	    return this;	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
@Override	public int previousIndex() {	    return tokenPos - 1;	}
@Override	public void close() {	}
static boolean isOSNameMatch(final String osName, final String osNamePrefix) {	    if (osName == null) {	        return false;	    }	    return osName.startsWith(osNamePrefix);	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public void add(final Number operand) {	    this.value += operand.intValue();	}
@Override	public void setFormat(final int formatElementIndex, final Format newFormat) {	    throw new UnsupportedOperationException();	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static CharRange isIn(final char start, final char end) {	    return new CharRange(start, end, false);	}
@Override	public String toString() {	    return "FastDateFormat[" + printer.getPattern() + "," + printer.getLocale() + "," + printer.getTimeZone().getID() + "]";	}
public static int indexOfDifference(final CharSequence... css) {	    if (css == null || css.length <= 1) {	        return INDEX_NOT_FOUND;	    }	    boolean anyStringNull = false;	    boolean allStringsNull = true;	    final int arrayLen = css.length;	    int shortestStrLen = Integer.MAX_VALUE;	    int longestStrLen = 0;	    for (int i = 0; i < arrayLen; i++) {	        if (css[i] == null) {	            anyStringNull = true;	            shortestStrLen = 0;	        } else {	            allStringsNull = false;	            shortestStrLen = Math.min(css[i].length(), shortestStrLen);	            longestStrLen = Math.max(css[i].length(), longestStrLen);	        }	    }	    if (allStringsNull || longestStrLen == 0 && !anyStringNull) {	        return INDEX_NOT_FOUND;	    }	    if (shortestStrLen == 0) {	        return 0;	    }	    int firstDiff = -1;	    for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {	        final char comparisonChar = css[0].charAt(stringPos);	        for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {	            if (css[arrayPos].charAt(stringPos) != comparisonChar) {	                firstDiff = stringPos;	                break;	            }	        }	        if (firstDiff != -1) {	            break;	        }	    }	    if (firstDiff == -1 && shortestStrLen != longestStrLen) {	        return shortestStrLen;	    }	    return firstDiff;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static String removeStartIgnoreCase(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (startsWithIgnoreCase(str, remove)) {	        return str.substring(remove.length());	    }	    return str;	}
public String getNullText() {	    return nullText;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static String right(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(str.length() - len);	}
protected void appendFieldSeparator(final StringBuffer buffer) {	    buffer.append(fieldSeparator);	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
public static <T> Future<T> constantFuture(final T value) {	    return new ConstantFuture<T>(value);	}
public int capacity() {	    return buffer.length;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static float min(final float a, final float b) {	    if (Float.isNaN(a)) {	        return b;	    } else if (Float.isNaN(b)) {	        return a;	    } else {	        return Math.min(a, b);	    }	}
@Override	public double doubleValue() {	    return value;	}
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) {	    return new Range<T>(fromInclusive, toInclusive, comparator);	}
public boolean isEmpty() {	    return size == 0;	}
public long getStartTime() {	    if (this.runningState == STATE_UNSTARTED) {	        throw new IllegalStateException("Stopwatch has not been started");	    }	    return this.startTimeMillis;	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
static void register(final Object lhs, final Object rhs) {	    synchronized (EqualsBuilder.class) {	        if (getRegistry() == null) {	            REGISTRY.set(new HashSet<Pair<IDKey, IDKey>>());	        }	    }	    final Set<Pair<IDKey, IDKey>> registry = getRegistry();	    final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);	    registry.add(pair);	}
public static int indexOfDifference(final CharSequence... css) {	    if (css == null || css.length <= 1) {	        return INDEX_NOT_FOUND;	    }	    boolean anyStringNull = false;	    boolean allStringsNull = true;	    final int arrayLen = css.length;	    int shortestStrLen = Integer.MAX_VALUE;	    int longestStrLen = 0;	    for (int i = 0; i < arrayLen; i++) {	        if (css[i] == null) {	            anyStringNull = true;	            shortestStrLen = 0;	        } else {	            allStringsNull = false;	            shortestStrLen = Math.min(css[i].length(), shortestStrLen);	            longestStrLen = Math.max(css[i].length(), longestStrLen);	        }	    }	    if (allStringsNull || longestStrLen == 0 && !anyStringNull) {	        return INDEX_NOT_FOUND;	    }	    if (shortestStrLen == 0) {	        return 0;	    }	    int firstDiff = -1;	    for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {	        final char comparisonChar = css[0].charAt(stringPos);	        for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {	            if (css[arrayPos].charAt(stringPos) != comparisonChar) {	                firstDiff = stringPos;	                break;	            }	        }	        if (firstDiff != -1) {	            break;	        }	    }	    if (firstDiff == -1 && shortestStrLen != longestStrLen) {	        return shortestStrLen;	    }	    return firstDiff;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public boolean isEmptyTokenAsNull() {	    return this.emptyAsNull;	}
protected String getArrayEnd() {	    return arrayEnd;	}
public static boolean startsWithAny(final CharSequence string, final CharSequence... searchStrings) {	    if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {	        return false;	    }	    for (final CharSequence searchString : searchStrings) {	        if (StringUtils.startsWith(string, searchString)) {	            return true;	        }	    }	    return false;	}
@Override	public boolean isUseClassName() {	    return super.isUseClassName();	}
public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException {	    return parseDateWithLeniency(str, locale, parsePatterns, true);	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static Boolean or(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
public static String[] getRootCauseStackTrace(final Throwable throwable) {	    if (throwable == null) {	        return ArrayUtils.EMPTY_STRING_ARRAY;	    }	    final Throwable[] throwables = getThrowables(throwable);	    final int count = throwables.length;	    final List<String> frames = new ArrayList<String>();	    List<String> nextTrace = getStackFrameList(throwables[count - 1]);	    for (int i = count; --i >= 0; ) {	        final List<String> trace = nextTrace;	        if (i != 0) {	            nextTrace = getStackFrameList(throwables[i - 1]);	            removeCommonFrames(trace, nextTrace);	        }	        if (i == count - 1) {	            frames.add(throwables[i].toString());	        } else {	            frames.add(WRAPPED_MARKER + throwables[i].toString());	        }	        for (int j = 0; j < trace.size(); j++) {	            frames.add(trace.get(j));	        }	    }	    return frames.toArray(new String[frames.size()]);	}
public boolean isAppendTransients() {	    return this.appendTransients;	}
public String getNullText() {	    return nullText;	}
public char getEscapeChar() {	    return this.escapeChar;	}
public static Iterator<?> iterator(final Object focus, final int rangeStyle) {	    if (focus == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (focus instanceof Date) {	        return iterator((Date) focus, rangeStyle);	    } else if (focus instanceof Calendar) {	        return iterator((Calendar) focus, rangeStyle);	    } else {	        throw new ClassCastException("Could not iterate based on " + focus);	    }	}
public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale) {	    return cache.getDateInstance(style, timeZone, locale);	}
public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) {	    String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'");	    if (suppressLeadingZeroElements) {	        duration = " " + duration;	        String tmp = StringUtils.replaceOnce(duration, " 0 days", "");	        if (tmp.length() != duration.length()) {	            duration = tmp;	            tmp = StringUtils.replaceOnce(duration, " 0 hours", "");	            if (tmp.length() != duration.length()) {	                duration = tmp;	                tmp = StringUtils.replaceOnce(duration, " 0 minutes", "");	                duration = tmp;	                if (tmp.length() != duration.length()) {	                    duration = StringUtils.replaceOnce(tmp, " 0 seconds", "");	                }	            }	        }	        if (duration.length() != 0) {	            duration = duration.substring(1);	        }	    }	    if (suppressTrailingZeroElements) {	        String tmp = StringUtils.replaceOnce(duration, " 0 seconds", "");	        if (tmp.length() != duration.length()) {	            duration = tmp;	            tmp = StringUtils.replaceOnce(duration, " 0 minutes", "");	            if (tmp.length() != duration.length()) {	                duration = tmp;	                tmp = StringUtils.replaceOnce(duration, " 0 hours", "");	                if (tmp.length() != duration.length()) {	                    duration = StringUtils.replaceOnce(tmp, " 0 days", "");	                }	            }	        }	    }	    duration = " " + duration;	    duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second");	    duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute");	    duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour");	    duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day");	    return duration.trim();	}
public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {	    if (str == null || searchStr == null) {	        return INDEX_NOT_FOUND;	    }	    if (startPos > str.length() - searchStr.length()) {	        startPos = str.length() - searchStr.length();	    }	    if (startPos < 0) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return startPos;	    }	    for (int i = startPos; i >= 0; i--) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static short[] removeElement(final short[] array, final short element) {	    final int index = indexOf(array, element);	    if (index == INDEX_NOT_FOUND) {	        return clone(array);	    }	    return remove(array, index);	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
public static StrTokenizer getCSVInstance(final char[] input) {	    final StrTokenizer tok = getCSVClone();	    tok.reset(input);	    return tok;	}
public Short toShort() {	    return Short.valueOf(shortValue());	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static float max(final float a, final float b, final float c) {	    return Math.max(Math.max(a, b), c);	}
@Override	public boolean markSupported() {	    return true;	}
public static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) {	    if (0 == nBools) {	        return dst;	    }	    if (nBools - 1 + srcPos >= 8) {	        throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 8");	    }	    int shift = 0;	    for (int i = 0; i < nBools; i++) {	        shift = i * 1 + srcPos;	        dst[dstPos + i] = ((0x1 & (src >> shift)) != 0);	    }	    return dst;	}
protected void setEquals(final boolean isEquals) {	    this.isEquals = isEquals;	}
public static String stripEnd(final String str, final String stripChars) {	    int end;	    if (str == null || (end = str.length()) == 0) {	        return str;	    }	    if (stripChars == null) {	        while (end != 0 && Character.isWhitespace(str.charAt(end - 1))) {	            end--;	        }	    } else if (stripChars.isEmpty()) {	        return str;	    } else {	        while (end != 0 && stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND) {	            end--;	        }	    }	    return str.substring(0, end);	}
@Override	public TimeZone getTimeZone() {	    return printer.getTimeZone();	}
public static boolean containsAny(final CharSequence cs, final CharSequence searchChars) {	    if (searchChars == null) {	        return false;	    }	    return containsAny(cs, CharSequenceUtils.toCharArray(searchChars));	}
@Override	public TimeZone getTimeZone() {	    return mTimeZone;	}
public static String capitalize(final String str) {	    int strLen;	    if (str == null || (strLen = str.length()) == 0) {	        return str;	    }	    char firstChar = str.charAt(0);	    if (Character.isTitleCase(firstChar)) {	        return str;	    }	    return new StringBuilder(strLen).append(Character.toTitleCase(firstChar)).append(str.substring(1)).toString();	}
public static <T> T initialize(final ConcurrentInitializer<T> initializer) throws ConcurrentException {	    return initializer != null ? initializer.get() : null;	}
public static boolean containsNone(final CharSequence cs, final String invalidChars) {	    if (cs == null || invalidChars == null) {	        return true;	    }	    return containsNone(cs, invalidChars.toCharArray());	}
public boolean isEmpty() {	    return size == 0;	}
public boolean isAppendTransients() {	    return this.appendTransients;	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
public static String appendIfMissingIgnoreCase(final String str, final CharSequence suffix, final CharSequence... suffixes) {	    return appendIfMissing(str, suffix, true, suffixes);	}
public boolean contains(final CharRange range) {	    if (range == null) {	        throw new IllegalArgumentException("The Range must not be null");	    }	    if (negated) {	        if (range.negated) {	            return start >= range.start && end <= range.end;	        }	        return range.end < start || range.start > end;	    }	    if (range.negated) {	        return start == 0 && end == Character.MAX_VALUE;	    }	    return start <= range.start && end >= range.end;	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public static boolean isAllUpperCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isUpperCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static boolean isAscii(final char ch) {	    return ch < 128;	}
public int size() {	    return size;	}
static boolean regionMatches(final CharSequence cs, final boolean ignoreCase, final int thisStart, final CharSequence substring, final int start, final int length) {	    if (cs instanceof String && substring instanceof String) {	        return ((String) cs).regionMatches(ignoreCase, thisStart, (String) substring, start, length);	    } else {	        int index1 = thisStart;	        int index2 = start;	        int tmpLen = length;	        while (tmpLen-- > 0) {	            char c1 = cs.charAt(index1++);	            char c2 = substring.charAt(index2++);	            if (c1 == c2) {	                continue;	            }	            if (!ignoreCase) {	                return false;	            }	            if (Character.toUpperCase(c1) != Character.toUpperCase(c2) && Character.toLowerCase(c1) != Character.toLowerCase(c2)) {	                return false;	            }	        }	        return true;	    }	}
public StrTokenizer setEmptyTokenAsNull(final boolean emptyAsNull) {	    this.emptyAsNull = emptyAsNull;	    return this;	}
@Override	public long longValue() {	    return (long) value;	}
public static final String unescapeJava(final String input) {	    return UNESCAPE_JAVA.translate(input);	}
@Override	public int hashCode() {	    return toHashCode();	}
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) {	    final StringBuilder buffer = new StringBuilder();	    boolean lastOutputSeconds = false;	    final int sz = tokens.length;	    for (int i = 0; i < sz; i++) {	        final Token token = tokens[i];	        final Object value = token.getValue();	        final int count = token.getCount();	        if (value instanceof StringBuilder) {	            buffer.append(value.toString());	        } else {	            if (value == y) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years));	                lastOutputSeconds = false;	            } else if (value == M) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months));	                lastOutputSeconds = false;	            } else if (value == d) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days));	                lastOutputSeconds = false;	            } else if (value == H) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours));	                lastOutputSeconds = false;	            } else if (value == m) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes));	                lastOutputSeconds = false;	            } else if (value == s) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds));	                lastOutputSeconds = true;	            } else if (value == S) {	                if (lastOutputSeconds) {	                    milliseconds += 1000;	                    final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds);	                    buffer.append(str.substring(1));	                } else {	                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds));	                }	                lastOutputSeconds = false;	            }	        }	    }	    return buffer.toString();	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) {	    if (str == null) {	        if (trueString == null) {	            return Boolean.TRUE;	        }	        if (falseString == null) {	            return Boolean.FALSE;	        }	        if (nullString == null) {	            return null;	        }	    } else if (str.equals(trueString)) {	        return Boolean.TRUE;	    } else if (str.equals(falseString)) {	        return Boolean.FALSE;	    } else if (str.equals(nullString)) {	        return null;	    }	    throw new IllegalArgumentException("The String did not match any specified value");	}
public static Boolean[] nullToEmpty(final Boolean[] array) {	    if (array == null || array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    return array;	}
@Override	public int length() {	    return size;	}
@Override	public T call() throws Exception {	    try {	        return initialize();	    } finally {	        if (execFinally != null) {	            execFinally.shutdown();	        }	    }	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public static float min(final float a, final float b) {	    if (Float.isNaN(a)) {	        return b;	    } else if (Float.isNaN(b)) {	        return a;	    } else {	        return Math.min(a, b);	    }	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public char getEscapeChar() {	    return this.escapeChar;	}
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] result = new boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        final Boolean b = array[i];	        result[i] = (b == null ? valueForNull : b.booleanValue());	    }	    return result;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
protected String getArrayStart() {	    return arrayStart;	}
public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher) {	    if (suffixMatcher == null) {	        throw new IllegalArgumentException("Variable suffix matcher must not be null!");	    }	    this.suffixMatcher = suffixMatcher;	    return this;	}
public static String appendIfMissing(final String str, final CharSequence suffix, final CharSequence... suffixes) {	    return appendIfMissing(str, suffix, false, suffixes);	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public StrBuilder minimizeCapacity() {	    if (buffer.length > length()) {	        final char[] old = buffer;	        buffer = new char[length()];	        System.arraycopy(old, 0, buffer, 0, size);	    }	    return this;	}
public static String normalizeSpace(final String str) {	    if (str == null) {	        return null;	    }	    return WHITESPACE_PATTERN.matcher(trim(str)).replaceAll(SPACE);	}
public static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes) {	    if (0 == nBytes) {	        return dst;	    }	    if (nBytes > 16) {	        throw new IllegalArgumentException("nBytes is greather than 16");	    }	    longToByteArray(src.getMostSignificantBits(), 0, dst, dstPos, nBytes > 8 ? 8 : nBytes);	    if (nBytes >= 8) {	        longToByteArray(src.getLeastSignificantBits(), 0, dst, dstPos + 8, nBytes - 8);	    }	    return dst;	}
public int indexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex < 0 ? 0 : startIndex);	    if (matcher == null || startIndex >= size) {	        return -1;	    }	    final int len = size;	    final char[] buf = buffer;	    for (int i = startIndex; i < len; i++) {	        if (matcher.isMatch(buf, i, startIndex, len) > 0) {	            return i;	        }	    }	    return -1;	}
public boolean isEmpty() {	    return size == 0;	}
public static String removeStart(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.startsWith(remove)) {	        return str.substring(remove.length());	    }	    return str;	}
protected String getNullText() {	    return nullText;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static boolean isNotBlank(final CharSequence cs) {	    return !StringUtils.isBlank(cs);	}
public static CharRange is(final char ch) {	    return new CharRange(ch, ch, false);	}
public static String repeat(final char ch, final int repeat) {	    final char[] buf = new char[repeat];	    for (int i = repeat - 1; i >= 0; i--) {	        buf[i] = ch;	    }	    return new String(buf);	}
public static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex) {	    if (0 == nHex) {	        return dstInit;	    }	    if ((nHex - 1) * 4 + dstPos >= 32) {	        throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 32");	    }	    int out = dstInit;	    int shift = 0;	    for (int i = 0; i < nHex; i++) {	        shift = i * 4 + dstPos;	        final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift;	        final int mask = 0xf << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static final String escapeCsv(final String input) {	    return ESCAPE_CSV.translate(input);	}
protected String getSummaryObjectEndText() {	    return summaryObjectEndText;	}
public static Boolean[] nullToEmpty(final Boolean[] array) {	    if (array == null || array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    return array;	}
static JavaVersion get(final String nom) {	    if ("0.9".equals(nom)) {	        return JAVA_0_9;	    } else if ("1.1".equals(nom)) {	        return JAVA_1_1;	    } else if ("1.2".equals(nom)) {	        return JAVA_1_2;	    } else if ("1.3".equals(nom)) {	        return JAVA_1_3;	    } else if ("1.4".equals(nom)) {	        return JAVA_1_4;	    } else if ("1.5".equals(nom)) {	        return JAVA_1_5;	    } else if ("1.6".equals(nom)) {	        return JAVA_1_6;	    } else if ("1.7".equals(nom)) {	        return JAVA_1_7;	    } else if ("1.8".equals(nom)) {	        return JAVA_1_8;	    } else {	        return null;	    }	}
public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) {	    if (it != null) {	        separator = ObjectUtils.toString(separator);	        while (it.hasNext()) {	            append(it.next());	            if (it.hasNext()) {	                append(separator);	            }	        }	    }	    return this;	}
protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart) {	    this.fieldSeparatorAtStart = fieldSeparatorAtStart;	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public void reset() {	    this.isEquals = true;	}
public static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) {	    if (0 == nHexs) {	        return dstInit;	    }	    if ((nHexs - 1) * 4 + srcPos >= 64) {	        throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 64");	    }	    final StringBuilder sb = new StringBuilder(dstInit);	    int shift = 0;	    int append = sb.length();	    for (int i = 0; i < nHexs; i++) {	        shift = i * 4 + srcPos;	        final int bits = (int) (0xF & (src >> shift));	        if (dstPos + i == append) {	            ++append;	            sb.append(intToHexDigit(bits));	        } else {	            sb.setCharAt(dstPos + i, intToHexDigit(bits));	        }	    }	    return sb.toString();	}
public int toComparison() {	    return comparison;	}
public int size() {	    return size;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public void subtract(final Number operand) {	    this.value -= operand.longValue();	}
public boolean isEquals() {	    return this.isEquals;	}
public static short[] removeElement(final short[] array, final short element) {	    final int index = indexOf(array, element);	    if (index == INDEX_NOT_FOUND) {	        return clone(array);	    }	    return remove(array, index);	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public boolean isIgnoreEmptyTokens() {	    return ignoreEmptyTokens;	}
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) {	    style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));	    return this;	}
public String getNewLineText() {	    return newLine;	}
@Override	public StringBuffer format(final Calendar calendar, final StringBuffer buf) {	    return applyRules(calendar, buf);	}
public static <T> T invokeExactConstructor(final Class<T> cls, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {	    if (args == null) {	        args = ArrayUtils.EMPTY_OBJECT_ARRAY;	    }	    if (parameterTypes == null) {	        parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;	    }	    final Constructor<T> ctor = getAccessibleConstructor(cls, parameterTypes);	    if (ctor == null) {	        throw new NoSuchMethodException("No such accessible constructor on object: " + cls.getName());	    }	    return ctor.newInstance(args);	}
public static Class<?> getClass(final String className, final boolean initialize) throws ClassNotFoundException {	    final ClassLoader contextCL = Thread.currentThread().getContextClassLoader();	    final ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL;	    return getClass(loader, className, initialize);	}
public static String rightPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return rightPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return str.concat(padStr);	    } else if (pads < padLen) {	        return str.concat(padStr.substring(0, pads));	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return str.concat(new String(padding));	    }	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
protected ScheduledFuture<?> startTimer() {	    return getExecutorService().scheduleAtFixedRate(new Runnable() {		        @Override	        public void run() {	            endOfPeriod();	        }	    }, getPeriod(), getPeriod(), getUnit());	}
public static boolean containsNone(final CharSequence cs, final String invalidChars) {	    if (cs == null || invalidChars == null) {	        return true;	    }	    return containsNone(cs, invalidChars.toCharArray());	}
@Override	public void setUseFieldNames(final boolean useFieldNames) {	    super.setUseFieldNames(useFieldNames);	}
@Override	public R getRight() {	    return right;	}
public static String right(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(str.length() - len);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public void subtract(final Number operand) {	    this.value -= operand.byteValue();	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public String getNewLineText() {	    return newLine;	}
public void stop() {	    if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {	        throw new IllegalStateException("Stopwatch is not running. ");	    }	    if (this.runningState == STATE_RUNNING) {	        this.stopTime = System.nanoTime();	    }	    this.runningState = STATE_STOPPED;	}
public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) {	    if (it != null) {	        separator = ObjectUtils.toString(separator);	        while (it.hasNext()) {	            append(it.next());	            if (it.hasNext()) {	                append(separator);	            }	        }	    }	    return this;	}
public static String substringAfterLast(final String str, final String separator) {	    if (isEmpty(str)) {	        return str;	    }	    if (isEmpty(separator)) {	        return EMPTY;	    }	    final int pos = str.lastIndexOf(separator);	    if (pos == INDEX_NOT_FOUND || pos == str.length() - separator.length()) {	        return EMPTY;	    }	    return str.substring(pos + separator.length());	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
@Override	public int compareTo(final MutableDouble other) {	    final double anotherVal = other.value;	    return Double.compare(value, anotherVal);	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static String abbreviate(final String str, int offset, final int maxWidth) {	    if (str == null) {	        return null;	    }	    if (maxWidth < 4) {	        throw new IllegalArgumentException("Minimum abbreviation width is 4");	    }	    if (str.length() <= maxWidth) {	        return str;	    }	    if (offset > str.length()) {	        offset = str.length();	    }	    if (str.length() - offset < maxWidth - 3) {	        offset = str.length() - (maxWidth - 3);	    }	    final String abrevMarker = "...";	    if (offset <= 4) {	        return str.substring(0, maxWidth - 3) + abrevMarker;	    }	    if (maxWidth < 7) {	        throw new IllegalArgumentException("Minimum abbreviation width with offset is 7");	    }	    if (offset + maxWidth - 3 < str.length()) {	        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);	    }	    return abrevMarker + str.substring(str.length() - (maxWidth - 3));	}
protected boolean isFieldSeparatorAtStart() {	    return fieldSeparatorAtStart;	}
@Override	public double doubleValue() {	    return value;	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static <T extends CharSequence> T notEmpty(final T chars) {	    return notEmpty(chars, DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE);	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public StrBuilder appendPadding(final int length, final char padChar) {	    if (length >= 0) {	        ensureCapacity(size + length);	        for (int i = 0; i < length; i++) {	            buffer[size++] = padChar;	        }	    }	    return this;	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) {	    style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));	    return this;	}
public static String lowerCase(final String str, final Locale locale) {	    if (str == null) {	        return null;	    }	    return str.toLowerCase(locale);	}
static Object removeAll(final Object array, final BitSet indices) {	    final int srcLength = ArrayUtils.getLength(array);	    final int removals = indices.cardinality();	    final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals);	    int srcIndex = 0;	    int destIndex = 0;	    int count;	    int set;	    while ((set = indices.nextSetBit(srcIndex)) != -1) {	        count = set - srcIndex;	        if (count > 0) {	            System.arraycopy(array, srcIndex, result, destIndex, count);	            destIndex += count;	        }	        srcIndex = indices.nextClearBit(set);	    }	    count = srcLength - srcIndex;	    if (count > 0) {	        System.arraycopy(array, srcIndex, result, destIndex, count);	    }	    return result;	}
public static boolean isPrimitiveOrWrapper(final Class<?> type) {	    if (type == null) {	        return false;	    }	    return type.isPrimitive() || isPrimitiveWrapper(type);	}
public static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes) {	    if (0 == nBytes) {	        return dst;	    }	    if ((nBytes - 1) * 8 + srcPos >= 16) {	        throw new IllegalArgumentException("(nBytes-1)*8+srcPos is greather or equal to than 16");	    }	    int shift = 0;	    for (int i = 0; i < nBytes; i++) {	        shift = i * 8 + srcPos;	        dst[dstPos + i] = (byte) (0xff & (src >> shift));	    }	    return dst;	}
public String getNullText() {	    return nullText;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public static <T extends CharSequence> T notBlank(final T chars) {	    return notBlank(chars, DEFAULT_NOT_BLANK_EX_MESSAGE);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public String getNullText() {	    return nullText;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
@Override	public String toString() {	    return StringUtils.repeat(this.value.toString(), this.count);	}
public boolean isIgnoreEmptyTokens() {	    return ignoreEmptyTokens;	}
protected ScheduledFuture<?> startTimer() {	    return getExecutorService().scheduleAtFixedRate(new Runnable() {		        @Override	        public void run() {	            endOfPeriod();	        }	    }, getPeriod(), getPeriod(), getUnit());	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static boolean isAllUpperCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isUpperCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException {	    if (target == null) {	        throw new IllegalArgumentException("target object must not be null");	    }	    final Class<?> cls = target.getClass();	    final Field field = getDeclaredField(cls, fieldName, forceAccess);	    if (field == null) {	        throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName);	    }	    return readField(field, target);	}
public static boolean isAsciiAlpha(final char ch) {	    return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');	}
@Override	public int compare(final Object obj1, final Object obj2) {	    return ((Comparable) obj1).compareTo(obj2);	}
public String rightString(final int length) {	    if (length <= 0) {	        return "";	    } else if (length >= size) {	        return new String(buffer, 0, size);	    } else {	        return new String(buffer, size - length, length);	    }	}
protected String getContentEnd() {	    return contentEnd;	}
public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) {	    if (src.length > 8) {	        throw new IllegalArgumentException("src.length>8: src.length=" + src.length);	    }	    if (src.length - srcPos < 4) {	        throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos);	    }	    if (src[srcPos + 3]) {	        if (src[srcPos + 2]) {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return '7';	                }	            } else {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return '3';	                }	            }	        } else {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return '5';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '1';	                }	            }	        }	    } else {	        if (src[srcPos + 2]) {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'e';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return 'a';	                } else {	                    return '2';	                }	            }	        } else {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'c';	                } else {	                    return '4';	                }	            } else {	                if (src[srcPos]) {	                    return '8';	                } else {	                    return '0';	                }	            }	        }	    }	}
public String getNewLineText() {	    return newLine;	}
public static Date addSeconds(final Date date, final int amount) {	    return add(date, Calendar.SECOND, amount);	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static String stripEnd(final String str, final String stripChars) {	    int end;	    if (str == null || (end = str.length()) == 0) {	        return str;	    }	    if (stripChars == null) {	        while (end != 0 && Character.isWhitespace(str.charAt(end - 1))) {	            end--;	        }	    } else if (stripChars.isEmpty()) {	        return str;	    } else {	        while (end != 0 && stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND) {	            end--;	        }	    }	    return str.substring(0, end);	}
public static String abbreviateMiddle(final String str, final String middle, final int length) {	    if (isEmpty(str) || isEmpty(middle)) {	        return str;	    }	    if (length >= str.length() || length < middle.length() + 2) {	        return str;	    }	    final int targetSting = length - middle.length();	    final int startOffset = targetSting / 2 + targetSting % 2;	    final int endOffset = str.length() - targetSting / 2;	    final StringBuilder builder = new StringBuilder(length);	    builder.append(str.substring(0, startOffset));	    builder.append(middle);	    builder.append(str.substring(endOffset));	    return builder.toString();	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public char getEscapeChar() {	    return this.escapeChar;	}
public String getNewLineText() {	    return newLine;	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public static boolean isAlpha(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
@Override	public Integer build() {	    return Integer.valueOf(toHashCode());	}
@Override	public boolean cancel(final boolean mayInterruptIfRunning) {	    return false;	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public static String substringBetween(final String str, final String open, final String close) {	    if (str == null || open == null || close == null) {	        return null;	    }	    final int start = str.indexOf(open);	    if (start != INDEX_NOT_FOUND) {	        final int end = str.indexOf(close, start + open.length());	        if (end != INDEX_NOT_FOUND) {	            return str.substring(start + open.length(), end);	        }	    }	    return null;	}
public static Boolean or(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
public static Locale toLocale(final String str) {	    if (str == null) {	        return null;	    }	    if (str.contains("#")) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final int len = str.length();	    if (len < 2) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final char ch0 = str.charAt(0);	    if (ch0 == '_') {	        if (len < 3) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        final char ch1 = str.charAt(1);	        final char ch2 = str.charAt(2);	        if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        if (len == 3) {	            return new Locale("", str.substring(1, 3));	        }	        if (len < 5) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        if (str.charAt(3) != '_') {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        return new Locale("", str.substring(1, 3), str.substring(4));	    }	    final char ch1 = str.charAt(1);	    if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (len == 2) {	        return new Locale(str);	    }	    if (len < 5) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (str.charAt(2) != '_') {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final char ch3 = str.charAt(3);	    if (ch3 == '_') {	        return new Locale(str.substring(0, 2), "", str.substring(4));	    }	    final char ch4 = str.charAt(4);	    if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (len == 5) {	        return new Locale(str.substring(0, 2), str.substring(3, 5));	    }	    if (len < 7) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (str.charAt(5) != '_') {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));	}
@Override	public void write(final String str, final int off, final int len) {	    StrBuilder.this.append(str, off, len);	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public static String swapCase(final String str) {	    if (StringUtils.isEmpty(str)) {	        return str;	    }	    final char[] buffer = str.toCharArray();	    for (int i = 0; i < buffer.length; i++) {	        final char ch = buffer[i];	        if (Character.isUpperCase(ch)) {	            buffer[i] = Character.toLowerCase(ch);	        } else if (Character.isTitleCase(ch)) {	            buffer[i] = Character.toLowerCase(ch);	        } else if (Character.isLowerCase(ch)) {	            buffer[i] = Character.toUpperCase(ch);	        }	    }	    return new String(buffer);	}
public static void handleCauseUnchecked(final ExecutionException ex) {	    final ConcurrentRuntimeException crex = extractCauseUnchecked(ex);	    if (crex != null) {	        throw crex;	    }	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
@Override	public int compare(final Object obj1, final Object obj2) {	    return ((Comparable) obj1).compareTo(obj2);	}
protected String getContentEnd() {	    return contentEnd;	}
public static String formatPeriodISO(final long startMillis, final long endMillis) {	    return formatPeriod(startMillis, endMillis, ISO_EXTENDED_FORMAT_PATTERN, false, TimeZone.getDefault());	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
@Override	public T get(final long timeout, final TimeUnit unit) {	    return value;	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
@Override	public void setValue(final Number value) {	    this.value = value.shortValue();	}
public boolean isEmpty() {	    return size == 0;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public boolean isAfter(final T element) {	    if (element == null) {	        return false;	    }	    return comparator.compare(element, minimum) < 0;	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) {	    if (toClass == null) {	        return false;	    }	    if (cls == null) {	        return !toClass.isPrimitive();	    }	    if (autoboxing) {	        if (cls.isPrimitive() && !toClass.isPrimitive()) {	            cls = primitiveToWrapper(cls);	            if (cls == null) {	                return false;	            }	        }	        if (toClass.isPrimitive() && !cls.isPrimitive()) {	            cls = wrapperToPrimitive(cls);	            if (cls == null) {	                return false;	            }	        }	    }	    if (cls.equals(toClass)) {	        return true;	    }	    if (cls.isPrimitive()) {	        if (toClass.isPrimitive() == false) {	            return false;	        }	        if (Integer.TYPE.equals(cls)) {	            return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Long.TYPE.equals(cls)) {	            return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Boolean.TYPE.equals(cls)) {	            return false;	        }	        if (Double.TYPE.equals(cls)) {	            return false;	        }	        if (Float.TYPE.equals(cls)) {	            return Double.TYPE.equals(toClass);	        }	        if (Character.TYPE.equals(cls)) {	            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Short.TYPE.equals(cls)) {	            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Byte.TYPE.equals(cls)) {	            return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        return false;	    }	    return toClass.isAssignableFrom(cls);	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
public static char binaryToHexDigit(final boolean[] src, final int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    if (src.length > srcPos + 3 && src[srcPos + 3]) {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src[srcPos]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
public static int toIntValue(final Character ch, final int defaultValue) {	    if (ch == null) {	        return defaultValue;	    }	    return toIntValue(ch.charValue(), defaultValue);	}
public int size() {	    return size;	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public int capacity() {	    return buffer.length;	}
public static char intToHexDigit(final int nibble) {	    final char c = Character.forDigit(nibble, 16);	    if (c == Character.MIN_VALUE) {	        throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble);	    }	    return c;	}
public static String overlay(final String str, String overlay, int start, int end) {	    if (str == null) {	        return null;	    }	    if (overlay == null) {	        overlay = EMPTY;	    }	    final int len = str.length();	    if (start < 0) {	        start = 0;	    }	    if (start > len) {	        start = len;	    }	    if (end < 0) {	        end = 0;	    }	    if (end > len) {	        end = len;	    }	    if (start > end) {	        final int temp = start;	        start = end;	        end = temp;	    }	    return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString();	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    int max = longest;	    if (index + longest > input.length()) {	        max = input.length() - index;	    }	    for (int i = max; i >= shortest; i--) {	        final CharSequence subSeq = input.subSequence(index, index + i);	        final CharSequence result = lookupMap.get(subSeq.toString());	        if (result != null) {	            out.write(result.toString());	            return i;	        }	    }	    return 0;	}
public static String[] substringsBetween(final String str, final String open, final String close) {	    if (str == null || isEmpty(open) || isEmpty(close)) {	        return null;	    }	    final int strLen = str.length();	    if (strLen == 0) {	        return ArrayUtils.EMPTY_STRING_ARRAY;	    }	    final int closeLen = close.length();	    final int openLen = open.length();	    final List<String> list = new ArrayList<String>();	    int pos = 0;	    while (pos < strLen - closeLen) {	        int start = str.indexOf(open, pos);	        if (start < 0) {	            break;	        }	        start += openLen;	        final int end = str.indexOf(close, start);	        if (end < 0) {	            break;	        }	        list.add(str.substring(start, end));	        pos = end + closeLen;	    }	    if (list.isEmpty()) {	        return null;	    }	    return list.toArray(new String[list.size()]);	}
public boolean isEmptyTokenAsNull() {	    return this.emptyAsNull;	}
public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {	    if (str == null || searchStr == null) {	        return INDEX_NOT_FOUND;	    }	    if (startPos > str.length() - searchStr.length()) {	        startPos = str.length() - searchStr.length();	    }	    if (startPos < 0) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return startPos;	    }	    for (int i = startPos; i >= 0; i--) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static StrMatcher charSetMatcher(final String chars) {	    if (StringUtils.isEmpty(chars)) {	        return NONE_MATCHER;	    }	    if (chars.length() == 1) {	        return new CharMatcher(chars.charAt(0));	    }	    return new CharSetMatcher(chars.toCharArray());	}
public int size() {	    return size;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public boolean isEmpty() {	    return size == 0;	}
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) {	    return new Range<T>(fromInclusive, toInclusive, comparator);	}
protected boolean isArrayContentDetail() {	    return arrayContentDetail;	}
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) {	    return new Range<T>(fromInclusive, toInclusive, comparator);	}
public void subtract(final Number operand) {	    this.value -= operand.intValue();	}
public static boolean isAllUpperCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isUpperCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public int size() {	    return size;	}
public static String substringAfter(final String str, final String separator) {	    if (isEmpty(str)) {	        return str;	    }	    if (separator == null) {	        return EMPTY;	    }	    final int pos = str.indexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return EMPTY;	    }	    return str.substring(pos + separator.length());	}
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) {	    if (str == null) {	        if (trueString == null) {	            return Boolean.TRUE;	        }	        if (falseString == null) {	            return Boolean.FALSE;	        }	        if (nullString == null) {	            return null;	        }	    } else if (str.equals(trueString)) {	        return Boolean.TRUE;	    } else if (str.equals(falseString)) {	        return Boolean.FALSE;	    } else if (str.equals(nullString)) {	        return null;	    }	    throw new IllegalArgumentException("The String did not match any specified value");	}
public static Object readField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException {	    if (target == null) {	        throw new IllegalArgumentException("target object must not be null");	    }	    final Class<?> cls = target.getClass();	    final Field field = getField(cls, fieldName, forceAccess);	    if (field == null) {	        throw new IllegalArgumentException("Cannot locate field " + fieldName + " on " + cls);	    }	    return readField(field, target);	}
public static String getPackageName(String className) {	    if (StringUtils.isEmpty(className)) {	        return StringUtils.EMPTY;	    }	    while (className.charAt(0) == '[') {	        className = className.substring(1);	    }	    if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {	        className = className.substring(1);	    }	    final int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);	    if (i == -1) {	        return StringUtils.EMPTY;	    }	    return className.substring(0, i);	}
public static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) {	    if (0 == nHexs) {	        return dstInit;	    }	    if ((nHexs - 1) * 4 + srcPos >= 32) {	        throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 32");	    }	    final StringBuilder sb = new StringBuilder(dstInit);	    int shift = 0;	    int append = sb.length();	    for (int i = 0; i < nHexs; i++) {	        shift = i * 4 + srcPos;	        final int bits = 0xF & (src >> shift);	        if (dstPos + i == append) {	            ++append;	            sb.append(intToHexDigit(bits));	        } else {	            sb.setCharAt(dstPos + i, intToHexDigit(bits));	        }	    }	    return sb.toString();	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
@Override	public StringBuffer format(final Calendar calendar, final StringBuffer buf) {	    return printer.format(calendar, buf);	}
public static String capitalize(final String str, final char... delimiters) {	    final int delimLen = delimiters == null ? -1 : delimiters.length;	    if (StringUtils.isEmpty(str) || delimLen == 0) {	        return str;	    }	    final char[] buffer = str.toCharArray();	    boolean capitalizeNext = true;	    for (int i = 0; i < buffer.length; i++) {	        final char ch = buffer[i];	        if (isDelimiter(ch, delimiters)) {	            capitalizeNext = true;	        } else if (capitalizeNext) {	            buffer[i] = Character.toTitleCase(ch);	            capitalizeNext = false;	        }	    }	    return new String(buffer);	}
@Override	public int hashCode() {	    return id;	}
public static String rightPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return rightPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return str.concat(padStr);	    } else if (pads < padLen) {	        return str.concat(padStr.substring(0, pads));	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return str.concat(new String(padding));	    }	}
public EqualsBuilder appendSuper(final boolean superEquals) {	    if (isEquals == false) {	        return this;	    }	    isEquals = superEquals;	    return this;	}
@Override	public CharSequence subSequence(final int startIndex, final int endIndex) {	    if (startIndex < 0) {	        throw new StringIndexOutOfBoundsException(startIndex);	    }	    if (endIndex > size) {	        throw new StringIndexOutOfBoundsException(endIndex);	    }	    if (startIndex > endIndex) {	        throw new StringIndexOutOfBoundsException(endIndex - startIndex);	    }	    return substring(startIndex, endIndex);	}
public int size() {	    return size;	}
@Override	public StringBuffer format(final Calendar calendar, final StringBuffer buf) {	    return printer.format(calendar, buf);	}
public int getDenominator() {	    return denominator;	}
public int toHashCode() {	    return iTotal;	}
public static float max(final float a, final float b) {	    if (Float.isNaN(a)) {	        return b;	    } else if (Float.isNaN(b)) {	        return a;	    } else {	        return Math.max(a, b);	    }	}
public static String chop(final String str) {	    if (str == null) {	        return null;	    }	    final int strLen = str.length();	    if (strLen < 2) {	        return EMPTY;	    }	    final int lastIdx = strLen - 1;	    final String ret = str.substring(0, lastIdx);	    final char last = str.charAt(lastIdx);	    if (last == CharUtils.LF && ret.charAt(lastIdx - 1) == CharUtils.CR) {	        return ret.substring(0, lastIdx - 1);	    }	    return ret;	}
public int getDenominator() {	    return denominator;	}
public boolean isEmpty() {	    return size == 0;	}
private static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal, final boolean lastIndex) {	    if (str == null || searchStr == null || ordinal <= 0) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return lastIndex ? str.length() : 0;	    }	    int found = 0;	    int index = lastIndex ? str.length() : INDEX_NOT_FOUND;	    do {	        if (lastIndex) {	            index = CharSequenceUtils.lastIndexOf(str, searchStr, index - 1);	        } else {	            index = CharSequenceUtils.indexOf(str, searchStr, index + 1);	        }	        if (index < 0) {	            return index;	        }	        found++;	    } while (found < ordinal);	    return index;	}
public static String trimToNull(final String str) {	    final String ts = trim(str);	    return isEmpty(ts) ? null : ts;	}
public static Fraction getReducedFraction(int numerator, int denominator) {	    if (denominator == 0) {	        throw new ArithmeticException("The denominator must not be zero");	    }	    if (numerator == 0) {	        return ZERO;	    }	    if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) {	        numerator /= 2;	        denominator /= 2;	    }	    if (denominator < 0) {	        if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {	            throw new ArithmeticException("overflow: can't negate");	        }	        numerator = -numerator;	        denominator = -denominator;	    }	    final int gcd = greatestCommonDivisor(numerator, denominator);	    numerator /= gcd;	    denominator /= gcd;	    return new Fraction(numerator, denominator);	}
public static boolean isAlphanumeric(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetterOrDigit(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public int size() {	    return size;	}
@Override	public int length() {	    return size;	}
@Override	public int hashCode() {	    return toHashCode();	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public boolean isAfter(final T element) {	    if (element == null) {	        return false;	    }	    return comparator.compare(element, minimum) < 0;	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public StrBuilder ensureCapacity(final int capacity) {	    if (capacity > buffer.length) {	        final char[] old = buffer;	        buffer = new char[capacity * 2];	        System.arraycopy(old, 0, buffer, 0, size);	    }	    return this;	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
@Override	public boolean equals(final Object obj) {	    if (obj == this) {	        return true;	    }	    if (obj instanceof Fraction == false) {	        return false;	    }	    final Fraction other = (Fraction) obj;	    return getNumerator() == other.getNumerator() && getDenominator() == other.getDenominator();	}
public static String defaultString(final String str, final String defaultStr) {	    return str == null ? defaultStr : str;	}
public void resume() {	    if (this.runningState != STATE_SUSPENDED) {	        throw new IllegalStateException("Stopwatch must be suspended to resume. ");	    }	    this.startTime += System.nanoTime() - this.stopTime;	    this.runningState = STATE_RUNNING;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public Fraction invert() {	    if (numerator == 0) {	        throw new ArithmeticException("Unable to invert zero.");	    }	    if (numerator == Integer.MIN_VALUE) {	        throw new ArithmeticException("overflow: can't negate numerator");	    }	    if (numerator < 0) {	        return new Fraction(-denominator, -numerator);	    } else {	        return new Fraction(denominator, numerator);	    }	}
public static String capitalize(final String str) {	    int strLen;	    if (str == null || (strLen = str.length()) == 0) {	        return str;	    }	    char firstChar = str.charAt(0);	    if (Character.isTitleCase(firstChar)) {	        return str;	    }	    return new StringBuilder(strLen).append(Character.toTitleCase(firstChar)).append(str.substring(1)).toString();	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static Boolean[] toObject(final boolean[] array) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    final Boolean[] result = new Boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        result[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE);	    }	    return result;	}
public static CharRange isNot(final char ch) {	    return new CharRange(ch, ch, true);	}
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) {	    style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));	    return this;	}
public static <L, M, R> Triple<L, M, R> of(final L left, final M middle, final R right) {	    return new ImmutableTriple<L, M, R>(left, middle, right);	}
protected boolean isUseShortClassName() {	    return useShortClassName;	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static String getPackageCanonicalName(final String canonicalName) {	    return ClassUtils.getPackageName(getCanonicalName(canonicalName));	}
public boolean isAppendStatics() {	    return this.appendStatics;	}
public static boolean isEmpty(final CharSequence cs) {	    return cs == null || cs.length() == 0;	}
public int toComparison() {	    return comparison;	}
public static boolean isAllUpperCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isUpperCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
protected String getFieldNameValueSeparator() {	    return fieldNameValueSeparator;	}
public static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes) {	    if (0 == nBytes) {	        return dst;	    }	    if (nBytes > 16) {	        throw new IllegalArgumentException("nBytes is greather than 16");	    }	    longToByteArray(src.getMostSignificantBits(), 0, dst, dstPos, nBytes > 8 ? 8 : nBytes);	    if (nBytes >= 8) {	        longToByteArray(src.getLeastSignificantBits(), 0, dst, dstPos + 8, nBytes - 8);	    }	    return dst;	}
static Throwable checkedException(final Throwable ex) {	    if (ex != null && !(ex instanceof RuntimeException) && !(ex instanceof Error)) {	        return ex;	    } else {	        throw new IllegalArgumentException("Not a checked exception: " + ex);	    }	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
private static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal, final boolean lastIndex) {	    if (str == null || searchStr == null || ordinal <= 0) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return lastIndex ? str.length() : 0;	    }	    int found = 0;	    int index = lastIndex ? str.length() : INDEX_NOT_FOUND;	    do {	        if (lastIndex) {	            index = CharSequenceUtils.lastIndexOf(str, searchStr, index - 1);	        } else {	            index = CharSequenceUtils.indexOf(str, searchStr, index + 1);	        }	        if (index < 0) {	            return index;	        }	        found++;	    } while (found < ordinal);	    return index;	}
public static StrTokenizer getCSVInstance(final char[] input) {	    final StrTokenizer tok = getCSVClone();	    tok.reset(input);	    return tok;	}
public static String randomAlphanumeric(final int count) {	    return random(count, true, true);	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
@Override	public boolean ready() {	    return pos < StrBuilder.this.size();	}
public static int indexOfAnyBut(final CharSequence seq, final CharSequence searchChars) {	    if (isEmpty(seq) || isEmpty(searchChars)) {	        return INDEX_NOT_FOUND;	    }	    final int strLen = seq.length();	    for (int i = 0; i < strLen; i++) {	        final char ch = seq.charAt(i);	        final boolean chFound = CharSequenceUtils.indexOf(searchChars, ch, 0) >= 0;	        if (i + 1 < strLen && Character.isHighSurrogate(ch)) {	            final char ch2 = seq.charAt(i + 1);	            if (chFound && CharSequenceUtils.indexOf(searchChars, ch2, 0) < 0) {	                return i;	            }	        } else {	            if (!chFound) {	                return i;	            }	        }	    }	    return INDEX_NOT_FOUND;	}
protected String getFieldNameValueSeparator() {	    return fieldNameValueSeparator;	}
public static CharSequence subSequence(final CharSequence cs, final int start) {	    return cs == null ? null : cs.subSequence(start, cs.length());	}
public static boolean contains(final boolean[] array, final boolean valueToFind) {	    return indexOf(array, valueToFind) != INDEX_NOT_FOUND;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
@Override	public void setValue(final T value) {	    this.value = value;	}
public static boolean[] clone(final boolean[] array) {	    if (array == null) {	        return null;	    }	    return array.clone();	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
@Override	public int intValue() {	    return numerator / denominator;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
@Deprecated	public static String chomp(final String str, final String separator) {	    return removeEnd(str, separator);	}
public int size() {	    return size;	}
public String getNullText() {	    return nullText;	}
protected String getSummaryObjectEndText() {	    return summaryObjectEndText;	}
public Fraction reduce() {	    if (numerator == 0) {	        return equals(ZERO) ? this : ZERO;	    }	    final int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);	    if (gcd == 1) {	        return this;	    }	    return Fraction.getFraction(numerator / gcd, denominator / gcd);	}
public static String removePattern(final String source, final String regex) {	    return replacePattern(source, regex, StringUtils.EMPTY);	}
@Override	public int length() {	    return size;	}
public int lastIndexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex >= size ? size - 1 : startIndex);	    if (matcher == null || startIndex < 0) {	        return -1;	    }	    final char[] buf = buffer;	    final int endIndex = startIndex + 1;	    for (int i = startIndex; i >= 0; i--) {	        if (matcher.isMatch(buf, i, 0, endIndex) > 0) {	            return i;	        }	    }	    return -1;	}
public static String chop(final String str) {	    if (str == null) {	        return null;	    }	    final int strLen = str.length();	    if (strLen < 2) {	        return EMPTY;	    }	    final int lastIdx = strLen - 1;	    final String ret = str.substring(0, lastIdx);	    final char last = str.charAt(lastIdx);	    if (last == CharUtils.LF && ret.charAt(lastIdx - 1) == CharUtils.CR) {	        return ret.substring(0, lastIdx - 1);	    }	    return ret;	}
public static String lowerCase(final String str, final Locale locale) {	    if (str == null) {	        return null;	    }	    return str.toLowerCase(locale);	}
public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) {	    if (array == null) {	        return null;	    }	    if (startIndexInclusive < 0) {	        startIndexInclusive = 0;	    }	    if (endIndexExclusive > array.length) {	        endIndexExclusive = array.length;	    }	    final int newSize = endIndexExclusive - startIndexInclusive;	    if (newSize <= 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] subarray = new boolean[newSize];	    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);	    return subarray;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public static CharRange is(final char ch) {	    return new CharRange(ch, ch, false);	}
@Override	public int length() {	    return size;	}
public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final E... values) {	    asEnum(enumClass);	    Validate.noNullElements(values);	    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);	    Collections.addAll(condensed, values);	    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];	    for (final E value : condensed) {	        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);	    }	    ArrayUtils.reverse(result);	    return result;	}
public static String prependIfMissingIgnoreCase(final String str, final CharSequence prefix, final CharSequence... prefixes) {	    return prependIfMissing(str, prefix, true, prefixes);	}
public static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes) {	    if ((src.length == 0 && srcPos == 0) || 0 == nBytes) {	        return dstInit;	    }	    if ((nBytes - 1) * 8 + dstPos >= 32) {	        throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 32");	    }	    int out = dstInit;	    int shift = 0;	    for (int i = 0; i < nBytes; i++) {	        shift = i * 8 + dstPos;	        final int bits = (0xff & src[i + srcPos]) << shift;	        final int mask = 0xff << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
public static String capitalize(final String str, final char... delimiters) {	    final int delimLen = delimiters == null ? -1 : delimiters.length;	    if (StringUtils.isEmpty(str) || delimLen == 0) {	        return str;	    }	    final char[] buffer = str.toCharArray();	    boolean capitalizeNext = true;	    for (int i = 0; i < buffer.length; i++) {	        final char ch = buffer[i];	        if (isDelimiter(ch, delimiters)) {	            capitalizeNext = true;	        } else if (capitalizeNext) {	            buffer[i] = Character.toTitleCase(ch);	            capitalizeNext = false;	        }	    }	    return new String(buffer);	}
public static Date truncate(final Object date, final int field) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (date instanceof Date) {	        return truncate((Date) date, field);	    } else if (date instanceof Calendar) {	        return truncate((Calendar) date, field).getTime();	    } else {	        throw new ClassCastException("Could not truncate " + date);	    }	}
protected String getContentStart() {	    return contentStart;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public static String[] substringsBetween(final String str, final String open, final String close) {	    if (str == null || isEmpty(open) || isEmpty(close)) {	        return null;	    }	    final int strLen = str.length();	    if (strLen == 0) {	        return ArrayUtils.EMPTY_STRING_ARRAY;	    }	    final int closeLen = close.length();	    final int openLen = open.length();	    final List<String> list = new ArrayList<String>();	    int pos = 0;	    while (pos < strLen - closeLen) {	        int start = str.indexOf(open, pos);	        if (start < 0) {	            break;	        }	        start += openLen;	        final int end = str.indexOf(close, start);	        if (end < 0) {	            break;	        }	        list.add(str.substring(start, end));	        pos = end + closeLen;	    }	    if (list.isEmpty()) {	        return null;	    }	    return list.toArray(new String[list.size()]);	}
public static StrMatcher charMatcher(final char ch) {	    return new CharMatcher(ch);	}
@Override	public int length() {	    return size;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public boolean isEmpty() {	    return size == 0;	}
public static StrTokenizer getTSVInstance(final char[] input) {	    final StrTokenizer tok = getTSVClone();	    tok.reset(input);	    return tok;	}
public static Boolean[] toObject(final boolean[] array) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    final Boolean[] result = new Boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        result[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE);	    }	    return result;	}
public static float max(final float a, final float b, final float c) {	    return Math.max(Math.max(a, b), c);	}
protected String getArrayStart() {	    return arrayStart;	}
public static String leftPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return leftPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return padStr.concat(str);	    } else if (pads < padLen) {	        return padStr.substring(0, pads).concat(str);	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return new String(padding).concat(str);	    }	}
@Override	public long longValue() {	    return value;	}
public int capacity() {	    return buffer.length;	}
public boolean isEmptyTokenAsNull() {	    return this.emptyAsNull;	}
public String getNewLineText() {	    return newLine;	}
@Override	public int length() {	    return size;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public boolean isAfter(final T element) {	    if (element == null) {	        return false;	    }	    return comparator.compare(element, minimum) < 0;	}
@Override	public int previousIndex() {	    return tokenPos - 1;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static boolean containsNone(final CharSequence cs, final String invalidChars) {	    if (cs == null || invalidChars == null) {	        return true;	    }	    return containsNone(cs, invalidChars.toCharArray());	}
public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final E... values) {	    asEnum(enumClass);	    Validate.noNullElements(values);	    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);	    Collections.addAll(condensed, values);	    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];	    for (final E value : condensed) {	        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);	    }	    ArrayUtils.reverse(result);	    return result;	}
@Override	public String getArrayStart() {	    return super.getArrayStart();	}
public static String leftPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return leftPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return padStr.concat(str);	    } else if (pads < padLen) {	        return padStr.substring(0, pads).concat(str);	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return new String(padding).concat(str);	    }	}
@Override	public TimeZone getTimeZone() {	    return timeZone;	}
public StrBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar) {	    return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
@Override	public void setSummaryObjectEndText(final String summaryObjectEndText) {	    super.setSummaryObjectEndText(summaryObjectEndText);	}
public int size() {	    return size;	}
public static boolean isAlphanumeric(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetterOrDigit(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static String removeStart(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.startsWith(remove)) {	        return str.substring(remove.length());	    }	    return str;	}
public boolean isIgnoreEmptyTokens() {	    return ignoreEmptyTokens;	}
public static Double createDouble(final String str) {	    if (str == null) {	        return null;	    }	    return Double.valueOf(str);	}
public static BigDecimal createBigDecimal(final String str) {	    if (str == null) {	        return null;	    }	    if (StringUtils.isBlank(str)) {	        throw new NumberFormatException("A blank string is not a valid number");	    }	    if (str.trim().startsWith("--")) {	        throw new NumberFormatException(str + " is not a valid number.");	    }	    return new BigDecimal(str);	}
@Override	public int intValue() {	    return (int) value;	}
@Override	public boolean ready() {	    return pos < StrBuilder.this.size();	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static String trim(final String str) {	    return str == null ? null : str.trim();	}
public static String leftPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return leftPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return padStr.concat(str);	    } else if (pads < padLen) {	        return padStr.substring(0, pads).concat(str);	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return new String(padding).concat(str);	    }	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    final int seqEnd = input.length();	    if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') {	        int start = index + 2;	        boolean isHex = false;	        final char firstChar = input.charAt(start);	        if (firstChar == 'x' || firstChar == 'X') {	            start++;	            isHex = true;	            if (start == seqEnd) {	                return 0;	            }	        }	        int end = start;	        while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) {	            end++;	        }	        final boolean semiNext = end != seqEnd && input.charAt(end) == ';';	        if (!semiNext) {	            if (isSet(OPTION.semiColonRequired)) {	                return 0;	            } else if (isSet(OPTION.errorIfNoSemiColon)) {	                throw new IllegalArgumentException("Semi-colon required at end of numeric entity");	            }	        }	        int entityValue;	        try {	            if (isHex) {	                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);	            } else {	                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);	            }	        } catch (final NumberFormatException nfe) {	            return 0;	        }	        if (entityValue > 0xFFFF) {	            final char[] chrs = Character.toChars(entityValue);	            out.write(chrs[0]);	            out.write(chrs[1]);	        } else {	            out.write(entityValue);	        }	        return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0);	    }	    return 0;	}
public static <T> T initialize(final ConcurrentInitializer<T> initializer) throws ConcurrentException {	    return initializer != null ? initializer.get() : null;	}
private static Date set(final Date date, final int calendarField, final int amount) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final Calendar c = Calendar.getInstance();	    c.setLenient(false);	    c.setTime(date);	    c.set(calendarField, amount);	    return c.getTime();	}
@Override	public int length() {	    return size;	}
public boolean isNegated() {	    return negated;	}
@Override	public void reset() {	    pos = mark;	}
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException {	    return charsetName == null ? new String(bytes) : new String(bytes, charsetName);	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static Class<?> primitiveToWrapper(final Class<?> cls) {	    Class<?> convertedClass = cls;	    if (cls != null && cls.isPrimitive()) {	        convertedClass = primitiveWrapperMap.get(cls);	    }	    return convertedClass;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public StrBuilder appendSeparator(final char separator, final int loopIndex) {	    if (loopIndex > 0) {	        append(separator);	    }	    return this;	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
@Override	public TimeZone getTimeZone() {	    return timeZone;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public static String abbreviate(final String str, int offset, final int maxWidth) {	    if (str == null) {	        return null;	    }	    if (maxWidth < 4) {	        throw new IllegalArgumentException("Minimum abbreviation width is 4");	    }	    if (str.length() <= maxWidth) {	        return str;	    }	    if (offset > str.length()) {	        offset = str.length();	    }	    if (str.length() - offset < maxWidth - 3) {	        offset = str.length() - (maxWidth - 3);	    }	    final String abrevMarker = "...";	    if (offset <= 4) {	        return str.substring(0, maxWidth - 3) + abrevMarker;	    }	    if (maxWidth < 7) {	        throw new IllegalArgumentException("Minimum abbreviation width with offset is 7");	    }	    if (offset + maxWidth - 3 < str.length()) {	        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);	    }	    return abrevMarker + str.substring(str.length() - (maxWidth - 3));	}
public int indexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex < 0 ? 0 : startIndex);	    if (matcher == null || startIndex >= size) {	        return -1;	    }	    final int len = size;	    final char[] buf = buffer;	    for (int i = startIndex; i < len; i++) {	        if (matcher.isMatch(buf, i, startIndex, len) > 0) {	            return i;	        }	    }	    return -1;	}
static JavaVersion getJavaVersion(final String nom) {	    return get(nom);	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public boolean equalsIgnoreCase(final StrBuilder other) {	    if (this == other) {	        return true;	    }	    if (this.size != other.size) {	        return false;	    }	    final char[] thisBuf = this.buffer;	    final char[] otherBuf = other.buffer;	    for (int i = size - 1; i >= 0; i--) {	        final char c1 = thisBuf[i];	        final char c2 = otherBuf[i];	        if (c1 != c2 && Character.toUpperCase(c1) != Character.toUpperCase(c2)) {	            return false;	        }	    }	    return true;	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static String stripStart(final String str, final String stripChars) {	    int strLen;	    if (str == null || (strLen = str.length()) == 0) {	        return str;	    }	    int start = 0;	    if (stripChars == null) {	        while (start != strLen && Character.isWhitespace(str.charAt(start))) {	            start++;	        }	    } else if (stripChars.isEmpty()) {	        return str;	    } else {	        while (start != strLen && stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND) {	            start++;	        }	    }	    return str.substring(start);	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
@Override	public int length() {	    return size;	}
@Override	public int length() {	    return size;	}
public static boolean isBlank(final CharSequence cs) {	    int strLen;	    if (cs == null || (strLen = cs.length()) == 0) {	        return true;	    }	    for (int i = 0; i < strLen; i++) {	        if (Character.isWhitespace(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public void stop() {	    if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {	        throw new IllegalStateException("Stopwatch is not running. ");	    }	    if (this.runningState == STATE_RUNNING) {	        this.stopTime = System.nanoTime();	    }	    this.runningState = STATE_STOPPED;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public int elementCompareTo(final T element) {	    if (element == null) {	        throw new NullPointerException("Element is null");	    }	    if (isAfter(element)) {	        return -1;	    } else if (isBefore(element)) {	        return 1;	    } else {	        return 0;	    }	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
@Override	public double doubleValue() {	    return value;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
protected String getNullText() {	    return nullText;	}
public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale) {	    return cache.getDateInstance(style, timeZone, locale);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) {	    if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {	        return text;	    }	    if (timeToLive < 0) {	        throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another");	    }	    final int searchLength = searchList.length;	    final int replacementLength = replacementList.length;	    if (searchLength != replacementLength) {	        throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength);	    }	    final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];	    int textIndex = -1;	    int replaceIndex = -1;	    int tempIndex = -1;	    for (int i = 0; i < searchLength; i++) {	        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {	            continue;	        }	        tempIndex = text.indexOf(searchList[i]);	        if (tempIndex == -1) {	            noMoreMatchesForReplIndex[i] = true;	        } else {	            if (textIndex == -1 || tempIndex < textIndex) {	                textIndex = tempIndex;	                replaceIndex = i;	            }	        }	    }	    if (textIndex == -1) {	        return text;	    }	    int start = 0;	    int increase = 0;	    for (int i = 0; i < searchList.length; i++) {	        if (searchList[i] == null || replacementList[i] == null) {	            continue;	        }	        final int greater = replacementList[i].length() - searchList[i].length();	        if (greater > 0) {	            increase += 3 * greater;	        }	    }	    increase = Math.min(increase, text.length() / 5);	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (textIndex != -1) {	        for (int i = start; i < textIndex; i++) {	            buf.append(text.charAt(i));	        }	        buf.append(replacementList[replaceIndex]);	        start = textIndex + searchList[replaceIndex].length();	        textIndex = -1;	        replaceIndex = -1;	        tempIndex = -1;	        for (int i = 0; i < searchLength; i++) {	            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {	                continue;	            }	            tempIndex = text.indexOf(searchList[i], start);	            if (tempIndex == -1) {	                noMoreMatchesForReplIndex[i] = true;	            } else {	                if (textIndex == -1 || tempIndex < textIndex) {	                    textIndex = tempIndex;	                    replaceIndex = i;	                }	            }	        }	    }	    final int textLength = text.length();	    for (int i = start; i < textLength; i++) {	        buf.append(text.charAt(i));	    }	    final String result = buf.toString();	    if (!repeat) {	        return result;	    }	    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);	}
public boolean isEquals() {	    return this.isEquals;	}
public static boolean isAllUpperCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isUpperCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public StrBuilder replaceAll(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, -1);	}
public static Locale toLocale(final String str) {	    if (str == null) {	        return null;	    }	    if (str.contains("#")) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final int len = str.length();	    if (len < 2) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final char ch0 = str.charAt(0);	    if (ch0 == '_') {	        if (len < 3) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        final char ch1 = str.charAt(1);	        final char ch2 = str.charAt(2);	        if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        if (len == 3) {	            return new Locale("", str.substring(1, 3));	        }	        if (len < 5) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        if (str.charAt(3) != '_') {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        return new Locale("", str.substring(1, 3), str.substring(4));	    }	    final char ch1 = str.charAt(1);	    if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (len == 2) {	        return new Locale(str);	    }	    if (len < 5) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (str.charAt(2) != '_') {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final char ch3 = str.charAt(3);	    if (ch3 == '_') {	        return new Locale(str.substring(0, 2), "", str.substring(4));	    }	    final char ch4 = str.charAt(4);	    if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (len == 5) {	        return new Locale(str.substring(0, 2), str.substring(3, 5));	    }	    if (len < 7) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (str.charAt(5) != '_') {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));	}
@Override	public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) {	    return formatter.format(obj, toAppendTo, pos);	}
public static boolean isAlphanumericSpace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetterOrDigit(cs.charAt(i)) == false && cs.charAt(i) != ' ') {	            return false;	        }	    }	    return true;	}
public static boolean containsIgnoreCase(final CharSequence str, final CharSequence searchStr) {	    if (str == null || searchStr == null) {	        return false;	    }	    final int len = searchStr.length();	    final int max = str.length() - len;	    for (int i = 0; i <= max; i++) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, len)) {	            return true;	        }	    }	    return false;	}
public static String removeEndIgnoreCase(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (endsWithIgnoreCase(str, remove)) {	        return str.substring(0, str.length() - remove.length());	    }	    return str;	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
public String getNullText() {	    return nullText;	}
public StrBuilder ensureCapacity(final int capacity) {	    if (capacity > buffer.length) {	        final char[] old = buffer;	        buffer = new char[capacity * 2];	        System.arraycopy(old, 0, buffer, 0, size);	    }	    return this;	}
public static String leftPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return leftPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return padStr.concat(str);	    } else if (pads < padLen) {	        return padStr.substring(0, pads).concat(str);	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return new String(padding).concat(str);	    }	}
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException {	    return charsetName == null ? new String(bytes) : new String(bytes, charsetName);	}
public static void handleCause(final ExecutionException ex) throws ConcurrentException {	    final ConcurrentException cex = extractCause(ex);	    if (cex != null) {	        throw cex;	    }	}
@Override	public int length() {	    return size;	}
public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) {	    if (toClass == null) {	        return false;	    }	    if (cls == null) {	        return !toClass.isPrimitive();	    }	    if (autoboxing) {	        if (cls.isPrimitive() && !toClass.isPrimitive()) {	            cls = primitiveToWrapper(cls);	            if (cls == null) {	                return false;	            }	        }	        if (toClass.isPrimitive() && !cls.isPrimitive()) {	            cls = wrapperToPrimitive(cls);	            if (cls == null) {	                return false;	            }	        }	    }	    if (cls.equals(toClass)) {	        return true;	    }	    if (cls.isPrimitive()) {	        if (toClass.isPrimitive() == false) {	            return false;	        }	        if (Integer.TYPE.equals(cls)) {	            return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Long.TYPE.equals(cls)) {	            return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Boolean.TYPE.equals(cls)) {	            return false;	        }	        if (Double.TYPE.equals(cls)) {	            return false;	        }	        if (Float.TYPE.equals(cls)) {	            return Double.TYPE.equals(toClass);	        }	        if (Character.TYPE.equals(cls)) {	            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Short.TYPE.equals(cls)) {	            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Byte.TYPE.equals(cls)) {	            return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        return false;	    }	    return toClass.isAssignableFrom(cls);	}
public static String abbreviate(final String str, int offset, final int maxWidth) {	    if (str == null) {	        return null;	    }	    if (maxWidth < 4) {	        throw new IllegalArgumentException("Minimum abbreviation width is 4");	    }	    if (str.length() <= maxWidth) {	        return str;	    }	    if (offset > str.length()) {	        offset = str.length();	    }	    if (str.length() - offset < maxWidth - 3) {	        offset = str.length() - (maxWidth - 3);	    }	    final String abrevMarker = "...";	    if (offset <= 4) {	        return str.substring(0, maxWidth - 3) + abrevMarker;	    }	    if (maxWidth < 7) {	        throw new IllegalArgumentException("Minimum abbreviation width with offset is 7");	    }	    if (offset + maxWidth - 3 < str.length()) {	        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);	    }	    return abrevMarker + str.substring(str.length() - (maxWidth - 3));	}
@Override	public int compareTo(final Fraction other) {	    if (this == other) {	        return 0;	    }	    if (numerator == other.numerator && denominator == other.denominator) {	        return 0;	    }	    final long first = (long) numerator * (long) other.denominator;	    final long second = (long) other.numerator * (long) denominator;	    if (first == second) {	        return 0;	    } else if (first < second) {	        return -1;	    } else {	        return 1;	    }	}
public boolean isIgnoreEmptyTokens() {	    return ignoreEmptyTokens;	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
public StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, 1);	}
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException {	    return charsetName == null ? new String(bytes) : new String(bytes, charsetName);	}
public static String randomNumeric(final int count) {	    return random(count, false, true);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static Type[] getImplicitUpperBounds(final WildcardType wildcardType) {	    final Type[] bounds = wildcardType.getUpperBounds();	    return bounds.length == 0 ? new Type[] { Object.class } : normalizeUpperBounds(bounds);	}
public boolean isEmpty() {	    return size == 0;	}
@Override	public long skip(long n) {	    if (pos + n > StrBuilder.this.size()) {	        n = StrBuilder.this.size() - pos;	    }	    if (n < 0) {	        return 0;	    }	    pos += n;	    return n;	}
public int capacity() {	    return buffer.length;	}
public static final String escapeJava(final String input) {	    return ESCAPE_JAVA.translate(input);	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public short setShortBoolean(final short holder, final boolean flag) {	    return flag ? setShort(holder) : clearShort(holder);	}
public static boolean[] clone(final boolean[] array) {	    if (array == null) {	        return null;	    }	    return array.clone();	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public int capacity() {	    return buffer.length;	}
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] result = new boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        final Boolean b = array[i];	        result[i] = (b == null ? valueForNull : b.booleanValue());	    }	    return result;	}
public String getNullText() {	    return nullText;	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public StrTokenizer setDelimiterChar(final char delim) {	    return setDelimiterMatcher(StrMatcher.charMatcher(delim));	}
public Integer toInteger() {	    return Integer.valueOf(intValue());	}
protected String getSizeEndText() {	    return sizeEndText;	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public String getNewLineText() {	    return newLine;	}
public String getNewLineText() {	    return newLine;	}
protected String getSummaryObjectStartText() {	    return summaryObjectStartText;	}
public static String formatDurationHMS(final long durationMillis) {	    return formatDuration(durationMillis, "H:mm:ss.SSS");	}
public Fraction negate() {	    if (numerator == Integer.MIN_VALUE) {	        throw new ArithmeticException("overflow: too large to negate");	    }	    return new Fraction(-numerator, denominator);	}
@Override	protected MultiBackgroundInitializerResults initialize() throws Exception {	    Map<String, BackgroundInitializer<?>> inits;	    synchronized (this) {	        inits = new HashMap<String, BackgroundInitializer<?>>(childInitializers);	    }	    final ExecutorService exec = getActiveExecutor();	    for (final BackgroundInitializer<?> bi : inits.values()) {	        if (bi.getExternalExecutor() == null) {	            bi.setExternalExecutor(exec);	        }	        bi.start();	    }	    final Map<String, Object> results = new HashMap<String, Object>();	    final Map<String, ConcurrentException> excepts = new HashMap<String, ConcurrentException>();	    for (final Map.Entry<String, BackgroundInitializer<?>> e : inits.entrySet()) {	        try {	            results.put(e.getKey(), e.getValue().get());	        } catch (final ConcurrentException cex) {	            excepts.put(e.getKey(), cex);	        }	    }	    return new MultiBackgroundInitializerResults(inits, results, excepts);	}
public boolean isEmpty() {	    return size == 0;	}
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return true;	    }	    if (lhs == null || rhs == null) {	        return false;	    }	    final Class<?> lhsClass = lhs.getClass();	    final Class<?> rhsClass = rhs.getClass();	    Class<?> testClass;	    if (lhsClass.isInstance(rhs)) {	        testClass = lhsClass;	        if (!rhsClass.isInstance(lhs)) {	            testClass = rhsClass;	        }	    } else if (rhsClass.isInstance(lhs)) {	        testClass = rhsClass;	        if (!lhsClass.isInstance(rhs)) {	            testClass = lhsClass;	        }	    } else {	        return false;	    }	    final EqualsBuilder equalsBuilder = new EqualsBuilder();	    try {	        reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {	            testClass = testClass.getSuperclass();	            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        }	    } catch (final IllegalArgumentException e) {	        return false;	    }	    return equalsBuilder.isEquals();	}
public static char binaryToHexDigit(final boolean[] src, final int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    if (src.length > srcPos + 3 && src[srcPos + 3]) {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src[srcPos]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
public static String formatDurationISO(final long durationMillis) {	    return formatDuration(durationMillis, ISO_EXTENDED_FORMAT_PATTERN, false);	}
public final synchronized void setLimit(final int limit) {	    this.limit = limit;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static void isTrue(final boolean expression) {	    if (expression == false) {	        throw new IllegalArgumentException(DEFAULT_IS_TRUE_EX_MESSAGE);	    }	}
public String getNewLineText() {	    return newLine;	}
public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) {	    if (s == null || t == null) {	        throw new IllegalArgumentException("Strings must not be null");	    }	    if (threshold < 0) {	        throw new IllegalArgumentException("Threshold must not be negative");	    }	    int n = s.length();	    int m = t.length();	    if (n == 0) {	        return m <= threshold ? m : -1;	    } else if (m == 0) {	        return n <= threshold ? n : -1;	    }	    if (n > m) {	        final CharSequence tmp = s;	        s = t;	        t = tmp;	        n = m;	        m = t.length();	    }	    int[] p = new int[n + 1];	    int[] d = new int[n + 1];	    int[] _d;	    final int boundary = Math.min(n, threshold) + 1;	    for (int i = 0; i < boundary; i++) {	        p[i] = i;	    }	    Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);	    Arrays.fill(d, Integer.MAX_VALUE);	    for (int j = 1; j <= m; j++) {	        final char t_j = t.charAt(j - 1);	        d[0] = j;	        final int min = Math.max(1, j - threshold);	        final int max = Math.min(n, j + threshold);	        if (min > max) {	            return -1;	        }	        if (min > 1) {	            d[min - 1] = Integer.MAX_VALUE;	        }	        for (int i = min; i <= max; i++) {	            if (s.charAt(i - 1) == t_j) {	                d[i] = p[i - 1];	            } else {	                d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);	            }	        }	        _d = p;	        p = d;	        d = _d;	    }	    if (p[n] <= threshold) {	        return p[n];	    }	    return -1;	}
public static <E extends Enum<E>> EnumSet<E> processBitVector(final Class<E> enumClass, final long value) {	    checkBitVectorable(enumClass).getEnumConstants();	    return processBitVectors(enumClass, value);	}
public int capacity() {	    return buffer.length;	}
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return 0;	    }	    if (lhs == null || rhs == null) {	        throw new NullPointerException();	    }	    Class<?> lhsClazz = lhs.getClass();	    if (!lhsClazz.isInstance(rhs)) {	        throw new ClassCastException();	    }	    final CompareToBuilder compareToBuilder = new CompareToBuilder();	    reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);	    while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) {	        lhsClazz = lhsClazz.getSuperclass();	        reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);	    }	    return compareToBuilder.toComparison();	}
public static Boolean[] toObject(final boolean[] array) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    final Boolean[] result = new Boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        result[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE);	    }	    return result;	}
public boolean contains(final StrMatcher matcher) {	    return indexOf(matcher, 0) >= 0;	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof MutableLong) {	        return value == ((MutableLong) obj).longValue();	    }	    return false;	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    for (final CharSequenceTranslator translator : translators) {	        final int consumed = translator.translate(input, index, out);	        if (consumed != 0) {	            return consumed;	        }	    }	    return 0;	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static String capitalize(final String str) {	    int strLen;	    if (str == null || (strLen = str.length()) == 0) {	        return str;	    }	    char firstChar = str.charAt(0);	    if (Character.isTitleCase(firstChar)) {	        return str;	    }	    return new StringBuilder(strLen).append(Character.toTitleCase(firstChar)).append(str.substring(1)).toString();	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static String[] substringsBetween(final String str, final String open, final String close) {	    if (str == null || isEmpty(open) || isEmpty(close)) {	        return null;	    }	    final int strLen = str.length();	    if (strLen == 0) {	        return ArrayUtils.EMPTY_STRING_ARRAY;	    }	    final int closeLen = close.length();	    final int openLen = open.length();	    final List<String> list = new ArrayList<String>();	    int pos = 0;	    while (pos < strLen - closeLen) {	        int start = str.indexOf(open, pos);	        if (start < 0) {	            break;	        }	        start += openLen;	        final int end = str.indexOf(close, start);	        if (end < 0) {	            break;	        }	        list.add(str.substring(start, end));	        pos = end + closeLen;	    }	    if (list.isEmpty()) {	        return null;	    }	    return list.toArray(new String[list.size()]);	}
public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) {	    if (s == null || t == null) {	        throw new IllegalArgumentException("Strings must not be null");	    }	    if (threshold < 0) {	        throw new IllegalArgumentException("Threshold must not be negative");	    }	    int n = s.length();	    int m = t.length();	    if (n == 0) {	        return m <= threshold ? m : -1;	    } else if (m == 0) {	        return n <= threshold ? n : -1;	    }	    if (n > m) {	        final CharSequence tmp = s;	        s = t;	        t = tmp;	        n = m;	        m = t.length();	    }	    int[] p = new int[n + 1];	    int[] d = new int[n + 1];	    int[] _d;	    final int boundary = Math.min(n, threshold) + 1;	    for (int i = 0; i < boundary; i++) {	        p[i] = i;	    }	    Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);	    Arrays.fill(d, Integer.MAX_VALUE);	    for (int j = 1; j <= m; j++) {	        final char t_j = t.charAt(j - 1);	        d[0] = j;	        final int min = Math.max(1, j - threshold);	        final int max = Math.min(n, j + threshold);	        if (min > max) {	            return -1;	        }	        if (min > 1) {	            d[min - 1] = Integer.MAX_VALUE;	        }	        for (int i = min; i <= max; i++) {	            if (s.charAt(i - 1) == t_j) {	                d[i] = p[i - 1];	            } else {	                d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);	            }	        }	        _d = p;	        p = d;	        d = _d;	    }	    if (p[n] <= threshold) {	        return p[n];	    }	    return -1;	}
public int size() {	    return size;	}
protected void setUseShortClassName(final boolean useShortClassName) {	    this.useShortClassName = useShortClassName;	}
public int lastIndexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex >= size ? size - 1 : startIndex);	    if (matcher == null || startIndex < 0) {	        return -1;	    }	    final char[] buf = buffer;	    final int endIndex = startIndex + 1;	    for (int i = startIndex; i >= 0; i--) {	        if (matcher.isMatch(buf, i, 0, endIndex) > 0) {	            return i;	        }	    }	    return -1;	}
public StrBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar) {	    return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);	}
public String getNullText() {	    return nullText;	}
@Override	public String toString() {	    return StringUtils.repeat(this.value.toString(), this.count);	}
@Override	public T get(final long timeout, final TimeUnit unit) {	    return value;	}
public static boolean[] hexDigitToBinary(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return new boolean[] { false, false, false, false };	        case '1':	            return new boolean[] { true, false, false, false };	        case '2':	            return new boolean[] { false, true, false, false };	        case '3':	            return new boolean[] { true, true, false, false };	        case '4':	            return new boolean[] { false, false, true, false };	        case '5':	            return new boolean[] { true, false, true, false };	        case '6':	            return new boolean[] { false, true, true, false };	        case '7':	            return new boolean[] { true, true, true, false };	        case '8':	            return new boolean[] { false, false, false, true };	        case '9':	            return new boolean[] { true, false, false, true };	        case 'a':	        case 'A':	            return new boolean[] { false, true, false, true };	        case 'b':	        case 'B':	            return new boolean[] { true, true, false, true };	        case 'c':	        case 'C':	            return new boolean[] { false, false, true, true };	        case 'd':	        case 'D':	            return new boolean[] { true, false, true, true };	        case 'e':	        case 'E':	            return new boolean[] { false, true, true, true };	        case 'f':	        case 'F':	            return new boolean[] { true, true, true, true };	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public static boolean endsWithAny(final CharSequence string, final CharSequence... searchStrings) {	    if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {	        return false;	    }	    for (final CharSequence searchString : searchStrings) {	        if (StringUtils.endsWith(string, searchString)) {	            return true;	        }	    }	    return false;	}
public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException {	    return parseDateWithLeniency(str, null, parsePatterns, false);	}
public HashCodeBuilder append(final short[] array) {	    if (array == null) {	        iTotal = iTotal * iConstant;	    } else {	        for (final short element : array) {	            append(element);	        }	    }	    return this;	}
public int capacity() {	    return buffer.length;	}
public static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes) {	    if ((src.length == 0 && srcPos == 0) || 0 == nBytes) {	        return dstInit;	    }	    if ((nBytes - 1) * 8 + dstPos >= 32) {	        throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 32");	    }	    int out = dstInit;	    int shift = 0;	    for (int i = 0; i < nBytes; i++) {	        shift = i * 8 + dstPos;	        final int bits = (0xff & src[i + srcPos]) << shift;	        final int mask = 0xff << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
public int capacity() {	    return buffer.length;	}
@Override	public void mark(final int readAheadLimit) {	    mark = pos;	}
protected boolean isUseFieldNames() {	    return useFieldNames;	}
public static float max(final float a, final float b, final float c) {	    return Math.max(Math.max(a, b), c);	}
protected boolean isUseClassName() {	    return useClassName;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof MutableBoolean) {	        return value == ((MutableBoolean) obj).booleanValue();	    }	    return false;	}
public static String appendIfMissing(final String str, final CharSequence suffix, final CharSequence... suffixes) {	    return appendIfMissing(str, suffix, false, suffixes);	}
public static Date truncate(final Object date, final int field) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (date instanceof Date) {	        return truncate((Date) date, field);	    } else if (date instanceof Calendar) {	        return truncate((Calendar) date, field).getTime();	    } else {	        throw new ClassCastException("Could not truncate " + date);	    }	}
@Override	public T get() throws ConcurrentException {	    try {	        return getFuture().get();	    } catch (final ExecutionException execex) {	        ConcurrentUtils.handleCause(execex);	        return null;	    } catch (final InterruptedException iex) {	        Thread.currentThread().interrupt();	        throw new ConcurrentException(iex);	    }	}
protected String getArrayEnd() {	    return arrayEnd;	}
@Override	public int length() {	    return size;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
static boolean regionMatches(final CharSequence cs, final boolean ignoreCase, final int thisStart, final CharSequence substring, final int start, final int length) {	    if (cs instanceof String && substring instanceof String) {	        return ((String) cs).regionMatches(ignoreCase, thisStart, (String) substring, start, length);	    } else {	        int index1 = thisStart;	        int index2 = start;	        int tmpLen = length;	        while (tmpLen-- > 0) {	            char c1 = cs.charAt(index1++);	            char c2 = substring.charAt(index2++);	            if (c1 == c2) {	                continue;	            }	            if (!ignoreCase) {	                return false;	            }	            if (Character.toUpperCase(c1) != Character.toUpperCase(c2) && Character.toLowerCase(c1) != Character.toLowerCase(c2)) {	                return false;	            }	        }	        return true;	    }	}
public long getSplitNanoTime() {	    if (this.splitState != STATE_SPLIT) {	        throw new IllegalStateException("Stopwatch must be split to get the split time. ");	    }	    return this.stopTime - this.startTime;	}
public static String removePattern(final String source, final String regex) {	    return replacePattern(source, regex, StringUtils.EMPTY);	}
protected String getSummaryObjectStartText() {	    return summaryObjectStartText;	}
public static String leftPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return leftPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return padStr.concat(str);	    } else if (pads < padLen) {	        return padStr.substring(0, pads).concat(str);	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return new String(padding).concat(str);	    }	}
@Override	public BasicThreadFactory build() {	    final BasicThreadFactory factory = new BasicThreadFactory(this);	    reset();	    return factory;	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public static final String escapeEcmaScript(final String input) {	    return ESCAPE_ECMASCRIPT.translate(input);	}
public static Date round(final Object date, final int field) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (date instanceof Date) {	        return round((Date) date, field);	    } else if (date instanceof Calendar) {	        return round((Calendar) date, field).getTime();	    } else {	        throw new ClassCastException("Could not round " + date);	    }	}
protected String getSizeStartText() {	    return sizeStartText;	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
public static Boolean[] toObject(final boolean[] array) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    final Boolean[] result = new Boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        result[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE);	    }	    return result;	}
public void subtract(final Number operand) {	    this.value -= operand.longValue();	}
@Override	public boolean equals(final Object other) {	    if (!(other instanceof IDKey)) {	        return false;	    }	    final IDKey idKey = (IDKey) other;	    if (id != idKey.id) {	        return false;	    }	    return value == idKey.value;	}
public StringBuffer toStringBuffer() {	    return new StringBuffer(size).append(buffer, 0, size);	}
public static boolean isAllLowerCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLowerCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public Comparator<T> getComparator() {	    return comparator;	}
public static BigDecimal createBigDecimal(final String str) {	    if (str == null) {	        return null;	    }	    if (StringUtils.isBlank(str)) {	        throw new NumberFormatException("A blank string is not a valid number");	    }	    if (str.trim().startsWith("--")) {	        throw new NumberFormatException(str + " is not a valid number.");	    }	    return new BigDecimal(str);	}
public static String normalizeSpace(final String str) {	    if (str == null) {	        return null;	    }	    return WHITESPACE_PATTERN.matcher(trim(str)).replaceAll(SPACE);	}
public EqualsBuilder appendSuper(final boolean superEquals) {	    if (isEquals == false) {	        return this;	    }	    isEquals = superEquals;	    return this;	}
public static String center(String str, final int size, String padStr) {	    if (str == null || size <= 0) {	        return str;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    str = leftPad(str, strLen + pads / 2, padStr);	    str = rightPad(str, size, padStr);	    return str;	}
public int size() {	    return size;	}
public static int lastIndexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = INDEX_NOT_FOUND;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.lastIndexOf(str, search, str.length());	        if (tmp > ret) {	            ret = tmp;	        }	    }	    return ret;	}
public StrBuilder setLength(final int length) {	    if (length < 0) {	        throw new StringIndexOutOfBoundsException(length);	    }	    if (length < size) {	        size = length;	    } else if (length > size) {	        ensureCapacity(length);	        final int oldEnd = size;	        final int newEnd = length;	        size = length;	        for (int i = oldEnd; i < newEnd; i++) {	            buffer[i] = '\0';	        }	    }	    return this;	}
private static Date add(final Date date, final int calendarField, final int amount) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final Calendar c = Calendar.getInstance();	    c.setTime(date);	    c.add(calendarField, amount);	    return c.getTime();	}
@Override	public int length() {	    return size;	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public String getNewLineText() {	    return newLine;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public String getNullText() {	    return nullText;	}
protected String getContentEnd() {	    return contentEnd;	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
public static String formatDuration(long durationMillis, final String format, final boolean padWithZeros) {	    final Token[] tokens = lexx(format);	    int days = 0;	    int hours = 0;	    int minutes = 0;	    int seconds = 0;	    int milliseconds = 0;	    if (Token.containsTokenWithValue(tokens, d)) {	        days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY);	        durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY);	    }	    if (Token.containsTokenWithValue(tokens, H)) {	        hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR);	        durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR);	    }	    if (Token.containsTokenWithValue(tokens, m)) {	        minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE);	        durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE);	    }	    if (Token.containsTokenWithValue(tokens, s)) {	        seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND);	        durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND);	    }	    if (Token.containsTokenWithValue(tokens, S)) {	        milliseconds = (int) durationMillis;	    }	    return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
public String getNullText() {	    return nullText;	}
public void start() {	    if (this.runningState == STATE_STOPPED) {	        throw new IllegalStateException("Stopwatch must be reset before being restarted. ");	    }	    if (this.runningState != STATE_UNSTARTED) {	        throw new IllegalStateException("Stopwatch already started. ");	    }	    this.startTime = System.nanoTime();	    this.startTimeMillis = System.currentTimeMillis();	    this.runningState = STATE_RUNNING;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public boolean isNegated() {	    return negated;	}
@Override	public int length() {	    return size;	}
public static String swapCase(final String str) {	    if (StringUtils.isEmpty(str)) {	        return str;	    }	    final char[] buffer = str.toCharArray();	    for (int i = 0; i < buffer.length; i++) {	        final char ch = buffer[i];	        if (Character.isUpperCase(ch)) {	            buffer[i] = Character.toLowerCase(ch);	        } else if (Character.isTitleCase(ch)) {	            buffer[i] = Character.toLowerCase(ch);	        } else if (Character.isLowerCase(ch)) {	            buffer[i] = Character.toUpperCase(ch);	        }	    }	    return new String(buffer);	}
public String getNullText() {	    return nullText;	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public static boolean typesSatisfyVariables(final Map<TypeVariable<?>, Type> typeVarAssigns) {	    for (final Map.Entry<TypeVariable<?>, Type> entry : typeVarAssigns.entrySet()) {	        final TypeVariable<?> typeVar = entry.getKey();	        final Type type = entry.getValue();	        for (final Type bound : getImplicitBounds(typeVar)) {	            if (!isAssignable(type, substituteTypeVariables(bound, typeVarAssigns), typeVarAssigns)) {	                return false;	            }	        }	    }	    return true;	}
@Override	public Date parse(final String source, final ParsePosition pos) {	    final int offset = pos.getIndex();	    final Matcher matcher = parsePattern.matcher(source.substring(offset));	    if (!matcher.lookingAt()) {	        return null;	    }	    final Calendar cal = Calendar.getInstance(timeZone, locale);	    cal.clear();	    for (int i = 0; i < strategies.length; ) {	        final Strategy strategy = strategies[i++];	        strategy.setCalendar(this, cal, matcher.group(i));	    }	    pos.setIndex(offset + matcher.end());	    return cal.getTime();	}
public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException {	    return parseDateWithLeniency(str, locale, parsePatterns, true);	}
private static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns) {	    if (!isAssignable(cls, toClass)) {	        return null;	    }	    if (cls.isPrimitive()) {	        if (toClass.isPrimitive()) {	            return new HashMap<TypeVariable<?>, Type>();	        }	        cls = ClassUtils.primitiveToWrapper(cls);	    }	    final HashMap<TypeVariable<?>, Type> typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>() : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);	    if (toClass.equals(cls)) {	        return typeVarAssigns;	    }	    return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
protected String getContentEnd() {	    return contentEnd;	}
public int size() {	    return size;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
protected boolean isFieldSeparatorAtStart() {	    return fieldSeparatorAtStart;	}
@Override	public String next() {	    if (hasNext()) {	        return tokens[tokenPos++];	    }	    throw new NoSuchElementException();	}
@Override	public boolean isFieldSeparatorAtStart() {	    return super.isFieldSeparatorAtStart();	}
public static String removeEnd(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.endsWith(remove)) {	        return str.substring(0, str.length() - remove.length());	    }	    return str;	}
public int size() {	    return size;	}
public static boolean[] removeElements(final boolean[] array, final boolean... values) {	    if (isEmpty(array) || isEmpty(values)) {	        return clone(array);	    }	    final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2);	    for (final boolean v : values) {	        final Boolean boxed = Boolean.valueOf(v);	        final MutableInt count = occurrences.get(boxed);	        if (count == null) {	            occurrences.put(boxed, new MutableInt(1));	        } else {	            count.increment();	        }	    }	    final BitSet toRemove = new BitSet();	    for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) {	        final Boolean v = e.getKey();	        int found = 0;	        for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {	            found = indexOf(array, v.booleanValue(), found);	            if (found < 0) {	                break;	            }	            toRemove.set(found++);	        }	    }	    return (boolean[]) removeAll(array, toRemove);	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public static boolean containsIgnoreCase(final CharSequence str, final CharSequence searchStr) {	    if (str == null || searchStr == null) {	        return false;	    }	    final int len = searchStr.length();	    final int max = str.length() - len;	    for (int i = 0; i <= max; i++) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, len)) {	            return true;	        }	    }	    return false;	}
public static boolean isNotBlank(final CharSequence cs) {	    return !StringUtils.isBlank(cs);	}
@Override	public int hashCode() {	    final char[] buf = buffer;	    int hash = 0;	    for (int i = size - 1; i >= 0; i--) {	        hash = 31 * hash + buf[i];	    }	    return hash;	}
public boolean isEmpty() {	    return size == 0;	}
public StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, 1);	}
public static String leftPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return leftPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return padStr.concat(str);	    } else if (pads < padLen) {	        return padStr.substring(0, pads).concat(str);	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return new String(padding).concat(str);	    }	}
public static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex) {	    if (0 == nHex) {	        return dstInit;	    }	    if ((nHex - 1) * 4 + dstPos >= 32) {	        throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 32");	    }	    int out = dstInit;	    int shift = 0;	    for (int i = 0; i < nHex; i++) {	        shift = i * 4 + dstPos;	        final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift;	        final int mask = 0xf << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
public String getNewLineText() {	    return newLine;	}
public static boolean isAlpha(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public String getContent() {	    if (chars == null) {	        return null;	    }	    return new String(chars);	}
public String reformat(final String input) throws ParseException {	    return format(parseObject(input));	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
public EqualsBuilder appendSuper(final boolean superEquals) {	    if (isEquals == false) {	        return this;	    }	    isEquals = superEquals;	    return this;	}
@Override	public String next() {	    if (hasNext()) {	        return tokens[tokenPos++];	    }	    throw new NoSuchElementException();	}
public synchronized void acquire() throws InterruptedException {	    if (isShutdown()) {	        throw new IllegalStateException("TimedSemaphore is shut down!");	    }	    if (task == null) {	        task = startTimer();	    }	    boolean canPass = false;	    do {	        canPass = getLimit() <= NO_LIMIT || acquireCount < getLimit();	        if (!canPass) {	            wait();	        } else {	            acquireCount++;	        }	    } while (!canPass);	}
public static int hexDigitMsb0ToInt(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return 0x0;	        case '1':	            return 0x8;	        case '2':	            return 0x4;	        case '3':	            return 0xC;	        case '4':	            return 0x2;	        case '5':	            return 0xA;	        case '6':	            return 0x6;	        case '7':	            return 0xE;	        case '8':	            return 0x1;	        case '9':	            return 0x9;	        case 'a':	        case 'A':	            return 0x5;	        case 'b':	        case 'B':	            return 0xD;	        case 'c':	        case 'C':	            return 0x3;	        case 'd':	        case 'D':	            return 0xB;	        case 'e':	        case 'E':	            return 0x7;	        case 'f':	        case 'F':	            return 0xF;	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
@Override	public Long getValue() {	    return Long.valueOf(this.value);	}
protected boolean isUseIdentityHashCode() {	    return useIdentityHashCode;	}
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = Integer.MAX_VALUE;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.indexOf(str, search, 0);	        if (tmp == INDEX_NOT_FOUND) {	            continue;	        }	        if (tmp < ret) {	            ret = tmp;	        }	    }	    return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;	}
protected ScheduledFuture<?> startTimer() {	    return getExecutorService().scheduleAtFixedRate(new Runnable() {		        @Override	        public void run() {	            endOfPeriod();	        }	    }, getPeriod(), getPeriod(), getUnit());	}
public static boolean containsAny(final CharSequence cs, final CharSequence searchChars) {	    if (searchChars == null) {	        return false;	    }	    return containsAny(cs, CharSequenceUtils.toCharArray(searchChars));	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static boolean equals(final Object object1, final Object object2) {	    if (object1 == object2) {	        return true;	    }	    if (object1 == null || object2 == null) {	        return false;	    }	    return object1.equals(object2);	}
@Override	public Object parseObject(final String source, final ParsePosition pos) {	    return parse(source, pos);	}
public short setShortBoolean(final short holder, final boolean flag) {	    return flag ? setShort(holder) : clearShort(holder);	}
static boolean isAccessible(final Member m) {	    return m != null && Modifier.isPublic(m.getModifiers()) && !m.isSynthetic();	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    for (final CharSequenceTranslator translator : translators) {	        final int consumed = translator.translate(input, index, out);	        if (consumed != 0) {	            return consumed;	        }	    }	    return 0;	}
public static int lastIndexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = INDEX_NOT_FOUND;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.lastIndexOf(str, search, str.length());	        if (tmp > ret) {	            ret = tmp;	        }	    }	    return ret;	}
@Override	public String next() {	    if (hasNext()) {	        return tokens[tokenPos++];	    }	    throw new NoSuchElementException();	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public static short[] removeElement(final short[] array, final short element) {	    final int index = indexOf(array, element);	    if (index == INDEX_NOT_FOUND) {	        return clone(array);	    }	    return remove(array, index);	}
public boolean isIgnoreEmptyTokens() {	    return ignoreEmptyTokens;	}
public static String[] substringsBetween(final String str, final String open, final String close) {	    if (str == null || isEmpty(open) || isEmpty(close)) {	        return null;	    }	    final int strLen = str.length();	    if (strLen == 0) {	        return ArrayUtils.EMPTY_STRING_ARRAY;	    }	    final int closeLen = close.length();	    final int openLen = open.length();	    final List<String> list = new ArrayList<String>();	    int pos = 0;	    while (pos < strLen - closeLen) {	        int start = str.indexOf(open, pos);	        if (start < 0) {	            break;	        }	        start += openLen;	        final int end = str.indexOf(close, start);	        if (end < 0) {	            break;	        }	        list.add(str.substring(start, end));	        pos = end + closeLen;	    }	    if (list.isEmpty()) {	        return null;	    }	    return list.toArray(new String[list.size()]);	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public int capacity() {	    return buffer.length;	}
@Override	public double doubleValue() {	    return value;	}
public int indexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex < 0 ? 0 : startIndex);	    if (matcher == null || startIndex >= size) {	        return -1;	    }	    final int len = size;	    final char[] buf = buffer;	    for (int i = startIndex; i < len; i++) {	        if (matcher.isMatch(buf, i, startIndex, len) > 0) {	            return i;	        }	    }	    return -1;	}
public synchronized boolean isStarted() {	    return future != null;	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
@Override	public Long getValue() {	    return Long.valueOf(this.value);	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public Fraction add(final Fraction fraction) {	    return addSub(fraction, true);	}
@Override	public int length() {	    return size;	}
public synchronized boolean isShutdown() {	    return shutdown;	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public int capacity() {	    return buffer.length;	}
public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) {	    String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'");	    if (suppressLeadingZeroElements) {	        duration = " " + duration;	        String tmp = StringUtils.replaceOnce(duration, " 0 days", "");	        if (tmp.length() != duration.length()) {	            duration = tmp;	            tmp = StringUtils.replaceOnce(duration, " 0 hours", "");	            if (tmp.length() != duration.length()) {	                duration = tmp;	                tmp = StringUtils.replaceOnce(duration, " 0 minutes", "");	                duration = tmp;	                if (tmp.length() != duration.length()) {	                    duration = StringUtils.replaceOnce(tmp, " 0 seconds", "");	                }	            }	        }	        if (duration.length() != 0) {	            duration = duration.substring(1);	        }	    }	    if (suppressTrailingZeroElements) {	        String tmp = StringUtils.replaceOnce(duration, " 0 seconds", "");	        if (tmp.length() != duration.length()) {	            duration = tmp;	            tmp = StringUtils.replaceOnce(duration, " 0 minutes", "");	            if (tmp.length() != duration.length()) {	                duration = tmp;	                tmp = StringUtils.replaceOnce(duration, " 0 hours", "");	                if (tmp.length() != duration.length()) {	                    duration = StringUtils.replaceOnce(tmp, " 0 days", "");	                }	            }	        }	    }	    duration = " " + duration;	    duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second");	    duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute");	    duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour");	    duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day");	    return duration.trim();	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
@Override	public int read(final char[] b, final int off, int len) {	    if (off < 0 || len < 0 || off > b.length || (off + len) > b.length || (off + len) < 0) {	        throw new IndexOutOfBoundsException();	    }	    if (len == 0) {	        return 0;	    }	    if (pos >= StrBuilder.this.size()) {	        return -1;	    }	    if (pos + len > size()) {	        len = StrBuilder.this.size() - pos;	    }	    StrBuilder.this.getChars(pos, pos + len, b, off);	    pos += len;	    return len;	}
public int size() {	    return size;	}
protected String getFieldSeparator() {	    return fieldSeparator;	}
public int size() {	    return size;	}
public static <T extends Iterable<?>> T noNullElements(final T iterable) {	    return noNullElements(iterable, DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static String capitalize(final String str, final char... delimiters) {	    final int delimLen = delimiters == null ? -1 : delimiters.length;	    if (StringUtils.isEmpty(str) || delimLen == 0) {	        return str;	    }	    final char[] buffer = str.toCharArray();	    boolean capitalizeNext = true;	    for (int i = 0; i < buffer.length; i++) {	        final char ch = buffer[i];	        if (isDelimiter(ch, delimiters)) {	            capitalizeNext = true;	        } else if (capitalizeNext) {	            buffer[i] = Character.toTitleCase(ch);	            capitalizeNext = false;	        }	    }	    return new String(buffer);	}
public static String trimToNull(final String str) {	    final String ts = trim(str);	    return isEmpty(ts) ? null : ts;	}
public static Number createNumber(final String str) throws NumberFormatException {	    if (str == null) {	        return null;	    }	    if (StringUtils.isBlank(str)) {	        throw new NumberFormatException("A blank string is not a valid number");	    }	    final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" };	    int pfxLen = 0;	    for (final String pfx : hex_prefixes) {	        if (str.startsWith(pfx)) {	            pfxLen += pfx.length();	            break;	        }	    }	    if (pfxLen > 0) {	        final int hexDigits = str.length() - pfxLen;	        if (hexDigits > 16) {	            return createBigInteger(str);	        }	        if (hexDigits > 8) {	            return createLong(str);	        }	        return createInteger(str);	    }	    final char lastChar = str.charAt(str.length() - 1);	    String mant;	    String dec;	    String exp;	    final int decPos = str.indexOf('.');	    final int expPos = str.indexOf('e') + str.indexOf('E') + 1;	    int numDecimals = 0;	    if (decPos > -1) {	        if (expPos > -1) {	            if (expPos < decPos || expPos > str.length()) {	                throw new NumberFormatException(str + " is not a valid number.");	            }	            dec = str.substring(decPos + 1, expPos);	        } else {	            dec = str.substring(decPos + 1);	        }	        mant = str.substring(0, decPos);	        numDecimals = dec.length();	    } else {	        if (expPos > -1) {	            if (expPos > str.length()) {	                throw new NumberFormatException(str + " is not a valid number.");	            }	            mant = str.substring(0, expPos);	        } else {	            mant = str;	        }	        dec = null;	    }	    if (!Character.isDigit(lastChar) && lastChar != '.') {	        if (expPos > -1 && expPos < str.length() - 1) {	            exp = str.substring(expPos + 1, str.length() - 1);	        } else {	            exp = null;	        }	        final String numeric = str.substring(0, str.length() - 1);	        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);	        switch(lastChar) {	            case 'l':	            case 'L':	                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {	                    try {	                        return createLong(numeric);	                    } catch (final NumberFormatException nfe) {	                    }	                    return createBigInteger(numeric);	                }	                throw new NumberFormatException(str + " is not a valid number.");	            case 'f':	            case 'F':	                try {	                    final Float f = NumberUtils.createFloat(numeric);	                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {	                        return f;	                    }	                } catch (final NumberFormatException nfe) {	                }	            case 'd':	            case 'D':	                try {	                    final Double d = NumberUtils.createDouble(numeric);	                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {	                        return d;	                    }	                } catch (final NumberFormatException nfe) {	                }	                try {	                    return createBigDecimal(numeric);	                } catch (final NumberFormatException e) {	                }	            default:	                throw new NumberFormatException(str + " is not a valid number.");	        }	    }	    if (expPos > -1 && expPos < str.length() - 1) {	        exp = str.substring(expPos + 1, str.length());	    } else {	        exp = null;	    }	    if (dec == null && exp == null) {	        try {	            return createInteger(str);	        } catch (final NumberFormatException nfe) {	        }	        try {	            return createLong(str);	        } catch (final NumberFormatException nfe) {	        }	        return createBigInteger(str);	    }	    final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);	    try {	        if (numDecimals <= 7) {	            final Float f = createFloat(str);	            if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {	                return f;	            }	        }	    } catch (final NumberFormatException nfe) {	    }	    try {	        if (numDecimals <= 16) {	            final Double d = createDouble(str);	            if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {	                return d;	            }	        }	    } catch (final NumberFormatException nfe) {	    }	    return createBigDecimal(str);	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
public Fraction divideBy(final Fraction fraction) {	    if (fraction == null) {	        throw new IllegalArgumentException("The fraction must not be null");	    }	    if (fraction.numerator == 0) {	        throw new ArithmeticException("The fraction to divide by must not be zero");	    }	    return multiplyBy(fraction.invert());	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    buffer.append(arrayStart);	    for (int i = 0; i < array.length; i++) {	        if (i > 0) {	            buffer.append(arraySeparator);	        }	        appendDetail(buffer, fieldName, array[i]);	    }	    buffer.append(arrayEnd);	}
public StringBuilder toStringBuilder() {	    return new StringBuilder(size).append(buffer, 0, size);	}
public void stop() {	    if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {	        throw new IllegalStateException("Stopwatch is not running. ");	    }	    if (this.runningState == STATE_RUNNING) {	        this.stopTime = System.nanoTime();	    }	    this.runningState = STATE_STOPPED;	}
protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    appendSummarySize(buffer, fieldName, array.length);	}
@Override	public void mark(final int readAheadLimit) {	    mark = pos;	}
protected String getNullText() {	    return nullText;	}
public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) {	    if (s == null || t == null) {	        throw new IllegalArgumentException("Strings must not be null");	    }	    if (threshold < 0) {	        throw new IllegalArgumentException("Threshold must not be negative");	    }	    int n = s.length();	    int m = t.length();	    if (n == 0) {	        return m <= threshold ? m : -1;	    } else if (m == 0) {	        return n <= threshold ? n : -1;	    }	    if (n > m) {	        final CharSequence tmp = s;	        s = t;	        t = tmp;	        n = m;	        m = t.length();	    }	    int[] p = new int[n + 1];	    int[] d = new int[n + 1];	    int[] _d;	    final int boundary = Math.min(n, threshold) + 1;	    for (int i = 0; i < boundary; i++) {	        p[i] = i;	    }	    Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);	    Arrays.fill(d, Integer.MAX_VALUE);	    for (int j = 1; j <= m; j++) {	        final char t_j = t.charAt(j - 1);	        d[0] = j;	        final int min = Math.max(1, j - threshold);	        final int max = Math.min(n, j + threshold);	        if (min > max) {	            return -1;	        }	        if (min > 1) {	            d[min - 1] = Integer.MAX_VALUE;	        }	        for (int i = min; i <= max; i++) {	            if (s.charAt(i - 1) == t_j) {	                d[i] = p[i - 1];	            } else {	                d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);	            }	        }	        _d = p;	        p = d;	        d = _d;	    }	    if (p[n] <= threshold) {	        return p[n];	    }	    return -1;	}
public String getNewLineText() {	    return newLine;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
@Override	public int length() {	    return size;	}
public static boolean isEmpty(final CharSequence cs) {	    return cs == null || cs.length() == 0;	}
public static String getShortCanonicalName(final String canonicalName) {	    return ClassUtils.getShortClassName(getCanonicalName(canonicalName));	}
public boolean isEmptyTokenAsNull() {	    return this.emptyAsNull;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public static boolean isAllLowerCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLowerCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
@Override	public boolean equals(final Object obj) {	    if (obj == this) {	        return true;	    }	    if (obj instanceof CharRange == false) {	        return false;	    }	    final CharRange other = (CharRange) obj;	    return start == other.start && end == other.end && negated == other.negated;	}
public static String difference(final String str1, final String str2) {	    if (str1 == null) {	        return str2;	    }	    if (str2 == null) {	        return str1;	    }	    final int at = indexOfDifference(str1, str2);	    if (at == INDEX_NOT_FOUND) {	        return EMPTY;	    }	    return str2.substring(at);	}
@Override	public int nextIndex() {	    return tokenPos;	}
public boolean isEquals() {	    return this.isEquals;	}
public static String reverse(final String str) {	    if (str == null) {	        return null;	    }	    return new StringBuilder(str).reverse().toString();	}
public int getNumerator() {	    return numerator;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) {	    if (0 == nBools) {	        return dst;	    }	    if (nBools - 1 + srcPos >= 32) {	        throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 32");	    }	    int shift = 0;	    for (int i = 0; i < nBools; i++) {	        shift = i * 1 + srcPos;	        dst[dstPos + i] = ((0x1 & (src >> shift)) != 0);	    }	    return dst;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
public int toComparison() {	    return comparison;	}
public static String upperCase(final String str, final Locale locale) {	    if (str == null) {	        return null;	    }	    return str.toUpperCase(locale);	}
int adjustYear(final int twoDigitYear) {	    final int trial = twoDigitYear + thisYear - thisYear % 100;	    if (trial < thisYear + 20) {	        return trial;	    }	    return trial - 100;	}
public int size() {	    return size;	}
public static <T> T CONST(final T v) {	    return v;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
@Override	public boolean cancel(final boolean mayInterruptIfRunning) {	    return false;	}
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {	    if (array == null) {	        if (index != 0) {	            throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0");	        }	        final Object joinedArray = Array.newInstance(clss, 1);	        Array.set(joinedArray, 0, element);	        return joinedArray;	    }	    final int length = Array.getLength(array);	    if (index > length || index < 0) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(clss, length + 1);	    System.arraycopy(array, 0, result, 0, index);	    Array.set(result, index, element);	    if (index < length) {	        System.arraycopy(array, index, result, index + 1, length - index);	    }	    return result;	}
public int size() {	    return size;	}
static Pair<IDKey, IDKey> getRegisterPair(final Object lhs, final Object rhs) {	    final IDKey left = new IDKey(lhs);	    final IDKey right = new IDKey(rhs);	    return Pair.of(left, right);	}
public int toComparison() {	    return comparison;	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
protected String getNullText() {	    return nullText;	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public StrBuilder setLength(final int length) {	    if (length < 0) {	        throw new StringIndexOutOfBoundsException(length);	    }	    if (length < size) {	        size = length;	    } else if (length > size) {	        ensureCapacity(length);	        final int oldEnd = size;	        final int newEnd = length;	        size = length;	        for (int i = oldEnd; i < newEnd; i++) {	            buffer[i] = '\0';	        }	    }	    return this;	}
public static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) {	    if (0 == nBools) {	        return dst;	    }	    if (nBools - 1 + srcPos >= 16) {	        throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 16");	    }	    int shift = 0;	    assert ((nBools - 1) * 1 < 16 - srcPos);	    for (int i = 0; i < nBools; i++) {	        shift = i * 1 + srcPos;	        dst[dstPos + i] = ((0x1 & (src >> shift)) != 0);	    }	    return dst;	}
public static String formatDuration(long durationMillis, final String format, final boolean padWithZeros) {	    final Token[] tokens = lexx(format);	    int days = 0;	    int hours = 0;	    int minutes = 0;	    int seconds = 0;	    int milliseconds = 0;	    if (Token.containsTokenWithValue(tokens, d)) {	        days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY);	        durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY);	    }	    if (Token.containsTokenWithValue(tokens, H)) {	        hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR);	        durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR);	    }	    if (Token.containsTokenWithValue(tokens, m)) {	        minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE);	        durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE);	    }	    if (Token.containsTokenWithValue(tokens, s)) {	        seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND);	        durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND);	    }	    if (Token.containsTokenWithValue(tokens, S)) {	        milliseconds = (int) durationMillis;	    }	    return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
@Override	public String toString() {	    if (this.getObject() == null) {	        return this.getStyle().getNullText();	    }	    Class<?> clazz = this.getObject().getClass();	    this.appendFieldsIn(clazz);	    while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {	        clazz = clazz.getSuperclass();	        this.appendFieldsIn(clazz);	    }	    return super.toString();	}
public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) {	    if (src.length > 8) {	        throw new IllegalArgumentException("src.length>8: src.length=" + src.length);	    }	    if (src.length - srcPos < 4) {	        throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos);	    }	    if (src[srcPos + 3]) {	        if (src[srcPos + 2]) {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return '7';	                }	            } else {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return '3';	                }	            }	        } else {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return '5';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '1';	                }	            }	        }	    } else {	        if (src[srcPos + 2]) {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'e';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return 'a';	                } else {	                    return '2';	                }	            }	        } else {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'c';	                } else {	                    return '4';	                }	            } else {	                if (src[srcPos]) {	                    return '8';	                } else {	                    return '0';	                }	            }	        }	    }	}
@Override	public int length() {	    return size;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public int capacity() {	    return buffer.length;	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public static String replaceSystemProperties(final Object source) {	    return new StrSubstitutor(StrLookup.systemPropertiesLookup()).replace(source);	}
public String getNullText() {	    return nullText;	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
@Override	public int length() {	    return size;	}
private static long getFragment(final Calendar calendar, final int fragment, final int unit) {	    if (calendar == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final long millisPerUnit = getMillisPerUnit(unit);	    long result = 0;	    switch(fragment) {	        case Calendar.YEAR:	            result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit;	            break;	        case Calendar.MONTH:	            result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit;	            break;	    }	    switch(fragment) {	        case Calendar.YEAR:	        case Calendar.MONTH:	        case Calendar.DAY_OF_YEAR:	        case Calendar.DATE:	            result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit;	        case Calendar.HOUR_OF_DAY:	            result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit;	        case Calendar.MINUTE:	            result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit;	        case Calendar.SECOND:	            result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit;	            break;	        case Calendar.MILLISECOND:	            break;	        default:	            throw new IllegalArgumentException("The fragment " + fragment + " is not supported");	    }	    return result;	}
public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) {	    final Token[] tokens = lexx(format);	    final Calendar start = Calendar.getInstance(timezone);	    start.setTime(new Date(startMillis));	    final Calendar end = Calendar.getInstance(timezone);	    end.setTime(new Date(endMillis));	    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);	    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);	    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);	    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);	    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);	    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);	    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);	    while (milliseconds < 0) {	        milliseconds += 1000;	        seconds -= 1;	    }	    while (seconds < 0) {	        seconds += 60;	        minutes -= 1;	    }	    while (minutes < 0) {	        minutes += 60;	        hours -= 1;	    }	    while (hours < 0) {	        hours += 24;	        days -= 1;	    }	    if (Token.containsTokenWithValue(tokens, M)) {	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	        while (months < 0) {	            months += 12;	            years -= 1;	        }	        if (!Token.containsTokenWithValue(tokens, y) && years != 0) {	            while (years != 0) {	                months += 12 * years;	                years = 0;	            }	        }	    } else {	        if (!Token.containsTokenWithValue(tokens, y)) {	            int target = end.get(Calendar.YEAR);	            if (months < 0) {	                target -= 1;	            }	            while (start.get(Calendar.YEAR) != target) {	                days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);	                if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) {	                    days += 1;	                }	                start.add(Calendar.YEAR, 1);	                days += start.get(Calendar.DAY_OF_YEAR);	            }	            years = 0;	        }	        while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            start.add(Calendar.MONTH, 1);	        }	        months = 0;	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	    }	    if (!Token.containsTokenWithValue(tokens, d)) {	        hours += 24 * days;	        days = 0;	    }	    if (!Token.containsTokenWithValue(tokens, H)) {	        minutes += 60 * hours;	        hours = 0;	    }	    if (!Token.containsTokenWithValue(tokens, m)) {	        seconds += 60 * minutes;	        minutes = 0;	    }	    if (!Token.containsTokenWithValue(tokens, s)) {	        milliseconds += 1000 * seconds;	        seconds = 0;	    }	    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
public String toProperString() {	    if (toProperString == null) {	        if (numerator == 0) {	            toProperString = "0";	        } else if (numerator == denominator) {	            toProperString = "1";	        } else if (numerator == -1 * denominator) {	            toProperString = "-1";	        } else if ((numerator > 0 ? -numerator : numerator) < -denominator) {	            final int properNumerator = getProperNumerator();	            if (properNumerator == 0) {	                toProperString = Integer.toString(getProperWhole());	            } else {	                toProperString = new StringBuilder(32).append(getProperWhole()).append(' ').append(properNumerator).append('/').append(getDenominator()).toString();	            }	        } else {	            toProperString = new StringBuilder(32).append(getNumerator()).append('/').append(getDenominator()).toString();	        }	    }	    return toProperString;	}
public static String swapCase(final String str) {	    if (StringUtils.isEmpty(str)) {	        return str;	    }	    final char[] buffer = str.toCharArray();	    boolean whitespace = true;	    for (int i = 0; i < buffer.length; i++) {	        final char ch = buffer[i];	        if (Character.isUpperCase(ch)) {	            buffer[i] = Character.toLowerCase(ch);	            whitespace = false;	        } else if (Character.isTitleCase(ch)) {	            buffer[i] = Character.toLowerCase(ch);	            whitespace = false;	        } else if (Character.isLowerCase(ch)) {	            if (whitespace) {	                buffer[i] = Character.toTitleCase(ch);	                whitespace = false;	            } else {	                buffer[i] = Character.toUpperCase(ch);	            }	        } else {	            whitespace = Character.isWhitespace(ch);	        }	    }	    return new String(buffer);	}
protected boolean isDefaultFullDetail() {	    return defaultFullDetail;	}
public static String right(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(str.length() - len);	}
public void resume() {	    if (this.runningState != STATE_SUSPENDED) {	        throw new IllegalStateException("Stopwatch must be suspended to resume. ");	    }	    this.startTime += System.nanoTime() - this.stopTime;	    this.runningState = STATE_RUNNING;	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
@Override	public DefaultExceptionContext setContextValue(final String label, final Object value) {	    for (final Iterator<Pair<String, Object>> iter = contextValues.iterator(); iter.hasNext(); ) {	        final Pair<String, Object> p = iter.next();	        if (StringUtils.equals(label, p.getKey())) {	            iter.remove();	        }	    }	    addContextValue(label, value);	    return this;	}
public static <T extends CharSequence> T notBlank(final T chars) {	    return notBlank(chars, DEFAULT_NOT_BLANK_EX_MESSAGE);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return 0;	    }	    if (lhs == null || rhs == null) {	        throw new NullPointerException();	    }	    Class<?> lhsClazz = lhs.getClass();	    if (!lhsClazz.isInstance(rhs)) {	        throw new ClassCastException();	    }	    final CompareToBuilder compareToBuilder = new CompareToBuilder();	    reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);	    while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) {	        lhsClazz = lhsClazz.getSuperclass();	        reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);	    }	    return compareToBuilder.toComparison();	}
@Override	public int hashCode() {	    return toHashCode();	}
public String getNullText() {	    return nullText;	}
public int getNumerator() {	    return numerator;	}
public static StrMatcher stringMatcher(final String str) {	    if (StringUtils.isEmpty(str)) {	        return NONE_MATCHER;	    }	    return new StringMatcher(str);	}
public static String[] stripAll(final String[] strs, final String stripChars) {	    int strsLen;	    if (strs == null || (strsLen = strs.length) == 0) {	        return strs;	    }	    final String[] newArr = new String[strsLen];	    for (int i = 0; i < strsLen; i++) {	        newArr[i] = strip(strs[i], stripChars);	    }	    return newArr;	}
public static <K, V> V putIfAbsent(final ConcurrentMap<K, V> map, final K key, final V value) {	    if (map == null) {	        return null;	    }	    final V result = map.putIfAbsent(key, value);	    return result != null ? result : value;	}
public int capacity() {	    return buffer.length;	}
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) {	    if (bool == null) {	        return nullValue;	    }	    return bool.booleanValue() ? trueValue : falseValue;	}
public Byte toByte() {	    return Byte.valueOf(byteValue());	}
public static boolean isAlphanumericSpace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetterOrDigit(cs.charAt(i)) == false && cs.charAt(i) != ' ') {	            return false;	        }	    }	    return true;	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
public static final String escapeCsv(final String input) {	    return ESCAPE_CSV.translate(input);	}
@Override	public int previousIndex() {	    return tokenPos - 1;	}
@Override	public boolean ready() {	    return pos < StrBuilder.this.size();	}
protected boolean isUseFieldNames() {	    return useFieldNames;	}
public static boolean endsWithIgnoreCase(final CharSequence str, final CharSequence suffix) {	    return endsWith(str, suffix, true);	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
@Override	public boolean translate(final int codepoint, final Writer out) throws IOException {	    if (between) {	        if (codepoint < below || codepoint > above) {	            return false;	        }	    } else {	        if (codepoint >= below && codepoint <= above) {	            return false;	        }	    }	    if (codepoint > 0xffff) {	        out.write(toUtf16Escape(codepoint));	    } else if (codepoint > 0xfff) {	        out.write("\\u" + hex(codepoint));	    } else if (codepoint > 0xff) {	        out.write("\\u0" + hex(codepoint));	    } else if (codepoint > 0xf) {	        out.write("\\u00" + hex(codepoint));	    } else {	        out.write("\\u000" + hex(codepoint));	    }	    return true;	}
public static Date ceiling(final Object date, final int field) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (date instanceof Date) {	        return ceiling((Date) date, field);	    } else if (date instanceof Calendar) {	        return ceiling((Calendar) date, field).getTime();	    } else {	        throw new ClassCastException("Could not find ceiling of for type: " + date.getClass());	    }	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
@Override	public String previous() {	    if (hasPrevious()) {	        return tokens[--tokenPos];	    }	    throw new NoSuchElementException();	}
@Override	public int compareTo(final Triple<L, M, R> other) {	    return new CompareToBuilder().append(getLeft(), other.getLeft()).append(getMiddle(), other.getMiddle()).append(getRight(), other.getRight()).toComparison();	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
protected String getNullText() {	    return nullText;	}
public static String abbreviate(final String str, int offset, final int maxWidth) {	    if (str == null) {	        return null;	    }	    if (maxWidth < 4) {	        throw new IllegalArgumentException("Minimum abbreviation width is 4");	    }	    if (str.length() <= maxWidth) {	        return str;	    }	    if (offset > str.length()) {	        offset = str.length();	    }	    if (str.length() - offset < maxWidth - 3) {	        offset = str.length() - (maxWidth - 3);	    }	    final String abrevMarker = "...";	    if (offset <= 4) {	        return str.substring(0, maxWidth - 3) + abrevMarker;	    }	    if (maxWidth < 7) {	        throw new IllegalArgumentException("Minimum abbreviation width with offset is 7");	    }	    if (offset + maxWidth - 3 < str.length()) {	        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);	    }	    return abrevMarker + str.substring(str.length() - (maxWidth - 3));	}
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) {	    final StringBuilder buffer = new StringBuilder();	    boolean lastOutputSeconds = false;	    final int sz = tokens.length;	    for (int i = 0; i < sz; i++) {	        final Token token = tokens[i];	        final Object value = token.getValue();	        final int count = token.getCount();	        if (value instanceof StringBuilder) {	            buffer.append(value.toString());	        } else {	            if (value == y) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years));	                lastOutputSeconds = false;	            } else if (value == M) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months));	                lastOutputSeconds = false;	            } else if (value == d) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days));	                lastOutputSeconds = false;	            } else if (value == H) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours));	                lastOutputSeconds = false;	            } else if (value == m) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes));	                lastOutputSeconds = false;	            } else if (value == s) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds));	                lastOutputSeconds = true;	            } else if (value == S) {	                if (lastOutputSeconds) {	                    milliseconds += 1000;	                    final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds);	                    buffer.append(str.substring(1));	                } else {	                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds));	                }	                lastOutputSeconds = false;	            }	        }	    }	    return buffer.toString();	}
public Object getObject() {	    return object;	}
public static int indexOfDifference(final CharSequence... css) {	    if (css == null || css.length <= 1) {	        return INDEX_NOT_FOUND;	    }	    boolean anyStringNull = false;	    boolean allStringsNull = true;	    final int arrayLen = css.length;	    int shortestStrLen = Integer.MAX_VALUE;	    int longestStrLen = 0;	    for (int i = 0; i < arrayLen; i++) {	        if (css[i] == null) {	            anyStringNull = true;	            shortestStrLen = 0;	        } else {	            allStringsNull = false;	            shortestStrLen = Math.min(css[i].length(), shortestStrLen);	            longestStrLen = Math.max(css[i].length(), longestStrLen);	        }	    }	    if (allStringsNull || longestStrLen == 0 && !anyStringNull) {	        return INDEX_NOT_FOUND;	    }	    if (shortestStrLen == 0) {	        return 0;	    }	    int firstDiff = -1;	    for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {	        final char comparisonChar = css[0].charAt(stringPos);	        for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {	            if (css[arrayPos].charAt(stringPos) != comparisonChar) {	                firstDiff = stringPos;	                break;	            }	        }	        if (firstDiff != -1) {	            break;	        }	    }	    if (firstDiff == -1 && shortestStrLen != longestStrLen) {	        return shortestStrLen;	    }	    return firstDiff;	}
public static boolean isNumeric(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isDigit(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase) {	    if (str == null || prefix == null) {	        return str == null && prefix == null;	    }	    if (prefix.length() > str.length()) {	        return false;	    }	    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());	}
public int indexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex < 0 ? 0 : startIndex);	    if (matcher == null || startIndex >= size) {	        return -1;	    }	    final int len = size;	    final char[] buf = buffer;	    for (int i = startIndex; i < len; i++) {	        if (matcher.isMatch(buf, i, startIndex, len) > 0) {	            return i;	        }	    }	    return -1;	}
public int capacity() {	    return buffer.length;	}
public int size() {	    return size;	}
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) {	    if (str == null) {	        if (trueString == null) {	            return Boolean.TRUE;	        }	        if (falseString == null) {	            return Boolean.FALSE;	        }	        if (nullString == null) {	            return null;	        }	    } else if (str.equals(trueString)) {	        return Boolean.TRUE;	    } else if (str.equals(falseString)) {	        return Boolean.FALSE;	    } else if (str.equals(nullString)) {	        return null;	    }	    throw new IllegalArgumentException("The String did not match any specified value");	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
public static <T> T[] toArray(final T... items) {	    return items;	}
public static boolean[] removeElements(final boolean[] array, final boolean... values) {	    if (isEmpty(array) || isEmpty(values)) {	        return clone(array);	    }	    final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2);	    for (final boolean v : values) {	        final Boolean boxed = Boolean.valueOf(v);	        final MutableInt count = occurrences.get(boxed);	        if (count == null) {	            occurrences.put(boxed, new MutableInt(1));	        } else {	            count.increment();	        }	    }	    final BitSet toRemove = new BitSet();	    for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) {	        final Boolean v = e.getKey();	        int found = 0;	        for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {	            found = indexOf(array, v.booleanValue(), found);	            if (found < 0) {	                break;	            }	            toRemove.set(found++);	        }	    }	    return (boolean[]) removeAll(array, toRemove);	}
@Override	public DefaultExceptionContext setContextValue(final String label, final Object value) {	    for (final Iterator<Pair<String, Object>> iter = contextValues.iterator(); iter.hasNext(); ) {	        final Pair<String, Object> p = iter.next();	        if (StringUtils.equals(label, p.getKey())) {	            iter.remove();	        }	    }	    addContextValue(label, value);	    return this;	}
public static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    final int beSrcPos = src.length - 1 - srcPos;	    final int srcLen = Math.min(4, beSrcPos + 1);	    final boolean[] paddedSrc = new boolean[4];	    System.arraycopy(src, beSrcPos + 1 - srcLen, paddedSrc, 4 - srcLen, srcLen);	    src = paddedSrc;	    srcPos = 0;	    if (src[srcPos]) {	        if (src.length > srcPos + 1 && src[srcPos + 1]) {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 1 && src[srcPos + 1]) {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
public boolean isEmpty() {	    return size == 0;	}
public StrBuilder replaceAll(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, -1);	}
public int indexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex < 0 ? 0 : startIndex);	    if (matcher == null || startIndex >= size) {	        return -1;	    }	    final int len = size;	    final char[] buf = buffer;	    for (int i = startIndex; i < len; i++) {	        if (matcher.isMatch(buf, i, startIndex, len) > 0) {	            return i;	        }	    }	    return -1;	}
public static String toString(final Formattable formattable) {	    return String.format(SIMPLEST_FORMAT, formattable);	}
public Short toShort() {	    return Short.valueOf(shortValue());	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
public static boolean isEmpty(final CharSequence cs) {	    return cs == null || cs.length() == 0;	}
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, true);	}
public char getEscapeChar() {	    return this.escapeChar;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public static String getCommonPrefix(final String... strs) {	    if (strs == null || strs.length == 0) {	        return EMPTY;	    }	    final int smallestIndexOfDiff = indexOfDifference(strs);	    if (smallestIndexOfDiff == INDEX_NOT_FOUND) {	        if (strs[0] == null) {	            return EMPTY;	        }	        return strs[0];	    } else if (smallestIndexOfDiff == 0) {	        return EMPTY;	    } else {	        return strs[0].substring(0, smallestIndexOfDiff);	    }	}
@Override	public TimeZone getTimeZone() {	    return mTimeZone;	}
@Override	public Object parseObject(final String source, final ParsePosition pos) {	    return parser.parseObject(source, pos);	}
public static String toString(final boolean bool, final String trueString, final String falseString) {	    return bool ? trueString : falseString;	}
public static boolean isAsciiAlpha(final char ch) {	    return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');	}
protected boolean isDefaultFullDetail() {	    return defaultFullDetail;	}
@Override	public T call() throws Exception {	    try {	        return initialize();	    } finally {	        if (execFinally != null) {	            execFinally.shutdown();	        }	    }	}
public boolean isEmpty() {	    return size == 0;	}
public String[] getTokenArray() {	    checkTokenized();	    return tokens.clone();	}
public String getNewLineText() {	    return newLine;	}
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) {	    if (bool == null) {	        return nullValue;	    }	    return bool.booleanValue() ? trueValue : falseValue;	}
public StrTokenizer reset(final char[] input) {	    reset();	    this.chars = ArrayUtils.clone(input);	    return this;	}
public String getNewLineText() {	    return newLine;	}
@Override	public void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd) {	    super.setFieldSeparatorAtEnd(fieldSeparatorAtEnd);	}
protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    appendSummarySize(buffer, fieldName, array.length);	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public static String leftPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return leftPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return padStr.concat(str);	    } else if (pads < padLen) {	        return padStr.substring(0, pads).concat(str);	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return new String(padding).concat(str);	    }	}
static boolean regionMatches(final CharSequence cs, final boolean ignoreCase, final int thisStart, final CharSequence substring, final int start, final int length) {	    if (cs instanceof String && substring instanceof String) {	        return ((String) cs).regionMatches(ignoreCase, thisStart, (String) substring, start, length);	    } else {	        int index1 = thisStart;	        int index2 = start;	        int tmpLen = length;	        while (tmpLen-- > 0) {	            char c1 = cs.charAt(index1++);	            char c2 = substring.charAt(index2++);	            if (c1 == c2) {	                continue;	            }	            if (!ignoreCase) {	                return false;	            }	            if (Character.toUpperCase(c1) != Character.toUpperCase(c2) && Character.toLowerCase(c1) != Character.toLowerCase(c2)) {	                return false;	            }	        }	        return true;	    }	}
private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase) {	    if (str == null || prefix == null) {	        return str == null && prefix == null;	    }	    if (prefix.length() > str.length()) {	        return false;	    }	    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
@Override	public Date parse(final String source, final ParsePosition pos) {	    final int offset = pos.getIndex();	    final Matcher matcher = parsePattern.matcher(source.substring(offset));	    if (!matcher.lookingAt()) {	        return null;	    }	    final Calendar cal = Calendar.getInstance(timeZone, locale);	    cal.clear();	    for (int i = 0; i < strategies.length; ) {	        final Strategy strategy = strategies[i++];	        strategy.setCalendar(this, cal, matcher.group(i));	    }	    pos.setIndex(offset + matcher.end());	    return cal.getTime();	}
@Override	public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) {	    return formatter.format(obj, toAppendTo, pos);	}
public static CharRange isNot(final char ch) {	    return new CharRange(ch, ch, true);	}
public String getNewLineText() {	    return newLine;	}
public String toString(final String format) {	    return String.format(format, minimum, maximum, comparator);	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public static String substringAfter(final String str, final String separator) {	    if (isEmpty(str)) {	        return str;	    }	    if (separator == null) {	        return EMPTY;	    }	    final int pos = str.indexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return EMPTY;	    }	    return str.substring(pos + separator.length());	}
public static Fraction getReducedFraction(int numerator, int denominator) {	    if (denominator == 0) {	        throw new ArithmeticException("The denominator must not be zero");	    }	    if (numerator == 0) {	        return ZERO;	    }	    if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) {	        numerator /= 2;	        denominator /= 2;	    }	    if (denominator < 0) {	        if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {	            throw new ArithmeticException("overflow: can't negate");	        }	        numerator = -numerator;	        denominator = -denominator;	    }	    final int gcd = greatestCommonDivisor(numerator, denominator);	    numerator /= gcd;	    denominator /= gcd;	    return new Fraction(numerator, denominator);	}
public boolean isEmpty() {	    return size == 0;	}
public void subtract(final Number operand) {	    this.value -= operand.byteValue();	}
protected boolean isUseShortClassName() {	    return useShortClassName;	}
protected String getArraySeparator() {	    return arraySeparator;	}
public static String initials(final String str, final char... delimiters) {	    if (StringUtils.isEmpty(str)) {	        return str;	    }	    if (delimiters != null && delimiters.length == 0) {	        return "";	    }	    final int strLen = str.length();	    final char[] buf = new char[strLen / 2 + 1];	    int count = 0;	    boolean lastWasGap = true;	    for (int i = 0; i < strLen; i++) {	        final char ch = str.charAt(i);	        if (isDelimiter(ch, delimiters)) {	            lastWasGap = true;	        } else if (lastWasGap) {	            buf[count++] = ch;	            lastWasGap = false;	        } else {	            continue;	        }	    }	    return new String(buf, 0, count);	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof MutableShort) {	        return value == ((MutableShort) obj).shortValue();	    }	    return false;	}
public static int hashCodeMulti(final Object... objects) {	    int hash = 1;	    if (objects != null) {	        for (final Object object : objects) {	            hash = hash * 31 + ObjectUtils.hashCode(object);	        }	    }	    return hash;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables) {	    this.enableSubstitutionInVariables = enableSubstitutionInVariables;	}
@Override	public String previous() {	    if (hasPrevious()) {	        return tokens[--tokenPos];	    }	    throw new NoSuchElementException();	}
public Integer toInteger() {	    return Integer.valueOf(intValue());	}
public static String getCommonPrefix(final String... strs) {	    if (strs == null || strs.length == 0) {	        return EMPTY;	    }	    final int smallestIndexOfDiff = indexOfDifference(strs);	    if (smallestIndexOfDiff == INDEX_NOT_FOUND) {	        if (strs[0] == null) {	            return EMPTY;	        }	        return strs[0];	    } else if (smallestIndexOfDiff == 0) {	        return EMPTY;	    } else {	        return strs[0].substring(0, smallestIndexOfDiff);	    }	}
public int lastIndexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex >= size ? size - 1 : startIndex);	    if (matcher == null || startIndex < 0) {	        return -1;	    }	    final char[] buf = buffer;	    final int endIndex = startIndex + 1;	    for (int i = startIndex; i >= 0; i--) {	        if (matcher.isMatch(buf, i, 0, endIndex) > 0) {	            return i;	        }	    }	    return -1;	}
public StrBuilder appendNewLine() {	    if (newLine == null) {	        append(SystemUtils.LINE_SEPARATOR);	        return this;	    }	    return append(newLine);	}
public String getNewLineText() {	    return newLine;	}
@Override	public String previous() {	    if (hasPrevious()) {	        return tokens[--tokenPos];	    }	    throw new NoSuchElementException();	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
@Override	public void write(final String str, final int off, final int len) {	    StrBuilder.this.append(str, off, len);	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public static final String escapeXml(final String input) {	    return ESCAPE_XML.translate(input);	}
public static boolean isNumericSpace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isDigit(cs.charAt(i)) == false && cs.charAt(i) != ' ') {	            return false;	        }	    }	    return true;	}
@Override	public int length() {	    return size;	}
public StrBuilder minimizeCapacity() {	    if (buffer.length > length()) {	        final char[] old = buffer;	        buffer = new char[length()];	        System.arraycopy(old, 0, buffer, 0, size);	    }	    return this;	}
public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width, final int precision, final char padChar, final CharSequence ellipsis) {	    Validate.isTrue(ellipsis == null || precision < 0 || ellipsis.length() <= precision, "Specified ellipsis '%1$s' exceeds precision of %2$s", ellipsis, Integer.valueOf(precision));	    final StringBuilder buf = new StringBuilder(seq);	    if (precision >= 0 && precision < seq.length()) {	        final CharSequence _ellipsis = ObjectUtils.defaultIfNull(ellipsis, StringUtils.EMPTY);	        buf.replace(precision - _ellipsis.length(), seq.length(), _ellipsis.toString());	    }	    final boolean leftJustify = (flags & LEFT_JUSTIFY) == LEFT_JUSTIFY;	    for (int i = buf.length(); i < width; i++) {	        buf.insert(leftJustify ? i : 0, padChar);	    }	    formatter.format(buf.toString());	    return formatter;	}
static boolean isRegistered(final Object lhs, final Object rhs) {	    final Set<Pair<IDKey, IDKey>> registry = getRegistry();	    final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);	    final Pair<IDKey, IDKey> swappedPair = Pair.of(pair.getLeft(), pair.getRight());	    return registry != null && (registry.contains(pair) || registry.contains(swappedPair));	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public StrBuilder replaceAll(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, -1);	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static <L, M, R> Triple<L, M, R> of(final L left, final M middle, final R right) {	    return new ImmutableTriple<L, M, R>(left, middle, right);	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static String getPackageCanonicalName(final String canonicalName) {	    return ClassUtils.getPackageName(getCanonicalName(canonicalName));	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
protected boolean isFieldSeparatorAtEnd() {	    return fieldSeparatorAtEnd;	}
public boolean isEmpty() {	    return size == 0;	}
public static CharRange is(final char ch) {	    return new CharRange(ch, ch, false);	}
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return true;	    }	    if (lhs == null || rhs == null) {	        return false;	    }	    final Class<?> lhsClass = lhs.getClass();	    final Class<?> rhsClass = rhs.getClass();	    Class<?> testClass;	    if (lhsClass.isInstance(rhs)) {	        testClass = lhsClass;	        if (!rhsClass.isInstance(lhs)) {	            testClass = rhsClass;	        }	    } else if (rhsClass.isInstance(lhs)) {	        testClass = rhsClass;	        if (!lhsClass.isInstance(rhs)) {	            testClass = lhsClass;	        }	    } else {	        return false;	    }	    final EqualsBuilder equalsBuilder = new EqualsBuilder();	    try {	        reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {	            testClass = testClass.getSuperclass();	            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        }	    } catch (final IllegalArgumentException e) {	        return false;	    }	    return equalsBuilder.isEquals();	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
@Override	public int intValue() {	    return (int) value;	}
public static String random(final int count, final char... chars) {	    if (chars == null) {	        return random(count, 0, 0, false, false, null, RANDOM);	    }	    return random(count, 0, chars.length, false, false, chars, RANDOM);	}
public boolean isEmpty() {	    return size == 0;	}
public static String capitalize(final String str, final char... delimiters) {	    final int delimLen = delimiters == null ? -1 : delimiters.length;	    if (StringUtils.isEmpty(str) || delimLen == 0) {	        return str;	    }	    final char[] buffer = str.toCharArray();	    boolean capitalizeNext = true;	    for (int i = 0; i < buffer.length; i++) {	        final char ch = buffer[i];	        if (isDelimiter(ch, delimiters)) {	            capitalizeNext = true;	        } else if (capitalizeNext) {	            buffer[i] = Character.toTitleCase(ch);	            capitalizeNext = false;	        }	    }	    return new String(buffer);	}
protected boolean isArrayContentDetail() {	    return arrayContentDetail;	}
public boolean isEmpty() {	    return size == 0;	}
public static boolean isWhitespace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isWhitespace(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static <T> T mode(final T... items) {	    if (ArrayUtils.isNotEmpty(items)) {	        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(items.length);	        for (final T t : items) {	            final MutableInt count = occurrences.get(t);	            if (count == null) {	                occurrences.put(t, new MutableInt(1));	            } else {	                count.increment();	            }	        }	        T result = null;	        int max = 0;	        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {	            final int cmp = e.getValue().intValue();	            if (cmp == max) {	                result = null;	            } else if (cmp > max) {	                max = cmp;	                result = e.getKey();	            }	        }	        return result;	    }	    return null;	}
public StrBuilder deleteAll(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, -1);	}
@Override	public boolean equals(final Object obj) {	    if (obj == this) {	        return true;	    }	    if (obj instanceof CharSet == false) {	        return false;	    }	    final CharSet other = (CharSet) obj;	    return set.equals(other.set);	}
public static Fraction getReducedFraction(int numerator, int denominator) {	    if (denominator == 0) {	        throw new ArithmeticException("The denominator must not be zero");	    }	    if (numerator == 0) {	        return ZERO;	    }	    if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) {	        numerator /= 2;	        denominator /= 2;	    }	    if (denominator < 0) {	        if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {	            throw new ArithmeticException("overflow: can't negate");	        }	        numerator = -numerator;	        denominator = -denominator;	    }	    final int gcd = greatestCommonDivisor(numerator, denominator);	    numerator /= gcd;	    denominator /= gcd;	    return new Fraction(numerator, denominator);	}
public static Date setMilliseconds(final Date date, final int amount) {	    return set(date, Calendar.MILLISECOND, amount);	}
@Override	public int previousIndex() {	    return tokenPos - 1;	}
public static <T> Range<T> is(final T element, final Comparator<T> comparator) {	    return between(element, element, comparator);	}
public String midString(int index, final int length) {	    if (index < 0) {	        index = 0;	    }	    if (length <= 0 || index >= size) {	        return "";	    }	    if (size <= index + length) {	        return new String(buffer, index, size - index);	    }	    return new String(buffer, index, length);	}
public StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, 1);	}
public int size() {	    checkTokenized();	    return tokens.length;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
public static Throwable getRootCause(final Throwable throwable) {	    final List<Throwable> list = getThrowableList(throwable);	    return list.size() < 2 ? null : (Throwable) list.get(list.size() - 1);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public StrBuilder appendPadding(final int length, final char padChar) {	    if (length >= 0) {	        ensureCapacity(size + length);	        for (int i = 0; i < length; i++) {	            buffer[size++] = padChar;	        }	    }	    return this;	}
public static String center(String str, final int size, String padStr) {	    if (str == null || size <= 0) {	        return str;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    str = leftPad(str, strLen + pads / 2, padStr);	    str = rightPad(str, size, padStr);	    return str;	}
public int size() {	    return size;	}
public boolean isEquals() {	    return this.isEquals;	}
public void decrement() {	    value--;	}
public static String toString(final boolean bool, final String trueString, final String falseString) {	    return bool ? trueString : falseString;	}
public static boolean isBlank(final CharSequence cs) {	    int strLen;	    if (cs == null || (strLen = cs.length()) == 0) {	        return true;	    }	    for (int i = 0; i < strLen; i++) {	        if (Character.isWhitespace(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static boolean containsNone(final CharSequence cs, final String invalidChars) {	    if (cs == null || invalidChars == null) {	        return true;	    }	    return containsNone(cs, invalidChars.toCharArray());	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public StrBuilder replaceAll(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, -1);	}
public HashCodeBuilder append(final short[] array) {	    if (array == null) {	        iTotal = iTotal * iConstant;	    } else {	        for (final short element : array) {	            append(element);	        }	    }	    return this;	}
public char getStart() {	    return this.start;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static boolean isSameType(final Object array1, final Object array2) {	    if (array1 == null || array2 == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    return array1.getClass().getName().equals(array2.getClass().getName());	}
public int toHashCode() {	    return iTotal;	}
protected String getArrayStart() {	    return arrayStart;	}
public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) {	    final Token[] tokens = lexx(format);	    final Calendar start = Calendar.getInstance(timezone);	    start.setTime(new Date(startMillis));	    final Calendar end = Calendar.getInstance(timezone);	    end.setTime(new Date(endMillis));	    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);	    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);	    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);	    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);	    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);	    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);	    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);	    while (milliseconds < 0) {	        milliseconds += 1000;	        seconds -= 1;	    }	    while (seconds < 0) {	        seconds += 60;	        minutes -= 1;	    }	    while (minutes < 0) {	        minutes += 60;	        hours -= 1;	    }	    while (hours < 0) {	        hours += 24;	        days -= 1;	    }	    if (Token.containsTokenWithValue(tokens, M)) {	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	        while (months < 0) {	            months += 12;	            years -= 1;	        }	        if (!Token.containsTokenWithValue(tokens, y) && years != 0) {	            while (years != 0) {	                months += 12 * years;	                years = 0;	            }	        }	    } else {	        if (!Token.containsTokenWithValue(tokens, y)) {	            int target = end.get(Calendar.YEAR);	            if (months < 0) {	                target -= 1;	            }	            while (start.get(Calendar.YEAR) != target) {	                days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);	                if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) {	                    days += 1;	                }	                start.add(Calendar.YEAR, 1);	                days += start.get(Calendar.DAY_OF_YEAR);	            }	            years = 0;	        }	        while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            start.add(Calendar.MONTH, 1);	        }	        months = 0;	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	    }	    if (!Token.containsTokenWithValue(tokens, d)) {	        hours += 24 * days;	        days = 0;	    }	    if (!Token.containsTokenWithValue(tokens, H)) {	        minutes += 60 * hours;	        hours = 0;	    }	    if (!Token.containsTokenWithValue(tokens, m)) {	        seconds += 60 * minutes;	        minutes = 0;	    }	    if (!Token.containsTokenWithValue(tokens, s)) {	        milliseconds += 1000 * seconds;	        seconds = 0;	    }	    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
public static boolean[] hexDigitToBinary(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return new boolean[] { false, false, false, false };	        case '1':	            return new boolean[] { true, false, false, false };	        case '2':	            return new boolean[] { false, true, false, false };	        case '3':	            return new boolean[] { true, true, false, false };	        case '4':	            return new boolean[] { false, false, true, false };	        case '5':	            return new boolean[] { true, false, true, false };	        case '6':	            return new boolean[] { false, true, true, false };	        case '7':	            return new boolean[] { true, true, true, false };	        case '8':	            return new boolean[] { false, false, false, true };	        case '9':	            return new boolean[] { true, false, false, true };	        case 'a':	        case 'A':	            return new boolean[] { false, true, false, true };	        case 'b':	        case 'B':	            return new boolean[] { true, true, false, true };	        case 'c':	        case 'C':	            return new boolean[] { false, false, true, true };	        case 'd':	        case 'D':	            return new boolean[] { true, false, true, true };	        case 'e':	        case 'E':	            return new boolean[] { false, true, true, true };	        case 'f':	        case 'F':	            return new boolean[] { true, true, true, true };	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
@Override	public int length() {	    return size;	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
protected String getSizeEndText() {	    return sizeEndText;	}
public static int toIntValue(final Character ch, final int defaultValue) {	    if (ch == null) {	        return defaultValue;	    }	    return toIntValue(ch.charValue(), defaultValue);	}
@Override	public void setValue(final Boolean value) {	    this.value = value.booleanValue();	}
public void subtract(final Number operand) {	    this.value -= operand.doubleValue();	}
@Override	public DefaultExceptionContext setContextValue(final String label, final Object value) {	    for (final Iterator<Pair<String, Object>> iter = contextValues.iterator(); iter.hasNext(); ) {	        final Pair<String, Object> p = iter.next();	        if (StringUtils.equals(label, p.getKey())) {	            iter.remove();	        }	    }	    addContextValue(label, value);	    return this;	}
@Override	public String getContent() {	    final String str = super.getContent();	    if (str == null) {	        return StrBuilder.this.toString();	    }	    return str;	}
public static boolean truncatedEquals(final Date date1, final Date date2, final int field) {	    return truncatedCompareTo(date1, date2, field) == 0;	}
public boolean isEmpty() {	    return size == 0;	}
public static float min(final float a, final float b, final float c) {	    return Math.min(Math.min(a, b), c);	}
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) {	    if (str == null) {	        if (trueString == null) {	            return Boolean.TRUE;	        }	        if (falseString == null) {	            return Boolean.FALSE;	        }	        if (nullString == null) {	            return null;	        }	    } else if (str.equals(trueString)) {	        return Boolean.TRUE;	    } else if (str.equals(falseString)) {	        return Boolean.FALSE;	    } else if (str.equals(nullString)) {	        return null;	    }	    throw new IllegalArgumentException("The String did not match any specified value");	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public int lastIndexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex >= size ? size - 1 : startIndex);	    if (matcher == null || startIndex < 0) {	        return -1;	    }	    final char[] buf = buffer;	    final int endIndex = startIndex + 1;	    for (int i = startIndex; i >= 0; i--) {	        if (matcher.isMatch(buf, i, 0, endIndex) > 0) {	            return i;	        }	    }	    return -1;	}
public StrBuilder appendFixedWidthPadRight(final int value, final int width, final char padChar) {	    return appendFixedWidthPadRight(String.valueOf(value), width, padChar);	}
public static List<String> convertClassesToClassNames(final List<Class<?>> classes) {	    if (classes == null) {	        return null;	    }	    final List<String> classNames = new ArrayList<String>(classes.size());	    for (final Class<?> cls : classes) {	        if (cls == null) {	            classNames.add(null);	        } else {	            classNames.add(cls.getName());	        }	    }	    return classNames;	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
@Override	public void write(final String str, final int off, final int len) {	    StrBuilder.this.append(str, off, len);	}
@Override	public int length() {	    return size;	}
public static <T extends CharSequence> T notEmpty(final T chars) {	    return notEmpty(chars, DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE);	}
public void subtract(final Number operand) {	    this.value -= operand.shortValue();	}
public static boolean isNumericSpace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isDigit(cs.charAt(i)) == false && cs.charAt(i) != ' ') {	            return false;	        }	    }	    return true;	}
@Override	public void setValue(final Boolean value) {	    this.value = value.booleanValue();	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static boolean contains(final boolean[] array, final boolean valueToFind) {	    return indexOf(array, valueToFind) != INDEX_NOT_FOUND;	}
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {	    if (array == null) {	        if (index != 0) {	            throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0");	        }	        final Object joinedArray = Array.newInstance(clss, 1);	        Array.set(joinedArray, 0, element);	        return joinedArray;	    }	    final int length = Array.getLength(array);	    if (index > length || index < 0) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(clss, length + 1);	    System.arraycopy(array, 0, result, 0, index);	    Array.set(result, index, element);	    if (index < length) {	        System.arraycopy(array, index, result, index + 1, length - index);	    }	    return result;	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
@Override	public float floatValue() {	    return (float) numerator / (float) denominator;	}
public StrBuilder deleteAll(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, -1);	}
public void stop() {	    if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {	        throw new IllegalStateException("Stopwatch is not running. ");	    }	    if (this.runningState == STATE_RUNNING) {	        this.stopTime = System.nanoTime();	    }	    this.runningState = STATE_STOPPED;	}
public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {	    if (str == null || searchStr == null) {	        return INDEX_NOT_FOUND;	    }	    if (startPos > str.length() - searchStr.length()) {	        startPos = str.length() - searchStr.length();	    }	    if (startPos < 0) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return startPos;	    }	    for (int i = startPos; i >= 0; i--) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public int capacity() {	    return buffer.length;	}
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, true);	}
public static String prependIfMissing(final String str, final CharSequence prefix, final CharSequence... prefixes) {	    return prependIfMissing(str, prefix, false, prefixes);	}
public int size() {	    return size;	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
public void setUpToClass(final Class<?> clazz) {	    if (clazz != null) {	        final Object object = getObject();	        if (object != null && clazz.isInstance(object) == false) {	            throw new IllegalArgumentException("Specified class is not a superclass of the object");	        }	    }	    this.upToClass = clazz;	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return true;	    }	    if (lhs == null || rhs == null) {	        return false;	    }	    final Class<?> lhsClass = lhs.getClass();	    final Class<?> rhsClass = rhs.getClass();	    Class<?> testClass;	    if (lhsClass.isInstance(rhs)) {	        testClass = lhsClass;	        if (!rhsClass.isInstance(lhs)) {	            testClass = rhsClass;	        }	    } else if (rhsClass.isInstance(lhs)) {	        testClass = rhsClass;	        if (!lhsClass.isInstance(rhs)) {	            testClass = lhsClass;	        }	    } else {	        return false;	    }	    final EqualsBuilder equalsBuilder = new EqualsBuilder();	    try {	        reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {	            testClass = testClass.getSuperclass();	            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        }	    } catch (final IllegalArgumentException e) {	        return false;	    }	    return equalsBuilder.isEquals();	}
public static String getPackageCanonicalName(final String canonicalName) {	    return ClassUtils.getPackageName(getCanonicalName(canonicalName));	}
Object getValue() {	    return value;	}
public static boolean containsNone(final CharSequence cs, final String invalidChars) {	    if (cs == null || invalidChars == null) {	        return true;	    }	    return containsNone(cs, invalidChars.toCharArray());	}
protected String getContentStart() {	    return contentStart;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public int size() {	    return size;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public int capacity() {	    return buffer.length;	}
public int toHashCode() {	    return iTotal;	}
public static void reverse(final boolean[] array) {	    if (array == null) {	        return;	    }	    int i = 0;	    int j = array.length - 1;	    boolean tmp;	    while (j > i) {	        tmp = array[j];	        array[j] = array[i];	        array[i] = tmp;	        j--;	        i++;	    }	}
public static String formatDuration(long durationMillis, final String format, final boolean padWithZeros) {	    final Token[] tokens = lexx(format);	    int days = 0;	    int hours = 0;	    int minutes = 0;	    int seconds = 0;	    int milliseconds = 0;	    if (Token.containsTokenWithValue(tokens, d)) {	        days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY);	        durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY);	    }	    if (Token.containsTokenWithValue(tokens, H)) {	        hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR);	        durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR);	    }	    if (Token.containsTokenWithValue(tokens, m)) {	        minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE);	        durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE);	    }	    if (Token.containsTokenWithValue(tokens, s)) {	        seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND);	        durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND);	    }	    if (Token.containsTokenWithValue(tokens, S)) {	        milliseconds = (int) durationMillis;	    }	    return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException {	    return charsetName == null ? new String(bytes) : new String(bytes, charsetName);	}
public static Fraction getReducedFraction(int numerator, int denominator) {	    if (denominator == 0) {	        throw new ArithmeticException("The denominator must not be zero");	    }	    if (numerator == 0) {	        return ZERO;	    }	    if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) {	        numerator /= 2;	        denominator /= 2;	    }	    if (denominator < 0) {	        if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {	            throw new ArithmeticException("overflow: can't negate");	        }	        numerator = -numerator;	        denominator = -denominator;	    }	    final int gcd = greatestCommonDivisor(numerator, denominator);	    numerator /= gcd;	    denominator /= gcd;	    return new Fraction(numerator, denominator);	}
public int capacity() {	    return buffer.length;	}
@Override	public Object parseObject(final String source, final ParsePosition pos) {	    return parse(source, pos);	}
public static Date addHours(final Date date, final int amount) {	    return add(date, Calendar.HOUR_OF_DAY, amount);	}
public static String trim(final String str) {	    return str == null ? null : str.trim();	}
public String getNullText() {	    return nullText;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
static Set<IDKey> getRegistry() {	    return REGISTRY.get();	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public static boolean isNotBlank(final CharSequence cs) {	    return !StringUtils.isBlank(cs);	}
public static String center(String str, final int size, String padStr) {	    if (str == null || size <= 0) {	        return str;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    str = leftPad(str, strLen + pads / 2, padStr);	    str = rightPad(str, size, padStr);	    return str;	}
public boolean isEmpty() {	    return size == 0;	}
@Override	public int intValue() {	    return value;	}
protected String getFieldNameValueSeparator() {	    return fieldNameValueSeparator;	}
@Override	public long longValue() {	    return (long) value;	}
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) {	    if (bool == null) {	        return nullValue;	    }	    return bool.booleanValue() ? trueValue : falseValue;	}
public ToStringBuilder appendSuper(final String superToString) {	    if (superToString != null) {	        style.appendSuper(buffer, superToString);	    }	    return this;	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static <T> Range<T> is(final T element, final Comparator<T> comparator) {	    return between(element, element, comparator);	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public boolean isEmpty() {	    return size == 0;	}
public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale) {	    return cache.getTimeInstance(style, timeZone, locale);	}
public static String trim(final String str) {	    return str == null ? null : str.trim();	}
public static <T> T CONST(final T v) {	    return v;	}
@Override	public int read(final char[] b, final int off, int len) {	    if (off < 0 || len < 0 || off > b.length || (off + len) > b.length || (off + len) < 0) {	        throw new IndexOutOfBoundsException();	    }	    if (len == 0) {	        return 0;	    }	    if (pos >= StrBuilder.this.size()) {	        return -1;	    }	    if (pos + len > size()) {	        len = StrBuilder.this.size() - pos;	    }	    StrBuilder.this.getChars(pos, pos + len, b, off);	    pos += len;	    return len;	}
public boolean isEmpty() {	    return size == 0;	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    if (input.charAt(index) == '\\' && index + 1 < input.length() && input.charAt(index + 1) == 'u') {	        int i = 2;	        while (index + i < input.length() && input.charAt(index + i) == 'u') {	            i++;	        }	        if (index + i < input.length() && input.charAt(index + i) == '+') {	            i++;	        }	        if (index + i + 4 <= input.length()) {	            final CharSequence unicode = input.subSequence(index + i, index + i + 4);	            try {	                final int value = Integer.parseInt(unicode.toString(), 16);	                out.write((char) value);	            } catch (final NumberFormatException nfe) {	                throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe);	            }	            return i + 4;	        } else {	            throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + input.subSequence(index, input.length()) + "' due to end of CharSequence");	        }	    }	    return 0;	}
@Override	public Integer build() {	    return Integer.valueOf(toHashCode());	}
public abstract R getRight();
@Override	public void setValue(final Number value) {	    this.value = value.floatValue();	}
public boolean isAppendTransients() {	    return this.appendTransients;	}
public static String removeStart(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.startsWith(remove)) {	        return str.substring(remove.length());	    }	    return str;	}
@Override	public int length() {	    return size;	}
public static boolean contains(final boolean[] array, final boolean valueToFind) {	    return indexOf(array, valueToFind) != INDEX_NOT_FOUND;	}
public boolean replaceIn(final StrBuilder source, final int offset, final int length) {	    if (source == null) {	        return false;	    }	    return substitute(source, offset, length);	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
@Override	public boolean markSupported() {	    return true;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public boolean isEmpty() {	    return size == 0;	}
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) {	    final StringBuilder buffer = new StringBuilder();	    boolean lastOutputSeconds = false;	    final int sz = tokens.length;	    for (int i = 0; i < sz; i++) {	        final Token token = tokens[i];	        final Object value = token.getValue();	        final int count = token.getCount();	        if (value instanceof StringBuilder) {	            buffer.append(value.toString());	        } else {	            if (value == y) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years));	                lastOutputSeconds = false;	            } else if (value == M) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months));	                lastOutputSeconds = false;	            } else if (value == d) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days));	                lastOutputSeconds = false;	            } else if (value == H) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours));	                lastOutputSeconds = false;	            } else if (value == m) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes));	                lastOutputSeconds = false;	            } else if (value == s) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds));	                lastOutputSeconds = true;	            } else if (value == S) {	                if (lastOutputSeconds) {	                    milliseconds += 1000;	                    final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds);	                    buffer.append(str.substring(1));	                } else {	                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds));	                }	                lastOutputSeconds = false;	            }	        }	    }	    return buffer.toString();	}
@Override	public Byte getValue() {	    return Byte.valueOf(this.value);	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts) {	    if ((src.length == 0 && srcPos == 0) || 0 == nShorts) {	        return dstInit;	    }	    if ((nShorts - 1) * 16 + dstPos >= 32) {	        throw new IllegalArgumentException("(nShorts-1)*16+dstPos is greather or equal to than 32");	    }	    int out = dstInit;	    int shift = 0;	    for (int i = 0; i < nShorts; i++) {	        shift = i * 16 + dstPos;	        final int bits = (0xffff & src[i + srcPos]) << shift;	        final int mask = 0xffff << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
public static ConcurrentRuntimeException extractCauseUnchecked(final ExecutionException ex) {	    if (ex == null || ex.getCause() == null) {	        return null;	    }	    throwCause(ex);	    return new ConcurrentRuntimeException(ex.getMessage(), ex.getCause());	}
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return 0;	    }	    if (lhs == null || rhs == null) {	        throw new NullPointerException();	    }	    Class<?> lhsClazz = lhs.getClass();	    if (!lhsClazz.isInstance(rhs)) {	        throw new ClassCastException();	    }	    final CompareToBuilder compareToBuilder = new CompareToBuilder();	    reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);	    while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) {	        lhsClazz = lhsClazz.getSuperclass();	        reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);	    }	    return compareToBuilder.toComparison();	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
private static long getFragment(final Calendar calendar, final int fragment, final int unit) {	    if (calendar == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final long millisPerUnit = getMillisPerUnit(unit);	    long result = 0;	    switch(fragment) {	        case Calendar.YEAR:	            result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit;	            break;	        case Calendar.MONTH:	            result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit;	            break;	    }	    switch(fragment) {	        case Calendar.YEAR:	        case Calendar.MONTH:	        case Calendar.DAY_OF_YEAR:	        case Calendar.DATE:	            result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit;	        case Calendar.HOUR_OF_DAY:	            result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit;	        case Calendar.MINUTE:	            result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit;	        case Calendar.SECOND:	            result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit;	            break;	        case Calendar.MILLISECOND:	            break;	        default:	            throw new IllegalArgumentException("The fragment " + fragment + " is not supported");	    }	    return result;	}
public String getNullText() {	    return nullText;	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public static long getFragmentInHours(final Calendar calendar, final int fragment) {	    return getFragment(calendar, fragment, Calendar.HOUR_OF_DAY);	}
@Override	public double doubleValue() {	    return value;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
protected boolean isFieldSeparatorAtEnd() {	    return fieldSeparatorAtEnd;	}
@Override	public Date parse(final String source, final ParsePosition pos) {	    final int offset = pos.getIndex();	    final Matcher matcher = parsePattern.matcher(source.substring(offset));	    if (!matcher.lookingAt()) {	        return null;	    }	    final Calendar cal = Calendar.getInstance(timeZone, locale);	    cal.clear();	    for (int i = 0; i < strategies.length; ) {	        final Strategy strategy = strategies[i++];	        strategy.setCalendar(this, cal, matcher.group(i));	    }	    pos.setIndex(offset + matcher.end());	    return cal.getTime();	}
@Override	public boolean markSupported() {	    return true;	}
public int capacity() {	    return buffer.length;	}
public static CharRange is(final char ch) {	    return new CharRange(ch, ch, false);	}
public String getNewLineText() {	    return newLine;	}
@Override	public boolean equals(final Object obj) {	    if (obj == this) {	        return true;	    }	    if (obj == null) {	        return false;	    }	    if (!super.equals(obj)) {	        return false;	    }	    if (ObjectUtils.notEqual(getClass(), obj.getClass())) {	        return false;	    }	    final ExtendedMessageFormat rhs = (ExtendedMessageFormat) obj;	    if (ObjectUtils.notEqual(toPattern, rhs.toPattern)) {	        return false;	    }	    if (ObjectUtils.notEqual(registry, rhs.registry)) {	        return false;	    }	    return true;	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public int size() {	    return size;	}
public StrBuilder setNewLineText(final String newLine) {	    this.newLine = newLine;	    return this;	}
public static <K, V> V createIfAbsent(final ConcurrentMap<K, V> map, final K key, final ConcurrentInitializer<V> init) throws ConcurrentException {	    if (map == null || init == null) {	        return null;	    }	    final V value = map.get(key);	    if (value == null) {	        return putIfAbsent(map, key, init.get());	    }	    return value;	}
public static double[] addAll(final double[] array1, final double... array2) {	    if (array1 == null) {	        return clone(array2);	    } else if (array2 == null) {	        return clone(array1);	    }	    final double[] joinedArray = new double[array1.length + array2.length];	    System.arraycopy(array1, 0, joinedArray, 0, array1.length);	    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);	    return joinedArray;	}
public int capacity() {	    return buffer.length;	}
public int size() {	    return size;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) {	    if (src.length > 8) {	        throw new IllegalArgumentException("src.length>8: src.length=" + src.length);	    }	    if (src.length - srcPos < 4) {	        throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos);	    }	    if (src[srcPos + 3]) {	        if (src[srcPos + 2]) {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return '7';	                }	            } else {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return '3';	                }	            }	        } else {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return '5';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '1';	                }	            }	        }	    } else {	        if (src[srcPos + 2]) {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'e';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return 'a';	                } else {	                    return '2';	                }	            }	        } else {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'c';	                } else {	                    return '4';	                }	            } else {	                if (src[srcPos]) {	                    return '8';	                } else {	                    return '0';	                }	            }	        }	    }	}
@Override	public T get(final long timeout, final TimeUnit unit) {	    return value;	}
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = Integer.MAX_VALUE;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.indexOf(str, search, 0);	        if (tmp == INDEX_NOT_FOUND) {	            continue;	        }	        if (tmp < ret) {	            ret = tmp;	        }	    }	    return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public static Integer toIntegerObject(final Boolean bool, final Integer trueValue, final Integer falseValue, final Integer nullValue) {	    if (bool == null) {	        return nullValue;	    }	    return bool.booleanValue() ? trueValue : falseValue;	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static Boolean[] toObject(final boolean[] array) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    final Boolean[] result = new Boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        result[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE);	    }	    return result;	}
public static <T> T CONST(final T v) {	    return v;	}
protected String getNullText() {	    return nullText;	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public static int hexDigitMsb0ToInt(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return 0x0;	        case '1':	            return 0x8;	        case '2':	            return 0x4;	        case '3':	            return 0xC;	        case '4':	            return 0x2;	        case '5':	            return 0xA;	        case '6':	            return 0x6;	        case '7':	            return 0xE;	        case '8':	            return 0x1;	        case '9':	            return 0x9;	        case 'a':	        case 'A':	            return 0x5;	        case 'b':	        case 'B':	            return 0xD;	        case 'c':	        case 'C':	            return 0x3;	        case 'd':	        case 'D':	            return 0xB;	        case 'e':	        case 'E':	            return 0x7;	        case 'f':	        case 'F':	            return 0xF;	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
@Override	public int length() {	    return size;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static long getFragmentInSeconds(final Calendar calendar, final int fragment) {	    return getFragment(calendar, fragment, Calendar.SECOND);	}
public String getNullText() {	    return nullText;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public void appendStart(final StringBuffer buffer, final Object object) {	    if (object != null) {	        appendClassName(buffer, object);	        appendIdentityHashCode(buffer, object);	        appendContentStart(buffer);	        if (fieldSeparatorAtStart) {	            appendFieldSeparator(buffer);	        }	    }	}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    buffer.append(arrayStart);	    for (int i = 0; i < array.length; i++) {	        if (i > 0) {	            buffer.append(arraySeparator);	        }	        appendDetail(buffer, fieldName, array[i]);	    }	    buffer.append(arrayEnd);	}
protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    appendSummarySize(buffer, fieldName, array.length);	}
public static String random(final int count, final char... chars) {	    if (chars == null) {	        return random(count, 0, 0, false, false, null, RANDOM);	    }	    return random(count, 0, chars.length, false, false, chars, RANDOM);	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
protected void setSummaryObjectEndText(String summaryObjectEndText) {	    if (summaryObjectEndText == null) {	        summaryObjectEndText = "";	    }	    this.summaryObjectEndText = summaryObjectEndText;	}
public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) {	    if (it != null) {	        separator = ObjectUtils.toString(separator);	        while (it.hasNext()) {	            append(it.next());	            if (it.hasNext()) {	                append(separator);	            }	        }	    }	    return this;	}
public static short[] removeElement(final short[] array, final short element) {	    final int index = indexOf(array, element);	    if (index == INDEX_NOT_FOUND) {	        return clone(array);	    }	    return remove(array, index);	}
@Deprecated	public static String chomp(final String str, final String separator) {	    return removeEnd(str, separator);	}
public static String getPackageName(String className) {	    if (StringUtils.isEmpty(className)) {	        return StringUtils.EMPTY;	    }	    while (className.charAt(0) == '[') {	        className = className.substring(1);	    }	    if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {	        className = className.substring(1);	    }	    final int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);	    if (i == -1) {	        return StringUtils.EMPTY;	    }	    return className.substring(0, i);	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
protected String getSummaryObjectStartText() {	    return summaryObjectStartText;	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
@Deprecated	public static String chomp(final String str, final String separator) {	    return removeEnd(str, separator);	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public static void reverse(final boolean[] array) {	    if (array == null) {	        return;	    }	    int i = 0;	    int j = array.length - 1;	    boolean tmp;	    while (j > i) {	        tmp = array[j];	        array[j] = array[i];	        array[i] = tmp;	        j--;	        i++;	    }	}
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) {	    style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));	    return this;	}
@Override	public Integer build() {	    return Integer.valueOf(toHashCode());	}
public static Class<?> getRawType(final Type type, final Type assigningType) {	    if (type instanceof Class<?>) {	        return (Class<?>) type;	    }	    if (type instanceof ParameterizedType) {	        return getRawType((ParameterizedType) type);	    }	    if (type instanceof TypeVariable<?>) {	        if (assigningType == null) {	            return null;	        }	        final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration();	        if (!(genericDeclaration instanceof Class<?>)) {	            return null;	        }	        final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType, (Class<?>) genericDeclaration);	        if (typeVarAssigns == null) {	            return null;	        }	        final Type typeArgument = typeVarAssigns.get(type);	        if (typeArgument == null) {	            return null;	        }	        return getRawType(typeArgument, assigningType);	    }	    if (type instanceof GenericArrayType) {	        final Class<?> rawComponentType = getRawType(((GenericArrayType) type).getGenericComponentType(), assigningType);	        return Array.newInstance(rawComponentType, 0).getClass();	    }	    if (type instanceof WildcardType) {	        return null;	    }	    throw new IllegalArgumentException("unknown type: " + type);	}
public static long toLong(final String str, final long defaultValue) {	    if (str == null) {	        return defaultValue;	    }	    try {	        return Long.parseLong(str);	    } catch (final NumberFormatException nfe) {	        return defaultValue;	    }	}
public static boolean isSameDay(final Calendar cal1, final Calendar cal2) {	    if (cal1 == null || cal2 == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    return (cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR));	}
public static boolean containsIgnoreCase(final CharSequence str, final CharSequence searchStr) {	    if (str == null || searchStr == null) {	        return false;	    }	    final int len = searchStr.length();	    final int max = str.length() - len;	    for (int i = 0; i <= max; i++) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, len)) {	            return true;	        }	    }	    return false;	}
public String substring(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    return new String(buffer, startIndex, endIndex - startIndex);	}
public static String abbreviate(final String str, int offset, final int maxWidth) {	    if (str == null) {	        return null;	    }	    if (maxWidth < 4) {	        throw new IllegalArgumentException("Minimum abbreviation width is 4");	    }	    if (str.length() <= maxWidth) {	        return str;	    }	    if (offset > str.length()) {	        offset = str.length();	    }	    if (str.length() - offset < maxWidth - 3) {	        offset = str.length() - (maxWidth - 3);	    }	    final String abrevMarker = "...";	    if (offset <= 4) {	        return str.substring(0, maxWidth - 3) + abrevMarker;	    }	    if (maxWidth < 7) {	        throw new IllegalArgumentException("Minimum abbreviation width with offset is 7");	    }	    if (offset + maxWidth - 3 < str.length()) {	        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);	    }	    return abrevMarker + str.substring(str.length() - (maxWidth - 3));	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
public static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) {	    if (0 == nHexs) {	        return dstInit;	    }	    if ((nHexs - 1) * 4 + srcPos >= 8) {	        throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 8");	    }	    final StringBuilder sb = new StringBuilder(dstInit);	    int shift = 0;	    int append = sb.length();	    for (int i = 0; i < nHexs; i++) {	        shift = i * 4 + srcPos;	        final int bits = 0xF & (src >> shift);	        if (dstPos + i == append) {	            ++append;	            sb.append(intToHexDigit(bits));	        } else {	            sb.setCharAt(dstPos + i, intToHexDigit(bits));	        }	    }	    return sb.toString();	}
public static boolean contains(final boolean[] array, final boolean valueToFind) {	    return indexOf(array, valueToFind) != INDEX_NOT_FOUND;	}
public boolean isEquals() {	    return this.isEquals;	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public boolean contains(final StrMatcher matcher) {	    return indexOf(matcher, 0) >= 0;	}
public static String stripToNull(String str) {	    if (str == null) {	        return null;	    }	    str = strip(str, null);	    return str.isEmpty() ? null : str;	}
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = Integer.MAX_VALUE;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.indexOf(str, search, 0);	        if (tmp == INDEX_NOT_FOUND) {	            continue;	        }	        if (tmp < ret) {	            ret = tmp;	        }	    }	    return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;	}
public static String overlay(final String str, String overlay, int start, int end) {	    if (str == null) {	        return null;	    }	    if (overlay == null) {	        overlay = EMPTY;	    }	    final int len = str.length();	    if (start < 0) {	        start = 0;	    }	    if (start > len) {	        start = len;	    }	    if (end < 0) {	        end = 0;	    }	    if (end > len) {	        end = len;	    }	    if (start > end) {	        final int temp = start;	        start = end;	        end = temp;	    }	    return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString();	}
public StrBuilder setNullText(String nullText) {	    if (nullText != null && nullText.isEmpty()) {	        nullText = null;	    }	    this.nullText = nullText;	    return this;	}
public String getNullText() {	    return nullText;	}
public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale) {	    return cache.getDateInstance(style, timeZone, locale);	}
@Override	public boolean markSupported() {	    return true;	}
@Override	public boolean equals(final Object obj2) {	    if (obj2 instanceof Token) {	        final Token tok2 = (Token) obj2;	        if (this.value.getClass() != tok2.value.getClass()) {	            return false;	        }	        if (this.count != tok2.count) {	            return false;	        }	        if (this.value instanceof StringBuilder) {	            return this.value.toString().equals(tok2.value.toString());	        } else if (this.value instanceof Number) {	            return this.value.equals(tok2.value);	        } else {	            return this.value == tok2.value;	        }	    }	    return false;	}
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] result = new boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        final Boolean b = array[i];	        result[i] = (b == null ? valueForNull : b.booleanValue());	    }	    return result;	}
protected abstract T initialize() throws Exception;
public boolean isEnableSubstitutionInVariables() {	    return enableSubstitutionInVariables;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale) {	    return cache.getDateTimeInstance(dateStyle, timeStyle, timeZone, locale);	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public static String formatUTC(final Date date, final String pattern, final Locale locale) {	    return format(date, pattern, UTC_TIME_ZONE, locale);	}
public StrTokenizer asTokenizer() {	    return new StrBuilderTokenizer();	}
@Override	public String getArrayEnd() {	    return super.getArrayEnd();	}
public Fraction abs() {	    if (numerator >= 0) {	        return this;	    }	    return negate();	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
protected String getSizeEndText() {	    return sizeEndText;	}
public static String appendIfMissing(final String str, final CharSequence suffix, final CharSequence... suffixes) {	    return appendIfMissing(str, suffix, false, suffixes);	}
public static Boolean or(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
protected boolean isUseFieldNames() {	    return useFieldNames;	}
@Override	public int length() {	    return size;	}
public int lastIndexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex >= size ? size - 1 : startIndex);	    if (matcher == null || startIndex < 0) {	        return -1;	    }	    final char[] buf = buffer;	    final int endIndex = startIndex + 1;	    for (int i = startIndex; i >= 0; i--) {	        if (matcher.isMatch(buf, i, 0, endIndex) > 0) {	            return i;	        }	    }	    return -1;	}
public static float min(final float a, final float b) {	    if (Float.isNaN(a)) {	        return b;	    } else if (Float.isNaN(b)) {	        return a;	    } else {	        return Math.min(a, b);	    }	}
public int getDenominator() {	    return denominator;	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public int size() {	    return size;	}
@Override	public String next() {	    if (hasNext()) {	        return tokens[tokenPos++];	    }	    throw new NoSuchElementException();	}
public static String random(final int count, final char... chars) {	    if (chars == null) {	        return random(count, 0, 0, false, false, null, RANDOM);	    }	    return random(count, 0, chars.length, false, false, chars, RANDOM);	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public static Boolean or(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
public boolean isInfinite() {	    return Double.isInfinite(value);	}
public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment) {	    return getFragment(calendar, fragment, Calendar.MILLISECOND);	}
public static float min(final float a, final float b) {	    if (Float.isNaN(a)) {	        return b;	    } else if (Float.isNaN(b)) {	        return a;	    } else {	        return Math.min(a, b);	    }	}
public StrBuilder replaceAll(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, -1);	}
@Override	public String toString() {	    return StringUtils.repeat(this.value.toString(), this.count);	}
protected String getArrayStart() {	    return arrayStart;	}
public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) {	    final Token[] tokens = lexx(format);	    final Calendar start = Calendar.getInstance(timezone);	    start.setTime(new Date(startMillis));	    final Calendar end = Calendar.getInstance(timezone);	    end.setTime(new Date(endMillis));	    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);	    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);	    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);	    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);	    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);	    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);	    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);	    while (milliseconds < 0) {	        milliseconds += 1000;	        seconds -= 1;	    }	    while (seconds < 0) {	        seconds += 60;	        minutes -= 1;	    }	    while (minutes < 0) {	        minutes += 60;	        hours -= 1;	    }	    while (hours < 0) {	        hours += 24;	        days -= 1;	    }	    if (Token.containsTokenWithValue(tokens, M)) {	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	        while (months < 0) {	            months += 12;	            years -= 1;	        }	        if (!Token.containsTokenWithValue(tokens, y) && years != 0) {	            while (years != 0) {	                months += 12 * years;	                years = 0;	            }	        }	    } else {	        if (!Token.containsTokenWithValue(tokens, y)) {	            int target = end.get(Calendar.YEAR);	            if (months < 0) {	                target -= 1;	            }	            while (start.get(Calendar.YEAR) != target) {	                days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);	                if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) {	                    days += 1;	                }	                start.add(Calendar.YEAR, 1);	                days += start.get(Calendar.DAY_OF_YEAR);	            }	            years = 0;	        }	        while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            start.add(Calendar.MONTH, 1);	        }	        months = 0;	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	    }	    if (!Token.containsTokenWithValue(tokens, d)) {	        hours += 24 * days;	        days = 0;	    }	    if (!Token.containsTokenWithValue(tokens, H)) {	        minutes += 60 * hours;	        hours = 0;	    }	    if (!Token.containsTokenWithValue(tokens, m)) {	        seconds += 60 * minutes;	        minutes = 0;	    }	    if (!Token.containsTokenWithValue(tokens, s)) {	        milliseconds += 1000 * seconds;	        seconds = 0;	    }	    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
static void unregister(final Object value) {	    Set<IDKey> registry = getRegistry();	    if (registry != null) {	        registry.remove(new IDKey(value));	        synchronized (HashCodeBuilder.class) {	            registry = getRegistry();	            if (registry != null && registry.isEmpty()) {	                REGISTRY.remove();	            }	        }	    }	}
public String getNewLineText() {	    return newLine;	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale) {	    return cache.getTimeInstance(style, timeZone, locale);	}
public static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools) {	    if ((src.length == 0 && srcPos == 0) || 0 == nBools) {	        return dstInit;	    }	    if (nBools - 1 + dstPos >= 8) {	        throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 8");	    }	    byte out = dstInit;	    int shift = 0;	    for (int i = 0; i < nBools; i++) {	        shift = i * 1 + dstPos;	        final int bits = (src[i + srcPos] ? 1 : 0) << shift;	        final int mask = 0x1 << shift;	        out = (byte) ((out & ~mask) | bits);	    }	    return out;	}
public StrBuilder replaceAll(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, -1);	}
private static boolean endsWith(final CharSequence str, final CharSequence suffix, final boolean ignoreCase) {	    if (str == null || suffix == null) {	        return str == null && suffix == null;	    }	    if (suffix.length() > str.length()) {	        return false;	    }	    final int strOffset = str.length() - suffix.length();	    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, suffix, 0, suffix.length());	}
public static String removeStartIgnoreCase(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (startsWithIgnoreCase(str, remove)) {	        return str.substring(remove.length());	    }	    return str;	}
public static boolean truncatedEquals(final Date date1, final Date date2, final int field) {	    return truncatedCompareTo(date1, date2, field) == 0;	}
public static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex) {	    if (0 == nHex) {	        return dstInit;	    }	    if ((nHex - 1) * 4 + dstPos >= 64) {	        throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 64");	    }	    long out = dstInit;	    int shift = 0;	    for (int i = 0; i < nHex; i++) {	        shift = i * 4 + dstPos;	        final long bits = (0xfL & hexDigitToInt(src.charAt(i + srcPos))) << shift;	        final long mask = 0xfL << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
public StrTokenizer setTrimmerMatcher(final StrMatcher trimmer) {	    if (trimmer != null) {	        this.trimmerMatcher = trimmer;	    }	    return this;	}
public int size() {	    return size;	}
protected boolean isUseShortClassName() {	    return useShortClassName;	}
public Double toDouble() {	    return Double.valueOf(doubleValue());	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
protected String getArraySeparator() {	    return arraySeparator;	}
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return new boolean[] { false, false, false, false };	        case '1':	            return new boolean[] { false, false, false, true };	        case '2':	            return new boolean[] { false, false, true, false };	        case '3':	            return new boolean[] { false, false, true, true };	        case '4':	            return new boolean[] { false, true, false, false };	        case '5':	            return new boolean[] { false, true, false, true };	        case '6':	            return new boolean[] { false, true, true, false };	        case '7':	            return new boolean[] { false, true, true, true };	        case '8':	            return new boolean[] { true, false, false, false };	        case '9':	            return new boolean[] { true, false, false, true };	        case 'a':	        case 'A':	            return new boolean[] { true, false, true, false };	        case 'b':	        case 'B':	            return new boolean[] { true, false, true, true };	        case 'c':	        case 'C':	            return new boolean[] { true, true, false, false };	        case 'd':	        case 'D':	            return new boolean[] { true, true, false, true };	        case 'e':	        case 'E':	            return new boolean[] { true, true, true, false };	        case 'f':	        case 'F':	            return new boolean[] { true, true, true, true };	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public synchronized boolean isStarted() {	    return future != null;	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes) {	    if ((src.length == 0 && srcPos == 0) || 0 == nBytes) {	        return dstInit;	    }	    if ((nBytes - 1) * 8 + dstPos >= 32) {	        throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 32");	    }	    int out = dstInit;	    int shift = 0;	    for (int i = 0; i < nBytes; i++) {	        shift = i * 8 + dstPos;	        final int bits = (0xff & src[i + srcPos]) << shift;	        final int mask = 0xff << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
public static String random(final int count, final char... chars) {	    if (chars == null) {	        return random(count, 0, 0, false, false, null, RANDOM);	    }	    return random(count, 0, chars.length, false, false, chars, RANDOM);	}
public static <T> T deserialize(final byte[] objectData) {	    if (objectData == null) {	        throw new IllegalArgumentException("The byte[] must not be null");	    }	    return SerializationUtils.<T>deserialize(new ByteArrayInputStream(objectData));	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
@Override	public TimeZone getTimeZone() {	    return mTimeZone;	}
@Override	public boolean translate(final int codepoint, final Writer out) throws IOException {	    if (between) {	        if (codepoint < below || codepoint > above) {	            return false;	        }	    } else {	        if (codepoint >= below && codepoint <= above) {	            return false;	        }	    }	    out.write("&#");	    out.write(Integer.toString(codepoint, 10));	    out.write(';');	    return true;	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
protected boolean isUseIdentityHashCode() {	    return useIdentityHashCode;	}
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = Integer.MAX_VALUE;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.indexOf(str, search, 0);	        if (tmp == INDEX_NOT_FOUND) {	            continue;	        }	        if (tmp < ret) {	            ret = tmp;	        }	    }	    return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;	}
@Override	public Locale getLocale() {	    return mLocale;	}
public void subtract(final Number operand) {	    this.value -= operand.longValue();	}
@Override	public String getSummaryObjectEndText() {	    return super.getSummaryObjectEndText();	}
public int indexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex < 0 ? 0 : startIndex);	    if (matcher == null || startIndex >= size) {	        return -1;	    }	    final int len = size;	    final char[] buf = buffer;	    for (int i = startIndex; i < len; i++) {	        if (matcher.isMatch(buf, i, startIndex, len) > 0) {	            return i;	        }	    }	    return -1;	}
public synchronized Future<T> getFuture() {	    if (future == null) {	        throw new IllegalStateException("start() must be called first!");	    }	    return future;	}
protected boolean isUseIdentityHashCode() {	    return useIdentityHashCode;	}
@Override	public int read(final char[] b, final int off, int len) {	    if (off < 0 || len < 0 || off > b.length || (off + len) > b.length || (off + len) < 0) {	        throw new IndexOutOfBoundsException();	    }	    if (len == 0) {	        return 0;	    }	    if (pos >= StrBuilder.this.size()) {	        return -1;	    }	    if (pos + len > size()) {	        len = StrBuilder.this.size() - pos;	    }	    StrBuilder.this.getChars(pos, pos + len, b, off);	    pos += len;	    return len;	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    if (input.charAt(index) == '\\' && index + 1 < input.length() && input.charAt(index + 1) == 'u') {	        int i = 2;	        while (index + i < input.length() && input.charAt(index + i) == 'u') {	            i++;	        }	        if (index + i < input.length() && input.charAt(index + i) == '+') {	            i++;	        }	        if (index + i + 4 <= input.length()) {	            final CharSequence unicode = input.subSequence(index + i, index + i + 4);	            try {	                final int value = Integer.parseInt(unicode.toString(), 16);	                out.write((char) value);	            } catch (final NumberFormatException nfe) {	                throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe);	            }	            return i + 4;	        } else {	            throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + input.subSequence(index, input.length()) + "' due to end of CharSequence");	        }	    }	    return 0;	}
public int capacity() {	    return buffer.length;	}
protected String getSummaryObjectStartText() {	    return summaryObjectStartText;	}
public final Boolean getDaemonFlag() {	    return daemonFlag;	}
@Override	public String toString() {	    return StringUtils.repeat(this.value.toString(), this.count);	}
public boolean isEquals() {	    return this.isEquals;	}
public static float toFloat(final String str, final float defaultValue) {	    if (str == null) {	        return defaultValue;	    }	    try {	        return Float.parseFloat(str);	    } catch (final NumberFormatException nfe) {	        return defaultValue;	    }	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
@Override	public String getFieldSeparator() {	    return super.getFieldSeparator();	}
public static Object invokeExactStaticMethod(final Class<?> cls, final String methodName, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {	    if (args == null) {	        args = ArrayUtils.EMPTY_OBJECT_ARRAY;	    }	    final Class<?>[] parameterTypes = ClassUtils.toClass(args);	    return invokeExactStaticMethod(cls, methodName, args, parameterTypes);	}
public static Locale toLocale(final String str) {	    if (str == null) {	        return null;	    }	    if (str.contains("#")) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final int len = str.length();	    if (len < 2) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final char ch0 = str.charAt(0);	    if (ch0 == '_') {	        if (len < 3) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        final char ch1 = str.charAt(1);	        final char ch2 = str.charAt(2);	        if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        if (len == 3) {	            return new Locale("", str.substring(1, 3));	        }	        if (len < 5) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        if (str.charAt(3) != '_') {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        return new Locale("", str.substring(1, 3), str.substring(4));	    }	    final char ch1 = str.charAt(1);	    if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (len == 2) {	        return new Locale(str);	    }	    if (len < 5) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (str.charAt(2) != '_') {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final char ch3 = str.charAt(3);	    if (ch3 == '_') {	        return new Locale(str.substring(0, 2), "", str.substring(4));	    }	    final char ch4 = str.charAt(4);	    if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (len == 5) {	        return new Locale(str.substring(0, 2), str.substring(3, 5));	    }	    if (len < 7) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (str.charAt(5) != '_') {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));	}
public String getNewLineText() {	    return newLine;	}
public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final E... values) {	    Validate.noNullElements(values);	    return generateBitVector(enumClass, Arrays.<E>asList(values));	}
public static String replaceSystemProperties(final Object source) {	    return new StrSubstitutor(StrLookup.systemPropertiesLookup()).replace(source);	}
public StrBuilder deleteFirst(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, 1);	}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    buffer.append(arrayStart);	    for (int i = 0; i < array.length; i++) {	        if (i > 0) {	            buffer.append(arraySeparator);	        }	        appendDetail(buffer, fieldName, array[i]);	    }	    buffer.append(arrayEnd);	}
public int capacity() {	    return buffer.length;	}
protected void setFieldNameValueSeparator(String fieldNameValueSeparator) {	    if (fieldNameValueSeparator == null) {	        fieldNameValueSeparator = "";	    }	    this.fieldNameValueSeparator = fieldNameValueSeparator;	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
protected String getSizeEndText() {	    return sizeEndText;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public String getNullText() {	    return nullText;	}
@Override	public long longValue() {	    return (long) value;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static CharRange is(final char ch) {	    return new CharRange(ch, ch, false);	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public int capacity() {	    return buffer.length;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public static Boolean[] toObject(final boolean[] array) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    final Boolean[] result = new Boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        result[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE);	    }	    return result;	}
public static int lastIndexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = INDEX_NOT_FOUND;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.lastIndexOf(str, search, str.length());	        if (tmp > ret) {	            ret = tmp;	        }	    }	    return ret;	}
public static byte[] serialize(final Serializable obj) {	    final ByteArrayOutputStream baos = new ByteArrayOutputStream(512);	    serialize(obj, baos);	    return baos.toByteArray();	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static char binaryToHexDigit(final boolean[] src, final int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    if (src.length > srcPos + 3 && src[srcPos + 3]) {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src[srcPos]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
@Override	public int length() {	    return size;	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
public static short[] removeElement(final short[] array, final short element) {	    final int index = indexOf(array, element);	    if (index == INDEX_NOT_FOUND) {	        return clone(array);	    }	    return remove(array, index);	}
public EqualsBuilder appendSuper(final boolean superEquals) {	    if (isEquals == false) {	        return this;	    }	    isEquals = superEquals;	    return this;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public String getNullText() {	    return nullText;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
public static boolean containsNone(final CharSequence cs, final String invalidChars) {	    if (cs == null || invalidChars == null) {	        return true;	    }	    return containsNone(cs, invalidChars.toCharArray());	}
public static boolean isEmpty(final CharSequence cs) {	    return cs == null || cs.length() == 0;	}
public static String trim(final String str) {	    return str == null ? null : str.trim();	}
public static String repeat(final char ch, final int repeat) {	    final char[] buf = new char[repeat];	    for (int i = repeat - 1; i >= 0; i--) {	        buf[i] = ch;	    }	    return new String(buf);	}
protected String getArraySeparator() {	    return arraySeparator;	}
public void subtract(final Number operand) {	    this.value -= operand.doubleValue();	}
public Fraction negate() {	    if (numerator == Integer.MIN_VALUE) {	        throw new ArithmeticException("overflow: too large to negate");	    }	    return new Fraction(-numerator, denominator);	}
@Override	public int length() {	    return size;	}
public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale) {	    return cache.getTimeInstance(style, timeZone, locale);	}
@Override	public void setContentEnd(final String contentEnd) {	    super.setContentEnd(contentEnd);	}
@Override	public int length() {	    return size;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = Integer.MAX_VALUE;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.indexOf(str, search, 0);	        if (tmp == INDEX_NOT_FOUND) {	            continue;	        }	        if (tmp < ret) {	            ret = tmp;	        }	    }	    return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;	}
@Override	public Integer build() {	    return Integer.valueOf(toHashCode());	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static void matchesPattern(final CharSequence input, final String pattern, final String message, final Object... values) {	    if (Pattern.matches(pattern, input) == false) {	        throw new IllegalArgumentException(String.format(message, values));	    }	}
public String getNullText() {	    return nullText;	}
public static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools) {	    if ((src.length == 0 && srcPos == 0) || 0 == nBools) {	        return dstInit;	    }	    if (nBools - 1 + dstPos >= 8) {	        throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 8");	    }	    byte out = dstInit;	    int shift = 0;	    for (int i = 0; i < nBools; i++) {	        shift = i * 1 + dstPos;	        final int bits = (src[i + srcPos] ? 1 : 0) << shift;	        final int mask = 0x1 << shift;	        out = (byte) ((out & ~mask) | bits);	    }	    return out;	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
void increment() {	    count++;	}
@Override	public int compare(final Object obj1, final Object obj2) {	    return ((Comparable) obj1).compareTo(obj2);	}
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) {	    final StringBuilder buffer = new StringBuilder();	    boolean lastOutputSeconds = false;	    final int sz = tokens.length;	    for (int i = 0; i < sz; i++) {	        final Token token = tokens[i];	        final Object value = token.getValue();	        final int count = token.getCount();	        if (value instanceof StringBuilder) {	            buffer.append(value.toString());	        } else {	            if (value == y) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years));	                lastOutputSeconds = false;	            } else if (value == M) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months));	                lastOutputSeconds = false;	            } else if (value == d) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days));	                lastOutputSeconds = false;	            } else if (value == H) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours));	                lastOutputSeconds = false;	            } else if (value == m) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes));	                lastOutputSeconds = false;	            } else if (value == s) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds));	                lastOutputSeconds = true;	            } else if (value == S) {	                if (lastOutputSeconds) {	                    milliseconds += 1000;	                    final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds);	                    buffer.append(str.substring(1));	                } else {	                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds));	                }	                lastOutputSeconds = false;	            }	        }	    }	    return buffer.toString();	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
@Override	public T get(final long timeout, final TimeUnit unit) {	    return value;	}
public static String leftPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return leftPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return padStr.concat(str);	    } else if (pads < padLen) {	        return padStr.substring(0, pads).concat(str);	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return new String(padding).concat(str);	    }	}
@Override	protected List<String> tokenize(final char[] chars, final int offset, final int count) {	    if (chars == null) {	        return super.tokenize(StrBuilder.this.buffer, 0, StrBuilder.this.size());	    }	    return super.tokenize(chars, offset, count);	}
public static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) {	    if (0 == nHexs) {	        return dstInit;	    }	    if ((nHexs - 1) * 4 + srcPos >= 32) {	        throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 32");	    }	    final StringBuilder sb = new StringBuilder(dstInit);	    int shift = 0;	    int append = sb.length();	    for (int i = 0; i < nHexs; i++) {	        shift = i * 4 + srcPos;	        final int bits = 0xF & (src >> shift);	        if (dstPos + i == append) {	            ++append;	            sb.append(intToHexDigit(bits));	        } else {	            sb.setCharAt(dstPos + i, intToHexDigit(bits));	        }	    }	    return sb.toString();	}
public static <T> T CONST(final T v) {	    return v;	}
@Override	public int previousIndex() {	    return tokenPos - 1;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public static String appendIfMissing(final String str, final CharSequence suffix, final CharSequence... suffixes) {	    return appendIfMissing(str, suffix, false, suffixes);	}
private static String[] splitByCharacterType(final String str, final boolean camelCase) {	    if (str == null) {	        return null;	    }	    if (str.isEmpty()) {	        return ArrayUtils.EMPTY_STRING_ARRAY;	    }	    final char[] c = str.toCharArray();	    final List<String> list = new ArrayList<String>();	    int tokenStart = 0;	    int currentType = Character.getType(c[tokenStart]);	    for (int pos = tokenStart + 1; pos < c.length; pos++) {	        final int type = Character.getType(c[pos]);	        if (type == currentType) {	            continue;	        }	        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {	            final int newTokenStart = pos - 1;	            if (newTokenStart != tokenStart) {	                list.add(new String(c, tokenStart, newTokenStart - tokenStart));	                tokenStart = newTokenStart;	            }	        } else {	            list.add(new String(c, tokenStart, pos - tokenStart));	            tokenStart = pos;	        }	        currentType = type;	    }	    list.add(new String(c, tokenStart, c.length - tokenStart));	    return list.toArray(new String[list.size()]);	}
public static final String unescapeHtml3(final String input) {	    return UNESCAPE_HTML3.translate(input);	}
public static String random(final int count, final char... chars) {	    if (chars == null) {	        return random(count, 0, 0, false, false, null, RANDOM);	    }	    return random(count, 0, chars.length, false, false, chars, RANDOM);	}
public static <E extends Enum<E>> E getEnum(final Class<E> enumClass, final String enumName) {	    if (enumName == null) {	        return null;	    }	    try {	        return Enum.valueOf(enumClass, enumName);	    } catch (final IllegalArgumentException ex) {	        return null;	    }	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public boolean isEmpty() {	    return size == 0;	}
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] result = new boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        final Boolean b = array[i];	        result[i] = (b == null ? valueForNull : b.booleanValue());	    }	    return result;	}
public static <T> T median(final Comparator<T> comparator, final T... items) {	    Validate.notEmpty(items, "null/empty items");	    Validate.noNullElements(items);	    Validate.notNull(comparator, "null comparator");	    final TreeSet<T> sort = new TreeSet<T>(comparator);	    Collections.addAll(sort, items);	    @SuppressWarnings("unchecked")	    final T result = (T) sort.toArray()[(sort.size() - 1) / 2];	    return result;	}
public int capacity() {	    return buffer.length;	}
public void decrement() {	    value--;	}
public static boolean contains(final boolean[] array, final boolean valueToFind) {	    return indexOf(array, valueToFind) != INDEX_NOT_FOUND;	}
public static <T extends Comparable<? super T>> int compare(final T c1, final T c2, final boolean nullGreater) {	    if (c1 == c2) {	        return 0;	    } else if (c1 == null) {	        return nullGreater ? 1 : -1;	    } else if (c2 == null) {	        return nullGreater ? -1 : 1;	    }	    return c1.compareTo(c2);	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
@Override	public int hashCode() {	    return toHashCode();	}
public StrBuilder ensureCapacity(final int capacity) {	    if (capacity > buffer.length) {	        final char[] old = buffer;	        buffer = new char[capacity * 2];	        System.arraycopy(old, 0, buffer, 0, size);	    }	    return this;	}
public static String wrap(final String str, int wrapLength, String newLineStr, final boolean wrapLongWords) {	    if (str == null) {	        return null;	    }	    if (newLineStr == null) {	        newLineStr = SystemUtils.LINE_SEPARATOR;	    }	    if (wrapLength < 1) {	        wrapLength = 1;	    }	    final int inputLineLength = str.length();	    int offset = 0;	    final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32);	    while (inputLineLength - offset > wrapLength) {	        if (str.charAt(offset) == ' ') {	            offset++;	            continue;	        }	        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);	        if (spaceToWrapAt >= offset) {	            wrappedLine.append(str.substring(offset, spaceToWrapAt));	            wrappedLine.append(newLineStr);	            offset = spaceToWrapAt + 1;	        } else {	            if (wrapLongWords) {	                wrappedLine.append(str.substring(offset, wrapLength + offset));	                wrappedLine.append(newLineStr);	                offset += wrapLength;	            } else {	                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);	                if (spaceToWrapAt >= 0) {	                    wrappedLine.append(str.substring(offset, spaceToWrapAt));	                    wrappedLine.append(newLineStr);	                    offset = spaceToWrapAt + 1;	                } else {	                    wrappedLine.append(str.substring(offset));	                    offset = inputLineLength;	                }	            }	        }	    }	    wrappedLine.append(str.substring(offset));	    return wrappedLine.toString();	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public String getNullText() {	    return nullText;	}
public static Long createLong(final String str) {	    if (str == null) {	        return null;	    }	    return Long.decode(str);	}
@Override	public int compare(final Object obj1, final Object obj2) {	    return ((Comparable) obj1).compareTo(obj2);	}
static boolean isPackageAccess(final int modifiers) {	    return (modifiers & ACCESS_TEST) == 0;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public String getNewLineText() {	    return newLine;	}
@Override	public boolean equals(final Object obj) {	    if (obj == null) {	        return false;	    }	    if (this == obj) {	        return true;	    }	    if (this.getClass() == obj.getClass()) {	        final MutableObject<?> that = (MutableObject<?>) obj;	        return this.value.equals(that.value);	    } else {	        return false;	    }	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static void reverse(final boolean[] array) {	    if (array == null) {	        return;	    }	    int i = 0;	    int j = array.length - 1;	    boolean tmp;	    while (j > i) {	        tmp = array[j];	        array[j] = array[i];	        array[i] = tmp;	        j--;	        i++;	    }	}
public boolean isEmpty() {	    return size == 0;	}
public static String keep(final String str, final String... set) {	    if (str == null) {	        return null;	    }	    if (str.isEmpty() || deepEmpty(set)) {	        return StringUtils.EMPTY;	    }	    return modify(str, set, true);	}
public static boolean toBooleanDefaultIfNull(final Boolean bool, final boolean valueIfNull) {	    if (bool == null) {	        return valueIfNull;	    }	    return bool.booleanValue();	}
public boolean isEquals() {	    return this.isEquals;	}
public static String replaceChars(final String str, final String searchChars, String replaceChars) {	    if (isEmpty(str) || isEmpty(searchChars)) {	        return str;	    }	    if (replaceChars == null) {	        replaceChars = EMPTY;	    }	    boolean modified = false;	    final int replaceCharsLength = replaceChars.length();	    final int strLength = str.length();	    final StringBuilder buf = new StringBuilder(strLength);	    for (int i = 0; i < strLength; i++) {	        final char ch = str.charAt(i);	        final int index = searchChars.indexOf(ch);	        if (index >= 0) {	            modified = true;	            if (index < replaceCharsLength) {	                buf.append(replaceChars.charAt(index));	            }	        } else {	            buf.append(ch);	        }	    }	    if (modified) {	        return buf.toString();	    }	    return str;	}
@Override	public int length() {	    return size;	}
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) {	    return new Range<T>(fromInclusive, toInclusive, comparator);	}
public int size() {	    return size;	}
@Override	public Integer build() {	    return Integer.valueOf(toHashCode());	}
@Override	public ContextedRuntimeException setContextValue(final String label, final Object value) {	    exceptionContext.setContextValue(label, value);	    return this;	}
public static Locale toLocale(final String str) {	    if (str == null) {	        return null;	    }	    if (str.contains("#")) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final int len = str.length();	    if (len < 2) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final char ch0 = str.charAt(0);	    if (ch0 == '_') {	        if (len < 3) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        final char ch1 = str.charAt(1);	        final char ch2 = str.charAt(2);	        if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        if (len == 3) {	            return new Locale("", str.substring(1, 3));	        }	        if (len < 5) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        if (str.charAt(3) != '_') {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        return new Locale("", str.substring(1, 3), str.substring(4));	    }	    final char ch1 = str.charAt(1);	    if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (len == 2) {	        return new Locale(str);	    }	    if (len < 5) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (str.charAt(2) != '_') {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final char ch3 = str.charAt(3);	    if (ch3 == '_') {	        return new Locale(str.substring(0, 2), "", str.substring(4));	    }	    final char ch4 = str.charAt(4);	    if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (len == 5) {	        return new Locale(str.substring(0, 2), str.substring(3, 5));	    }	    if (len < 7) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (str.charAt(5) != '_') {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));	}
public Fraction invert() {	    if (numerator == 0) {	        throw new ArithmeticException("Unable to invert zero.");	    }	    if (numerator == Integer.MIN_VALUE) {	        throw new ArithmeticException("overflow: can't negate numerator");	    }	    if (numerator < 0) {	        return new Fraction(-denominator, -numerator);	    } else {	        return new Fraction(denominator, numerator);	    }	}
public static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) {	    if (0 == nHexs) {	        return dstInit;	    }	    if ((nHexs - 1) * 4 + srcPos >= 16) {	        throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 16");	    }	    final StringBuilder sb = new StringBuilder(dstInit);	    int shift = 0;	    int append = sb.length();	    for (int i = 0; i < nHexs; i++) {	        shift = i * 4 + srcPos;	        final int bits = 0xF & (src >> shift);	        if (dstPos + i == append) {	            ++append;	            sb.append(intToHexDigit(bits));	        } else {	            sb.setCharAt(dstPos + i, intToHexDigit(bits));	        }	    }	    return sb.toString();	}
@Override	public boolean markSupported() {	    return true;	}
public static Method getAccessibleMethod(Method method) {	    if (!MemberUtils.isAccessible(method)) {	        return null;	    }	    final Class<?> cls = method.getDeclaringClass();	    if (Modifier.isPublic(cls.getModifiers())) {	        return method;	    }	    final String methodName = method.getName();	    final Class<?>[] parameterTypes = method.getParameterTypes();	    method = getAccessibleMethodFromInterfaceNest(cls, methodName, parameterTypes);	    if (method == null) {	        method = getAccessibleMethodFromSuperclass(cls, methodName, parameterTypes);	    }	    return method;	}
public StrBuilder appendSeparator(final char separator, final int loopIndex) {	    if (loopIndex > 0) {	        append(separator);	    }	    return this;	}
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return 0;	    }	    if (lhs == null || rhs == null) {	        throw new NullPointerException();	    }	    Class<?> lhsClazz = lhs.getClass();	    if (!lhsClazz.isInstance(rhs)) {	        throw new ClassCastException();	    }	    final CompareToBuilder compareToBuilder = new CompareToBuilder();	    reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);	    while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) {	        lhsClazz = lhsClazz.getSuperclass();	        reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);	    }	    return compareToBuilder.toComparison();	}
public static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    final int beSrcPos = src.length - 1 - srcPos;	    final int srcLen = Math.min(4, beSrcPos + 1);	    final boolean[] paddedSrc = new boolean[4];	    System.arraycopy(src, beSrcPos + 1 - srcLen, paddedSrc, 4 - srcLen, srcLen);	    src = paddedSrc;	    srcPos = 0;	    if (src[srcPos]) {	        if (src.length > srcPos + 1 && src[srcPos + 1]) {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 1 && src[srcPos + 1]) {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
private static boolean endsWith(final CharSequence str, final CharSequence suffix, final boolean ignoreCase) {	    if (str == null || suffix == null) {	        return str == null && suffix == null;	    }	    if (suffix.length() > str.length()) {	        return false;	    }	    final int strOffset = str.length() - suffix.length();	    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, suffix, 0, suffix.length());	}
public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale) {	    return cache.getInstance(pattern, timeZone, locale);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static float min(final float a, final float b, final float c) {	    return Math.min(Math.min(a, b), c);	}
public static Boolean and(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return and(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
public static String leftPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return leftPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return padStr.concat(str);	    } else if (pads < padLen) {	        return padStr.substring(0, pads).concat(str);	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return new String(padding).concat(str);	    }	}
public static boolean isValidAnnotationMemberType(Class<?> type) {	    if (type == null) {	        return false;	    }	    if (type.isArray()) {	        type = type.getComponentType();	    }	    return type.isPrimitive() || type.isEnum() || type.isAnnotation() || String.class.equals(type) || Class.class.equals(type);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public Writer asWriter() {	    return new StrBuilderWriter();	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
@Override	public int hashCode() {	    return toHashCode();	}
public static String center(String str, final int size, String padStr) {	    if (str == null || size <= 0) {	        return str;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    str = leftPad(str, strLen + pads / 2, padStr);	    str = rightPad(str, size, padStr);	    return str;	}
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = Integer.MAX_VALUE;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.indexOf(str, search, 0);	        if (tmp == INDEX_NOT_FOUND) {	            continue;	        }	        if (tmp < ret) {	            ret = tmp;	        }	    }	    return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;	}
public final Thread.UncaughtExceptionHandler getUncaughtExceptionHandler() {	    return uncaughtExceptionHandler;	}
public static final String escapeHtml3(final String input) {	    return ESCAPE_HTML3.translate(input);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
protected boolean isFieldSeparatorAtStart() {	    return fieldSeparatorAtStart;	}
@Deprecated	public static String chomp(final String str, final String separator) {	    return removeEnd(str, separator);	}
public static <L, M, R> ImmutableTriple<L, M, R> of(final L left, final M middle, final R right) {	    return new ImmutableTriple<L, M, R>(left, middle, right);	}
public static Number createNumber(final String str) throws NumberFormatException {	    if (str == null) {	        return null;	    }	    if (StringUtils.isBlank(str)) {	        throw new NumberFormatException("A blank string is not a valid number");	    }	    final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" };	    int pfxLen = 0;	    for (final String pfx : hex_prefixes) {	        if (str.startsWith(pfx)) {	            pfxLen += pfx.length();	            break;	        }	    }	    if (pfxLen > 0) {	        final int hexDigits = str.length() - pfxLen;	        if (hexDigits > 16) {	            return createBigInteger(str);	        }	        if (hexDigits > 8) {	            return createLong(str);	        }	        return createInteger(str);	    }	    final char lastChar = str.charAt(str.length() - 1);	    String mant;	    String dec;	    String exp;	    final int decPos = str.indexOf('.');	    final int expPos = str.indexOf('e') + str.indexOf('E') + 1;	    int numDecimals = 0;	    if (decPos > -1) {	        if (expPos > -1) {	            if (expPos < decPos || expPos > str.length()) {	                throw new NumberFormatException(str + " is not a valid number.");	            }	            dec = str.substring(decPos + 1, expPos);	        } else {	            dec = str.substring(decPos + 1);	        }	        mant = str.substring(0, decPos);	        numDecimals = dec.length();	    } else {	        if (expPos > -1) {	            if (expPos > str.length()) {	                throw new NumberFormatException(str + " is not a valid number.");	            }	            mant = str.substring(0, expPos);	        } else {	            mant = str;	        }	        dec = null;	    }	    if (!Character.isDigit(lastChar) && lastChar != '.') {	        if (expPos > -1 && expPos < str.length() - 1) {	            exp = str.substring(expPos + 1, str.length() - 1);	        } else {	            exp = null;	        }	        final String numeric = str.substring(0, str.length() - 1);	        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);	        switch(lastChar) {	            case 'l':	            case 'L':	                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {	                    try {	                        return createLong(numeric);	                    } catch (final NumberFormatException nfe) {	                    }	                    return createBigInteger(numeric);	                }	                throw new NumberFormatException(str + " is not a valid number.");	            case 'f':	            case 'F':	                try {	                    final Float f = NumberUtils.createFloat(numeric);	                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {	                        return f;	                    }	                } catch (final NumberFormatException nfe) {	                }	            case 'd':	            case 'D':	                try {	                    final Double d = NumberUtils.createDouble(numeric);	                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {	                        return d;	                    }	                } catch (final NumberFormatException nfe) {	                }	                try {	                    return createBigDecimal(numeric);	                } catch (final NumberFormatException e) {	                }	            default:	                throw new NumberFormatException(str + " is not a valid number.");	        }	    }	    if (expPos > -1 && expPos < str.length() - 1) {	        exp = str.substring(expPos + 1, str.length());	    } else {	        exp = null;	    }	    if (dec == null && exp == null) {	        try {	            return createInteger(str);	        } catch (final NumberFormatException nfe) {	        }	        try {	            return createLong(str);	        } catch (final NumberFormatException nfe) {	        }	        return createBigInteger(str);	    }	    final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);	    try {	        if (numDecimals <= 7) {	            final Float f = createFloat(str);	            if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {	                return f;	            }	        }	    } catch (final NumberFormatException nfe) {	    }	    try {	        if (numDecimals <= 16) {	            final Double d = createDouble(str);	            if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {	                return d;	            }	        }	    } catch (final NumberFormatException nfe) {	    }	    return createBigDecimal(str);	}
public String getNullText() {	    return nullText;	}
public String getNullText() {	    return nullText;	}
public static boolean isAlphanumeric(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetterOrDigit(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static CharRange is(final char ch) {	    return new CharRange(ch, ch, false);	}
@Override	public int length() {	    return size;	}
public static <E extends Enum<E>> E getEnum(final Class<E> enumClass, final String enumName) {	    if (enumName == null) {	        return null;	    }	    try {	        return Enum.valueOf(enumClass, enumName);	    } catch (final IllegalArgumentException ex) {	        return null;	    }	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
@Override	public TimeZone getTimeZone() {	    return timeZone;	}
public static String trimToNull(final String str) {	    final String ts = trim(str);	    return isEmpty(ts) ? null : ts;	}
public static float min(final float a, final float b, final float c) {	    return Math.min(Math.min(a, b), c);	}
public boolean isEmpty() {	    return size == 0;	}
public String getNullText() {	    return nullText;	}
public int capacity() {	    return buffer.length;	}
public void stop() {	    if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {	        throw new IllegalStateException("Stopwatch is not running. ");	    }	    if (this.runningState == STATE_RUNNING) {	        this.stopTime = System.nanoTime();	    }	    this.runningState = STATE_STOPPED;	}
public StrBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar) {	    return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);	}
public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final E... values) {	    Validate.noNullElements(values);	    return generateBitVector(enumClass, Arrays.<E>asList(values));	}
public static boolean containsNone(final CharSequence cs, final String invalidChars) {	    if (cs == null || invalidChars == null) {	        return true;	    }	    return containsNone(cs, invalidChars.toCharArray());	}
public String getNewLineText() {	    return newLine;	}
@Override	public TimeZone getTimeZone() {	    return printer.getTimeZone();	}
CharRange[] getCharRanges() {	    return set.toArray(new CharRange[set.size()]);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public int size() {	    return size;	}
public static Date truncate(final Object date, final int field) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (date instanceof Date) {	        return truncate((Date) date, field);	    } else if (date instanceof Calendar) {	        return truncate((Calendar) date, field).getTime();	    } else {	        throw new ClassCastException("Could not truncate " + date);	    }	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public StrBuilder deleteFirst(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, 1);	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
protected String getFieldNameValueSeparator() {	    return fieldNameValueSeparator;	}
public String getNewLineText() {	    return newLine;	}
public static Throwable[] getThrowables(final Throwable throwable) {	    final List<Throwable> list = getThrowableList(throwable);	    return list.toArray(new Throwable[list.size()]);	}
public String getNewLineText() {	    return newLine;	}
public String getNullText() {	    return nullText;	}
public static boolean isAllLowerCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLowerCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public int size() {	    return size;	}
public static String abbreviate(final String str, int offset, final int maxWidth) {	    if (str == null) {	        return null;	    }	    if (maxWidth < 4) {	        throw new IllegalArgumentException("Minimum abbreviation width is 4");	    }	    if (str.length() <= maxWidth) {	        return str;	    }	    if (offset > str.length()) {	        offset = str.length();	    }	    if (str.length() - offset < maxWidth - 3) {	        offset = str.length() - (maxWidth - 3);	    }	    final String abrevMarker = "...";	    if (offset <= 4) {	        return str.substring(0, maxWidth - 3) + abrevMarker;	    }	    if (maxWidth < 7) {	        throw new IllegalArgumentException("Minimum abbreviation width with offset is 7");	    }	    if (offset + maxWidth - 3 < str.length()) {	        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);	    }	    return abrevMarker + str.substring(str.length() - (maxWidth - 3));	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
@Override	public int length() {	    return size;	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public static final String escapeCsv(final String input) {	    return ESCAPE_CSV.translate(input);	}
public int size() {	    return size;	}
@Override	public boolean equals(final Object obj) {	    if (obj == this) {	        return true;	    }	    if (obj instanceof CharRange == false) {	        return false;	    }	    final CharRange other = (CharRange) obj;	    return start == other.start && end == other.end && negated == other.negated;	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public char[] toCharArray(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len == 0) {	        return ArrayUtils.EMPTY_CHAR_ARRAY;	    }	    final char[] chars = new char[len];	    System.arraycopy(buffer, startIndex, chars, 0, len);	    return chars;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public String midString(int index, final int length) {	    if (index < 0) {	        index = 0;	    }	    if (length <= 0 || index >= size) {	        return "";	    }	    if (size <= index + length) {	        return new String(buffer, index, size - index);	    }	    return new String(buffer, index, length);	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
protected boolean isUseIdentityHashCode() {	    return useIdentityHashCode;	}
public int toHashCode() {	    return iTotal;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public static long getFragmentInDays(final Calendar calendar, final int fragment) {	    return getFragment(calendar, fragment, Calendar.DAY_OF_YEAR);	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public StrBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar) {	    return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);	}
public String getNullText() {	    return nullText;	}
public boolean isEmpty() {	    return size == 0;	}
public int size() {	    return size;	}
public static List<Class<?>> convertClassNamesToClasses(final List<String> classNames) {	    if (classNames == null) {	        return null;	    }	    final List<Class<?>> classes = new ArrayList<Class<?>>(classNames.size());	    for (final String className : classNames) {	        try {	            classes.add(Class.forName(className));	        } catch (final Exception ex) {	            classes.add(null);	        }	    }	    return classes;	}
public static <T extends CharSequence> T defaultIfBlank(final T str, final T defaultStr) {	    return StringUtils.isBlank(str) ? defaultStr : str;	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, 1);	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
@Override	public int hashCode() {	    return toHashCode();	}
public boolean isEmptyTokenAsNull() {	    return this.emptyAsNull;	}
public static Throwable getRootCause(final Throwable throwable) {	    final List<Throwable> list = getThrowableList(throwable);	    return list.size() < 2 ? null : (Throwable) list.get(list.size() - 1);	}
public int capacity() {	    return buffer.length;	}
public static long getFragmentInMinutes(final Calendar calendar, final int fragment) {	    return getFragment(calendar, fragment, Calendar.MINUTE);	}
public String getNewLineText() {	    return newLine;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
static void register(final Object lhs, final Object rhs) {	    synchronized (EqualsBuilder.class) {	        if (getRegistry() == null) {	            REGISTRY.set(new HashSet<Pair<IDKey, IDKey>>());	        }	    }	    final Set<Pair<IDKey, IDKey>> registry = getRegistry();	    final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);	    registry.add(pair);	}
static JavaVersion getJavaVersion(final String nom) {	    return get(nom);	}
public boolean isEmpty() {	    return size == 0;	}
public boolean isEmpty() {	    return size == 0;	}
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) {	    if (str == null) {	        if (trueString == null) {	            return Boolean.TRUE;	        }	        if (falseString == null) {	            return Boolean.FALSE;	        }	        if (nullString == null) {	            return null;	        }	    } else if (str.equals(trueString)) {	        return Boolean.TRUE;	    } else if (str.equals(falseString)) {	        return Boolean.FALSE;	    } else if (str.equals(nullString)) {	        return null;	    }	    throw new IllegalArgumentException("The String did not match any specified value");	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
protected boolean isUseIdentityHashCode() {	    return useIdentityHashCode;	}
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException {	    return charsetName == null ? new String(bytes) : new String(bytes, charsetName);	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public StrBuilder appendSeparator(final char separator, final int loopIndex) {	    if (loopIndex > 0) {	        append(separator);	    }	    return this;	}
public StrTokenizer setQuoteMatcher(final StrMatcher quote) {	    if (quote != null) {	        this.quoteMatcher = quote;	    }	    return this;	}
private static String[] splitByCharacterType(final String str, final boolean camelCase) {	    if (str == null) {	        return null;	    }	    if (str.isEmpty()) {	        return ArrayUtils.EMPTY_STRING_ARRAY;	    }	    final char[] c = str.toCharArray();	    final List<String> list = new ArrayList<String>();	    int tokenStart = 0;	    int currentType = Character.getType(c[tokenStart]);	    for (int pos = tokenStart + 1; pos < c.length; pos++) {	        final int type = Character.getType(c[pos]);	        if (type == currentType) {	            continue;	        }	        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {	            final int newTokenStart = pos - 1;	            if (newTokenStart != tokenStart) {	                list.add(new String(c, tokenStart, newTokenStart - tokenStart));	                tokenStart = newTokenStart;	            }	        } else {	            list.add(new String(c, tokenStart, pos - tokenStart));	            tokenStart = pos;	        }	        currentType = type;	    }	    list.add(new String(c, tokenStart, c.length - tokenStart));	    return list.toArray(new String[list.size()]);	}
@Override	public void write(final String str, final int off, final int len) {	    StrBuilder.this.append(str, off, len);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
@Override	public void mark(final int readAheadLimit) {	    mark = pos;	}
static Object removeAll(final Object array, final BitSet indices) {	    final int srcLength = ArrayUtils.getLength(array);	    final int removals = indices.cardinality();	    final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals);	    int srcIndex = 0;	    int destIndex = 0;	    int count;	    int set;	    while ((set = indices.nextSetBit(srcIndex)) != -1) {	        count = set - srcIndex;	        if (count > 0) {	            System.arraycopy(array, srcIndex, result, destIndex, count);	            destIndex += count;	        }	        srcIndex = indices.nextClearBit(set);	    }	    count = srcLength - srcIndex;	    if (count > 0) {	        System.arraycopy(array, srcIndex, result, destIndex, count);	    }	    return result;	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
@Override	public TimeZone getTimeZone() {	    return timeZone;	}
protected boolean isUseShortClassName() {	    return useShortClassName;	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
public static boolean isAsciiAlphanumeric(final char ch) {	    return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9');	}
public void addInitializer(final String name, final BackgroundInitializer<?> init) {	    if (name == null) {	        throw new IllegalArgumentException("Name of child initializer must not be null!");	    }	    if (init == null) {	        throw new IllegalArgumentException("Child initializer must not be null!");	    }	    synchronized (this) {	        if (isStarted()) {	            throw new IllegalStateException("addInitializer() must not be called after start()!");	        }	        childInitializers.put(name, init);	    }	}
public int capacity() {	    return buffer.length;	}
public static String right(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(str.length() - len);	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public static boolean truncatedEquals(final Date date1, final Date date2, final int field) {	    return truncatedCompareTo(date1, date2, field) == 0;	}
public static String rightPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return rightPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return str.concat(padStr);	    } else if (pads < padLen) {	        return str.concat(padStr.substring(0, pads));	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return str.concat(new String(padding));	    }	}
static List<String> getStackFrameList(final Throwable t) {	    final String stackTrace = getStackTrace(t);	    final String linebreak = SystemUtils.LINE_SEPARATOR;	    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);	    final List<String> list = new ArrayList<String>();	    boolean traceStarted = false;	    while (frames.hasMoreTokens()) {	        final String token = frames.nextToken();	        final int at = token.indexOf("at");	        if (at != -1 && token.substring(0, at).trim().isEmpty()) {	            traceStarted = true;	            list.add(token);	        } else if (traceStarted) {	            break;	        }	    }	    return list;	}
public static boolean isAsciiControl(final char ch) {	    return ch < 32 || ch == 127;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public String getNullText() {	    return nullText;	}
public static short[] removeElement(final short[] array, final short element) {	    final int index = indexOf(array, element);	    if (index == INDEX_NOT_FOUND) {	        return clone(array);	    }	    return remove(array, index);	}
public static ConcurrentException extractCause(final ExecutionException ex) {	    if (ex == null || ex.getCause() == null) {	        return null;	    }	    throwCause(ex);	    return new ConcurrentException(ex.getMessage(), ex.getCause());	}
static char[] toCharArray(final CharSequence cs) {	    if (cs instanceof String) {	        return ((String) cs).toCharArray();	    } else {	        final int sz = cs.length();	        final char[] array = new char[cs.length()];	        for (int i = 0; i < sz; i++) {	            array[i] = cs.charAt(i);	        }	        return array;	    }	}
@Override	public int length() {	    return size;	}
public String getNewLineText() {	    return newLine;	}
public static int countMatches(final CharSequence str, final CharSequence sub) {	    if (isEmpty(str) || isEmpty(sub)) {	        return 0;	    }	    int count = 0;	    int idx = 0;	    while ((idx = CharSequenceUtils.indexOf(str, sub, idx)) != INDEX_NOT_FOUND) {	        count++;	        idx += sub.length();	    }	    return count;	}
public StrBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar) {	    return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);	}
public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) {	    if (array == null) {	        return null;	    }	    if (startIndexInclusive < 0) {	        startIndexInclusive = 0;	    }	    if (endIndexExclusive > array.length) {	        endIndexExclusive = array.length;	    }	    final int newSize = endIndexExclusive - startIndexInclusive;	    if (newSize <= 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] subarray = new boolean[newSize];	    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);	    return subarray;	}
public boolean isEmpty() {	    return size == 0;	}
protected ScheduledFuture<?> startTimer() {	    return getExecutorService().scheduleAtFixedRate(new Runnable() {		        @Override	        public void run() {	            endOfPeriod();	        }	    }, getPeriod(), getPeriod(), getUnit());	}
protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf) {	    return printer.applyRules(calendar, buf);	}
public long getNanoTime() {	    if (this.runningState == STATE_STOPPED || this.runningState == STATE_SUSPENDED) {	        return this.stopTime - this.startTime;	    } else if (this.runningState == STATE_UNSTARTED) {	        return 0;	    } else if (this.runningState == STATE_RUNNING) {	        return System.nanoTime() - this.startTime;	    }	    throw new RuntimeException("Illegal running state has occurred.");	}
public static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes) {	    if (0 == nBytes) {	        return dst;	    }	    if ((nBytes - 1) * 8 + srcPos >= 64) {	        throw new IllegalArgumentException("(nBytes-1)*8+srcPos is greather or equal to than 64");	    }	    int shift = 0;	    for (int i = 0; i < nBytes; i++) {	        shift = i * 8 + srcPos;	        dst[dstPos + i] = (byte) (0xff & (src >> shift));	    }	    return dst;	}
public static boolean isNotBlank(final CharSequence cs) {	    return !StringUtils.isBlank(cs);	}
@Override	public int length() {	    return size;	}
public int lastIndexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex >= size ? size - 1 : startIndex);	    if (matcher == null || startIndex < 0) {	        return -1;	    }	    final char[] buf = buffer;	    final int endIndex = startIndex + 1;	    for (int i = startIndex; i >= 0; i--) {	        if (matcher.isMatch(buf, i, 0, endIndex) > 0) {	            return i;	        }	    }	    return -1;	}
public static char binaryToHexDigit(final boolean[] src, final int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    if (src.length > srcPos + 3 && src[srcPos + 3]) {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src[srcPos]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
public String getNewLineText() {	    return newLine;	}
@Override	public T call() throws Exception {	    try {	        return initialize();	    } finally {	        if (execFinally != null) {	            execFinally.shutdown();	        }	    }	}
public static boolean isEmpty(final boolean[] array) {	    return array == null || array.length == 0;	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public int toComparison() {	    return comparison;	}
public void decrement() {	    value--;	}
public static boolean isAscii(final char ch) {	    return ch < 128;	}
@Override	public int length() {	    return size;	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return true;	    }	    if (lhs == null || rhs == null) {	        return false;	    }	    final Class<?> lhsClass = lhs.getClass();	    final Class<?> rhsClass = rhs.getClass();	    Class<?> testClass;	    if (lhsClass.isInstance(rhs)) {	        testClass = lhsClass;	        if (!rhsClass.isInstance(lhs)) {	            testClass = rhsClass;	        }	    } else if (rhsClass.isInstance(lhs)) {	        testClass = rhsClass;	        if (!lhsClass.isInstance(rhs)) {	            testClass = lhsClass;	        }	    } else {	        return false;	    }	    final EqualsBuilder equalsBuilder = new EqualsBuilder();	    try {	        reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {	            testClass = testClass.getSuperclass();	            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        }	    } catch (final IllegalArgumentException e) {	        return false;	    }	    return equalsBuilder.isEquals();	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public int capacity() {	    return buffer.length;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static String[] splitByWholeSeparatorPreserveAllTokens(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, true);	}
public static void validState(final boolean expression, final String message, final Object... values) {	    if (expression == false) {	        throw new IllegalStateException(String.format(message, values));	    }	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public boolean isEmpty() {	    return size == 0;	}
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return true;	    }	    if (lhs == null || rhs == null) {	        return false;	    }	    final Class<?> lhsClass = lhs.getClass();	    final Class<?> rhsClass = rhs.getClass();	    Class<?> testClass;	    if (lhsClass.isInstance(rhs)) {	        testClass = lhsClass;	        if (!rhsClass.isInstance(lhs)) {	            testClass = rhsClass;	        }	    } else if (rhsClass.isInstance(lhs)) {	        testClass = rhsClass;	        if (!lhsClass.isInstance(rhs)) {	            testClass = lhsClass;	        }	    } else {	        return false;	    }	    final EqualsBuilder equalsBuilder = new EqualsBuilder();	    try {	        reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {	            testClass = testClass.getSuperclass();	            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        }	    } catch (final IllegalArgumentException e) {	        return false;	    }	    return equalsBuilder.isEquals();	}
protected String getSummaryObjectStartText() {	    return summaryObjectStartText;	}
public static String overlay(final String str, String overlay, int start, int end) {	    if (str == null) {	        return null;	    }	    if (overlay == null) {	        overlay = EMPTY;	    }	    final int len = str.length();	    if (start < 0) {	        start = 0;	    }	    if (start > len) {	        start = len;	    }	    if (end < 0) {	        end = 0;	    }	    if (end > len) {	        end = len;	    }	    if (start > end) {	        final int temp = start;	        start = end;	        end = temp;	    }	    return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString();	}
public static Class<?> getClass(final String className, final boolean initialize) throws ClassNotFoundException {	    final ClassLoader contextCL = Thread.currentThread().getContextClassLoader();	    final ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL;	    return getClass(loader, className, initialize);	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
public String getNewLineText() {	    return newLine;	}
@Override	public Date parse(final String source, final ParsePosition pos) {	    return parser.parse(source, pos);	}
protected boolean isUseClassName() {	    return useClassName;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static String toStringOnOff(final boolean bool) {	    return toString(bool, "on", "off");	}
public static String formatDuration(long durationMillis, final String format, final boolean padWithZeros) {	    final Token[] tokens = lexx(format);	    int days = 0;	    int hours = 0;	    int minutes = 0;	    int seconds = 0;	    int milliseconds = 0;	    if (Token.containsTokenWithValue(tokens, d)) {	        days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY);	        durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY);	    }	    if (Token.containsTokenWithValue(tokens, H)) {	        hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR);	        durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR);	    }	    if (Token.containsTokenWithValue(tokens, m)) {	        minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE);	        durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE);	    }	    if (Token.containsTokenWithValue(tokens, s)) {	        seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND);	        durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND);	    }	    if (Token.containsTokenWithValue(tokens, S)) {	        milliseconds = (int) durationMillis;	    }	    return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
public boolean isEquals() {	    return this.isEquals;	}
public static String replaceChars(final String str, final String searchChars, String replaceChars) {	    if (isEmpty(str) || isEmpty(searchChars)) {	        return str;	    }	    if (replaceChars == null) {	        replaceChars = EMPTY;	    }	    boolean modified = false;	    final int replaceCharsLength = replaceChars.length();	    final int strLength = str.length();	    final StringBuilder buf = new StringBuilder(strLength);	    for (int i = 0; i < strLength; i++) {	        final char ch = str.charAt(i);	        final int index = searchChars.indexOf(ch);	        if (index >= 0) {	            modified = true;	            if (index < replaceCharsLength) {	                buf.append(replaceChars.charAt(index));	            }	        } else {	            buf.append(ch);	        }	    }	    if (modified) {	        return buf.toString();	    }	    return str;	}
public String nextToken() {	    if (hasNext()) {	        return tokens[tokenPos++];	    }	    return null;	}
public static Boolean[] nullToEmpty(final Boolean[] array) {	    if (array == null || array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    return array;	}
public static String right(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(str.length() - len);	}
protected boolean isFieldSeparatorAtEnd() {	    return fieldSeparatorAtEnd;	}
public static long getFragmentInSeconds(final Calendar calendar, final int fragment) {	    return getFragment(calendar, fragment, Calendar.SECOND);	}
@Override	public Date parse(final String source, final ParsePosition pos) {	    return parser.parse(source, pos);	}
public static String repeat(final char ch, final int repeat) {	    final char[] buf = new char[repeat];	    for (int i = repeat - 1; i >= 0; i--) {	        buf[i] = ch;	    }	    return new String(buf);	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
public final synchronized void setLimit(final int limit) {	    this.limit = limit;	}
public static boolean[] removeElements(final boolean[] array, final boolean... values) {	    if (isEmpty(array) || isEmpty(values)) {	        return clone(array);	    }	    final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2);	    for (final boolean v : values) {	        final Boolean boxed = Boolean.valueOf(v);	        final MutableInt count = occurrences.get(boxed);	        if (count == null) {	            occurrences.put(boxed, new MutableInt(1));	        } else {	            count.increment();	        }	    }	    final BitSet toRemove = new BitSet();	    for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) {	        final Boolean v = e.getKey();	        int found = 0;	        for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {	            found = indexOf(array, v.booleanValue(), found);	            if (found < 0) {	                break;	            }	            toRemove.set(found++);	        }	    }	    return (boolean[]) removeAll(array, toRemove);	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    if (input.charAt(index) == '\\' && index + 1 < input.length() && input.charAt(index + 1) == 'u') {	        int i = 2;	        while (index + i < input.length() && input.charAt(index + i) == 'u') {	            i++;	        }	        if (index + i < input.length() && input.charAt(index + i) == '+') {	            i++;	        }	        if (index + i + 4 <= input.length()) {	            final CharSequence unicode = input.subSequence(index + i, index + i + 4);	            try {	                final int value = Integer.parseInt(unicode.toString(), 16);	                out.write((char) value);	            } catch (final NumberFormatException nfe) {	                throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe);	            }	            return i + 4;	        } else {	            throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + input.subSequence(index, input.length()) + "' due to end of CharSequence");	        }	    }	    return 0;	}
public static boolean isAlpha(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public static String replaceOnce(final String text, final String searchString, final String replacement) {	    return replace(text, searchString, replacement, 1);	}
private static long getFragment(final Calendar calendar, final int fragment, final int unit) {	    if (calendar == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final long millisPerUnit = getMillisPerUnit(unit);	    long result = 0;	    switch(fragment) {	        case Calendar.YEAR:	            result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit;	            break;	        case Calendar.MONTH:	            result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit;	            break;	    }	    switch(fragment) {	        case Calendar.YEAR:	        case Calendar.MONTH:	        case Calendar.DAY_OF_YEAR:	        case Calendar.DATE:	            result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit;	        case Calendar.HOUR_OF_DAY:	            result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit;	        case Calendar.MINUTE:	            result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit;	        case Calendar.SECOND:	            result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit;	            break;	        case Calendar.MILLISECOND:	            break;	        default:	            throw new IllegalArgumentException("The fragment " + fragment + " is not supported");	    }	    return result;	}
public static <T extends CharSequence> T defaultIfBlank(final T str, final T defaultStr) {	    return StringUtils.isBlank(str) ? defaultStr : str;	}
static void unregister(final Object lhs, final Object rhs) {	    Set<Pair<IDKey, IDKey>> registry = getRegistry();	    if (registry != null) {	        final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);	        registry.remove(pair);	        synchronized (EqualsBuilder.class) {	            registry = getRegistry();	            if (registry != null && registry.isEmpty()) {	                REGISTRY.remove();	            }	        }	    }	}
public boolean isEmpty() {	    return size == 0;	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public void stop() {	    if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {	        throw new IllegalStateException("Stopwatch is not running. ");	    }	    if (this.runningState == STATE_RUNNING) {	        this.stopTime = System.nanoTime();	    }	    this.runningState = STATE_STOPPED;	}
public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) {	    if (array == null) {	        return null;	    }	    if (startIndexInclusive < 0) {	        startIndexInclusive = 0;	    }	    if (endIndexExclusive > array.length) {	        endIndexExclusive = array.length;	    }	    final int newSize = endIndexExclusive - startIndexInclusive;	    if (newSize <= 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] subarray = new boolean[newSize];	    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);	    return subarray;	}
@Override	public int hashCode() {	    return toHashCode();	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
@Override	public R getRight() {	    return right;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public int capacity() {	    return buffer.length;	}
public static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex) {	    if (0 == nHex) {	        return dstInit;	    }	    if ((nHex - 1) * 4 + dstPos >= 16) {	        throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 16");	    }	    short out = dstInit;	    int shift = 0;	    for (int i = 0; i < nHex; i++) {	        shift = i * 4 + dstPos;	        final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift;	        final int mask = 0xf << shift;	        out = (short) ((out & ~mask) | bits);	    }	    return out;	}
@Override	public TimeZone getTimeZone() {	    return mTimeZone;	}
public int capacity() {	    return buffer.length;	}
public static boolean isAlpha(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static String random(final int count, final char... chars) {	    if (chars == null) {	        return random(count, 0, 0, false, false, null, RANDOM);	    }	    return random(count, 0, chars.length, false, false, chars, RANDOM);	}
public static CharRange isNot(final char ch) {	    return new CharRange(ch, ch, true);	}
public int clear(final int holder) {	    return holder & ~_mask;	}
protected boolean accept(final Field field) {	    if (field.getName().indexOf(ClassUtils.INNER_CLASS_SEPARATOR_CHAR) != -1) {	        return false;	    }	    if (Modifier.isTransient(field.getModifiers()) && !this.isAppendTransients()) {	        return false;	    }	    if (Modifier.isStatic(field.getModifiers()) && !this.isAppendStatics()) {	        return false;	    }	    if (this.excludeFieldNames != null && Arrays.binarySearch(this.excludeFieldNames, field.getName()) >= 0) {	        return false;	    }	    return true;	}
@Override	public TimeZone getTimeZone() {	    return timeZone;	}
public static String reverse(final String str) {	    if (str == null) {	        return null;	    }	    return new StringBuilder(str).reverse().toString();	}
public boolean isEmptyTokenAsNull() {	    return this.emptyAsNull;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException {	    return parseDateWithLeniency(str, null, parsePatterns, false);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static CharRange is(final char ch) {	    return new CharRange(ch, ch, false);	}
protected boolean isArrayContentDetail() {	    return arrayContentDetail;	}
public HashCodeBuilder append(final short[] array) {	    if (array == null) {	        iTotal = iTotal * iConstant;	    } else {	        for (final short element : array) {	            append(element);	        }	    }	    return this;	}
protected String getArrayEnd() {	    return arrayEnd;	}
@Override	public void setValue(final Boolean value) {	    this.value = value.booleanValue();	}
protected void setSizeStartText(String sizeStartText) {	    if (sizeStartText == null) {	        sizeStartText = "";	    }	    this.sizeStartText = sizeStartText;	}
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] result = new boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        final Boolean b = array[i];	        result[i] = (b == null ? valueForNull : b.booleanValue());	    }	    return result;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public static String right(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(str.length() - len);	}
public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException {	    return parseDateWithLeniency(str, locale, parsePatterns, true);	}
public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) {	    if (it != null) {	        separator = ObjectUtils.toString(separator);	        while (it.hasNext()) {	            append(it.next());	            if (it.hasNext()) {	                append(separator);	            }	        }	    }	    return this;	}
public static String unicodeEscaped(final Character ch) {	    if (ch == null) {	        return null;	    }	    return unicodeEscaped(ch.charValue());	}
protected String getArrayStart() {	    return arrayStart;	}
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) {	    return new Range<T>(fromInclusive, toInclusive, comparator);	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static List<String> convertClassesToClassNames(final List<Class<?>> classes) {	    if (classes == null) {	        return null;	    }	    final List<String> classNames = new ArrayList<String>(classes.size());	    for (final Class<?> cls : classes) {	        if (cls == null) {	            classNames.add(null);	        } else {	            classNames.add(cls.getName());	        }	    }	    return classNames;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public static Locale toLocale(final String str) {	    if (str == null) {	        return null;	    }	    if (str.contains("#")) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final int len = str.length();	    if (len < 2) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final char ch0 = str.charAt(0);	    if (ch0 == '_') {	        if (len < 3) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        final char ch1 = str.charAt(1);	        final char ch2 = str.charAt(2);	        if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        if (len == 3) {	            return new Locale("", str.substring(1, 3));	        }	        if (len < 5) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        if (str.charAt(3) != '_') {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        return new Locale("", str.substring(1, 3), str.substring(4));	    }	    final char ch1 = str.charAt(1);	    if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (len == 2) {	        return new Locale(str);	    }	    if (len < 5) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (str.charAt(2) != '_') {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final char ch3 = str.charAt(3);	    if (ch3 == '_') {	        return new Locale(str.substring(0, 2), "", str.substring(4));	    }	    final char ch4 = str.charAt(4);	    if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (len == 5) {	        return new Locale(str.substring(0, 2), str.substring(3, 5));	    }	    if (len < 7) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (str.charAt(5) != '_') {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));	}
@Override	public boolean hasPrevious() {	    checkTokenized();	    return tokenPos > 0;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
@Override	public TimeZone getTimeZone() {	    return timeZone;	}
public int size() {	    return size;	}
static boolean isRegistered(final Object lhs, final Object rhs) {	    final Set<Pair<IDKey, IDKey>> registry = getRegistry();	    final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);	    final Pair<IDKey, IDKey> swappedPair = Pair.of(pair.getLeft(), pair.getRight());	    return registry != null && (registry.contains(pair) || registry.contains(swappedPair));	}
@Override	public Object parseObject(final String source, final ParsePosition pos) {	    return parse(source, pos);	}
@Override	public T get(final long timeout, final TimeUnit unit) {	    return value;	}
public static BigInteger createBigInteger(final String str) {	    if (str == null) {	        return null;	    }	    int pos = 0;	    int radix = 10;	    boolean negate = false;	    if (str.startsWith("-")) {	        negate = true;	        pos = 1;	    }	    if (str.startsWith("0x", pos) || str.startsWith("0x", pos)) {	        radix = 16;	        pos += 2;	    } else if (str.startsWith("#", pos)) {	        radix = 16;	        pos++;	    } else if (str.startsWith("0", pos) && str.length() > pos + 1) {	        radix = 8;	        pos++;	    }	    final BigInteger value = new BigInteger(str.substring(pos), radix);	    return negate ? value.negate() : value;	}
public static boolean endsWithIgnoreCase(final CharSequence str, final CharSequence suffix) {	    return endsWith(str, suffix, true);	}
public static String getCommonPrefix(final String... strs) {	    if (strs == null || strs.length == 0) {	        return EMPTY;	    }	    final int smallestIndexOfDiff = indexOfDifference(strs);	    if (smallestIndexOfDiff == INDEX_NOT_FOUND) {	        if (strs[0] == null) {	            return EMPTY;	        }	        return strs[0];	    } else if (smallestIndexOfDiff == 0) {	        return EMPTY;	    } else {	        return strs[0].substring(0, smallestIndexOfDiff);	    }	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
public static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts) {	    if (0 == nShorts) {	        return dst;	    }	    if ((nShorts - 1) * 16 + srcPos >= 64) {	        throw new IllegalArgumentException("(nShorts-1)*16+srcPos is greather or equal to than 64");	    }	    int shift = 0;	    for (int i = 0; i < nShorts; i++) {	        shift = i * 16 + srcPos;	        dst[dstPos + i] = (short) (0xffff & (src >> shift));	    }	    return dst;	}
public static <L, R> Pair<L, R> of(final L left, final R right) {	    return new ImmutablePair<L, R>(left, right);	}
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) {	    final StringBuilder buffer = new StringBuilder();	    boolean lastOutputSeconds = false;	    final int sz = tokens.length;	    for (int i = 0; i < sz; i++) {	        final Token token = tokens[i];	        final Object value = token.getValue();	        final int count = token.getCount();	        if (value instanceof StringBuilder) {	            buffer.append(value.toString());	        } else {	            if (value == y) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years));	                lastOutputSeconds = false;	            } else if (value == M) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months));	                lastOutputSeconds = false;	            } else if (value == d) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days));	                lastOutputSeconds = false;	            } else if (value == H) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours));	                lastOutputSeconds = false;	            } else if (value == m) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes));	                lastOutputSeconds = false;	            } else if (value == s) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds));	                lastOutputSeconds = true;	            } else if (value == S) {	                if (lastOutputSeconds) {	                    milliseconds += 1000;	                    final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds);	                    buffer.append(str.substring(1));	                } else {	                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds));	                }	                lastOutputSeconds = false;	            }	        }	    }	    return buffer.toString();	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static int lastIndexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = INDEX_NOT_FOUND;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.lastIndexOf(str, search, str.length());	        if (tmp > ret) {	            ret = tmp;	        }	    }	    return ret;	}
public int getNumerator() {	    return numerator;	}
public static long getFragmentInHours(final Calendar calendar, final int fragment) {	    return getFragment(calendar, fragment, Calendar.HOUR_OF_DAY);	}
public static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools) {	    if ((src.length == 0 && srcPos == 0) || 0 == nBools) {	        return dstInit;	    }	    if (nBools - 1 + dstPos >= 64) {	        throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 64");	    }	    long out = dstInit;	    int shift = 0;	    for (int i = 0; i < nBools; i++) {	        shift = i * 1 + dstPos;	        final long bits = (src[i + srcPos] ? 1L : 0) << shift;	        final long mask = 0x1L << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
private static void getAllInterfaces(Class<?> cls, final HashSet<Class<?>> interfacesFound) {	    while (cls != null) {	        final Class<?>[] interfaces = cls.getInterfaces();	        for (final Class<?> i : interfaces) {	            if (interfacesFound.add(i)) {	                getAllInterfaces(i, interfacesFound);	            }	        }	        cls = cls.getSuperclass();	    }	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
@Override	public int previousIndex() {	    return tokenPos - 1;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public boolean isEmpty() {	    return size == 0;	}
public int set(final int holder) {	    return holder | _mask;	}
protected String getArrayStart() {	    return arrayStart;	}
public static ConcurrentException extractCause(final ExecutionException ex) {	    if (ex == null || ex.getCause() == null) {	        return null;	    }	    throwCause(ex);	    return new ConcurrentException(ex.getMessage(), ex.getCause());	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static final String escapeJson(final String input) {	    return ESCAPE_JSON.translate(input);	}
public boolean isEquals() {	    return this.isEquals;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public int capacity() {	    return buffer.length;	}
public static String replaceChars(final String str, final String searchChars, String replaceChars) {	    if (isEmpty(str) || isEmpty(searchChars)) {	        return str;	    }	    if (replaceChars == null) {	        replaceChars = EMPTY;	    }	    boolean modified = false;	    final int replaceCharsLength = replaceChars.length();	    final int strLength = str.length();	    final StringBuilder buf = new StringBuilder(strLength);	    for (int i = 0; i < strLength; i++) {	        final char ch = str.charAt(i);	        final int index = searchChars.indexOf(ch);	        if (index >= 0) {	            modified = true;	            if (index < replaceCharsLength) {	                buf.append(replaceChars.charAt(index));	            }	        } else {	            buf.append(ch);	        }	    }	    if (modified) {	        return buf.toString();	    }	    return str;	}
public StrBuilder appendSeparator(final char separator, final int loopIndex) {	    if (loopIndex > 0) {	        append(separator);	    }	    return this;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public String getNewLineText() {	    return newLine;	}
public static String trimToNull(final String str) {	    final String ts = trim(str);	    return isEmpty(ts) ? null : ts;	}
public static boolean isAlphanumeric(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetterOrDigit(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
@Override	public BasicThreadFactory build() {	    final BasicThreadFactory factory = new BasicThreadFactory(this);	    reset();	    return factory;	}
public int lastIndexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex >= size ? size - 1 : startIndex);	    if (matcher == null || startIndex < 0) {	        return -1;	    }	    final char[] buf = buffer;	    final int endIndex = startIndex + 1;	    for (int i = startIndex; i >= 0; i--) {	        if (matcher.isMatch(buf, i, 0, endIndex) > 0) {	            return i;	        }	    }	    return -1;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public void subtract(final Number operand) {	    this.value -= operand.intValue();	}
public static short[] removeElement(final short[] array, final short element) {	    final int index = indexOf(array, element);	    if (index == INDEX_NOT_FOUND) {	        return clone(array);	    }	    return remove(array, index);	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public StrBuilder trim() {	    if (size == 0) {	        return this;	    }	    int len = size;	    final char[] buf = buffer;	    int pos = 0;	    while (pos < len && buf[pos] <= ' ') {	        pos++;	    }	    while (pos < len && buf[len - 1] <= ' ') {	        len--;	    }	    if (len < size) {	        delete(len, size);	    }	    if (pos > 0) {	        delete(0, pos);	    }	    return this;	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public void setLeft(final L left) {	    this.left = left;	}
public static int hexDigitMsb0ToInt(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return 0x0;	        case '1':	            return 0x8;	        case '2':	            return 0x4;	        case '3':	            return 0xC;	        case '4':	            return 0x2;	        case '5':	            return 0xA;	        case '6':	            return 0x6;	        case '7':	            return 0xE;	        case '8':	            return 0x1;	        case '9':	            return 0x9;	        case 'a':	        case 'A':	            return 0x5;	        case 'b':	        case 'B':	            return 0xD;	        case 'c':	        case 'C':	            return 0x3;	        case 'd':	        case 'D':	            return 0xB;	        case 'e':	        case 'E':	            return 0x7;	        case 'f':	        case 'F':	            return 0xF;	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public static boolean[] hexDigitToBinary(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return new boolean[] { false, false, false, false };	        case '1':	            return new boolean[] { true, false, false, false };	        case '2':	            return new boolean[] { false, true, false, false };	        case '3':	            return new boolean[] { true, true, false, false };	        case '4':	            return new boolean[] { false, false, true, false };	        case '5':	            return new boolean[] { true, false, true, false };	        case '6':	            return new boolean[] { false, true, true, false };	        case '7':	            return new boolean[] { true, true, true, false };	        case '8':	            return new boolean[] { false, false, false, true };	        case '9':	            return new boolean[] { true, false, false, true };	        case 'a':	        case 'A':	            return new boolean[] { false, true, false, true };	        case 'b':	        case 'B':	            return new boolean[] { true, true, false, true };	        case 'c':	        case 'C':	            return new boolean[] { false, false, true, true };	        case 'd':	        case 'D':	            return new boolean[] { true, false, true, true };	        case 'e':	        case 'E':	            return new boolean[] { false, true, true, true };	        case 'f':	        case 'F':	            return new boolean[] { true, true, true, true };	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public int lastIndexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex >= size ? size - 1 : startIndex);	    if (matcher == null || startIndex < 0) {	        return -1;	    }	    final char[] buf = buffer;	    final int endIndex = startIndex + 1;	    for (int i = startIndex; i >= 0; i--) {	        if (matcher.isMatch(buf, i, 0, endIndex) > 0) {	            return i;	        }	    }	    return -1;	}
public boolean isEmpty() {	    return size == 0;	}
@Override	public TimeZone getTimeZone() {	    return mTimeZone;	}
public int toHashCode() {	    return iTotal;	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) {	    return new Range<T>(fromInclusive, toInclusive, comparator);	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
protected void appendClassName(final StringBuffer buffer, final Object object) {	    if (useClassName && object != null) {	        register(object);	        if (useShortClassName) {	            buffer.append(getShortClassName(object.getClass()));	        } else {	            buffer.append(object.getClass().getName());	        }	    }	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) {	    if (s == null || t == null) {	        throw new IllegalArgumentException("Strings must not be null");	    }	    if (threshold < 0) {	        throw new IllegalArgumentException("Threshold must not be negative");	    }	    int n = s.length();	    int m = t.length();	    if (n == 0) {	        return m <= threshold ? m : -1;	    } else if (m == 0) {	        return n <= threshold ? n : -1;	    }	    if (n > m) {	        final CharSequence tmp = s;	        s = t;	        t = tmp;	        n = m;	        m = t.length();	    }	    int[] p = new int[n + 1];	    int[] d = new int[n + 1];	    int[] _d;	    final int boundary = Math.min(n, threshold) + 1;	    for (int i = 0; i < boundary; i++) {	        p[i] = i;	    }	    Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);	    Arrays.fill(d, Integer.MAX_VALUE);	    for (int j = 1; j <= m; j++) {	        final char t_j = t.charAt(j - 1);	        d[0] = j;	        final int min = Math.max(1, j - threshold);	        final int max = Math.min(n, j + threshold);	        if (min > max) {	            return -1;	        }	        if (min > 1) {	            d[min - 1] = Integer.MAX_VALUE;	        }	        for (int i = min; i <= max; i++) {	            if (s.charAt(i - 1) == t_j) {	                d[i] = p[i - 1];	            } else {	                d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);	            }	        }	        _d = p;	        p = d;	        d = _d;	    }	    if (p[n] <= threshold) {	        return p[n];	    }	    return -1;	}
@Override	public int compare(final Object obj1, final Object obj2) {	    return ((Comparable) obj1).compareTo(obj2);	}
public static Class<?>[] toClass(final Object... array) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return ArrayUtils.EMPTY_CLASS_ARRAY;	    }	    final Class<?>[] classes = new Class[array.length];	    for (int i = 0; i < array.length; i++) {	        classes[i] = array[i] == null ? null : array[i].getClass();	    }	    return classes;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public int capacity() {	    return buffer.length;	}
public static void reverse(final boolean[] array) {	    if (array == null) {	        return;	    }	    int i = 0;	    int j = array.length - 1;	    boolean tmp;	    while (j > i) {	        tmp = array[j];	        array[j] = array[i];	        array[i] = tmp;	        j--;	        i++;	    }	}
public static boolean isAsciiAlpha(final char ch) {	    return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
@Override	public int intValue() {	    return value;	}
public boolean isEmpty() {	    return size == 0;	}
@Override	public boolean equals(final Object obj) {	    if (obj == this) {	        return true;	    }	    if (obj instanceof Map.Entry<?, ?>) {	        final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;	        return ObjectUtils.equals(getKey(), other.getKey()) && ObjectUtils.equals(getValue(), other.getValue());	    }	    return false;	}
public int capacity() {	    return buffer.length;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static String abbreviateMiddle(final String str, final String middle, final int length) {	    if (isEmpty(str) || isEmpty(middle)) {	        return str;	    }	    if (length >= str.length() || length < middle.length() + 2) {	        return str;	    }	    final int targetSting = length - middle.length();	    final int startOffset = targetSting / 2 + targetSting % 2;	    final int endOffset = str.length() - targetSting / 2;	    final StringBuilder builder = new StringBuilder(length);	    builder.append(str.substring(0, startOffset));	    builder.append(middle);	    builder.append(str.substring(endOffset));	    return builder.toString();	}
protected String getFieldNameValueSeparator() {	    return fieldNameValueSeparator;	}
public String rightString(final int length) {	    if (length <= 0) {	        return "";	    } else if (length >= size) {	        return new String(buffer, 0, size);	    } else {	        return new String(buffer, size - length, length);	    }	}
public int getMaxLengthEstimate() {	    return mMaxLengthEstimate;	}
public String getNewLineText() {	    return newLine;	}
@Override	public int length() {	    return size;	}
public static String repeat(final char ch, final int repeat) {	    final char[] buf = new char[repeat];	    for (int i = repeat - 1; i >= 0; i--) {	        buf[i] = ch;	    }	    return new String(buf);	}
public static boolean isWhitespace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isWhitespace(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {	    if (str == null || searchStr == null) {	        return INDEX_NOT_FOUND;	    }	    if (startPos > str.length() - searchStr.length()) {	        startPos = str.length() - searchStr.length();	    }	    if (startPos < 0) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return startPos;	    }	    for (int i = startPos; i >= 0; i--) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static String formatDuration(long durationMillis, final String format, final boolean padWithZeros) {	    final Token[] tokens = lexx(format);	    int days = 0;	    int hours = 0;	    int minutes = 0;	    int seconds = 0;	    int milliseconds = 0;	    if (Token.containsTokenWithValue(tokens, d)) {	        days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY);	        durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY);	    }	    if (Token.containsTokenWithValue(tokens, H)) {	        hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR);	        durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR);	    }	    if (Token.containsTokenWithValue(tokens, m)) {	        minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE);	        durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE);	    }	    if (Token.containsTokenWithValue(tokens, s)) {	        seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND);	        durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND);	    }	    if (Token.containsTokenWithValue(tokens, S)) {	        milliseconds = (int) durationMillis;	    }	    return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
public static boolean startsWithAny(final CharSequence string, final CharSequence... searchStrings) {	    if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {	        return false;	    }	    for (final CharSequence searchString : searchStrings) {	        if (StringUtils.startsWith(string, searchString)) {	            return true;	        }	    }	    return false;	}
public final synchronized void setLimit(final int limit) {	    this.limit = limit;	}
public static String trimToEmpty(final String str) {	    return str == null ? EMPTY : str.trim();	}
public String getNullText() {	    return nullText;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public static String toString(final Object array, final String stringIfNull) {	    if (array == null) {	        return stringIfNull;	    }	    return new ToStringBuilder(array, ToStringStyle.SIMPLE_STYLE).append(array).toString();	}
@Override	public String next() {	    if (hasNext()) {	        return tokens[tokenPos++];	    }	    throw new NoSuchElementException();	}
private static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns) {	    if (!isAssignable(cls, toClass)) {	        return null;	    }	    if (cls.isPrimitive()) {	        if (toClass.isPrimitive()) {	            return new HashMap<TypeVariable<?>, Type>();	        }	        cls = ClassUtils.primitiveToWrapper(cls);	    }	    final HashMap<TypeVariable<?>, Type> typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>() : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);	    if (toClass.equals(cls)) {	        return typeVarAssigns;	    }	    return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns);	}
public static String formatDuration(long durationMillis, final String format, final boolean padWithZeros) {	    final Token[] tokens = lexx(format);	    int days = 0;	    int hours = 0;	    int minutes = 0;	    int seconds = 0;	    int milliseconds = 0;	    if (Token.containsTokenWithValue(tokens, d)) {	        days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY);	        durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY);	    }	    if (Token.containsTokenWithValue(tokens, H)) {	        hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR);	        durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR);	    }	    if (Token.containsTokenWithValue(tokens, m)) {	        minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE);	        durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE);	    }	    if (Token.containsTokenWithValue(tokens, s)) {	        seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND);	        durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND);	    }	    if (Token.containsTokenWithValue(tokens, S)) {	        milliseconds = (int) durationMillis;	    }	    return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
@Override	public int compareTo(final MutableInt other) {	    final int anotherVal = other.value;	    return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1);	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public int size() {	    return size;	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
@Override	public void setArrayStart(final String arrayStart) {	    super.setArrayStart(arrayStart);	}
public static String[] substringsBetween(final String str, final String open, final String close) {	    if (str == null || isEmpty(open) || isEmpty(close)) {	        return null;	    }	    final int strLen = str.length();	    if (strLen == 0) {	        return ArrayUtils.EMPTY_STRING_ARRAY;	    }	    final int closeLen = close.length();	    final int openLen = open.length();	    final List<String> list = new ArrayList<String>();	    int pos = 0;	    while (pos < strLen - closeLen) {	        int start = str.indexOf(open, pos);	        if (start < 0) {	            break;	        }	        start += openLen;	        final int end = str.indexOf(close, start);	        if (end < 0) {	            break;	        }	        list.add(str.substring(start, end));	        pos = end + closeLen;	    }	    if (list.isEmpty()) {	        return null;	    }	    return list.toArray(new String[list.size()]);	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
@Override	protected String toUtf16Escape(final int codepoint) {	    final char[] surrogatePair = Character.toChars(codepoint);	    return "\\u" + hex(surrogatePair[0]) + "\\u" + hex(surrogatePair[1]);	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
@Override	public String toString() {	    if (iToString == null) {	        final StringBuilder buf = new StringBuilder(4);	        if (isNegated()) {	            buf.append('^');	        }	        buf.append(start);	        if (start != end) {	            buf.append('-');	            buf.append(end);	        }	        iToString = buf.toString();	    }	    return iToString;	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
@Override	public int length() {	    return size;	}
public static boolean isEmpty(final boolean[] array) {	    return array == null || array.length == 0;	}
public Fraction pow(final int power) {	    if (power == 1) {	        return this;	    } else if (power == 0) {	        return ONE;	    } else if (power < 0) {	        if (power == Integer.MIN_VALUE) {	            return this.invert().pow(2).pow(-(power / 2));	        }	        return this.invert().pow(-power);	    } else {	        final Fraction f = this.multiplyBy(this);	        if (power % 2 == 0) {	            return f.pow(power / 2);	        } else {	            return f.pow(power / 2).multiplyBy(this);	        }	    }	}
@Override	public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) {	    return buffer[pos] <= 32 ? 1 : 0;	}
protected String getFieldNameValueSeparator() {	    return fieldNameValueSeparator;	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public static short CONST_SHORT(final int v) throws IllegalArgumentException {	    if (v < Short.MIN_VALUE || v > Short.MAX_VALUE) {	        throw new IllegalArgumentException("Supplied value must be a valid byte literal between -32768 and 32767: [" + v + "]");	    }	    return (short) v;	}
protected boolean isFieldSeparatorAtStart() {	    return fieldSeparatorAtStart;	}
@Override	public void mark(final int readAheadLimit) {	    mark = pos;	}
public char getStart() {	    return this.start;	}
public static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes) {	    if (0 == nBytes) {	        return dst;	    }	    if ((nBytes - 1) * 8 + srcPos >= 64) {	        throw new IllegalArgumentException("(nBytes-1)*8+srcPos is greather or equal to than 64");	    }	    int shift = 0;	    for (int i = 0; i < nBytes; i++) {	        shift = i * 8 + srcPos;	        dst[dstPos + i] = (byte) (0xff & (src >> shift));	    }	    return dst;	}
public StrSubstitutor setVariablePrefix(final String prefix) {	    if (prefix == null) {	        throw new IllegalArgumentException("Variable prefix must not be null!");	    }	    return setVariablePrefixMatcher(StrMatcher.stringMatcher(prefix));	}
public static <T extends CharSequence> T defaultIfBlank(final T str, final T defaultStr) {	    return StringUtils.isBlank(str) ? defaultStr : str;	}
public static <L, M, R> MutableTriple<L, M, R> of(final L left, final M middle, final R right) {	    return new MutableTriple<L, M, R>(left, middle, right);	}
public static Boolean xor(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return xor(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) {	    return new Range<T>(fromInclusive, toInclusive, comparator);	}
public static String lowerCase(final String str, final Locale locale) {	    if (str == null) {	        return null;	    }	    return str.toLowerCase(locale);	}
public boolean isAfter(final T element) {	    if (element == null) {	        return false;	    }	    return comparator.compare(element, minimum) < 0;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public int getDenominator() {	    return denominator;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public static StrTokenizer getCSVInstance(final char[] input) {	    final StrTokenizer tok = getCSVClone();	    tok.reset(input);	    return tok;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
@Override	public double doubleValue() {	    return value;	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
public char getEnd() {	    return this.end;	}
public static final String unescapeCsv(final String input) {	    return UNESCAPE_CSV.translate(input);	}
public boolean isEmpty() {	    return size == 0;	}
protected String getNullText() {	    return nullText;	}
protected String getArraySeparator() {	    return arraySeparator;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static Integer createInteger(final String str) {	    if (str == null) {	        return null;	    }	    return Integer.decode(str);	}
public static CharSequence subSequence(final CharSequence cs, final int start) {	    return cs == null ? null : cs.subSequence(start, cs.length());	}
protected String getFieldNameValueSeparator() {	    return fieldNameValueSeparator;	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public boolean replaceIn(final StrBuilder source, final int offset, final int length) {	    if (source == null) {	        return false;	    }	    return substitute(source, offset, length);	}
static String[] toNoNullStringArray(final Object[] array) {	    final List<String> list = new ArrayList<String>(array.length);	    for (final Object e : array) {	        if (e != null) {	            list.add(e.toString());	        }	    }	    return list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
@Override	public Date parse(final String source, final ParsePosition pos) {	    final int offset = pos.getIndex();	    final Matcher matcher = parsePattern.matcher(source.substring(offset));	    if (!matcher.lookingAt()) {	        return null;	    }	    final Calendar cal = Calendar.getInstance(timeZone, locale);	    cal.clear();	    for (int i = 0; i < strategies.length; ) {	        final Strategy strategy = strategies[i++];	        strategy.setCalendar(this, cal, matcher.group(i));	    }	    pos.setIndex(offset + matcher.end());	    return cal.getTime();	}
public static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) {	    if (0 == nHexs) {	        return dstInit;	    }	    if ((nHexs - 1) * 4 + srcPos >= 16) {	        throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 16");	    }	    final StringBuilder sb = new StringBuilder(dstInit);	    int shift = 0;	    int append = sb.length();	    for (int i = 0; i < nHexs; i++) {	        shift = i * 4 + srcPos;	        final int bits = 0xF & (src >> shift);	        if (dstPos + i == append) {	            ++append;	            sb.append(intToHexDigit(bits));	        } else {	            sb.setCharAt(dstPos + i, intToHexDigit(bits));	        }	    }	    return sb.toString();	}
public static String chop(final String str) {	    if (str == null) {	        return null;	    }	    final int strLen = str.length();	    if (strLen < 2) {	        return EMPTY;	    }	    final int lastIdx = strLen - 1;	    final String ret = str.substring(0, lastIdx);	    final char last = str.charAt(lastIdx);	    if (last == CharUtils.LF && ret.charAt(lastIdx - 1) == CharUtils.CR) {	        return ret.substring(0, lastIdx - 1);	    }	    return ret;	}
@Override	protected MultiBackgroundInitializerResults initialize() throws Exception {	    Map<String, BackgroundInitializer<?>> inits;	    synchronized (this) {	        inits = new HashMap<String, BackgroundInitializer<?>>(childInitializers);	    }	    final ExecutorService exec = getActiveExecutor();	    for (final BackgroundInitializer<?> bi : inits.values()) {	        if (bi.getExternalExecutor() == null) {	            bi.setExternalExecutor(exec);	        }	        bi.start();	    }	    final Map<String, Object> results = new HashMap<String, Object>();	    final Map<String, ConcurrentException> excepts = new HashMap<String, ConcurrentException>();	    for (final Map.Entry<String, BackgroundInitializer<?>> e : inits.entrySet()) {	        try {	            results.put(e.getKey(), e.getValue().get());	        } catch (final ConcurrentException cex) {	            excepts.put(e.getKey(), cex);	        }	    }	    return new MultiBackgroundInitializerResults(inits, results, excepts);	}
private static long getFragment(final Calendar calendar, final int fragment, final int unit) {	    if (calendar == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final long millisPerUnit = getMillisPerUnit(unit);	    long result = 0;	    switch(fragment) {	        case Calendar.YEAR:	            result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit;	            break;	        case Calendar.MONTH:	            result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit;	            break;	    }	    switch(fragment) {	        case Calendar.YEAR:	        case Calendar.MONTH:	        case Calendar.DAY_OF_YEAR:	        case Calendar.DATE:	            result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit;	        case Calendar.HOUR_OF_DAY:	            result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit;	        case Calendar.MINUTE:	            result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit;	        case Calendar.SECOND:	            result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit;	            break;	        case Calendar.MILLISECOND:	            break;	        default:	            throw new IllegalArgumentException("The fragment " + fragment + " is not supported");	    }	    return result;	}
public void add(final Number operand) {	    this.value += operand.shortValue();	}
public void start() {	    if (this.runningState == STATE_STOPPED) {	        throw new IllegalStateException("Stopwatch must be reset before being restarted. ");	    }	    if (this.runningState != STATE_UNSTARTED) {	        throw new IllegalStateException("Stopwatch already started. ");	    }	    this.startTime = System.nanoTime();	    this.startTimeMillis = System.currentTimeMillis();	    this.runningState = STATE_RUNNING;	}
public static boolean isEmpty(final CharSequence cs) {	    return cs == null || cs.length() == 0;	}
public static boolean isEmpty(final CharSequence cs) {	    return cs == null || cs.length() == 0;	}
public StrLookup<?> getVariableResolver() {	    return this.variableResolver;	}
public static Boolean[] nullToEmpty(final Boolean[] array) {	    if (array == null || array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    return array;	}
static Token[] lexx(final String format) {	    final char[] array = format.toCharArray();	    final ArrayList<Token> list = new ArrayList<Token>(array.length);	    boolean inLiteral = false;	    StringBuilder buffer = null;	    Token previous = null;	    final int sz = array.length;	    for (int i = 0; i < sz; i++) {	        final char ch = array[i];	        if (inLiteral && ch != '\'') {	            buffer.append(ch);	            continue;	        }	        Object value = null;	        switch(ch) {	            case '\'':	                if (inLiteral) {	                    buffer = null;	                    inLiteral = false;	                } else {	                    buffer = new StringBuilder();	                    list.add(new Token(buffer));	                    inLiteral = true;	                }	                break;	            case 'y':	                value = y;	                break;	            case 'M':	                value = M;	                break;	            case 'd':	                value = d;	                break;	            case 'H':	                value = H;	                break;	            case 'm':	                value = m;	                break;	            case 's':	                value = s;	                break;	            case 'S':	                value = S;	                break;	            default:	                if (buffer == null) {	                    buffer = new StringBuilder();	                    list.add(new Token(buffer));	                }	                buffer.append(ch);	        }	        if (value != null) {	            if (previous != null && previous.getValue() == value) {	                previous.increment();	            } else {	                final Token token = new Token(value);	                list.add(token);	                previous = token;	            }	            buffer = null;	        }	    }	    return list.toArray(new Token[list.size()]);	}
public int size() {	    return size;	}
public int capacity() {	    return buffer.length;	}
@Override	public int compareTo(final MutableInt other) {	    final int anotherVal = other.value;	    return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1);	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public boolean isEmptyTokenAsNull() {	    return this.emptyAsNull;	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public static int countMatches(final CharSequence str, final CharSequence sub) {	    if (isEmpty(str) || isEmpty(sub)) {	        return 0;	    }	    int count = 0;	    int idx = 0;	    while ((idx = CharSequenceUtils.indexOf(str, sub, idx)) != INDEX_NOT_FOUND) {	        count++;	        idx += sub.length();	    }	    return count;	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    final int seqEnd = input.length();	    if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') {	        int start = index + 2;	        boolean isHex = false;	        final char firstChar = input.charAt(start);	        if (firstChar == 'x' || firstChar == 'X') {	            start++;	            isHex = true;	            if (start == seqEnd) {	                return 0;	            }	        }	        int end = start;	        while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) {	            end++;	        }	        final boolean semiNext = end != seqEnd && input.charAt(end) == ';';	        if (!semiNext) {	            if (isSet(OPTION.semiColonRequired)) {	                return 0;	            } else if (isSet(OPTION.errorIfNoSemiColon)) {	                throw new IllegalArgumentException("Semi-colon required at end of numeric entity");	            }	        }	        int entityValue;	        try {	            if (isHex) {	                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);	            } else {	                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);	            }	        } catch (final NumberFormatException nfe) {	            return 0;	        }	        if (entityValue > 0xFFFF) {	            final char[] chrs = Character.toChars(entityValue);	            out.write(chrs[0]);	            out.write(chrs[1]);	        } else {	            out.write(entityValue);	        }	        return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0);	    }	    return 0;	}
public StrBuilder appendFixedWidthPadRight(final int value, final int width, final char padChar) {	    return appendFixedWidthPadRight(String.valueOf(value), width, padChar);	}
public static Integer toIntegerObject(final Boolean bool, final Integer trueValue, final Integer falseValue, final Integer nullValue) {	    if (bool == null) {	        return nullValue;	    }	    return bool.booleanValue() ? trueValue : falseValue;	}
@Override	public int length() {	    return size;	}
static int indexOf(final CharSequence cs, final CharSequence searchChar, final int start) {	    return cs.toString().indexOf(searchChar.toString(), start);	}
public boolean contains(final CharRange range) {	    if (range == null) {	        throw new IllegalArgumentException("The Range must not be null");	    }	    if (negated) {	        if (range.negated) {	            return start >= range.start && end <= range.end;	        }	        return range.end < start || range.start > end;	    }	    if (range.negated) {	        return start == 0 && end == Character.MAX_VALUE;	    }	    return start <= range.start && end >= range.end;	}
public static boolean isNumeric(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isDigit(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
public static String deleteWhitespace(final String str) {	    if (isEmpty(str)) {	        return str;	    }	    final int sz = str.length();	    final char[] chs = new char[sz];	    int count = 0;	    for (int i = 0; i < sz; i++) {	        if (!Character.isWhitespace(str.charAt(i))) {	            chs[count++] = str.charAt(i);	        }	    }	    if (count == sz) {	        return str;	    }	    return new String(chs, 0, count);	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public static double[] addAll(final double[] array1, final double... array2) {	    if (array1 == null) {	        return clone(array2);	    } else if (array2 == null) {	        return clone(array1);	    }	    final double[] joinedArray = new double[array1.length + array2.length];	    System.arraycopy(array1, 0, joinedArray, 0, array1.length);	    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);	    return joinedArray;	}
public int capacity() {	    return buffer.length;	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public static Calendar toCalendar(final Date date) {	    final Calendar c = Calendar.getInstance();	    c.setTime(date);	    return c;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return true;	    }	    if (lhs == null || rhs == null) {	        return false;	    }	    final Class<?> lhsClass = lhs.getClass();	    final Class<?> rhsClass = rhs.getClass();	    Class<?> testClass;	    if (lhsClass.isInstance(rhs)) {	        testClass = lhsClass;	        if (!rhsClass.isInstance(lhs)) {	            testClass = rhsClass;	        }	    } else if (rhsClass.isInstance(lhs)) {	        testClass = rhsClass;	        if (!lhsClass.isInstance(rhs)) {	            testClass = lhsClass;	        }	    } else {	        return false;	    }	    final EqualsBuilder equalsBuilder = new EqualsBuilder();	    try {	        reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {	            testClass = testClass.getSuperclass();	            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        }	    } catch (final IllegalArgumentException e) {	        return false;	    }	    return equalsBuilder.isEquals();	}
public static <K, V> V putIfAbsent(final ConcurrentMap<K, V> map, final K key, final V value) {	    if (map == null) {	        return null;	    }	    final V result = map.putIfAbsent(key, value);	    return result != null ? result : value;	}
@Override	public int previousIndex() {	    return tokenPos - 1;	}
public static boolean isAscii(final char ch) {	    return ch < 128;	}
@Override	public L getLeft() {	    return left;	}
public HashCodeBuilder append(final short[] array) {	    if (array == null) {	        iTotal = iTotal * iConstant;	    } else {	        for (final short element : array) {	            append(element);	        }	    }	    return this;	}
private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase) {	    if (str == null || prefix == null) {	        return str == null && prefix == null;	    }	    if (prefix.length() > str.length()) {	        return false;	    }	    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public int capacity() {	    return buffer.length;	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
@Override	public int length() {	    return size;	}
public static String substringAfter(final String str, final String separator) {	    if (isEmpty(str)) {	        return str;	    }	    if (separator == null) {	        return EMPTY;	    }	    final int pos = str.indexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return EMPTY;	    }	    return str.substring(pos + separator.length());	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static String abbreviateMiddle(final String str, final String middle, final int length) {	    if (isEmpty(str) || isEmpty(middle)) {	        return str;	    }	    if (length >= str.length() || length < middle.length() + 2) {	        return str;	    }	    final int targetSting = length - middle.length();	    final int startOffset = targetSting / 2 + targetSting % 2;	    final int endOffset = str.length() - targetSting / 2;	    final StringBuilder builder = new StringBuilder(length);	    builder.append(str.substring(0, startOffset));	    builder.append(middle);	    builder.append(str.substring(endOffset));	    return builder.toString();	}
public static String deleteWhitespace(final String str) {	    if (isEmpty(str)) {	        return str;	    }	    final int sz = str.length();	    final char[] chs = new char[sz];	    int count = 0;	    for (int i = 0; i < sz; i++) {	        if (!Character.isWhitespace(str.charAt(i))) {	            chs[count++] = str.charAt(i);	        }	    }	    if (count == sz) {	        return str;	    }	    return new String(chs, 0, count);	}
@Override	public int length() {	    return size;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
protected String getContentStart() {	    return contentStart;	}
public static String initials(final String str, final char... delimiters) {	    if (StringUtils.isEmpty(str)) {	        return str;	    }	    if (delimiters != null && delimiters.length == 0) {	        return "";	    }	    final int strLen = str.length();	    final char[] buf = new char[strLen / 2 + 1];	    int count = 0;	    boolean lastWasGap = true;	    for (int i = 0; i < strLen; i++) {	        final char ch = str.charAt(i);	        if (isDelimiter(ch, delimiters)) {	            lastWasGap = true;	        } else if (lastWasGap) {	            buf[count++] = ch;	            lastWasGap = false;	        } else {	            continue;	        }	    }	    return new String(buf, 0, count);	}
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) {	    if (bool == null) {	        return nullValue;	    }	    return bool.booleanValue() ? trueValue : falseValue;	}
@Override	public Set<String> getContextLabels() {	    final Set<String> labels = new HashSet<String>();	    for (final Pair<String, Object> pair : contextValues) {	        labels.add(pair.getKey());	    }	    return labels;	}
public static boolean isEmpty(final boolean[] array) {	    return array == null || array.length == 0;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
@Override	public int intValue() {	    return value;	}
public boolean isEquals() {	    return this.isEquals;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
@Override	public String next() {	    if (hasNext()) {	        return tokens[tokenPos++];	    }	    throw new NoSuchElementException();	}
public boolean isInfinite() {	    return Double.isInfinite(value);	}
public static String capitalize(final String str, final char... delimiters) {	    final int delimLen = delimiters == null ? -1 : delimiters.length;	    if (StringUtils.isEmpty(str) || delimLen == 0) {	        return str;	    }	    final char[] buffer = str.toCharArray();	    boolean capitalizeNext = true;	    for (int i = 0; i < buffer.length; i++) {	        final char ch = buffer[i];	        if (isDelimiter(ch, delimiters)) {	            capitalizeNext = true;	        } else if (capitalizeNext) {	            buffer[i] = Character.toTitleCase(ch);	            capitalizeNext = false;	        }	    }	    return new String(buffer);	}
public static String normalizeSpace(final String str) {	    if (str == null) {	        return null;	    }	    return WHITESPACE_PATTERN.matcher(trim(str)).replaceAll(SPACE);	}
public static String uncapitalize(final String str) {	    int strLen;	    if (str == null || (strLen = str.length()) == 0) {	        return str;	    }	    char firstChar = str.charAt(0);	    if (Character.isLowerCase(firstChar)) {	        return str;	    }	    return new StringBuilder(strLen).append(Character.toLowerCase(firstChar)).append(str.substring(1)).toString();	}
public static boolean isBlank(final CharSequence cs) {	    int strLen;	    if (cs == null || (strLen = cs.length()) == 0) {	        return true;	    }	    for (int i = 0; i < strLen; i++) {	        if (Character.isWhitespace(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
@Override	protected MultiBackgroundInitializerResults initialize() throws Exception {	    Map<String, BackgroundInitializer<?>> inits;	    synchronized (this) {	        inits = new HashMap<String, BackgroundInitializer<?>>(childInitializers);	    }	    final ExecutorService exec = getActiveExecutor();	    for (final BackgroundInitializer<?> bi : inits.values()) {	        if (bi.getExternalExecutor() == null) {	            bi.setExternalExecutor(exec);	        }	        bi.start();	    }	    final Map<String, Object> results = new HashMap<String, Object>();	    final Map<String, ConcurrentException> excepts = new HashMap<String, ConcurrentException>();	    for (final Map.Entry<String, BackgroundInitializer<?>> e : inits.entrySet()) {	        try {	            results.put(e.getKey(), e.getValue().get());	        } catch (final ConcurrentException cex) {	            excepts.put(e.getKey(), cex);	        }	    }	    return new MultiBackgroundInitializerResults(inits, results, excepts);	}
public StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, 1);	}
public int getNumerator() {	    return numerator;	}
public static <L, M, R> Triple<L, M, R> of(final L left, final M middle, final R right) {	    return new ImmutableTriple<L, M, R>(left, middle, right);	}
public void increment() {	    value++;	}
protected String getArrayStart() {	    return arrayStart;	}
@Override	public void mark(final int readAheadLimit) {	    mark = pos;	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static String toStringExclude(final Object object, final String... excludeFieldNames) {	    return new ReflectionToStringBuilder(object).setExcludeFieldNames(excludeFieldNames).toString();	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) {	    if (toClass == null) {	        return false;	    }	    if (cls == null) {	        return !toClass.isPrimitive();	    }	    if (autoboxing) {	        if (cls.isPrimitive() && !toClass.isPrimitive()) {	            cls = primitiveToWrapper(cls);	            if (cls == null) {	                return false;	            }	        }	        if (toClass.isPrimitive() && !cls.isPrimitive()) {	            cls = wrapperToPrimitive(cls);	            if (cls == null) {	                return false;	            }	        }	    }	    if (cls.equals(toClass)) {	        return true;	    }	    if (cls.isPrimitive()) {	        if (toClass.isPrimitive() == false) {	            return false;	        }	        if (Integer.TYPE.equals(cls)) {	            return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Long.TYPE.equals(cls)) {	            return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Boolean.TYPE.equals(cls)) {	            return false;	        }	        if (Double.TYPE.equals(cls)) {	            return false;	        }	        if (Float.TYPE.equals(cls)) {	            return Double.TYPE.equals(toClass);	        }	        if (Character.TYPE.equals(cls)) {	            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Short.TYPE.equals(cls)) {	            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Byte.TYPE.equals(cls)) {	            return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        return false;	    }	    return toClass.isAssignableFrom(cls);	}
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = Integer.MAX_VALUE;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.indexOf(str, search, 0);	        if (tmp == INDEX_NOT_FOUND) {	            continue;	        }	        if (tmp < ret) {	            ret = tmp;	        }	    }	    return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;	}
public String reformat(final String input) throws ParseException {	    return format(parseObject(input));	}
public boolean isEnableSubstitutionInVariables() {	    return enableSubstitutionInVariables;	}
protected String getArrayStart() {	    return arrayStart;	}
public static void handleCause(final ExecutionException ex) throws ConcurrentException {	    final ConcurrentException cex = extractCause(ex);	    if (cex != null) {	        throw cex;	    }	}
static JavaVersion get(final String nom) {	    if ("0.9".equals(nom)) {	        return JAVA_0_9;	    } else if ("1.1".equals(nom)) {	        return JAVA_1_1;	    } else if ("1.2".equals(nom)) {	        return JAVA_1_2;	    } else if ("1.3".equals(nom)) {	        return JAVA_1_3;	    } else if ("1.4".equals(nom)) {	        return JAVA_1_4;	    } else if ("1.5".equals(nom)) {	        return JAVA_1_5;	    } else if ("1.6".equals(nom)) {	        return JAVA_1_6;	    } else if ("1.7".equals(nom)) {	        return JAVA_1_7;	    } else if ("1.8".equals(nom)) {	        return JAVA_1_8;	    } else {	        return null;	    }	}
@Override	public Integer build() {	    return Integer.valueOf(toHashCode());	}
@Override	public void write(final String str, final int off, final int len) {	    StrBuilder.this.append(str, off, len);	}
@Override	public BasicThreadFactory build() {	    final BasicThreadFactory factory = new BasicThreadFactory(this);	    reset();	    return factory;	}
static void register(final Object value) {	    synchronized (HashCodeBuilder.class) {	        if (getRegistry() == null) {	            REGISTRY.set(new HashSet<IDKey>());	        }	    }	    getRegistry().add(new IDKey(value));	}
public String getNullText() {	    return nullText;	}
public int lastIndexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex >= size ? size - 1 : startIndex);	    if (matcher == null || startIndex < 0) {	        return -1;	    }	    final char[] buf = buffer;	    final int endIndex = startIndex + 1;	    for (int i = startIndex; i >= 0; i--) {	        if (matcher.isMatch(buf, i, 0, endIndex) > 0) {	            return i;	        }	    }	    return -1;	}
@Override	public void setFieldSeparator(final String fieldSeparator) {	    super.setFieldSeparator(fieldSeparator);	}
public int size() {	    return size;	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public static int reflectionHashCode(final Object object, final String... excludeFields) {	    return reflectionHashCode(17, 37, object, false, null, excludeFields);	}
protected boolean isArrayContentDetail() {	    return arrayContentDetail;	}
@Override	public float floatValue() {	    return (float) value;	}
@Override	public Float getValue() {	    return Float.valueOf(this.value);	}
public static String substringAfterLast(final String str, final String separator) {	    if (isEmpty(str)) {	        return str;	    }	    if (isEmpty(separator)) {	        return EMPTY;	    }	    final int pos = str.lastIndexOf(separator);	    if (pos == INDEX_NOT_FOUND || pos == str.length() - separator.length()) {	        return EMPTY;	    }	    return str.substring(pos + separator.length());	}
static int indexOf(final CharSequence cs, final CharSequence searchChar, final int start) {	    return cs.toString().indexOf(searchChar.toString(), start);	}
public void resume() {	    if (this.runningState != STATE_SUSPENDED) {	        throw new IllegalStateException("Stopwatch must be suspended to resume. ");	    }	    this.startTime += System.nanoTime() - this.stopTime;	    this.runningState = STATE_RUNNING;	}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    buffer.append(arrayStart);	    for (int i = 0; i < array.length; i++) {	        if (i > 0) {	            buffer.append(arraySeparator);	        }	        appendDetail(buffer, fieldName, array[i]);	    }	    buffer.append(arrayEnd);	}
public String getNewLineText() {	    return newLine;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static String random(final int count, final char... chars) {	    if (chars == null) {	        return random(count, 0, 0, false, false, null, RANDOM);	    }	    return random(count, 0, chars.length, false, false, chars, RANDOM);	}
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) {	    if (bool == null) {	        return nullValue;	    }	    return bool.booleanValue() ? trueValue : falseValue;	}
public char getEscapeChar() {	    return this.escapeChar;	}
public static float min(final float a, final float b) {	    if (Float.isNaN(a)) {	        return b;	    } else if (Float.isNaN(b)) {	        return a;	    } else {	        return Math.min(a, b);	    }	}
public static float toFloat(final String str, final float defaultValue) {	    if (str == null) {	        return defaultValue;	    }	    try {	        return Float.parseFloat(str);	    } catch (final NumberFormatException nfe) {	        return defaultValue;	    }	}
@Override	public void setValue(final Number value) {	    this.value = value.doubleValue();	}
public StrTokenizer setQuoteChar(final char quote) {	    return setQuoteMatcher(StrMatcher.charMatcher(quote));	}
protected String getSummaryObjectStartText() {	    return summaryObjectStartText;	}
@Override	public int length() {	    return size;	}
public static String randomAscii(final int count) {	    return random(count, 32, 127, false, false);	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public int getDenominator() {	    return denominator;	}
@Override	public TimeZone getTimeZone() {	    return mTimeZone;	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static Throwable getRootCause(final Throwable throwable) {	    final List<Throwable> list = getThrowableList(throwable);	    return list.size() < 2 ? null : (Throwable) list.get(list.size() - 1);	}
public static boolean isEmpty(final CharSequence cs) {	    return cs == null || cs.length() == 0;	}
public static Boolean[] nullToEmpty(final Boolean[] array) {	    if (array == null || array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    return array;	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    final int seqEnd = input.length();	    if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') {	        int start = index + 2;	        boolean isHex = false;	        final char firstChar = input.charAt(start);	        if (firstChar == 'x' || firstChar == 'X') {	            start++;	            isHex = true;	            if (start == seqEnd) {	                return 0;	            }	        }	        int end = start;	        while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) {	            end++;	        }	        final boolean semiNext = end != seqEnd && input.charAt(end) == ';';	        if (!semiNext) {	            if (isSet(OPTION.semiColonRequired)) {	                return 0;	            } else if (isSet(OPTION.errorIfNoSemiColon)) {	                throw new IllegalArgumentException("Semi-colon required at end of numeric entity");	            }	        }	        int entityValue;	        try {	            if (isHex) {	                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);	            } else {	                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);	            }	        } catch (final NumberFormatException nfe) {	            return 0;	        }	        if (entityValue > 0xFFFF) {	            final char[] chrs = Character.toChars(entityValue);	            out.write(chrs[0]);	            out.write(chrs[1]);	        } else {	            out.write(entityValue);	        }	        return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0);	    }	    return 0;	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
public static <T extends CharSequence> T validIndex(final T chars, final int index) {	    return validIndex(chars, index, DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE, Integer.valueOf(index));	}
@Override	public long longValue() {	    return (long) numerator / denominator;	}
public static boolean containsAny(final CharSequence cs, final CharSequence searchChars) {	    if (searchChars == null) {	        return false;	    }	    return containsAny(cs, CharSequenceUtils.toCharArray(searchChars));	}
@Override	public T call() throws Exception {	    try {	        return initialize();	    } finally {	        if (execFinally != null) {	            execFinally.shutdown();	        }	    }	}
public static boolean containsAny(final CharSequence cs, final CharSequence searchChars) {	    if (searchChars == null) {	        return false;	    }	    return containsAny(cs, CharSequenceUtils.toCharArray(searchChars));	}
@Override	public L getLeft() {	    return left;	}
public static String random(final int count, final char... chars) {	    if (chars == null) {	        return random(count, 0, 0, false, false, null, RANDOM);	    }	    return random(count, 0, chars.length, false, false, chars, RANDOM);	}
public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {	    if (str == null || searchStr == null) {	        return INDEX_NOT_FOUND;	    }	    if (startPos > str.length() - searchStr.length()) {	        startPos = str.length() - searchStr.length();	    }	    if (startPos < 0) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return startPos;	    }	    for (int i = startPos; i >= 0; i--) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static String chop(final String str) {	    if (str == null) {	        return null;	    }	    final int strLen = str.length();	    if (strLen < 2) {	        return EMPTY;	    }	    final int lastIdx = strLen - 1;	    final String ret = str.substring(0, lastIdx);	    final char last = str.charAt(lastIdx);	    if (last == CharUtils.LF && ret.charAt(lastIdx - 1) == CharUtils.CR) {	        return ret.substring(0, lastIdx - 1);	    }	    return ret;	}
public static <T> Range<T> is(final T element, final Comparator<T> comparator) {	    return between(element, element, comparator);	}
private static String[] splitByCharacterType(final String str, final boolean camelCase) {	    if (str == null) {	        return null;	    }	    if (str.isEmpty()) {	        return ArrayUtils.EMPTY_STRING_ARRAY;	    }	    final char[] c = str.toCharArray();	    final List<String> list = new ArrayList<String>();	    int tokenStart = 0;	    int currentType = Character.getType(c[tokenStart]);	    for (int pos = tokenStart + 1; pos < c.length; pos++) {	        final int type = Character.getType(c[pos]);	        if (type == currentType) {	            continue;	        }	        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {	            final int newTokenStart = pos - 1;	            if (newTokenStart != tokenStart) {	                list.add(new String(c, tokenStart, newTokenStart - tokenStart));	                tokenStart = newTokenStart;	            }	        } else {	            list.add(new String(c, tokenStart, pos - tokenStart));	            tokenStart = pos;	        }	        currentType = type;	    }	    list.add(new String(c, tokenStart, c.length - tokenStart));	    return list.toArray(new String[list.size()]);	}
public static String repeat(final char ch, final int repeat) {	    final char[] buf = new char[repeat];	    for (int i = repeat - 1; i >= 0; i--) {	        buf[i] = ch;	    }	    return new String(buf);	}
@Override	public boolean translate(final int codepoint, final Writer out) throws IOException {	    if (between) {	        if (codepoint < below || codepoint > above) {	            return false;	        }	    } else {	        if (codepoint >= below && codepoint <= above) {	            return false;	        }	    }	    out.write("&#");	    out.write(Integer.toString(codepoint, 10));	    out.write(';');	    return true;	}
public boolean isEmpty() {	    return size == 0;	}
public static String replaceChars(final String str, final String searchChars, String replaceChars) {	    if (isEmpty(str) || isEmpty(searchChars)) {	        return str;	    }	    if (replaceChars == null) {	        replaceChars = EMPTY;	    }	    boolean modified = false;	    final int replaceCharsLength = replaceChars.length();	    final int strLength = str.length();	    final StringBuilder buf = new StringBuilder(strLength);	    for (int i = 0; i < strLength; i++) {	        final char ch = str.charAt(i);	        final int index = searchChars.indexOf(ch);	        if (index >= 0) {	            modified = true;	            if (index < replaceCharsLength) {	                buf.append(replaceChars.charAt(index));	            }	        } else {	            buf.append(ch);	        }	    }	    if (modified) {	        return buf.toString();	    }	    return str;	}
public boolean startsWith(final String str) {	    if (str == null) {	        return false;	    }	    final int len = str.length();	    if (len == 0) {	        return true;	    }	    if (len > size) {	        return false;	    }	    for (int i = 0; i < len; i++) {	        if (buffer[i] != str.charAt(i)) {	            return false;	        }	    }	    return true;	}
public boolean replaceIn(final StrBuilder source, final int offset, final int length) {	    if (source == null) {	        return false;	    }	    return substitute(source, offset, length);	}
public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) {	    if (toClass == null) {	        return false;	    }	    if (cls == null) {	        return !toClass.isPrimitive();	    }	    if (autoboxing) {	        if (cls.isPrimitive() && !toClass.isPrimitive()) {	            cls = primitiveToWrapper(cls);	            if (cls == null) {	                return false;	            }	        }	        if (toClass.isPrimitive() && !cls.isPrimitive()) {	            cls = wrapperToPrimitive(cls);	            if (cls == null) {	                return false;	            }	        }	    }	    if (cls.equals(toClass)) {	        return true;	    }	    if (cls.isPrimitive()) {	        if (toClass.isPrimitive() == false) {	            return false;	        }	        if (Integer.TYPE.equals(cls)) {	            return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Long.TYPE.equals(cls)) {	            return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Boolean.TYPE.equals(cls)) {	            return false;	        }	        if (Double.TYPE.equals(cls)) {	            return false;	        }	        if (Float.TYPE.equals(cls)) {	            return Double.TYPE.equals(toClass);	        }	        if (Character.TYPE.equals(cls)) {	            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Short.TYPE.equals(cls)) {	            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Byte.TYPE.equals(cls)) {	            return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        return false;	    }	    return toClass.isAssignableFrom(cls);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static String[] splitByWholeSeparatorPreserveAllTokens(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, true);	}
public static String upperCase(final String str, final Locale locale) {	    if (str == null) {	        return null;	    }	    return str.toUpperCase(locale);	}
public static List<Locale> countriesByLanguage(final String languageCode) {	    if (languageCode == null) {	        return Collections.emptyList();	    }	    List<Locale> countries = cCountriesByLanguage.get(languageCode);	    if (countries == null) {	        countries = new ArrayList<Locale>();	        final List<Locale> locales = availableLocaleList();	        for (int i = 0; i < locales.size(); i++) {	            final Locale locale = locales.get(i);	            if (languageCode.equals(locale.getLanguage()) && locale.getCountry().length() != 0 && locale.getVariant().isEmpty()) {	                countries.add(locale);	            }	        }	        countries = Collections.unmodifiableList(countries);	        cCountriesByLanguage.putIfAbsent(languageCode, countries);	        countries = cCountriesByLanguage.get(languageCode);	    }	    return countries;	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
@Override	public TimeZone getTimeZone() {	    return timeZone;	}
public static int reflectionHashCode(final Object object, final String... excludeFields) {	    return reflectionHashCode(17, 37, object, false, null, excludeFields);	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
public String getNullText() {	    return nullText;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
protected String getArraySeparator() {	    return arraySeparator;	}
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) {	    if (bool == null) {	        return nullValue;	    }	    return bool.booleanValue() ? trueValue : falseValue;	}
@Override	public void setValue(final Boolean value) {	    this.value = value.booleanValue();	}
public static Date round(final Object date, final int field) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (date instanceof Date) {	        return round((Date) date, field);	    } else if (date instanceof Calendar) {	        return round((Calendar) date, field).getTime();	    } else {	        throw new ClassCastException("Could not round " + date);	    }	}
@Override	public String next() {	    if (hasNext()) {	        return tokens[tokenPos++];	    }	    throw new NoSuchElementException();	}
@Override	public int length() {	    return size;	}
protected String getArrayEnd() {	    return arrayEnd;	}
public StrBuilder deleteFirst(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, 1);	}
public boolean contains(final StrMatcher matcher) {	    return indexOf(matcher, 0) >= 0;	}
public int toComparison() {	    return comparison;	}
public static Boolean[] nullToEmpty(final Boolean[] array) {	    if (array == null || array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    return array;	}
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) {	    style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));	    return this;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
public static String formatDuration(long durationMillis, final String format, final boolean padWithZeros) {	    final Token[] tokens = lexx(format);	    int days = 0;	    int hours = 0;	    int minutes = 0;	    int seconds = 0;	    int milliseconds = 0;	    if (Token.containsTokenWithValue(tokens, d)) {	        days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY);	        durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY);	    }	    if (Token.containsTokenWithValue(tokens, H)) {	        hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR);	        durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR);	    }	    if (Token.containsTokenWithValue(tokens, m)) {	        minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE);	        durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE);	    }	    if (Token.containsTokenWithValue(tokens, s)) {	        seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND);	        durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND);	    }	    if (Token.containsTokenWithValue(tokens, S)) {	        milliseconds = (int) durationMillis;	    }	    return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
public String getNullText() {	    return nullText;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public String getNewLineText() {	    return newLine;	}
private static Date set(final Date date, final int calendarField, final int amount) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final Calendar c = Calendar.getInstance();	    c.setLenient(false);	    c.setTime(date);	    c.set(calendarField, amount);	    return c.getTime();	}
public static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes) {	    if (0 == nBytes) {	        return dst;	    }	    if ((nBytes - 1) * 8 + srcPos >= 64) {	        throw new IllegalArgumentException("(nBytes-1)*8+srcPos is greather or equal to than 64");	    }	    int shift = 0;	    for (int i = 0; i < nBytes; i++) {	        shift = i * 8 + srcPos;	        dst[dstPos + i] = (byte) (0xff & (src >> shift));	    }	    return dst;	}
public String getNewLineText() {	    return newLine;	}
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) {	    if (bool == null) {	        return nullValue;	    }	    return bool.booleanValue() ? trueValue : falseValue;	}
public void increment() {	    value++;	}
@Override	public T call() throws Exception {	    try {	        return initialize();	    } finally {	        if (execFinally != null) {	            execFinally.shutdown();	        }	    }	}
public static Date addWeeks(final Date date, final int amount) {	    return add(date, Calendar.WEEK_OF_YEAR, amount);	}
public static <L, M, R> Triple<L, M, R> of(final L left, final M middle, final R right) {	    return new ImmutableTriple<L, M, R>(left, middle, right);	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public boolean isEmpty() {	    return size == 0;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
public static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes) {	    if (0 == nBytes) {	        return dst;	    }	    if ((nBytes - 1) * 8 + srcPos >= 64) {	        throw new IllegalArgumentException("(nBytes-1)*8+srcPos is greather or equal to than 64");	    }	    int shift = 0;	    for (int i = 0; i < nBytes; i++) {	        shift = i * 8 + srcPos;	        dst[dstPos + i] = (byte) (0xff & (src >> shift));	    }	    return dst;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) {	    final Token[] tokens = lexx(format);	    final Calendar start = Calendar.getInstance(timezone);	    start.setTime(new Date(startMillis));	    final Calendar end = Calendar.getInstance(timezone);	    end.setTime(new Date(endMillis));	    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);	    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);	    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);	    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);	    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);	    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);	    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);	    while (milliseconds < 0) {	        milliseconds += 1000;	        seconds -= 1;	    }	    while (seconds < 0) {	        seconds += 60;	        minutes -= 1;	    }	    while (minutes < 0) {	        minutes += 60;	        hours -= 1;	    }	    while (hours < 0) {	        hours += 24;	        days -= 1;	    }	    if (Token.containsTokenWithValue(tokens, M)) {	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	        while (months < 0) {	            months += 12;	            years -= 1;	        }	        if (!Token.containsTokenWithValue(tokens, y) && years != 0) {	            while (years != 0) {	                months += 12 * years;	                years = 0;	            }	        }	    } else {	        if (!Token.containsTokenWithValue(tokens, y)) {	            int target = end.get(Calendar.YEAR);	            if (months < 0) {	                target -= 1;	            }	            while (start.get(Calendar.YEAR) != target) {	                days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);	                if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) {	                    days += 1;	                }	                start.add(Calendar.YEAR, 1);	                days += start.get(Calendar.DAY_OF_YEAR);	            }	            years = 0;	        }	        while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            start.add(Calendar.MONTH, 1);	        }	        months = 0;	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	    }	    if (!Token.containsTokenWithValue(tokens, d)) {	        hours += 24 * days;	        days = 0;	    }	    if (!Token.containsTokenWithValue(tokens, H)) {	        minutes += 60 * hours;	        hours = 0;	    }	    if (!Token.containsTokenWithValue(tokens, m)) {	        seconds += 60 * minutes;	        minutes = 0;	    }	    if (!Token.containsTokenWithValue(tokens, s)) {	        milliseconds += 1000 * seconds;	        seconds = 0;	    }	    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
public HashCodeBuilder append(final short[] array) {	    if (array == null) {	        iTotal = iTotal * iConstant;	    } else {	        for (final short element : array) {	            append(element);	        }	    }	    return this;	}
public static boolean isAsciiAlphaLower(final char ch) {	    return ch >= 'a' && ch <= 'z';	}
public boolean isEmpty() {	    return size == 0;	}
@Override	public int compareTo(final Pair<L, R> other) {	    return new CompareToBuilder().append(getLeft(), other.getLeft()).append(getRight(), other.getRight()).toComparison();	}
public boolean isEmpty() {	    return size == 0;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {	    if (array == null) {	        if (index != 0) {	            throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0");	        }	        final Object joinedArray = Array.newInstance(clss, 1);	        Array.set(joinedArray, 0, element);	        return joinedArray;	    }	    final int length = Array.getLength(array);	    if (index > length || index < 0) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(clss, length + 1);	    System.arraycopy(array, 0, result, 0, index);	    Array.set(result, index, element);	    if (index < length) {	        System.arraycopy(array, index, result, index + 1, length - index);	    }	    return result;	}
public static String rightPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return rightPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return str.concat(padStr);	    } else if (pads < padLen) {	        return str.concat(padStr.substring(0, pads));	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return str.concat(new String(padding));	    }	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
@Override	public String toString() {	    return String.valueOf(value);	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public void split() {	    if (this.runningState != STATE_RUNNING) {	        throw new IllegalStateException("Stopwatch is not running. ");	    }	    this.stopTime = System.nanoTime();	    this.splitState = STATE_SPLIT;	}
public boolean isAppendStatics() {	    return this.appendStatics;	}
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {	    if (array == null) {	        if (index != 0) {	            throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0");	        }	        final Object joinedArray = Array.newInstance(clss, 1);	        Array.set(joinedArray, 0, element);	        return joinedArray;	    }	    final int length = Array.getLength(array);	    if (index > length || index < 0) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(clss, length + 1);	    System.arraycopy(array, 0, result, 0, index);	    Array.set(result, index, element);	    if (index < length) {	        System.arraycopy(array, index, result, index + 1, length - index);	    }	    return result;	}
public static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes) {	    if ((src.length == 0 && srcPos == 0) || 0 == nBytes) {	        return dstInit;	    }	    if ((nBytes - 1) * 8 + dstPos >= 32) {	        throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 32");	    }	    int out = dstInit;	    int shift = 0;	    for (int i = 0; i < nBytes; i++) {	        shift = i * 8 + dstPos;	        final int bits = (0xff & src[i + srcPos]) << shift;	        final int mask = 0xff << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale) {	    return cache.getInstance(pattern, timeZone, locale);	}
@Override	public TimeZone getTimeZone() {	    return printer.getTimeZone();	}
protected String getArraySeparator() {	    return arraySeparator;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
@Override	public int length() {	    return size;	}
public static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes) {	    if (0 == nBytes) {	        return dst;	    }	    if ((nBytes - 1) * 8 + srcPos >= 32) {	        throw new IllegalArgumentException("(nBytes-1)*8+srcPos is greather or equal to than 32");	    }	    int shift = 0;	    for (int i = 0; i < nBytes; i++) {	        shift = i * 8 + srcPos;	        dst[dstPos + i] = (byte) (0xff & (src >> shift));	    }	    return dst;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) {	    if (0 == nHexs) {	        return dstInit;	    }	    if ((nHexs - 1) * 4 + srcPos >= 64) {	        throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 64");	    }	    final StringBuilder sb = new StringBuilder(dstInit);	    int shift = 0;	    int append = sb.length();	    for (int i = 0; i < nHexs; i++) {	        shift = i * 4 + srcPos;	        final int bits = (int) (0xF & (src >> shift));	        if (dstPos + i == append) {	            ++append;	            sb.append(intToHexDigit(bits));	        } else {	            sb.setCharAt(dstPos + i, intToHexDigit(bits));	        }	    }	    return sb.toString();	}
public int toComparison() {	    return comparison;	}
public Fraction subtract(final Fraction fraction) {	    return addSub(fraction, false);	}
public int capacity() {	    return buffer.length;	}
protected String getArrayStart() {	    return arrayStart;	}
public boolean isEmpty() {	    return size == 0;	}
public static CharRange isNot(final char ch) {	    return new CharRange(ch, ch, true);	}
public static String repeat(final char ch, final int repeat) {	    final char[] buf = new char[repeat];	    for (int i = repeat - 1; i >= 0; i--) {	        buf[i] = ch;	    }	    return new String(buf);	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static boolean equalsIgnoreCase(final CharSequence str1, final CharSequence str2) {	    if (str1 == null || str2 == null) {	        return str1 == str2;	    } else if (str1 == str2) {	        return true;	    } else if (str1.length() != str2.length()) {	        return false;	    } else {	        return CharSequenceUtils.regionMatches(str1, true, 0, str2, 0, str1.length());	    }	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
@Override	public String toString() {	    if (toString == null) {	        toString = new StringBuilder(32).append(getNumerator()).append('/').append(getDenominator()).toString();	    }	    return toString;	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static String formatPeriodISO(final long startMillis, final long endMillis) {	    return formatPeriod(startMillis, endMillis, ISO_EXTENDED_FORMAT_PATTERN, false, TimeZone.getDefault());	}
public static int indexOfAnyBut(final CharSequence seq, final CharSequence searchChars) {	    if (isEmpty(seq) || isEmpty(searchChars)) {	        return INDEX_NOT_FOUND;	    }	    final int strLen = seq.length();	    for (int i = 0; i < strLen; i++) {	        final char ch = seq.charAt(i);	        final boolean chFound = CharSequenceUtils.indexOf(searchChars, ch, 0) >= 0;	        if (i + 1 < strLen && Character.isHighSurrogate(ch)) {	            final char ch2 = seq.charAt(i + 1);	            if (chFound && CharSequenceUtils.indexOf(searchChars, ch2, 0) < 0) {	                return i;	            }	        } else {	            if (!chFound) {	                return i;	            }	        }	    }	    return INDEX_NOT_FOUND;	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
public int capacity() {	    return buffer.length;	}
public int capacity() {	    return buffer.length;	}
public static Iterator<?> iterator(final Object focus, final int rangeStyle) {	    if (focus == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (focus instanceof Date) {	        return iterator((Date) focus, rangeStyle);	    } else if (focus instanceof Calendar) {	        return iterator((Calendar) focus, rangeStyle);	    } else {	        throw new ClassCastException("Could not iterate based on " + focus);	    }	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static String randomAlphanumeric(final int count) {	    return random(count, true, true);	}
public static String right(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(str.length() - len);	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public boolean isEmpty() {	    return size == 0;	}
public int getNumerator() {	    return numerator;	}
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return new boolean[] { false, false, false, false };	        case '1':	            return new boolean[] { false, false, false, true };	        case '2':	            return new boolean[] { false, false, true, false };	        case '3':	            return new boolean[] { false, false, true, true };	        case '4':	            return new boolean[] { false, true, false, false };	        case '5':	            return new boolean[] { false, true, false, true };	        case '6':	            return new boolean[] { false, true, true, false };	        case '7':	            return new boolean[] { false, true, true, true };	        case '8':	            return new boolean[] { true, false, false, false };	        case '9':	            return new boolean[] { true, false, false, true };	        case 'a':	        case 'A':	            return new boolean[] { true, false, true, false };	        case 'b':	        case 'B':	            return new boolean[] { true, false, true, true };	        case 'c':	        case 'C':	            return new boolean[] { true, true, false, false };	        case 'd':	        case 'D':	            return new boolean[] { true, true, false, true };	        case 'e':	        case 'E':	            return new boolean[] { true, true, true, false };	        case 'f':	        case 'F':	            return new boolean[] { true, true, true, true };	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames) {	    if (causeFrames == null || wrapperFrames == null) {	        throw new IllegalArgumentException("The List must not be null");	    }	    int causeFrameIndex = causeFrames.size() - 1;	    int wrapperFrameIndex = wrapperFrames.size() - 1;	    while (causeFrameIndex >= 0 && wrapperFrameIndex >= 0) {	        final String causeFrame = causeFrames.get(causeFrameIndex);	        final String wrapperFrame = wrapperFrames.get(wrapperFrameIndex);	        if (causeFrame.equals(wrapperFrame)) {	            causeFrames.remove(causeFrameIndex);	        }	        causeFrameIndex--;	        wrapperFrameIndex--;	    }	}
public static short[] removeElement(final short[] array, final short element) {	    final int index = indexOf(array, element);	    if (index == INDEX_NOT_FOUND) {	        return clone(array);	    }	    return remove(array, index);	}
public static String removeEnd(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.endsWith(remove)) {	        return str.substring(0, str.length() - remove.length());	    }	    return str;	}
public StrBuilder appendSeparator(final char separator, final int loopIndex) {	    if (loopIndex > 0) {	        append(separator);	    }	    return this;	}
public String getNewLineText() {	    return newLine;	}
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException {	    return charsetName == null ? new String(bytes) : new String(bytes, charsetName);	}
public Fraction divideBy(final Fraction fraction) {	    if (fraction == null) {	        throw new IllegalArgumentException("The fraction must not be null");	    }	    if (fraction.numerator == 0) {	        throw new ArithmeticException("The fraction to divide by must not be zero");	    }	    return multiplyBy(fraction.invert());	}
@Override	public TimeZone getTimeZone() {	    return printer.getTimeZone();	}
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException {	    return charsetName == null ? new String(bytes) : new String(bytes, charsetName);	}
public boolean isAppendStatics() {	    return this.appendStatics;	}
public int getProperWhole() {	    return numerator / denominator;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public static final String unescapeJava(final String input) {	    return UNESCAPE_JAVA.translate(input);	}
public void add(final Number operand) {	    this.value += operand.longValue();	}
protected int getTaskCount() {	    return 1;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public static final String escapeJson(final String input) {	    return ESCAPE_JSON.translate(input);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
@Override	public int length() {	    return size;	}
public Byte toByte() {	    return Byte.valueOf(byteValue());	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    if (index != 0) {	        throw new IllegalStateException("CsvUnescaper should never reach the [1] index");	    }	    if (input.charAt(0) != CSV_QUOTE || input.charAt(input.length() - 1) != CSV_QUOTE) {	        out.write(input.toString());	        return input.length();	    }	    final String quoteless = input.subSequence(1, input.length() - 1).toString();	    if (StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS)) {	        out.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR));	    } else {	        out.write(input.toString());	    }	    return input.length();	}
@Override	public boolean equals(final Object obj) {	    if (this == obj) {	        return true;	    }	    if (!(obj instanceof ConstantInitializer<?>)) {	        return false;	    }	    final ConstantInitializer<?> c = (ConstantInitializer<?>) obj;	    return ObjectUtils.equals(getObject(), c.getObject());	}
@Override	public boolean translate(final int codepoint, final Writer out) throws IOException {	    if (between) {	        if (codepoint < below || codepoint > above) {	            return false;	        }	    } else {	        if (codepoint >= below && codepoint <= above) {	            return false;	        }	    }	    out.write("&#");	    out.write(Integer.toString(codepoint, 10));	    out.write(';');	    return true;	}
protected boolean isUseShortClassName() {	    return useShortClassName;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public boolean isEmpty() {	    return size == 0;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static CharSet getInstance(final String... setStrs) {	    if (setStrs == null) {	        return null;	    }	    if (setStrs.length == 1) {	        final CharSet common = COMMON.get(setStrs[0]);	        if (common != null) {	            return common;	        }	    }	    return new CharSet(setStrs);	}
public String getNewLineText() {	    return newLine;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public String getNullText() {	    return nullText;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public boolean isEquals() {	    return this.isEquals;	}
public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final E... values) {	    Validate.noNullElements(values);	    return generateBitVector(enumClass, Arrays.<E>asList(values));	}
@Override	public String next() {	    if (hasNext()) {	        return tokens[tokenPos++];	    }	    throw new NoSuchElementException();	}
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = Integer.MAX_VALUE;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.indexOf(str, search, 0);	        if (tmp == INDEX_NOT_FOUND) {	            continue;	        }	        if (tmp < ret) {	            ret = tmp;	        }	    }	    return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
@Override	public int length() {	    return size;	}
public static String lowerCase(final String str, final Locale locale) {	    if (str == null) {	        return null;	    }	    return str.toLowerCase(locale);	}
public int capacity() {	    return buffer.length;	}
public static Date truncate(final Object date, final int field) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (date instanceof Date) {	        return truncate((Date) date, field);	    } else if (date instanceof Calendar) {	        return truncate((Calendar) date, field).getTime();	    } else {	        throw new ClassCastException("Could not truncate " + date);	    }	}
public String getNewLineText() {	    return newLine;	}
public void appendEnd(final StringBuffer buffer, final Object object) {	    if (this.fieldSeparatorAtEnd == false) {	        removeLastFieldSeparator(buffer);	    }	    appendContentEnd(buffer);	    unregister(object);	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
@Override	public long longValue() {	    return (long) value;	}
public char getEscapeChar() {	    return this.escapeChar;	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static String deleteWhitespace(final String str) {	    if (isEmpty(str)) {	        return str;	    }	    final int sz = str.length();	    final char[] chs = new char[sz];	    int count = 0;	    for (int i = 0; i < sz; i++) {	        if (!Character.isWhitespace(str.charAt(i))) {	            chs[count++] = str.charAt(i);	        }	    }	    if (count == sz) {	        return str;	    }	    return new String(chs, 0, count);	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
@Override	public boolean ready() {	    return pos < StrBuilder.this.size();	}
public static <T> T CONST(final T v) {	    return v;	}
public int clear(final int holder) {	    return holder & ~_mask;	}
public void stop() {	    if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {	        throw new IllegalStateException("Stopwatch is not running. ");	    }	    if (this.runningState == STATE_RUNNING) {	        this.stopTime = System.nanoTime();	    }	    this.runningState = STATE_STOPPED;	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    if (input.charAt(index) == '\\' && index < (input.length() - 1) && Character.isDigit(input.charAt(index + 1))) {	        final int start = index + 1;	        int end = index + 2;	        while (end < input.length() && Character.isDigit(input.charAt(end))) {	            end++;	            if (Integer.parseInt(input.subSequence(start, end).toString(), 10) > OCTAL_MAX) {	                end--;	                break;	            }	        }	        out.write(Integer.parseInt(input.subSequence(start, end).toString(), 8));	        return 1 + end - start;	    }	    return 0;	}
public boolean replaceIn(final StrBuilder source, final int offset, final int length) {	    if (source == null) {	        return false;	    }	    return substitute(source, offset, length);	}
public static void reverse(final boolean[] array) {	    if (array == null) {	        return;	    }	    int i = 0;	    int j = array.length - 1;	    boolean tmp;	    while (j > i) {	        tmp = array[j];	        array[j] = array[i];	        array[i] = tmp;	        j--;	        i++;	    }	}
public static Boolean and(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return and(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
public static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts) {	    if (0 == nShorts) {	        return dst;	    }	    if ((nShorts - 1) * 16 + srcPos >= 64) {	        throw new IllegalArgumentException("(nShorts-1)*16+srcPos is greather or equal to than 64");	    }	    int shift = 0;	    for (int i = 0; i < nShorts; i++) {	        shift = i * 16 + srcPos;	        dst[dstPos + i] = (short) (0xffff & (src >> shift));	    }	    return dst;	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale) {	    return cache.getInstance(pattern, timeZone, locale);	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
@Override	public String getContent() {	    final String str = super.getContent();	    if (str == null) {	        return StrBuilder.this.toString();	    }	    return str;	}
@Override	public boolean equals(final Object obj) {	    if (obj == this) {	        return true;	    }	    if (obj instanceof CharSet == false) {	        return false;	    }	    final CharSet other = (CharSet) obj;	    return set.equals(other.set);	}
public static boolean containsNone(final CharSequence cs, final String invalidChars) {	    if (cs == null || invalidChars == null) {	        return true;	    }	    return containsNone(cs, invalidChars.toCharArray());	}
public static double[] addAll(final double[] array1, final double... array2) {	    if (array1 == null) {	        return clone(array2);	    } else if (array2 == null) {	        return clone(array1);	    }	    final double[] joinedArray = new double[array1.length + array2.length];	    System.arraycopy(array1, 0, joinedArray, 0, array1.length);	    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);	    return joinedArray;	}
public static boolean isAlphanumeric(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetterOrDigit(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale) {	    return cache.getDateTimeInstance(dateStyle, timeStyle, timeZone, locale);	}
public char getEscapeChar() {	    return this.escapeChar;	}
public Fraction abs() {	    if (numerator >= 0) {	        return this;	    }	    return negate();	}
public static void handleCause(final ExecutionException ex) throws ConcurrentException {	    final ConcurrentException cex = extractCause(ex);	    if (cex != null) {	        throw cex;	    }	}
public static <T extends Iterable<?>> T noNullElements(final T iterable) {	    return noNullElements(iterable, DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE);	}
public static String toString(final Formattable formattable) {	    return String.format(SIMPLEST_FORMAT, formattable);	}
static boolean isRegistered(final Object value) {	    final Set<IDKey> registry = getRegistry();	    return registry != null && registry.contains(new IDKey(value));	}
@Override	public boolean isCancelled() {	    return false;	}
public boolean isBefore(final T element) {	    if (element == null) {	        return false;	    }	    return comparator.compare(element, maximum) > 0;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public static Date ceiling(final Object date, final int field) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (date instanceof Date) {	        return ceiling((Date) date, field);	    } else if (date instanceof Calendar) {	        return ceiling((Calendar) date, field).getTime();	    } else {	        throw new ClassCastException("Could not find ceiling of for type: " + date.getClass());	    }	}
public static String rightPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return rightPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return str.concat(padStr);	    } else if (pads < padLen) {	        return str.concat(padStr.substring(0, pads));	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return str.concat(new String(padding));	    }	}
@Override	public boolean ready() {	    return pos < StrBuilder.this.size();	}
@Override	public int length() {	    return size;	}
@Override	public double doubleValue() {	    return value;	}
public static Boolean or(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
public static int indexOfDifference(final CharSequence... css) {	    if (css == null || css.length <= 1) {	        return INDEX_NOT_FOUND;	    }	    boolean anyStringNull = false;	    boolean allStringsNull = true;	    final int arrayLen = css.length;	    int shortestStrLen = Integer.MAX_VALUE;	    int longestStrLen = 0;	    for (int i = 0; i < arrayLen; i++) {	        if (css[i] == null) {	            anyStringNull = true;	            shortestStrLen = 0;	        } else {	            allStringsNull = false;	            shortestStrLen = Math.min(css[i].length(), shortestStrLen);	            longestStrLen = Math.max(css[i].length(), longestStrLen);	        }	    }	    if (allStringsNull || longestStrLen == 0 && !anyStringNull) {	        return INDEX_NOT_FOUND;	    }	    if (shortestStrLen == 0) {	        return 0;	    }	    int firstDiff = -1;	    for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {	        final char comparisonChar = css[0].charAt(stringPos);	        for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {	            if (css[arrayPos].charAt(stringPos) != comparisonChar) {	                firstDiff = stringPos;	                break;	            }	        }	        if (firstDiff != -1) {	            break;	        }	    }	    if (firstDiff == -1 && shortestStrLen != longestStrLen) {	        return shortestStrLen;	    }	    return firstDiff;	}
public static Boolean and(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return and(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static <T> Range<T> is(final T element, final Comparator<T> comparator) {	    return between(element, element, comparator);	}
public static String removePattern(final String source, final String regex) {	    return replacePattern(source, regex, StringUtils.EMPTY);	}
protected boolean isFieldSeparatorAtStart() {	    return fieldSeparatorAtStart;	}
@Override	public float floatValue() {	    return (float) numerator / (float) denominator;	}
@Override	public R getValue() {	    return getRight();	}
protected String getSizeEndText() {	    return sizeEndText;	}
protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) {	    if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {	        appendCyclicObject(buffer, fieldName, value);	        return;	    }	    register(value);	    try {	        if (value instanceof Collection<?>) {	            if (detail) {	                appendDetail(buffer, fieldName, (Collection<?>) value);	            } else {	                appendSummarySize(buffer, fieldName, ((Collection<?>) value).size());	            }	        } else if (value instanceof Map<?, ?>) {	            if (detail) {	                appendDetail(buffer, fieldName, (Map<?, ?>) value);	            } else {	                appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());	            }	        } else if (value instanceof long[]) {	            if (detail) {	                appendDetail(buffer, fieldName, (long[]) value);	            } else {	                appendSummary(buffer, fieldName, (long[]) value);	            }	        } else if (value instanceof int[]) {	            if (detail) {	                appendDetail(buffer, fieldName, (int[]) value);	            } else {	                appendSummary(buffer, fieldName, (int[]) value);	            }	        } else if (value instanceof short[]) {	            if (detail) {	                appendDetail(buffer, fieldName, (short[]) value);	            } else {	                appendSummary(buffer, fieldName, (short[]) value);	            }	        } else if (value instanceof byte[]) {	            if (detail) {	                appendDetail(buffer, fieldName, (byte[]) value);	            } else {	                appendSummary(buffer, fieldName, (byte[]) value);	            }	        } else if (value instanceof char[]) {	            if (detail) {	                appendDetail(buffer, fieldName, (char[]) value);	            } else {	                appendSummary(buffer, fieldName, (char[]) value);	            }	        } else if (value instanceof double[]) {	            if (detail) {	                appendDetail(buffer, fieldName, (double[]) value);	            } else {	                appendSummary(buffer, fieldName, (double[]) value);	            }	        } else if (value instanceof float[]) {	            if (detail) {	                appendDetail(buffer, fieldName, (float[]) value);	            } else {	                appendSummary(buffer, fieldName, (float[]) value);	            }	        } else if (value instanceof boolean[]) {	            if (detail) {	                appendDetail(buffer, fieldName, (boolean[]) value);	            } else {	                appendSummary(buffer, fieldName, (boolean[]) value);	            }	        } else if (value.getClass().isArray()) {	            if (detail) {	                appendDetail(buffer, fieldName, (Object[]) value);	            } else {	                appendSummary(buffer, fieldName, (Object[]) value);	            }	        } else {	            if (detail) {	                appendDetail(buffer, fieldName, value);	            } else {	                appendSummary(buffer, fieldName, value);	            }	        }	    } finally {	        unregister(value);	    }	}
public StrBuilder deleteAll(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, -1);	}
public static String replacePattern(final String source, final String regex, final String replacement) {	    return Pattern.compile(regex, Pattern.DOTALL).matcher(source).replaceAll(replacement);	}
public static String trimToEmpty(final String str) {	    return str == null ? EMPTY : str.trim();	}
@Override	public BasicThreadFactory build() {	    final BasicThreadFactory factory = new BasicThreadFactory(this);	    reset();	    return factory;	}
static void register(final Object value) {	    if (value != null) {	        final Map<Object, Object> m = getRegistry();	        if (m == null) {	            REGISTRY.set(new WeakHashMap<Object, Object>());	        }	        getRegistry().put(value, null);	    }	}
public static int lastIndexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = INDEX_NOT_FOUND;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.lastIndexOf(str, search, str.length());	        if (tmp > ret) {	            ret = tmp;	        }	    }	    return ret;	}
@Override	public String toString() {	    return value == null ? "null" : value.toString();	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public final void translate(final CharSequence input, final Writer out) throws IOException {	    if (out == null) {	        throw new IllegalArgumentException("The Writer must not be null");	    }	    if (input == null) {	        return;	    }	    int pos = 0;	    final int len = input.length();	    while (pos < len) {	        final int consumed = translate(input, pos, out);	        if (consumed == 0) {	            final char[] c = Character.toChars(Character.codePointAt(input, pos));	            out.write(c);	            pos += c.length;	            continue;	        }	        for (int pt = 0; pt < consumed; pt++) {	            pos += Character.charCount(Character.codePointAt(input, pt));	        }	    }	}
public static Iterator<?> iterator(final Object focus, final int rangeStyle) {	    if (focus == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (focus instanceof Date) {	        return iterator((Date) focus, rangeStyle);	    } else if (focus instanceof Calendar) {	        return iterator((Calendar) focus, rangeStyle);	    } else {	        throw new ClassCastException("Could not iterate based on " + focus);	    }	}
protected boolean isUseFieldNames() {	    return useFieldNames;	}
@Override	public double doubleValue() {	    return (double) numerator / (double) denominator;	}
@Override	public BasicThreadFactory build() {	    final BasicThreadFactory factory = new BasicThreadFactory(this);	    reset();	    return factory;	}
public boolean isEmpty() {	    return size == 0;	}
public StrTokenizer setQuoteMatcher(final StrMatcher quote) {	    if (quote != null) {	        this.quoteMatcher = quote;	    }	    return this;	}
@Override	public Short getValue() {	    return Short.valueOf(this.value);	}
public static String mid(final String str, int pos, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0 || pos > str.length()) {	        return EMPTY;	    }	    if (pos < 0) {	        pos = 0;	    }	    if (str.length() <= pos + len) {	        return str.substring(pos);	    }	    return str.substring(pos, pos + len);	}
protected abstract T initialize() throws Exception;
public static short[] removeElement(final short[] array, final short element) {	    final int index = indexOf(array, element);	    if (index == INDEX_NOT_FOUND) {	        return clone(array);	    }	    return remove(array, index);	}
public static String getSimpleName(final Object object, final String valueIfNull) {	    if (object == null) {	        return valueIfNull;	    }	    return getSimpleName(object.getClass());	}
public int size() {	    return size;	}
public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width, final int precision, final char padChar, final CharSequence ellipsis) {	    Validate.isTrue(ellipsis == null || precision < 0 || ellipsis.length() <= precision, "Specified ellipsis '%1$s' exceeds precision of %2$s", ellipsis, Integer.valueOf(precision));	    final StringBuilder buf = new StringBuilder(seq);	    if (precision >= 0 && precision < seq.length()) {	        final CharSequence _ellipsis = ObjectUtils.defaultIfNull(ellipsis, StringUtils.EMPTY);	        buf.replace(precision - _ellipsis.length(), seq.length(), _ellipsis.toString());	    }	    final boolean leftJustify = (flags & LEFT_JUSTIFY) == LEFT_JUSTIFY;	    for (int i = buf.length(); i < width; i++) {	        buf.insert(leftJustify ? i : 0, padChar);	    }	    formatter.format(buf.toString());	    return formatter;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public static String overlay(final String str, String overlay, int start, int end) {	    if (str == null) {	        return null;	    }	    if (overlay == null) {	        overlay = EMPTY;	    }	    final int len = str.length();	    if (start < 0) {	        start = 0;	    }	    if (start > len) {	        start = len;	    }	    if (end < 0) {	        end = 0;	    }	    if (end > len) {	        end = len;	    }	    if (start > end) {	        final int temp = start;	        start = end;	        end = temp;	    }	    return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString();	}
public synchronized void shutdown() {	    if (!shutdown) {	        if (ownExecutor) {	            getExecutorService().shutdownNow();	        }	        if (task != null) {	            task.cancel(false);	        }	        shutdown = true;	    }	}
public static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) {	    if (0 == nBools) {	        return dst;	    }	    if (nBools - 1 + srcPos >= 32) {	        throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 32");	    }	    int shift = 0;	    for (int i = 0; i < nBools; i++) {	        shift = i * 1 + srcPos;	        dst[dstPos + i] = ((0x1 & (src >> shift)) != 0);	    }	    return dst;	}
public static CharRange is(final char ch) {	    return new CharRange(ch, ch, false);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
@Override	public boolean equals(final Object obj2) {	    if (obj2 instanceof Token) {	        final Token tok2 = (Token) obj2;	        if (this.value.getClass() != tok2.value.getClass()) {	            return false;	        }	        if (this.count != tok2.count) {	            return false;	        }	        if (this.value instanceof StringBuilder) {	            return this.value.toString().equals(tok2.value.toString());	        } else if (this.value instanceof Number) {	            return this.value.equals(tok2.value);	        } else {	            return this.value == tok2.value;	        }	    }	    return false;	}
@Override	public Integer build() {	    return Integer.valueOf(toHashCode());	}
public static boolean isAscii(final char ch) {	    return ch < 128;	}
public static boolean isAsciiPrintable(final char ch) {	    return ch >= 32 && ch < 127;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static String right(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(str.length() - len);	}
public StrBuilder appendFixedWidthPadRight(final int value, final int width, final char padChar) {	    return appendFixedWidthPadRight(String.valueOf(value), width, padChar);	}
public int size() {	    return size;	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
@Override	public String next() {	    if (hasNext()) {	        return tokens[tokenPos++];	    }	    throw new NoSuchElementException();	}
public static String deleteWhitespace(final String str) {	    if (isEmpty(str)) {	        return str;	    }	    final int sz = str.length();	    final char[] chs = new char[sz];	    int count = 0;	    for (int i = 0; i < sz; i++) {	        if (!Character.isWhitespace(str.charAt(i))) {	            chs[count++] = str.charAt(i);	        }	    }	    if (count == sz) {	        return str;	    }	    return new String(chs, 0, count);	}
private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase) {	    if (str == null || prefix == null) {	        return str == null && prefix == null;	    }	    if (prefix.length() > str.length()) {	        return false;	    }	    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());	}
public static void writeDeclaredField(final Object target, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException {	    if (target == null) {	        throw new IllegalArgumentException("target object must not be null");	    }	    final Class<?> cls = target.getClass();	    final Field field = getDeclaredField(cls, fieldName, forceAccess);	    if (field == null) {	        throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName);	    }	    writeField(field, target, value);	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
public static CharRange is(final char ch) {	    return new CharRange(ch, ch, false);	}
public void decrement() {	    value--;	}
public static String right(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(str.length() - len);	}
public final Integer getPriority() {	    return priority;	}
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) {	    if (str == null) {	        if (trueString == null) {	            return Boolean.TRUE;	        }	        if (falseString == null) {	            return Boolean.FALSE;	        }	        if (nullString == null) {	            return null;	        }	    } else if (str.equals(trueString)) {	        return Boolean.TRUE;	    } else if (str.equals(falseString)) {	        return Boolean.FALSE;	    } else if (str.equals(nullString)) {	        return null;	    }	    throw new IllegalArgumentException("The String did not match any specified value");	}
public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final E... values) {	    Validate.noNullElements(values);	    return generateBitVector(enumClass, Arrays.<E>asList(values));	}
public static String random(final int count, final char... chars) {	    if (chars == null) {	        return random(count, 0, 0, false, false, null, RANDOM);	    }	    return random(count, 0, chars.length, false, false, chars, RANDOM);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public boolean isEmpty() {	    return size == 0;	}
@Override	public boolean equals(final Object obj) {	    if (obj == this) {	        return true;	    }	    if (obj instanceof Fraction == false) {	        return false;	    }	    final Fraction other = (Fraction) obj;	    return getNumerator() == other.getNumerator() && getDenominator() == other.getDenominator();	}
public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) {	    if (src.length > 8) {	        throw new IllegalArgumentException("src.length>8: src.length=" + src.length);	    }	    if (src.length - srcPos < 4) {	        throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos);	    }	    if (src[srcPos + 3]) {	        if (src[srcPos + 2]) {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return '7';	                }	            } else {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return '3';	                }	            }	        } else {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return '5';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '1';	                }	            }	        }	    } else {	        if (src[srcPos + 2]) {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'e';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return 'a';	                } else {	                    return '2';	                }	            }	        } else {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'c';	                } else {	                    return '4';	                }	            } else {	                if (src[srcPos]) {	                    return '8';	                } else {	                    return '0';	                }	            }	        }	    }	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
static Set<Pair<IDKey, IDKey>> getRegistry() {	    return REGISTRY.get();	}
public StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, 1);	}
protected String getFieldSeparator() {	    return fieldSeparator;	}
@Override	public boolean equals(final Object obj) {	    if (!(obj instanceof FastDateParser)) {	        return false;	    }	    final FastDateParser other = (FastDateParser) obj;	    return pattern.equals(other.pattern) && timeZone.equals(other.timeZone) && locale.equals(other.locale);	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public String getNewLineText() {	    return newLine;	}
public void stop() {	    if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {	        throw new IllegalStateException("Stopwatch is not running. ");	    }	    if (this.runningState == STATE_RUNNING) {	        this.stopTime = System.nanoTime();	    }	    this.runningState = STATE_STOPPED;	}
public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final E... values) {	    Validate.noNullElements(values);	    return generateBitVector(enumClass, Arrays.<E>asList(values));	}
public char getEnd() {	    return this.end;	}
public String getNewLineText() {	    return newLine;	}
public static CharRange isNot(final char ch) {	    return new CharRange(ch, ch, true);	}
public static int lastIndexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = INDEX_NOT_FOUND;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.lastIndexOf(str, search, str.length());	        if (tmp > ret) {	            ret = tmp;	        }	    }	    return ret;	}
public String getNewLineText() {	    return newLine;	}
public String reformat(final String input) throws ParseException {	    return format(parseObject(input));	}
public int capacity() {	    return buffer.length;	}
public static String getMessage(final Throwable th) {	    if (th == null) {	        return "";	    }	    final String clsName = ClassUtils.getShortClassName(th, null);	    final String msg = th.getMessage();	    return clsName + ": " + StringUtils.defaultString(msg);	}
public void appendToString(final StringBuffer buffer, final String toString) {	    if (toString != null) {	        final int pos1 = toString.indexOf(contentStart) + contentStart.length();	        final int pos2 = toString.lastIndexOf(contentEnd);	        if (pos1 != pos2 && pos1 >= 0 && pos2 >= 0) {	            final String data = toString.substring(pos1, pos2);	            if (fieldSeparatorAtStart) {	                removeLastFieldSeparator(buffer);	            }	            buffer.append(data);	            appendFieldSeparator(buffer);	        }	    }	}
public static <T> Range<T> is(final T element, final Comparator<T> comparator) {	    return between(element, element, comparator);	}
public static String getMessage(final Throwable th) {	    if (th == null) {	        return "";	    }	    final String clsName = ClassUtils.getShortClassName(th, null);	    final String msg = th.getMessage();	    return clsName + ": " + StringUtils.defaultString(msg);	}
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {	    if (array == null) {	        if (index != 0) {	            throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0");	        }	        final Object joinedArray = Array.newInstance(clss, 1);	        Array.set(joinedArray, 0, element);	        return joinedArray;	    }	    final int length = Array.getLength(array);	    if (index > length || index < 0) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(clss, length + 1);	    System.arraycopy(array, 0, result, 0, index);	    Array.set(result, index, element);	    if (index < length) {	        System.arraycopy(array, index, result, index + 1, length - index);	    }	    return result;	}
public int getNumerator() {	    return numerator;	}
public static String removeStart(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.startsWith(remove)) {	        return str.substring(remove.length());	    }	    return str;	}
public static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes) {	    if (0 == nBytes) {	        return dst;	    }	    if ((nBytes - 1) * 8 + srcPos >= 32) {	        throw new IllegalArgumentException("(nBytes-1)*8+srcPos is greather or equal to than 32");	    }	    int shift = 0;	    for (int i = 0; i < nBytes; i++) {	        shift = i * 8 + srcPos;	        dst[dstPos + i] = (byte) (0xff & (src >> shift));	    }	    return dst;	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public static Boolean or(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
public int size() {	    return size;	}
public static String randomNumeric(final int count) {	    return random(count, false, true);	}
public int size() {	    return size;	}
private static Date set(final Date date, final int calendarField, final int amount) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final Calendar c = Calendar.getInstance();	    c.setLenient(false);	    c.setTime(date);	    c.set(calendarField, amount);	    return c.getTime();	}
@Override	public int compareTo(final Triple<L, M, R> other) {	    return new CompareToBuilder().append(getLeft(), other.getLeft()).append(getMiddle(), other.getMiddle()).append(getRight(), other.getRight()).toComparison();	}
public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) {	    String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'");	    if (suppressLeadingZeroElements) {	        duration = " " + duration;	        String tmp = StringUtils.replaceOnce(duration, " 0 days", "");	        if (tmp.length() != duration.length()) {	            duration = tmp;	            tmp = StringUtils.replaceOnce(duration, " 0 hours", "");	            if (tmp.length() != duration.length()) {	                duration = tmp;	                tmp = StringUtils.replaceOnce(duration, " 0 minutes", "");	                duration = tmp;	                if (tmp.length() != duration.length()) {	                    duration = StringUtils.replaceOnce(tmp, " 0 seconds", "");	                }	            }	        }	        if (duration.length() != 0) {	            duration = duration.substring(1);	        }	    }	    if (suppressTrailingZeroElements) {	        String tmp = StringUtils.replaceOnce(duration, " 0 seconds", "");	        if (tmp.length() != duration.length()) {	            duration = tmp;	            tmp = StringUtils.replaceOnce(duration, " 0 minutes", "");	            if (tmp.length() != duration.length()) {	                duration = tmp;	                tmp = StringUtils.replaceOnce(duration, " 0 hours", "");	                if (tmp.length() != duration.length()) {	                    duration = StringUtils.replaceOnce(tmp, " 0 days", "");	                }	            }	        }	    }	    duration = " " + duration;	    duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second");	    duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute");	    duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour");	    duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day");	    return duration.trim();	}
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, true);	}
public static int reflectionHashCode(final Object object, final String... excludeFields) {	    return reflectionHashCode(17, 37, object, false, null, excludeFields);	}
@Override	public String previous() {	    if (hasPrevious()) {	        return tokens[--tokenPos];	    }	    throw new NoSuchElementException();	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public boolean isEmpty() {	    return size == 0;	}
public EqualsBuilder appendSuper(final boolean superEquals) {	    if (isEquals == false) {	        return this;	    }	    isEquals = superEquals;	    return this;	}
public String getNullText() {	    return nullText;	}
public int size() {	    return size;	}
protected boolean isUseFieldNames() {	    return useFieldNames;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public static String reverse(final String str) {	    if (str == null) {	        return null;	    }	    return new StringBuilder(str).reverse().toString();	}
protected String getFieldNameValueSeparator() {	    return fieldNameValueSeparator;	}
public StrTokenizer setIgnoreEmptyTokens(final boolean ignoreEmptyTokens) {	    this.ignoreEmptyTokens = ignoreEmptyTokens;	    return this;	}
public boolean replaceIn(final StrBuilder source, final int offset, final int length) {	    if (source == null) {	        return false;	    }	    return substitute(source, offset, length);	}
public void add(final Number operand) {	    this.value += operand.shortValue();	}
@Override	public int hashCode() {	    return toHashCode();	}
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] result = new boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        final Boolean b = array[i];	        result[i] = (b == null ? valueForNull : b.booleanValue());	    }	    return result;	}
public int size() {	    return size;	}
public static CharSet getInstance(final String... setStrs) {	    if (setStrs == null) {	        return null;	    }	    if (setStrs.length == 1) {	        final CharSet common = COMMON.get(setStrs[0]);	        if (common != null) {	            return common;	        }	    }	    return new CharSet(setStrs);	}
public int capacity() {	    return buffer.length;	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public static boolean containsAny(final CharSequence cs, final CharSequence searchChars) {	    if (searchChars == null) {	        return false;	    }	    return containsAny(cs, CharSequenceUtils.toCharArray(searchChars));	}
public static String repeat(final char ch, final int repeat) {	    final char[] buf = new char[repeat];	    for (int i = repeat - 1; i >= 0; i--) {	        buf[i] = ch;	    }	    return new String(buf);	}
@Override	public int length() {	    return size;	}
public static String stripStart(final String str, final String stripChars) {	    int strLen;	    if (str == null || (strLen = str.length()) == 0) {	        return str;	    }	    int start = 0;	    if (stripChars == null) {	        while (start != strLen && Character.isWhitespace(str.charAt(start))) {	            start++;	        }	    } else if (stripChars.isEmpty()) {	        return str;	    } else {	        while (start != strLen && stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND) {	            start++;	        }	    }	    return str.substring(start);	}
@Override	public double doubleValue() {	    return value;	}
public static float max(final float a, final float b, final float c) {	    return Math.max(Math.max(a, b), c);	}
public static void identityToString(final StringBuilder builder, final Object object) {	    if (object == null) {	        throw new NullPointerException("Cannot get the toString of a null identity");	    }	    builder.append(object.getClass().getName()).append('@').append(Integer.toHexString(System.identityHashCode(object)));	}
public static int countMatches(final CharSequence str, final CharSequence sub) {	    if (isEmpty(str) || isEmpty(sub)) {	        return 0;	    }	    int count = 0;	    int idx = 0;	    while ((idx = CharSequenceUtils.indexOf(str, sub, idx)) != INDEX_NOT_FOUND) {	        count++;	        idx += sub.length();	    }	    return count;	}
public static int indexOfDifference(final CharSequence... css) {	    if (css == null || css.length <= 1) {	        return INDEX_NOT_FOUND;	    }	    boolean anyStringNull = false;	    boolean allStringsNull = true;	    final int arrayLen = css.length;	    int shortestStrLen = Integer.MAX_VALUE;	    int longestStrLen = 0;	    for (int i = 0; i < arrayLen; i++) {	        if (css[i] == null) {	            anyStringNull = true;	            shortestStrLen = 0;	        } else {	            allStringsNull = false;	            shortestStrLen = Math.min(css[i].length(), shortestStrLen);	            longestStrLen = Math.max(css[i].length(), longestStrLen);	        }	    }	    if (allStringsNull || longestStrLen == 0 && !anyStringNull) {	        return INDEX_NOT_FOUND;	    }	    if (shortestStrLen == 0) {	        return 0;	    }	    int firstDiff = -1;	    for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {	        final char comparisonChar = css[0].charAt(stringPos);	        for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {	            if (css[arrayPos].charAt(stringPos) != comparisonChar) {	                firstDiff = stringPos;	                break;	            }	        }	        if (firstDiff != -1) {	            break;	        }	    }	    if (firstDiff == -1 && shortestStrLen != longestStrLen) {	        return shortestStrLen;	    }	    return firstDiff;	}
public int capacity() {	    return buffer.length;	}
public static <T extends Iterable<?>> T noNullElements(final T iterable) {	    return noNullElements(iterable, DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE);	}
public int capacity() {	    return buffer.length;	}
public StrTokenizer setIgnoredMatcher(final StrMatcher ignored) {	    if (ignored != null) {	        this.ignoredMatcher = ignored;	    }	    return this;	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public StrBuilder setNullText(String nullText) {	    if (nullText != null && nullText.isEmpty()) {	        nullText = null;	    }	    this.nullText = nullText;	    return this;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public synchronized void acquire() throws InterruptedException {	    if (isShutdown()) {	        throw new IllegalStateException("TimedSemaphore is shut down!");	    }	    if (task == null) {	        task = startTimer();	    }	    boolean canPass = false;	    do {	        canPass = getLimit() <= NO_LIMIT || acquireCount < getLimit();	        if (!canPass) {	            wait();	        } else {	            acquireCount++;	        }	    } while (!canPass);	}
public static String defaultString(final String str, final String defaultStr) {	    return str == null ? defaultStr : str;	}
@Override	public int previousIndex() {	    return tokenPos - 1;	}
public static boolean[] clone(final boolean[] array) {	    if (array == null) {	        return null;	    }	    return array.clone();	}
public static String capitalizeFully(String str, final char... delimiters) {	    final int delimLen = delimiters == null ? -1 : delimiters.length;	    if (StringUtils.isEmpty(str) || delimLen == 0) {	        return str;	    }	    str = str.toLowerCase();	    return capitalize(str, delimiters);	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static String abbreviateMiddle(final String str, final String middle, final int length) {	    if (isEmpty(str) || isEmpty(middle)) {	        return str;	    }	    if (length >= str.length() || length < middle.length() + 2) {	        return str;	    }	    final int targetSting = length - middle.length();	    final int startOffset = targetSting / 2 + targetSting % 2;	    final int endOffset = str.length() - targetSting / 2;	    final StringBuilder builder = new StringBuilder(length);	    builder.append(str.substring(0, startOffset));	    builder.append(middle);	    builder.append(str.substring(endOffset));	    return builder.toString();	}
public String getNullText() {	    return nullText;	}
Object getValue() {	    return value;	}
@Override	public int compare(final Object obj1, final Object obj2) {	    return ((Comparable) obj1).compareTo(obj2);	}
public StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, 1);	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
@Override	public float floatValue() {	    return value;	}
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) {	    if (bool == null) {	        return nullValue;	    }	    return bool.booleanValue() ? trueValue : falseValue;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static Boolean and(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return and(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
public static Object invokeStaticMethod(final Class<?> cls, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {	    if (parameterTypes == null) {	        parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;	    }	    if (args == null) {	        args = ArrayUtils.EMPTY_OBJECT_ARRAY;	    }	    final Method method = getMatchingAccessibleMethod(cls, methodName, parameterTypes);	    if (method == null) {	        throw new NoSuchMethodException("No such accessible method: " + methodName + "() on class: " + cls.getName());	    }	    return method.invoke(null, args);	}
public Builder daemon(final boolean f) {	    daemonFlag = Boolean.valueOf(f);	    return this;	}
@Override	public int hashCode() {	    return toHashCode();	}
public int toComparison() {	    return comparison;	}
public boolean isAppendStatics() {	    return this.appendStatics;	}
static JavaVersion get(final String nom) {	    if ("0.9".equals(nom)) {	        return JAVA_0_9;	    } else if ("1.1".equals(nom)) {	        return JAVA_1_1;	    } else if ("1.2".equals(nom)) {	        return JAVA_1_2;	    } else if ("1.3".equals(nom)) {	        return JAVA_1_3;	    } else if ("1.4".equals(nom)) {	        return JAVA_1_4;	    } else if ("1.5".equals(nom)) {	        return JAVA_1_5;	    } else if ("1.6".equals(nom)) {	        return JAVA_1_6;	    } else if ("1.7".equals(nom)) {	        return JAVA_1_7;	    } else if ("1.8".equals(nom)) {	        return JAVA_1_8;	    } else {	        return null;	    }	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public StrBuilder appendPadding(final int length, final char padChar) {	    if (length >= 0) {	        ensureCapacity(size + length);	        for (int i = 0; i < length; i++) {	            buffer[size++] = padChar;	        }	    }	    return this;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
@Override	public String previous() {	    if (hasPrevious()) {	        return tokens[--tokenPos];	    }	    throw new NoSuchElementException();	}
public static short[] removeElement(final short[] array, final short element) {	    final int index = indexOf(array, element);	    if (index == INDEX_NOT_FOUND) {	        return clone(array);	    }	    return remove(array, index);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public char[] toCharArray(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len == 0) {	        return ArrayUtils.EMPTY_CHAR_ARRAY;	    }	    final char[] chars = new char[len];	    System.arraycopy(buffer, startIndex, chars, 0, len);	    return chars;	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale) {	    return cache.getInstance(pattern, timeZone, locale);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static Integer toIntegerObject(final Boolean bool, final Integer trueValue, final Integer falseValue, final Integer nullValue) {	    if (bool == null) {	        return nullValue;	    }	    return bool.booleanValue() ? trueValue : falseValue;	}
@Override	public int length() {	    return size;	}
public StrBuilder deleteAll(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, -1);	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) {	    if (0 == nBools) {	        return dst;	    }	    if (nBools - 1 + srcPos >= 16) {	        throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 16");	    }	    int shift = 0;	    assert ((nBools - 1) * 1 < 16 - srcPos);	    for (int i = 0; i < nBools; i++) {	        shift = i * 1 + srcPos;	        dst[dstPos + i] = ((0x1 & (src >> shift)) != 0);	    }	    return dst;	}
public String toString(final String format) {	    return String.format(format, getLeft(), getMiddle(), getRight());	}
public int set(final int holder) {	    return holder | _mask;	}
public int setValue(final int holder, final int value) {	    return (holder & ~_mask) | ((value << _shift_count) & _mask);	}
public TimeUnit getUnit() {	    return unit;	}
public String getNewLineText() {	    return newLine;	}
public static boolean isEmpty(final boolean[] array) {	    return array == null || array.length == 0;	}
public static String prependIfMissing(final String str, final CharSequence prefix, final CharSequence... prefixes) {	    return prependIfMissing(str, prefix, false, prefixes);	}
@Override	public int previousIndex() {	    return tokenPos - 1;	}
public String getNullText() {	    return nullText;	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    if (input.charAt(index) == '\\' && index < (input.length() - 1) && Character.isDigit(input.charAt(index + 1))) {	        final int start = index + 1;	        int end = index + 2;	        while (end < input.length() && Character.isDigit(input.charAt(end))) {	            end++;	            if (Integer.parseInt(input.subSequence(start, end).toString(), 10) > OCTAL_MAX) {	                end--;	                break;	            }	        }	        out.write(Integer.parseInt(input.subSequence(start, end).toString(), 8));	        return 1 + end - start;	    }	    return 0;	}
public static boolean containsWhitespace(final CharSequence seq) {	    if (isEmpty(seq)) {	        return false;	    }	    final int strLen = seq.length();	    for (int i = 0; i < strLen; i++) {	        if (Character.isWhitespace(seq.charAt(i))) {	            return true;	        }	    }	    return false;	}
protected String getSummaryObjectStartText() {	    return summaryObjectStartText;	}
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {	    if (array == null) {	        if (index != 0) {	            throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0");	        }	        final Object joinedArray = Array.newInstance(clss, 1);	        Array.set(joinedArray, 0, element);	        return joinedArray;	    }	    final int length = Array.getLength(array);	    if (index > length || index < 0) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(clss, length + 1);	    System.arraycopy(array, 0, result, 0, index);	    Array.set(result, index, element);	    if (index < length) {	        System.arraycopy(array, index, result, index + 1, length - index);	    }	    return result;	}
public static String rightPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return rightPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return str.concat(padStr);	    } else if (pads < padLen) {	        return str.concat(padStr.substring(0, pads));	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return str.concat(new String(padding));	    }	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static boolean isEmpty(final CharSequence cs) {	    return cs == null || cs.length() == 0;	}
public static int truncatedCompareTo(final Date date1, final Date date2, final int field) {	    final Date truncatedDate1 = truncate(date1, field);	    final Date truncatedDate2 = truncate(date2, field);	    return truncatedDate1.compareTo(truncatedDate2);	}
public static String lowerCase(final String str, final Locale locale) {	    if (str == null) {	        return null;	    }	    return str.toLowerCase(locale);	}
public static String replaceChars(final String str, final String searchChars, String replaceChars) {	    if (isEmpty(str) || isEmpty(searchChars)) {	        return str;	    }	    if (replaceChars == null) {	        replaceChars = EMPTY;	    }	    boolean modified = false;	    final int replaceCharsLength = replaceChars.length();	    final int strLength = str.length();	    final StringBuilder buf = new StringBuilder(strLength);	    for (int i = 0; i < strLength; i++) {	        final char ch = str.charAt(i);	        final int index = searchChars.indexOf(ch);	        if (index >= 0) {	            modified = true;	            if (index < replaceCharsLength) {	                buf.append(replaceChars.charAt(index));	            }	        } else {	            buf.append(ch);	        }	    }	    if (modified) {	        return buf.toString();	    }	    return str;	}
public static Number createNumber(final String str) throws NumberFormatException {	    if (str == null) {	        return null;	    }	    if (StringUtils.isBlank(str)) {	        throw new NumberFormatException("A blank string is not a valid number");	    }	    final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" };	    int pfxLen = 0;	    for (final String pfx : hex_prefixes) {	        if (str.startsWith(pfx)) {	            pfxLen += pfx.length();	            break;	        }	    }	    if (pfxLen > 0) {	        final int hexDigits = str.length() - pfxLen;	        if (hexDigits > 16) {	            return createBigInteger(str);	        }	        if (hexDigits > 8) {	            return createLong(str);	        }	        return createInteger(str);	    }	    final char lastChar = str.charAt(str.length() - 1);	    String mant;	    String dec;	    String exp;	    final int decPos = str.indexOf('.');	    final int expPos = str.indexOf('e') + str.indexOf('E') + 1;	    int numDecimals = 0;	    if (decPos > -1) {	        if (expPos > -1) {	            if (expPos < decPos || expPos > str.length()) {	                throw new NumberFormatException(str + " is not a valid number.");	            }	            dec = str.substring(decPos + 1, expPos);	        } else {	            dec = str.substring(decPos + 1);	        }	        mant = str.substring(0, decPos);	        numDecimals = dec.length();	    } else {	        if (expPos > -1) {	            if (expPos > str.length()) {	                throw new NumberFormatException(str + " is not a valid number.");	            }	            mant = str.substring(0, expPos);	        } else {	            mant = str;	        }	        dec = null;	    }	    if (!Character.isDigit(lastChar) && lastChar != '.') {	        if (expPos > -1 && expPos < str.length() - 1) {	            exp = str.substring(expPos + 1, str.length() - 1);	        } else {	            exp = null;	        }	        final String numeric = str.substring(0, str.length() - 1);	        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);	        switch(lastChar) {	            case 'l':	            case 'L':	                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {	                    try {	                        return createLong(numeric);	                    } catch (final NumberFormatException nfe) {	                    }	                    return createBigInteger(numeric);	                }	                throw new NumberFormatException(str + " is not a valid number.");	            case 'f':	            case 'F':	                try {	                    final Float f = NumberUtils.createFloat(numeric);	                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {	                        return f;	                    }	                } catch (final NumberFormatException nfe) {	                }	            case 'd':	            case 'D':	                try {	                    final Double d = NumberUtils.createDouble(numeric);	                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {	                        return d;	                    }	                } catch (final NumberFormatException nfe) {	                }	                try {	                    return createBigDecimal(numeric);	                } catch (final NumberFormatException e) {	                }	            default:	                throw new NumberFormatException(str + " is not a valid number.");	        }	    }	    if (expPos > -1 && expPos < str.length() - 1) {	        exp = str.substring(expPos + 1, str.length());	    } else {	        exp = null;	    }	    if (dec == null && exp == null) {	        try {	            return createInteger(str);	        } catch (final NumberFormatException nfe) {	        }	        try {	            return createLong(str);	        } catch (final NumberFormatException nfe) {	        }	        return createBigInteger(str);	    }	    final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);	    try {	        if (numDecimals <= 7) {	            final Float f = createFloat(str);	            if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {	                return f;	            }	        }	    } catch (final NumberFormatException nfe) {	    }	    try {	        if (numDecimals <= 16) {	            final Double d = createDouble(str);	            if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {	                return d;	            }	        }	    } catch (final NumberFormatException nfe) {	    }	    return createBigDecimal(str);	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static void isTrue(final boolean expression) {	    if (expression == false) {	        throw new IllegalArgumentException(DEFAULT_IS_TRUE_EX_MESSAGE);	    }	}
public static Date setHours(final Date date, final int amount) {	    return set(date, Calendar.HOUR_OF_DAY, amount);	}
public static Class<?> getClass(final String className, final boolean initialize) throws ClassNotFoundException {	    final ClassLoader contextCL = Thread.currentThread().getContextClassLoader();	    final ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL;	    return getClass(loader, className, initialize);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
@Override	public short shortValue() {	    return value;	}
@Override	public String toString() {	    if (this.getObject() == null) {	        return this.getStyle().getNullText();	    }	    Class<?> clazz = this.getObject().getClass();	    this.appendFieldsIn(clazz);	    while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {	        clazz = clazz.getSuperclass();	        this.appendFieldsIn(clazz);	    }	    return super.toString();	}
public static String center(String str, final int size, String padStr) {	    if (str == null || size <= 0) {	        return str;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    str = leftPad(str, strLen + pads / 2, padStr);	    str = rightPad(str, size, padStr);	    return str;	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
protected String getContentStart() {	    return contentStart;	}
public static CharRange isNot(final char ch) {	    return new CharRange(ch, ch, true);	}
public static float max(final float a, final float b, final float c) {	    return Math.max(Math.max(a, b), c);	}
public int size() {	    return size;	}
public static String getShortCanonicalName(final String canonicalName) {	    return ClassUtils.getShortClassName(getCanonicalName(canonicalName));	}
public static String overlay(final String str, String overlay, int start, int end) {	    if (str == null) {	        return null;	    }	    if (overlay == null) {	        overlay = EMPTY;	    }	    final int len = str.length();	    if (start < 0) {	        start = 0;	    }	    if (start > len) {	        start = len;	    }	    if (end < 0) {	        end = 0;	    }	    if (end > len) {	        end = len;	    }	    if (start > end) {	        final int temp = start;	        start = end;	        end = temp;	    }	    return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString();	}
public static boolean equals(final Object object1, final Object object2) {	    if (object1 == object2) {	        return true;	    }	    if (object1 == null || object2 == null) {	        return false;	    }	    return object1.equals(object2);	}
public static char toChar(final String str, final char defaultValue) {	    if (StringUtils.isEmpty(str)) {	        return defaultValue;	    }	    return str.charAt(0);	}
public int lastIndexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex >= size ? size - 1 : startIndex);	    if (matcher == null || startIndex < 0) {	        return -1;	    }	    final char[] buf = buffer;	    final int endIndex = startIndex + 1;	    for (int i = startIndex; i >= 0; i--) {	        if (matcher.isMatch(buf, i, 0, endIndex) > 0) {	            return i;	        }	    }	    return -1;	}
public static Date setYears(final Date date, final int amount) {	    return set(date, Calendar.YEAR, amount);	}
public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables) {	    this.enableSubstitutionInVariables = enableSubstitutionInVariables;	}
public static <T> Range<T> is(final T element, final Comparator<T> comparator) {	    return between(element, element, comparator);	}
@Override	public void setFieldSeparator(final String fieldSeparator) {	    super.setFieldSeparator(fieldSeparator);	}
protected String getSizeEndText() {	    return sizeEndText;	}
@Override	public boolean markSupported() {	    return true;	}
public static final String escapeJava(final String input) {	    return ESCAPE_JAVA.translate(input);	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
@Override	public String getNullText() {	    return super.getNullText();	}
protected boolean isArrayContentDetail() {	    return arrayContentDetail;	}
public int capacity() {	    return buffer.length;	}
public static String stripToNull(String str) {	    if (str == null) {	        return null;	    }	    str = strip(str, null);	    return str.isEmpty() ? null : str;	}
public Fraction subtract(final Fraction fraction) {	    return addSub(fraction, false);	}
public static final String unescapeJson(final String input) {	    return UNESCAPE_JSON.translate(input);	}
public static String stripToEmpty(final String str) {	    return str == null ? EMPTY : strip(str, null);	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof MutableLong) {	        return value == ((MutableLong) obj).longValue();	    }	    return false;	}
public static String capitalize(final String str) {	    int strLen;	    if (str == null || (strLen = str.length()) == 0) {	        return str;	    }	    char firstChar = str.charAt(0);	    if (Character.isTitleCase(firstChar)) {	        return str;	    }	    return new StringBuilder(strLen).append(Character.toTitleCase(firstChar)).append(str.substring(1)).toString();	}
public char getStart() {	    return this.start;	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
@Override	public int nextIndex() {	    return tokenPos;	}
@Override	public float floatValue() {	    return value;	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public boolean isEmpty() {	    return size == 0;	}
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) {	    if (bool == null) {	        return nullValue;	    }	    return bool.booleanValue() ? trueValue : falseValue;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public static int reflectionHashCode(final Object object, final String... excludeFields) {	    return reflectionHashCode(17, 37, object, false, null, excludeFields);	}
public static String substringAfter(final String str, final String separator) {	    if (isEmpty(str)) {	        return str;	    }	    if (separator == null) {	        return EMPTY;	    }	    final int pos = str.indexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return EMPTY;	    }	    return str.substring(pos + separator.length());	}
protected String getNullText() {	    return nullText;	}
@Override	public long longValue() {	    return value;	}
public static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes) {	    if ((src.length == 0 && srcPos == 0) || 0 == nBytes) {	        return dstInit;	    }	    if ((nBytes - 1) * 8 + dstPos >= 64) {	        throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 64");	    }	    long out = dstInit;	    int shift = 0;	    for (int i = 0; i < nBytes; i++) {	        shift = i * 8 + dstPos;	        final long bits = (0xffL & src[i + srcPos]) << shift;	        final long mask = 0xffL << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public Byte toByte() {	    return Byte.valueOf(byteValue());	}
@Override	public long skip(long n) {	    if (pos + n > StrBuilder.this.size()) {	        n = StrBuilder.this.size() - pos;	    }	    if (n < 0) {	        return 0;	    }	    pos += n;	    return n;	}
public static String removeEndIgnoreCase(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (endsWithIgnoreCase(str, remove)) {	        return str.substring(0, str.length() - remove.length());	    }	    return str;	}
public static final String escapeHtml4(final String input) {	    return ESCAPE_HTML4.translate(input);	}
public static boolean isSameInstant(final Calendar cal1, final Calendar cal2) {	    if (cal1 == null || cal2 == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    return cal1.getTime().getTime() == cal2.getTime().getTime();	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public String getNullText() {	    return nullText;	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static boolean endsWithIgnoreCase(final CharSequence str, final CharSequence suffix) {	    return endsWith(str, suffix, true);	}
private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase) {	    if (str == null || prefix == null) {	        return str == null && prefix == null;	    }	    if (prefix.length() > str.length()) {	        return false;	    }	    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());	}
public static boolean isWhitespace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isWhitespace(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return true;	    }	    if (lhs == null || rhs == null) {	        return false;	    }	    final Class<?> lhsClass = lhs.getClass();	    final Class<?> rhsClass = rhs.getClass();	    Class<?> testClass;	    if (lhsClass.isInstance(rhs)) {	        testClass = lhsClass;	        if (!rhsClass.isInstance(lhs)) {	            testClass = rhsClass;	        }	    } else if (rhsClass.isInstance(lhs)) {	        testClass = rhsClass;	        if (!lhsClass.isInstance(rhs)) {	            testClass = lhsClass;	        }	    } else {	        return false;	    }	    final EqualsBuilder equalsBuilder = new EqualsBuilder();	    try {	        reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {	            testClass = testClass.getSuperclass();	            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        }	    } catch (final IllegalArgumentException e) {	        return false;	    }	    return equalsBuilder.isEquals();	}
@Override	public boolean equals(final Object obj) {	    if (obj == this) {	        return true;	    }	    if (obj instanceof Fraction == false) {	        return false;	    }	    final Fraction other = (Fraction) obj;	    return getNumerator() == other.getNumerator() && getDenominator() == other.getDenominator();	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) {	    if (cls == null) {	        throw new IllegalArgumentException("The class must not be null");	    }	    if (fieldName == null) {	        throw new IllegalArgumentException("The field name must not be null");	    }	    for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) {	        try {	            final Field field = acls.getDeclaredField(fieldName);	            if (!Modifier.isPublic(field.getModifiers())) {	                if (forceAccess) {	                    field.setAccessible(true);	                } else {	                    continue;	                }	            }	            return field;	        } catch (final NoSuchFieldException ex) {	        }	    }	    Field match = null;	    for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) {	        try {	            final Field test = ((Class<?>) class1).getField(fieldName);	            if (match != null) {	                throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + "; a matching field exists on two or more implemented interfaces.");	            }	            match = test;	        } catch (final NoSuchFieldException ex) {	        }	    }	    return match;	}
public static Locale toLocale(final String str) {	    if (str == null) {	        return null;	    }	    if (str.contains("#")) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final int len = str.length();	    if (len < 2) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final char ch0 = str.charAt(0);	    if (ch0 == '_') {	        if (len < 3) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        final char ch1 = str.charAt(1);	        final char ch2 = str.charAt(2);	        if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        if (len == 3) {	            return new Locale("", str.substring(1, 3));	        }	        if (len < 5) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        if (str.charAt(3) != '_') {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        return new Locale("", str.substring(1, 3), str.substring(4));	    }	    final char ch1 = str.charAt(1);	    if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (len == 2) {	        return new Locale(str);	    }	    if (len < 5) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (str.charAt(2) != '_') {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final char ch3 = str.charAt(3);	    if (ch3 == '_') {	        return new Locale(str.substring(0, 2), "", str.substring(4));	    }	    final char ch4 = str.charAt(4);	    if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (len == 5) {	        return new Locale(str.substring(0, 2), str.substring(3, 5));	    }	    if (len < 7) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (str.charAt(5) != '_') {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));	}
public StrBuilder trim() {	    if (size == 0) {	        return this;	    }	    int len = size;	    final char[] buf = buffer;	    int pos = 0;	    while (pos < len && buf[pos] <= ' ') {	        pos++;	    }	    while (pos < len && buf[len - 1] <= ' ') {	        len--;	    }	    if (len < size) {	        delete(len, size);	    }	    if (pos > 0) {	        delete(0, pos);	    }	    return this;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
@Override	public String toString() {	    return StringUtils.repeat(this.value.toString(), this.count);	}
public static StrTokenizer getTSVInstance(final char[] input) {	    final StrTokenizer tok = getTSVClone();	    tok.reset(input);	    return tok;	}
public boolean isEquals() {	    return this.isEquals;	}
public String getNewLineText() {	    return newLine;	}
public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) {	    if (toClass == null) {	        return false;	    }	    if (cls == null) {	        return !toClass.isPrimitive();	    }	    if (autoboxing) {	        if (cls.isPrimitive() && !toClass.isPrimitive()) {	            cls = primitiveToWrapper(cls);	            if (cls == null) {	                return false;	            }	        }	        if (toClass.isPrimitive() && !cls.isPrimitive()) {	            cls = wrapperToPrimitive(cls);	            if (cls == null) {	                return false;	            }	        }	    }	    if (cls.equals(toClass)) {	        return true;	    }	    if (cls.isPrimitive()) {	        if (toClass.isPrimitive() == false) {	            return false;	        }	        if (Integer.TYPE.equals(cls)) {	            return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Long.TYPE.equals(cls)) {	            return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Boolean.TYPE.equals(cls)) {	            return false;	        }	        if (Double.TYPE.equals(cls)) {	            return false;	        }	        if (Float.TYPE.equals(cls)) {	            return Double.TYPE.equals(toClass);	        }	        if (Character.TYPE.equals(cls)) {	            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Short.TYPE.equals(cls)) {	            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Byte.TYPE.equals(cls)) {	            return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        return false;	    }	    return toClass.isAssignableFrom(cls);	}
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {	    if (array == null) {	        if (index != 0) {	            throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0");	        }	        final Object joinedArray = Array.newInstance(clss, 1);	        Array.set(joinedArray, 0, element);	        return joinedArray;	    }	    final int length = Array.getLength(array);	    if (index > length || index < 0) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(clss, length + 1);	    System.arraycopy(array, 0, result, 0, index);	    Array.set(result, index, element);	    if (index < length) {	        System.arraycopy(array, index, result, index + 1, length - index);	    }	    return result;	}
@Override	public long longValue() {	    return value;	}
public String getNewLineText() {	    return newLine;	}
public static Class<?> getRawType(final Type type, final Type assigningType) {	    if (type instanceof Class<?>) {	        return (Class<?>) type;	    }	    if (type instanceof ParameterizedType) {	        return getRawType((ParameterizedType) type);	    }	    if (type instanceof TypeVariable<?>) {	        if (assigningType == null) {	            return null;	        }	        final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration();	        if (!(genericDeclaration instanceof Class<?>)) {	            return null;	        }	        final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType, (Class<?>) genericDeclaration);	        if (typeVarAssigns == null) {	            return null;	        }	        final Type typeArgument = typeVarAssigns.get(type);	        if (typeArgument == null) {	            return null;	        }	        return getRawType(typeArgument, assigningType);	    }	    if (type instanceof GenericArrayType) {	        final Class<?> rawComponentType = getRawType(((GenericArrayType) type).getGenericComponentType(), assigningType);	        return Array.newInstance(rawComponentType, 0).getClass();	    }	    if (type instanceof WildcardType) {	        return null;	    }	    throw new IllegalArgumentException("unknown type: " + type);	}
public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException {	    return parseDateWithLeniency(str, locale, parsePatterns, true);	}
protected void setFieldSeparator(String fieldSeparator) {	    if (fieldSeparator == null) {	        fieldSeparator = "";	    }	    this.fieldSeparator = fieldSeparator;	}
protected String getArrayEnd() {	    return arrayEnd;	}
public static boolean isWhitespace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isWhitespace(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static <T> T median(final Comparator<T> comparator, final T... items) {	    Validate.notEmpty(items, "null/empty items");	    Validate.noNullElements(items);	    Validate.notNull(comparator, "null comparator");	    final TreeSet<T> sort = new TreeSet<T>(comparator);	    Collections.addAll(sort, items);	    @SuppressWarnings("unchecked")	    final T result = (T) sort.toArray()[(sort.size() - 1) / 2];	    return result;	}
public static short[] removeElement(final short[] array, final short element) {	    final int index = indexOf(array, element);	    if (index == INDEX_NOT_FOUND) {	        return clone(array);	    }	    return remove(array, index);	}
public static String[] substringsBetween(final String str, final String open, final String close) {	    if (str == null || isEmpty(open) || isEmpty(close)) {	        return null;	    }	    final int strLen = str.length();	    if (strLen == 0) {	        return ArrayUtils.EMPTY_STRING_ARRAY;	    }	    final int closeLen = close.length();	    final int openLen = open.length();	    final List<String> list = new ArrayList<String>();	    int pos = 0;	    while (pos < strLen - closeLen) {	        int start = str.indexOf(open, pos);	        if (start < 0) {	            break;	        }	        start += openLen;	        final int end = str.indexOf(close, start);	        if (end < 0) {	            break;	        }	        list.add(str.substring(start, end));	        pos = end + closeLen;	    }	    if (list.isEmpty()) {	        return null;	    }	    return list.toArray(new String[list.size()]);	}
public int size() {	    return size;	}
@Override	public int length() {	    return size;	}
@Override	public int length() {	    return size;	}
protected String getArraySeparator() {	    return arraySeparator;	}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    buffer.append(arrayStart);	    for (int i = 0; i < array.length; i++) {	        if (i > 0) {	            buffer.append(arraySeparator);	        }	        appendDetail(buffer, fieldName, array[i]);	    }	    buffer.append(arrayEnd);	}
@Override	public int hashCode() {	    return toHashCode();	}
public boolean isNaN() {	    return Float.isNaN(value);	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
public static boolean isAscii(final char ch) {	    return ch < 128;	}
public static boolean containsNone(final CharSequence cs, final String invalidChars) {	    if (cs == null || invalidChars == null) {	        return true;	    }	    return containsNone(cs, invalidChars.toCharArray());	}
@Override	public boolean markSupported() {	    return true;	}
public boolean isEmpty() {	    return size == 0;	}
public static String substringAfterLast(final String str, final String separator) {	    if (isEmpty(str)) {	        return str;	    }	    if (isEmpty(separator)) {	        return EMPTY;	    }	    final int pos = str.lastIndexOf(separator);	    if (pos == INDEX_NOT_FOUND || pos == str.length() - separator.length()) {	        return EMPTY;	    }	    return str.substring(pos + separator.length());	}
public int capacity() {	    return buffer.length;	}
public static boolean isBlank(final CharSequence cs) {	    int strLen;	    if (cs == null || (strLen = cs.length()) == 0) {	        return true;	    }	    for (int i = 0; i < strLen; i++) {	        if (Character.isWhitespace(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static Date round(final Object date, final int field) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (date instanceof Date) {	        return round((Date) date, field);	    } else if (date instanceof Calendar) {	        return round((Calendar) date, field).getTime();	    } else {	        throw new ClassCastException("Could not round " + date);	    }	}
@Override	public int intValue() {	    return value;	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public int toComparison() {	    return comparison;	}
@Override	public int nextIndex() {	    return tokenPos;	}
public static void writeStaticField(final Class<?> cls, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException {	    final Field field = getField(cls, fieldName, forceAccess);	    if (field == null) {	        throw new IllegalArgumentException("Cannot locate field " + fieldName + " on " + cls);	    }	    writeStaticField(field, value);	}
public boolean isEmptyTokenAsNull() {	    return this.emptyAsNull;	}
public static <T> T deserialize(final byte[] objectData) {	    if (objectData == null) {	        throw new IllegalArgumentException("The byte[] must not be null");	    }	    return SerializationUtils.<T>deserialize(new ByteArrayInputStream(objectData));	}
public static StrMatcher singleQuoteMatcher() {	    return SINGLE_QUOTE_MATCHER;	}
@Override	public int length() {	    return size;	}
public boolean booleanValue() {	    return value;	}
public static float max(final float a, final float b, final float c) {	    return Math.max(Math.max(a, b), c);	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts) {	    if ((src.length == 0 && srcPos == 0) || 0 == nShorts) {	        return dstInit;	    }	    if ((nShorts - 1) * 16 + dstPos >= 32) {	        throw new IllegalArgumentException("(nShorts-1)*16+dstPos is greather or equal to than 32");	    }	    int out = dstInit;	    int shift = 0;	    for (int i = 0; i < nShorts; i++) {	        shift = i * 16 + dstPos;	        final int bits = (0xffff & src[i + srcPos]) << shift;	        final int mask = 0xffff << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) {	    if (bool == null) {	        return nullValue;	    }	    return bool.booleanValue() ? trueValue : falseValue;	}
public static String substringBetween(final String str, final String open, final String close) {	    if (str == null || open == null || close == null) {	        return null;	    }	    final int start = str.indexOf(open);	    if (start != INDEX_NOT_FOUND) {	        final int end = str.indexOf(close, start + open.length());	        if (end != INDEX_NOT_FOUND) {	            return str.substring(start + open.length(), end);	        }	    }	    return null;	}
private static Date set(final Date date, final int calendarField, final int amount) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final Calendar c = Calendar.getInstance();	    c.setLenient(false);	    c.setTime(date);	    c.set(calendarField, amount);	    return c.getTime();	}
protected void appendFieldsIn(final Class<?> clazz) {	    if (clazz.isArray()) {	        this.reflectionAppendArray(this.getObject());	        return;	    }	    final Field[] fields = clazz.getDeclaredFields();	    AccessibleObject.setAccessible(fields, true);	    for (final Field field : fields) {	        final String fieldName = field.getName();	        if (this.accept(field)) {	            try {	                final Object fieldValue = this.getValue(field);	                this.append(fieldName, fieldValue);	            } catch (final IllegalAccessException ex) {	                throw new InternalError("Unexpected IllegalAccessException: " + ex.getMessage());	            }	        }	    }	}
public static boolean isAlpha(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static String formatDuration(long durationMillis, final String format, final boolean padWithZeros) {	    final Token[] tokens = lexx(format);	    int days = 0;	    int hours = 0;	    int minutes = 0;	    int seconds = 0;	    int milliseconds = 0;	    if (Token.containsTokenWithValue(tokens, d)) {	        days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY);	        durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY);	    }	    if (Token.containsTokenWithValue(tokens, H)) {	        hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR);	        durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR);	    }	    if (Token.containsTokenWithValue(tokens, m)) {	        minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE);	        durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE);	    }	    if (Token.containsTokenWithValue(tokens, s)) {	        seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND);	        durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND);	    }	    if (Token.containsTokenWithValue(tokens, S)) {	        milliseconds = (int) durationMillis;	    }	    return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public static boolean isAlpha(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
@Override	public boolean isDone() {	    return true;	}
public static List<Class<?>> convertClassNamesToClasses(final List<String> classNames) {	    if (classNames == null) {	        return null;	    }	    final List<Class<?>> classes = new ArrayList<Class<?>>(classNames.size());	    for (final String className : classNames) {	        try {	            classes.add(Class.forName(className));	        } catch (final Exception ex) {	            classes.add(null);	        }	    }	    return classes;	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public static String uncapitalize(final String str) {	    int strLen;	    if (str == null || (strLen = str.length()) == 0) {	        return str;	    }	    char firstChar = str.charAt(0);	    if (Character.isLowerCase(firstChar)) {	        return str;	    }	    return new StringBuilder(strLen).append(Character.toLowerCase(firstChar)).append(str.substring(1)).toString();	}
public static String capitalize(final String str) {	    int strLen;	    if (str == null || (strLen = str.length()) == 0) {	        return str;	    }	    char firstChar = str.charAt(0);	    if (Character.isTitleCase(firstChar)) {	        return str;	    }	    return new StringBuilder(strLen).append(Character.toTitleCase(firstChar)).append(str.substring(1)).toString();	}
public static String[] splitByCharacterTypeCamelCase(final String str) {	    return splitByCharacterType(str, true);	}
public static Method getMatchingAccessibleMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) {	    try {	        final Method method = cls.getMethod(methodName, parameterTypes);	        MemberUtils.setAccessibleWorkaround(method);	        return method;	    } catch (final NoSuchMethodException e) {	    }	    Method bestMatch = null;	    final Method[] methods = cls.getMethods();	    for (final Method method : methods) {	        if (method.getName().equals(methodName) && ClassUtils.isAssignable(parameterTypes, method.getParameterTypes(), true)) {	            final Method accessibleMethod = getAccessibleMethod(method);	            if (accessibleMethod != null && (bestMatch == null || MemberUtils.compareParameterTypes(accessibleMethod.getParameterTypes(), bestMatch.getParameterTypes(), parameterTypes) < 0)) {	                bestMatch = accessibleMethod;	            }	        }	    }	    if (bestMatch != null) {	        MemberUtils.setAccessibleWorkaround(bestMatch);	    }	    return bestMatch;	}
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return 0;	    }	    if (lhs == null || rhs == null) {	        throw new NullPointerException();	    }	    Class<?> lhsClazz = lhs.getClass();	    if (!lhsClazz.isInstance(rhs)) {	        throw new ClassCastException();	    }	    final CompareToBuilder compareToBuilder = new CompareToBuilder();	    reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);	    while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) {	        lhsClazz = lhsClazz.getSuperclass();	        reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);	    }	    return compareToBuilder.toComparison();	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public int lastIndexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex >= size ? size - 1 : startIndex);	    if (matcher == null || startIndex < 0) {	        return -1;	    }	    final char[] buf = buffer;	    final int endIndex = startIndex + 1;	    for (int i = startIndex; i >= 0; i--) {	        if (matcher.isMatch(buf, i, 0, endIndex) > 0) {	            return i;	        }	    }	    return -1;	}
public static String difference(final String str1, final String str2) {	    if (str1 == null) {	        return str2;	    }	    if (str2 == null) {	        return str1;	    }	    final int at = indexOfDifference(str1, str2);	    if (at == INDEX_NOT_FOUND) {	        return EMPTY;	    }	    return str2.substring(at);	}
public static String overlay(final String str, String overlay, int start, int end) {	    if (str == null) {	        return null;	    }	    if (overlay == null) {	        overlay = EMPTY;	    }	    final int len = str.length();	    if (start < 0) {	        start = 0;	    }	    if (start > len) {	        start = len;	    }	    if (end < 0) {	        end = 0;	    }	    if (end > len) {	        end = len;	    }	    if (start > end) {	        final int temp = start;	        start = end;	        end = temp;	    }	    return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString();	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static int indexOfDifference(final CharSequence... css) {	    if (css == null || css.length <= 1) {	        return INDEX_NOT_FOUND;	    }	    boolean anyStringNull = false;	    boolean allStringsNull = true;	    final int arrayLen = css.length;	    int shortestStrLen = Integer.MAX_VALUE;	    int longestStrLen = 0;	    for (int i = 0; i < arrayLen; i++) {	        if (css[i] == null) {	            anyStringNull = true;	            shortestStrLen = 0;	        } else {	            allStringsNull = false;	            shortestStrLen = Math.min(css[i].length(), shortestStrLen);	            longestStrLen = Math.max(css[i].length(), longestStrLen);	        }	    }	    if (allStringsNull || longestStrLen == 0 && !anyStringNull) {	        return INDEX_NOT_FOUND;	    }	    if (shortestStrLen == 0) {	        return 0;	    }	    int firstDiff = -1;	    for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {	        final char comparisonChar = css[0].charAt(stringPos);	        for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {	            if (css[arrayPos].charAt(stringPos) != comparisonChar) {	                firstDiff = stringPos;	                break;	            }	        }	        if (firstDiff != -1) {	            break;	        }	    }	    if (firstDiff == -1 && shortestStrLen != longestStrLen) {	        return shortestStrLen;	    }	    return firstDiff;	}
public StrBuilder appendSeparator(final char separator, final int loopIndex) {	    if (loopIndex > 0) {	        append(separator);	    }	    return this;	}
public static boolean truncatedEquals(final Date date1, final Date date2, final int field) {	    return truncatedCompareTo(date1, date2, field) == 0;	}
public synchronized void acquire() throws InterruptedException {	    if (isShutdown()) {	        throw new IllegalStateException("TimedSemaphore is shut down!");	    }	    if (task == null) {	        task = startTimer();	    }	    boolean canPass = false;	    do {	        canPass = getLimit() <= NO_LIMIT || acquireCount < getLimit();	        if (!canPass) {	            wait();	        } else {	            acquireCount++;	        }	    } while (!canPass);	}
public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer) {	    if (throwable == null) {	        return;	    }	    if (writer == null) {	        throw new IllegalArgumentException("The PrintWriter must not be null");	    }	    final String[] trace = getRootCauseStackTrace(throwable);	    for (final String element : trace) {	        writer.println(element);	    }	    writer.flush();	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static <T> Future<T> constantFuture(final T value) {	    return new ConstantFuture<T>(value);	}
private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase) {	    if (str == null || prefix == null) {	        return str == null && prefix == null;	    }	    if (prefix.length() > str.length()) {	        return false;	    }	    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static Boolean or(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
private static String[] splitByCharacterType(final String str, final boolean camelCase) {	    if (str == null) {	        return null;	    }	    if (str.isEmpty()) {	        return ArrayUtils.EMPTY_STRING_ARRAY;	    }	    final char[] c = str.toCharArray();	    final List<String> list = new ArrayList<String>();	    int tokenStart = 0;	    int currentType = Character.getType(c[tokenStart]);	    for (int pos = tokenStart + 1; pos < c.length; pos++) {	        final int type = Character.getType(c[pos]);	        if (type == currentType) {	            continue;	        }	        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {	            final int newTokenStart = pos - 1;	            if (newTokenStart != tokenStart) {	                list.add(new String(c, tokenStart, newTokenStart - tokenStart));	                tokenStart = newTokenStart;	            }	        } else {	            list.add(new String(c, tokenStart, pos - tokenStart));	            tokenStart = pos;	        }	        currentType = type;	    }	    list.add(new String(c, tokenStart, c.length - tokenStart));	    return list.toArray(new String[list.size()]);	}
public static ConcurrentException extractCause(final ExecutionException ex) {	    if (ex == null || ex.getCause() == null) {	        return null;	    }	    throwCause(ex);	    return new ConcurrentException(ex.getMessage(), ex.getCause());	}
@Override	public void write(final String str, final int off, final int len) {	    StrBuilder.this.append(str, off, len);	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
public static String formatDurationISO(final long durationMillis) {	    return formatDuration(durationMillis, ISO_EXTENDED_FORMAT_PATTERN, false);	}
public int clear(final int holder) {	    return holder & ~_mask;	}
public boolean isEmpty() {	    return size == 0;	}
public static float min(final float a, final float b) {	    if (Float.isNaN(a)) {	        return b;	    } else if (Float.isNaN(b)) {	        return a;	    } else {	        return Math.min(a, b);	    }	}
public static <T> Range<T> is(final T element, final Comparator<T> comparator) {	    return between(element, element, comparator);	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static Boolean or(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
public boolean isEmpty() {	    return size == 0;	}
public static int hexDigitMsb0ToInt(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return 0x0;	        case '1':	            return 0x8;	        case '2':	            return 0x4;	        case '3':	            return 0xC;	        case '4':	            return 0x2;	        case '5':	            return 0xA;	        case '6':	            return 0x6;	        case '7':	            return 0xE;	        case '8':	            return 0x1;	        case '9':	            return 0x9;	        case 'a':	        case 'A':	            return 0x5;	        case 'b':	        case 'B':	            return 0xD;	        case 'c':	        case 'C':	            return 0x3;	        case 'd':	        case 'D':	            return 0xB;	        case 'e':	        case 'E':	            return 0x7;	        case 'f':	        case 'F':	            return 0xF;	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public boolean isEmpty() {	    return size == 0;	}
public static String repeat(final char ch, final int repeat) {	    final char[] buf = new char[repeat];	    for (int i = repeat - 1; i >= 0; i--) {	        buf[i] = ch;	    }	    return new String(buf);	}
public static <T> T cloneIfPossible(final T obj) {	    final T clone = clone(obj);	    return clone == null ? obj : clone;	}
public static <T> Constructor<T> getAccessibleConstructor(final Constructor<T> ctor) {	    return MemberUtils.isAccessible(ctor) && Modifier.isPublic(ctor.getDeclaringClass().getModifiers()) ? ctor : null;	}
public static boolean[] clone(final boolean[] array) {	    if (array == null) {	        return null;	    }	    return array.clone();	}
public static Fraction getReducedFraction(int numerator, int denominator) {	    if (denominator == 0) {	        throw new ArithmeticException("The denominator must not be zero");	    }	    if (numerator == 0) {	        return ZERO;	    }	    if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) {	        numerator /= 2;	        denominator /= 2;	    }	    if (denominator < 0) {	        if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {	            throw new ArithmeticException("overflow: can't negate");	        }	        numerator = -numerator;	        denominator = -denominator;	    }	    final int gcd = greatestCommonDivisor(numerator, denominator);	    numerator /= gcd;	    denominator /= gcd;	    return new Fraction(numerator, denominator);	}
public static String overlay(final String str, String overlay, int start, int end) {	    if (str == null) {	        return null;	    }	    if (overlay == null) {	        overlay = EMPTY;	    }	    final int len = str.length();	    if (start < 0) {	        start = 0;	    }	    if (start > len) {	        start = len;	    }	    if (end < 0) {	        end = 0;	    }	    if (end > len) {	        end = len;	    }	    if (start > end) {	        final int temp = start;	        start = end;	        end = temp;	    }	    return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString();	}
public static String normalizeSpace(final String str) {	    if (str == null) {	        return null;	    }	    return WHITESPACE_PATTERN.matcher(trim(str)).replaceAll(SPACE);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static String removeEnd(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.endsWith(remove)) {	        return str.substring(0, str.length() - remove.length());	    }	    return str;	}
public static String removeEnd(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.endsWith(remove)) {	        return str.substring(0, str.length() - remove.length());	    }	    return str;	}
protected int validateRange(final int startIndex, int endIndex) {	    if (startIndex < 0) {	        throw new StringIndexOutOfBoundsException(startIndex);	    }	    if (endIndex > size) {	        endIndex = size;	    }	    if (startIndex > endIndex) {	        throw new StringIndexOutOfBoundsException("end < start");	    }	    return endIndex;	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public static String appendIfMissingIgnoreCase(final String str, final CharSequence suffix, final CharSequence... suffixes) {	    return appendIfMissing(str, suffix, true, suffixes);	}
public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) {	    if (it != null) {	        separator = ObjectUtils.toString(separator);	        while (it.hasNext()) {	            append(it.next());	            if (it.hasNext()) {	                append(separator);	            }	        }	    }	    return this;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
@Override	public void mark(final int readAheadLimit) {	    mark = pos;	}
public static String appendIfMissing(final String str, final CharSequence suffix, final CharSequence... suffixes) {	    return appendIfMissing(str, suffix, false, suffixes);	}
public static String getShortClassName(String className) {	    if (StringUtils.isEmpty(className)) {	        return StringUtils.EMPTY;	    }	    final StringBuilder arrayPrefix = new StringBuilder();	    if (className.startsWith("[")) {	        while (className.charAt(0) == '[') {	            className = className.substring(1);	            arrayPrefix.append("[]");	        }	        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {	            className = className.substring(1, className.length() - 1);	        }	        if (reverseAbbreviationMap.containsKey(className)) {	            className = reverseAbbreviationMap.get(className);	        }	    }	    final int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);	    final int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);	    String out = className.substring(lastDotIdx + 1);	    if (innerIdx != -1) {	        out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);	    }	    return out + arrayPrefix;	}
protected boolean isArrayContentDetail() {	    return arrayContentDetail;	}
protected String getSizeStartText() {	    return sizeStartText;	}
public static String rightPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return rightPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return str.concat(padStr);	    } else if (pads < padLen) {	        return str.concat(padStr.substring(0, pads));	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return str.concat(new String(padding));	    }	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
protected boolean isUseClassName() {	    return useClassName;	}
@Override	public void close() {	}
static Object removeAll(final Object array, final BitSet indices) {	    final int srcLength = ArrayUtils.getLength(array);	    final int removals = indices.cardinality();	    final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals);	    int srcIndex = 0;	    int destIndex = 0;	    int count;	    int set;	    while ((set = indices.nextSetBit(srcIndex)) != -1) {	        count = set - srcIndex;	        if (count > 0) {	            System.arraycopy(array, srcIndex, result, destIndex, count);	            destIndex += count;	        }	        srcIndex = indices.nextClearBit(set);	    }	    count = srcLength - srcIndex;	    if (count > 0) {	        System.arraycopy(array, srcIndex, result, destIndex, count);	    }	    return result;	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
public int toComparison() {	    return comparison;	}
public static Boolean[] nullToEmpty(final Boolean[] array) {	    if (array == null || array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    return array;	}
protected String getNullText() {	    return nullText;	}
protected String getSizeStartText() {	    return sizeStartText;	}
public void decrement() {	    value--;	}
public static String squeeze(final String str, final String... set) {	    if (StringUtils.isEmpty(str) || deepEmpty(set)) {	        return str;	    }	    final CharSet chars = CharSet.getInstance(set);	    final StringBuilder buffer = new StringBuilder(str.length());	    final char[] chrs = str.toCharArray();	    final int sz = chrs.length;	    char lastChar = ' ';	    char ch = ' ';	    for (int i = 0; i < sz; i++) {	        ch = chrs[i];	        if (ch == lastChar && i != 0 && chars.contains(ch)) {	            continue;	        }	        buffer.append(ch);	        lastChar = ch;	    }	    return buffer.toString();	}
public int capacity() {	    return buffer.length;	}
public static <T extends CharSequence> T validIndex(final T chars, final int index) {	    return validIndex(chars, index, DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE, Integer.valueOf(index));	}
public static String capitalize(final String str) {	    int strLen;	    if (str == null || (strLen = str.length()) == 0) {	        return str;	    }	    char firstChar = str.charAt(0);	    if (Character.isTitleCase(firstChar)) {	        return str;	    }	    return new StringBuilder(strLen).append(Character.toTitleCase(firstChar)).append(str.substring(1)).toString();	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public final synchronized void setExternalExecutor(final ExecutorService externalExecutor) {	    if (isStarted()) {	        throw new IllegalStateException("Cannot set ExecutorService after start()!");	    }	    this.externalExecutor = externalExecutor;	}
@Override	public void write(final String str, final int off, final int len) {	    StrBuilder.this.append(str, off, len);	}
@Override	public int compareTo(final MutableShort other) {	    final short anotherVal = other.value;	    return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1);	}
public String getNewLineText() {	    return newLine;	}
@Override	public boolean equals(final Object obj) {	    if (obj == this) {	        return true;	    } else if (obj == null || obj.getClass() != getClass()) {	        return false;	    } else {	        @SuppressWarnings("unchecked")	        final Range<T> range = (Range<T>) obj;	        return minimum.equals(range.minimum) && maximum.equals(range.maximum);	    }	}
protected String getArrayEnd() {	    return arrayEnd;	}
public static int reflectionHashCode(final Object object, final String... excludeFields) {	    return reflectionHashCode(17, 37, object, false, null, excludeFields);	}
public static StrMatcher quoteMatcher() {	    return QUOTE_MATCHER;	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
@Override	public int read(final char[] b, final int off, int len) {	    if (off < 0 || len < 0 || off > b.length || (off + len) > b.length || (off + len) < 0) {	        throw new IndexOutOfBoundsException();	    }	    if (len == 0) {	        return 0;	    }	    if (pos >= StrBuilder.this.size()) {	        return -1;	    }	    if (pos + len > size()) {	        len = StrBuilder.this.size() - pos;	    }	    StrBuilder.this.getChars(pos, pos + len, b, off);	    pos += len;	    return len;	}
public static boolean[] removeElements(final boolean[] array, final boolean... values) {	    if (isEmpty(array) || isEmpty(values)) {	        return clone(array);	    }	    final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2);	    for (final boolean v : values) {	        final Boolean boxed = Boolean.valueOf(v);	        final MutableInt count = occurrences.get(boxed);	        if (count == null) {	            occurrences.put(boxed, new MutableInt(1));	        } else {	            count.increment();	        }	    }	    final BitSet toRemove = new BitSet();	    for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) {	        final Boolean v = e.getKey();	        int found = 0;	        for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {	            found = indexOf(array, v.booleanValue(), found);	            if (found < 0) {	                break;	            }	            toRemove.set(found++);	        }	    }	    return (boolean[]) removeAll(array, toRemove);	}
public static boolean isNumeric(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isDigit(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
@Override	public Integer getValue() {	    return Integer.valueOf(this.value);	}
public static String capitalizeFully(String str, final char... delimiters) {	    final int delimLen = delimiters == null ? -1 : delimiters.length;	    if (StringUtils.isEmpty(str) || delimLen == 0) {	        return str;	    }	    str = str.toLowerCase();	    return capitalize(str, delimiters);	}
public HashCodeBuilder append(final short[] array) {	    if (array == null) {	        iTotal = iTotal * iConstant;	    } else {	        for (final short element : array) {	            append(element);	        }	    }	    return this;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase) {	    if (str == null || prefix == null) {	        return str == null && prefix == null;	    }	    if (prefix.length() > str.length()) {	        return false;	    }	    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());	}
@Override	public void reset() {	    pos = mark;	}
public static <E extends Enum<E>> boolean isValidEnum(final Class<E> enumClass, final String enumName) {	    if (enumName == null) {	        return false;	    }	    try {	        Enum.valueOf(enumClass, enumName);	        return true;	    } catch (final IllegalArgumentException ex) {	        return false;	    }	}
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {	    if (array == null) {	        if (index != 0) {	            throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0");	        }	        final Object joinedArray = Array.newInstance(clss, 1);	        Array.set(joinedArray, 0, element);	        return joinedArray;	    }	    final int length = Array.getLength(array);	    if (index > length || index < 0) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(clss, length + 1);	    System.arraycopy(array, 0, result, 0, index);	    Array.set(result, index, element);	    if (index < length) {	        System.arraycopy(array, index, result, index + 1, length - index);	    }	    return result;	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
protected String getArrayEnd() {	    return arrayEnd;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public final T getObject() {	    return object;	}
public int capacity() {	    return buffer.length;	}
public static <T> T CONST(final T v) {	    return v;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static String trimToEmpty(final String str) {	    return str == null ? EMPTY : str.trim();	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return 0;	    }	    if (lhs == null || rhs == null) {	        throw new NullPointerException();	    }	    Class<?> lhsClazz = lhs.getClass();	    if (!lhsClazz.isInstance(rhs)) {	        throw new ClassCastException();	    }	    final CompareToBuilder compareToBuilder = new CompareToBuilder();	    reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);	    while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) {	        lhsClazz = lhsClazz.getSuperclass();	        reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);	    }	    return compareToBuilder.toComparison();	}
public StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, 1);	}
public String getNewLineText() {	    return newLine;	}
public static String reverse(final String str) {	    if (str == null) {	        return null;	    }	    return new StringBuilder(str).reverse().toString();	}
@Override	public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) {	    return buffer[pos] <= 32 ? 1 : 0;	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
private static boolean endsWith(final CharSequence str, final CharSequence suffix, final boolean ignoreCase) {	    if (str == null || suffix == null) {	        return str == null && suffix == null;	    }	    if (suffix.length() > str.length()) {	        return false;	    }	    final int strOffset = str.length() - suffix.length();	    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, suffix, 0, suffix.length());	}
public StrBuilder appendPadding(final int length, final char padChar) {	    if (length >= 0) {	        ensureCapacity(size + length);	        for (int i = 0; i < length; i++) {	            buffer[size++] = padChar;	        }	    }	    return this;	}
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {	    if (array == null) {	        if (index != 0) {	            throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0");	        }	        final Object joinedArray = Array.newInstance(clss, 1);	        Array.set(joinedArray, 0, element);	        return joinedArray;	    }	    final int length = Array.getLength(array);	    if (index > length || index < 0) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(clss, length + 1);	    System.arraycopy(array, 0, result, 0, index);	    Array.set(result, index, element);	    if (index < length) {	        System.arraycopy(array, index, result, index + 1, length - index);	    }	    return result;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public String getNullText() {	    return nullText;	}
public static boolean[] clone(final boolean[] array) {	    if (array == null) {	        return null;	    }	    return array.clone();	}
@Override	public T get(final long timeout, final TimeUnit unit) {	    return value;	}
public static float min(final float a, final float b) {	    if (Float.isNaN(a)) {	        return b;	    } else if (Float.isNaN(b)) {	        return a;	    } else {	        return Math.min(a, b);	    }	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public Fraction negate() {	    if (numerator == Integer.MIN_VALUE) {	        throw new ArithmeticException("overflow: too large to negate");	    }	    return new Fraction(-numerator, denominator);	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static String swapCase(final String str) {	    if (StringUtils.isEmpty(str)) {	        return str;	    }	    final char[] buffer = str.toCharArray();	    boolean whitespace = true;	    for (int i = 0; i < buffer.length; i++) {	        final char ch = buffer[i];	        if (Character.isUpperCase(ch)) {	            buffer[i] = Character.toLowerCase(ch);	            whitespace = false;	        } else if (Character.isTitleCase(ch)) {	            buffer[i] = Character.toLowerCase(ch);	            whitespace = false;	        } else if (Character.isLowerCase(ch)) {	            if (whitespace) {	                buffer[i] = Character.toTitleCase(ch);	                whitespace = false;	            } else {	                buffer[i] = Character.toUpperCase(ch);	            }	        } else {	            whitespace = Character.isWhitespace(ch);	        }	    }	    return new String(buffer);	}
public boolean replaceIn(final StrBuilder source, final int offset, final int length) {	    if (source == null) {	        return false;	    }	    return substitute(source, offset, length);	}
public static String[] stripAll(final String[] strs, final String stripChars) {	    int strsLen;	    if (strs == null || (strsLen = strs.length) == 0) {	        return strs;	    }	    final String[] newArr = new String[strsLen];	    for (int i = 0; i < strsLen; i++) {	        newArr[i] = strip(strs[i], stripChars);	    }	    return newArr;	}
@Override	public int length() {	    return size;	}
@Override	public StringBuffer format(final Calendar calendar, final StringBuffer buf) {	    return applyRules(calendar, buf);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public boolean isEquals() {	    return this.isEquals;	}
@Override	public int length() {	    return size;	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
public static boolean equalsIgnoreCase(final CharSequence str1, final CharSequence str2) {	    if (str1 == null || str2 == null) {	        return str1 == str2;	    } else if (str1 == str2) {	        return true;	    } else if (str1.length() != str2.length()) {	        return false;	    } else {	        return CharSequenceUtils.regionMatches(str1, true, 0, str2, 0, str1.length());	    }	}
protected String getFieldNameValueSeparator() {	    return fieldNameValueSeparator;	}
public void decrement() {	    value--;	}
public int getDenominator() {	    return denominator;	}
@Override	public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) {	    return buffer[pos] <= 32 ? 1 : 0;	}
@Override	public boolean ready() {	    return pos < StrBuilder.this.size();	}
protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    appendSummarySize(buffer, fieldName, array.length);	}
@Override	protected MultiBackgroundInitializerResults initialize() throws Exception {	    Map<String, BackgroundInitializer<?>> inits;	    synchronized (this) {	        inits = new HashMap<String, BackgroundInitializer<?>>(childInitializers);	    }	    final ExecutorService exec = getActiveExecutor();	    for (final BackgroundInitializer<?> bi : inits.values()) {	        if (bi.getExternalExecutor() == null) {	            bi.setExternalExecutor(exec);	        }	        bi.start();	    }	    final Map<String, Object> results = new HashMap<String, Object>();	    final Map<String, ConcurrentException> excepts = new HashMap<String, ConcurrentException>();	    for (final Map.Entry<String, BackgroundInitializer<?>> e : inits.entrySet()) {	        try {	            results.put(e.getKey(), e.getValue().get());	        } catch (final ConcurrentException cex) {	            excepts.put(e.getKey(), cex);	        }	    }	    return new MultiBackgroundInitializerResults(inits, results, excepts);	}
public static boolean isAllUpperCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isUpperCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public long getNanoTime() {	    if (this.runningState == STATE_STOPPED || this.runningState == STATE_SUSPENDED) {	        return this.stopTime - this.startTime;	    } else if (this.runningState == STATE_UNSTARTED) {	        return 0;	    } else if (this.runningState == STATE_RUNNING) {	        return System.nanoTime() - this.startTime;	    }	    throw new RuntimeException("Illegal running state has occurred.");	}
private static long getFragment(final Calendar calendar, final int fragment, final int unit) {	    if (calendar == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final long millisPerUnit = getMillisPerUnit(unit);	    long result = 0;	    switch(fragment) {	        case Calendar.YEAR:	            result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit;	            break;	        case Calendar.MONTH:	            result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit;	            break;	    }	    switch(fragment) {	        case Calendar.YEAR:	        case Calendar.MONTH:	        case Calendar.DAY_OF_YEAR:	        case Calendar.DATE:	            result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit;	        case Calendar.HOUR_OF_DAY:	            result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit;	        case Calendar.MINUTE:	            result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit;	        case Calendar.SECOND:	            result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit;	            break;	        case Calendar.MILLISECOND:	            break;	        default:	            throw new IllegalArgumentException("The fragment " + fragment + " is not supported");	    }	    return result;	}
public static <T> T initialize(final ConcurrentInitializer<T> initializer) throws ConcurrentException {	    return initializer != null ? initializer.get() : null;	}
public boolean isEquals() {	    return this.isEquals;	}
public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException {	    return parseDateWithLeniency(str, locale, parsePatterns, true);	}
public char getEscapeChar() {	    return this.escapeChar;	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public static StrTokenizer getTSVInstance(final char[] input) {	    final StrTokenizer tok = getTSVClone();	    tok.reset(input);	    return tok;	}
@Override	public CharSequence subSequence(final int startIndex, final int endIndex) {	    if (startIndex < 0) {	        throw new StringIndexOutOfBoundsException(startIndex);	    }	    if (endIndex > size) {	        throw new StringIndexOutOfBoundsException(endIndex);	    }	    if (startIndex > endIndex) {	        throw new StringIndexOutOfBoundsException(endIndex - startIndex);	    }	    return substring(startIndex, endIndex);	}
public static int lastIndexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = INDEX_NOT_FOUND;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.lastIndexOf(str, search, str.length());	        if (tmp > ret) {	            ret = tmp;	        }	    }	    return ret;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public int capacity() {	    return buffer.length;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public int toComparison() {	    return comparison;	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
@Override	public int read(final char[] b, final int off, int len) {	    if (off < 0 || len < 0 || off > b.length || (off + len) > b.length || (off + len) < 0) {	        throw new IndexOutOfBoundsException();	    }	    if (len == 0) {	        return 0;	    }	    if (pos >= StrBuilder.this.size()) {	        return -1;	    }	    if (pos + len > size()) {	        len = StrBuilder.this.size() - pos;	    }	    StrBuilder.this.getChars(pos, pos + len, b, off);	    pos += len;	    return len;	}
public static ConcurrentException extractCause(final ExecutionException ex) {	    if (ex == null || ex.getCause() == null) {	        return null;	    }	    throwCause(ex);	    return new ConcurrentException(ex.getMessage(), ex.getCause());	}
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return new boolean[] { false, false, false, false };	        case '1':	            return new boolean[] { false, false, false, true };	        case '2':	            return new boolean[] { false, false, true, false };	        case '3':	            return new boolean[] { false, false, true, true };	        case '4':	            return new boolean[] { false, true, false, false };	        case '5':	            return new boolean[] { false, true, false, true };	        case '6':	            return new boolean[] { false, true, true, false };	        case '7':	            return new boolean[] { false, true, true, true };	        case '8':	            return new boolean[] { true, false, false, false };	        case '9':	            return new boolean[] { true, false, false, true };	        case 'a':	        case 'A':	            return new boolean[] { true, false, true, false };	        case 'b':	        case 'B':	            return new boolean[] { true, false, true, true };	        case 'c':	        case 'C':	            return new boolean[] { true, true, false, false };	        case 'd':	        case 'D':	            return new boolean[] { true, true, false, true };	        case 'e':	        case 'E':	            return new boolean[] { true, true, true, false };	        case 'f':	        case 'F':	            return new boolean[] { true, true, true, true };	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
@Override	public String toString() {	    if (this.getObject() == null) {	        return this.getStyle().getNullText();	    }	    Class<?> clazz = this.getObject().getClass();	    this.appendFieldsIn(clazz);	    while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {	        clazz = clazz.getSuperclass();	        this.appendFieldsIn(clazz);	    }	    return super.toString();	}
public static String random(final int count, final char... chars) {	    if (chars == null) {	        return random(count, 0, 0, false, false, null, RANDOM);	    }	    return random(count, 0, chars.length, false, false, chars, RANDOM);	}
public static Object readField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException {	    if (target == null) {	        throw new IllegalArgumentException("target object must not be null");	    }	    final Class<?> cls = target.getClass();	    final Field field = getField(cls, fieldName, forceAccess);	    if (field == null) {	        throw new IllegalArgumentException("Cannot locate field " + fieldName + " on " + cls);	    }	    return readField(field, target);	}
public StrBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar) {	    return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);	}
public static <T> T CONST(final T v) {	    return v;	}
public static boolean isAlphanumericSpace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetterOrDigit(cs.charAt(i)) == false && cs.charAt(i) != ' ') {	            return false;	        }	    }	    return true;	}
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) {	    style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));	    return this;	}
@Override	public String toString() {	    if (this.getObject() == null) {	        return this.getStyle().getNullText();	    }	    Class<?> clazz = this.getObject().getClass();	    this.appendFieldsIn(clazz);	    while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {	        clazz = clazz.getSuperclass();	        this.appendFieldsIn(clazz);	    }	    return super.toString();	}
@Override	public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) {	    return buffer[pos] <= 32 ? 1 : 0;	}
public String getNewLineText() {	    return newLine;	}
public boolean contains(final T element) {	    if (element == null) {	        return false;	    }	    return comparator.compare(element, minimum) > -1 && comparator.compare(element, maximum) < 1;	}
static Token[] lexx(final String format) {	    final char[] array = format.toCharArray();	    final ArrayList<Token> list = new ArrayList<Token>(array.length);	    boolean inLiteral = false;	    StringBuilder buffer = null;	    Token previous = null;	    final int sz = array.length;	    for (int i = 0; i < sz; i++) {	        final char ch = array[i];	        if (inLiteral && ch != '\'') {	            buffer.append(ch);	            continue;	        }	        Object value = null;	        switch(ch) {	            case '\'':	                if (inLiteral) {	                    buffer = null;	                    inLiteral = false;	                } else {	                    buffer = new StringBuilder();	                    list.add(new Token(buffer));	                    inLiteral = true;	                }	                break;	            case 'y':	                value = y;	                break;	            case 'M':	                value = M;	                break;	            case 'd':	                value = d;	                break;	            case 'H':	                value = H;	                break;	            case 'm':	                value = m;	                break;	            case 's':	                value = s;	                break;	            case 'S':	                value = S;	                break;	            default:	                if (buffer == null) {	                    buffer = new StringBuilder();	                    list.add(new Token(buffer));	                }	                buffer.append(ch);	        }	        if (value != null) {	            if (previous != null && previous.getValue() == value) {	                previous.increment();	            } else {	                final Token token = new Token(value);	                list.add(token);	                previous = token;	            }	            buffer = null;	        }	    }	    return list.toArray(new Token[list.size()]);	}
@Override	public int length() {	    return size;	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) {	    if (str == null) {	        if (trueString == null) {	            return Boolean.TRUE;	        }	        if (falseString == null) {	            return Boolean.FALSE;	        }	        if (nullString == null) {	            return null;	        }	    } else if (str.equals(trueString)) {	        return Boolean.TRUE;	    } else if (str.equals(falseString)) {	        return Boolean.FALSE;	    } else if (str.equals(nullString)) {	        return null;	    }	    throw new IllegalArgumentException("The String did not match any specified value");	}
private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase) {	    if (str == null || prefix == null) {	        return str == null && prefix == null;	    }	    if (prefix.length() > str.length()) {	        return false;	    }	    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
public static <E extends Enum<E>> EnumSet<E> processBitVector(final Class<E> enumClass, final long value) {	    checkBitVectorable(enumClass).getEnumConstants();	    return processBitVectors(enumClass, value);	}
public StrBuilder appendFixedWidthPadRight(final int value, final int width, final char padChar) {	    return appendFixedWidthPadRight(String.valueOf(value), width, padChar);	}
@Override	public boolean ready() {	    return pos < StrBuilder.this.size();	}
public static String formatDurationISO(final long durationMillis) {	    return formatDuration(durationMillis, ISO_EXTENDED_FORMAT_PATTERN, false);	}
public static String appendIfMissing(final String str, final CharSequence suffix, final CharSequence... suffixes) {	    return appendIfMissing(str, suffix, false, suffixes);	}
protected String getArraySeparator() {	    return arraySeparator;	}
public String getRawMessage() {	    return super.getMessage();	}
public String getNewLineText() {	    return newLine;	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) {	    style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));	    return this;	}
@Override	public boolean equals(final Object obj2) {	    if (obj2 instanceof Token) {	        final Token tok2 = (Token) obj2;	        if (this.value.getClass() != tok2.value.getClass()) {	            return false;	        }	        if (this.count != tok2.count) {	            return false;	        }	        if (this.value instanceof StringBuilder) {	            return this.value.toString().equals(tok2.value.toString());	        } else if (this.value instanceof Number) {	            return this.value.equals(tok2.value);	        } else {	            return this.value == tok2.value;	        }	    }	    return false;	}
protected boolean isFieldSeparatorAtStart() {	    return fieldSeparatorAtStart;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public int getMaxLengthEstimate() {	    return mMaxLengthEstimate;	}
public void stop() {	    if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {	        throw new IllegalStateException("Stopwatch is not running. ");	    }	    if (this.runningState == STATE_RUNNING) {	        this.stopTime = System.nanoTime();	    }	    this.runningState = STATE_STOPPED;	}
protected String getFieldNameValueSeparator() {	    return fieldNameValueSeparator;	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
public int capacity() {	    return buffer.length;	}
public void appendToString(final StringBuffer buffer, final String toString) {	    if (toString != null) {	        final int pos1 = toString.indexOf(contentStart) + contentStart.length();	        final int pos2 = toString.lastIndexOf(contentEnd);	        if (pos1 != pos2 && pos1 >= 0 && pos2 >= 0) {	            final String data = toString.substring(pos1, pos2);	            if (fieldSeparatorAtStart) {	                removeLastFieldSeparator(buffer);	            }	            buffer.append(data);	            appendFieldSeparator(buffer);	        }	    }	}
@Override	public int compare(final Object obj1, final Object obj2) {	    return ((Comparable) obj1).compareTo(obj2);	}
private static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns) {	    if (!isAssignable(cls, toClass)) {	        return null;	    }	    if (cls.isPrimitive()) {	        if (toClass.isPrimitive()) {	            return new HashMap<TypeVariable<?>, Type>();	        }	        cls = ClassUtils.primitiveToWrapper(cls);	    }	    final HashMap<TypeVariable<?>, Type> typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>() : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);	    if (toClass.equals(cls)) {	        return typeVarAssigns;	    }	    return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale) {	    return cache.getInstance(pattern, timeZone, locale);	}
@Override	public Boolean getValue() {	    return Boolean.valueOf(this.value);	}
public synchronized int getLastAcquiresPerPeriod() {	    return lastCallsPerPeriod;	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public int getRawValue(final int holder) {	    return holder & _mask;	}
protected String getContentEnd() {	    return contentEnd;	}
public void stop() {	    if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {	        throw new IllegalStateException("Stopwatch is not running. ");	    }	    if (this.runningState == STATE_RUNNING) {	        this.stopTime = System.nanoTime();	    }	    this.runningState = STATE_STOPPED;	}
public static <T extends CharSequence> T notEmpty(final T chars) {	    return notEmpty(chars, DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE);	}
public static boolean isNumeric(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isDigit(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
protected void setFieldNameValueSeparator(String fieldNameValueSeparator) {	    if (fieldNameValueSeparator == null) {	        fieldNameValueSeparator = "";	    }	    this.fieldNameValueSeparator = fieldNameValueSeparator;	}
static Throwable checkedException(final Throwable ex) {	    if (ex != null && !(ex instanceof RuntimeException) && !(ex instanceof Error)) {	        return ex;	    } else {	        throw new IllegalArgumentException("Not a checked exception: " + ex);	    }	}
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return 0;	    }	    if (lhs == null || rhs == null) {	        throw new NullPointerException();	    }	    Class<?> lhsClazz = lhs.getClass();	    if (!lhsClazz.isInstance(rhs)) {	        throw new ClassCastException();	    }	    final CompareToBuilder compareToBuilder = new CompareToBuilder();	    reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);	    while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) {	        lhsClazz = lhsClazz.getSuperclass();	        reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);	    }	    return compareToBuilder.toComparison();	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static boolean startsWithIgnoreCase(final CharSequence str, final CharSequence prefix) {	    return startsWith(str, prefix, true);	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public Builder priority(final int prio) {	    priority = Integer.valueOf(prio);	    return this;	}
public static String mid(final String str, int pos, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0 || pos > str.length()) {	        return EMPTY;	    }	    if (pos < 0) {	        pos = 0;	    }	    if (str.length() <= pos + len) {	        return str.substring(pos);	    }	    return str.substring(pos, pos + len);	}
public String nextToken() {	    if (hasNext()) {	        return tokens[tokenPos++];	    }	    return null;	}
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) {	    if (bool == null) {	        return nullValue;	    }	    return bool.booleanValue() ? trueValue : falseValue;	}
public int capacity() {	    return buffer.length;	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public ToStringBuilder appendToString(final String toString) {	    if (toString != null) {	        style.appendToString(buffer, toString);	    }	    return this;	}
protected int getTaskCount() {	    return 1;	}
private static Date set(final Date date, final int calendarField, final int amount) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final Calendar c = Calendar.getInstance();	    c.setLenient(false);	    c.setTime(date);	    c.set(calendarField, amount);	    return c.getTime();	}
@Override	public void write(final String str, final int off, final int len) {	    StrBuilder.this.append(str, off, len);	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public int lastIndexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex >= size ? size - 1 : startIndex);	    if (matcher == null || startIndex < 0) {	        return -1;	    }	    final char[] buf = buffer;	    final int endIndex = startIndex + 1;	    for (int i = startIndex; i >= 0; i--) {	        if (matcher.isMatch(buf, i, 0, endIndex) > 0) {	            return i;	        }	    }	    return -1;	}
public static <T> void exclusiveBetween(final T start, final T end, final Comparable<T> value, final String message, final Object... values) {	    if (value.compareTo(start) <= 0 || value.compareTo(end) >= 0) {	        throw new IllegalArgumentException(String.format(message, values));	    }	}
public void increment() {	    value++;	}
protected boolean isUseIdentityHashCode() {	    return useIdentityHashCode;	}
@Override	public int hashCode() {	    return pattern.hashCode() + 13 * (timeZone.hashCode() + 13 * locale.hashCode());	}
public char getStart() {	    return this.start;	}
public static <L, R> MutablePair<L, R> of(final L left, final R right) {	    return new MutablePair<L, R>(left, right);	}
private static Date set(final Date date, final int calendarField, final int amount) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final Calendar c = Calendar.getInstance();	    c.setLenient(false);	    c.setTime(date);	    c.set(calendarField, amount);	    return c.getTime();	}
public static void handleCause(final ExecutionException ex) throws ConcurrentException {	    final ConcurrentException cex = extractCause(ex);	    if (cex != null) {	        throw cex;	    }	}
@Override	public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) {	    return buffer[pos] <= 32 ? 1 : 0;	}
public boolean contains(final CharRange range) {	    if (range == null) {	        throw new IllegalArgumentException("The Range must not be null");	    }	    if (negated) {	        if (range.negated) {	            return start >= range.start && end <= range.end;	        }	        return range.end < start || range.start > end;	    }	    if (range.negated) {	        return start == 0 && end == Character.MAX_VALUE;	    }	    return start <= range.start && end >= range.end;	}
public static int lastIndexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = INDEX_NOT_FOUND;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.lastIndexOf(str, search, str.length());	        if (tmp > ret) {	            ret = tmp;	        }	    }	    return ret;	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public static String toString(final Character ch) {	    if (ch == null) {	        return null;	    }	    return toString(ch.charValue());	}
public int capacity() {	    return buffer.length;	}
public static boolean isNotEmpty(final CharSequence cs) {	    return !StringUtils.isEmpty(cs);	}
public static String repeat(final char ch, final int repeat) {	    final char[] buf = new char[repeat];	    for (int i = repeat - 1; i >= 0; i--) {	        buf[i] = ch;	    }	    return new String(buf);	}
public static boolean containsOnly(final CharSequence cs, final String validChars) {	    if (cs == null || validChars == null) {	        return false;	    }	    return containsOnly(cs, validChars.toCharArray());	}
public String getNewLineText() {	    return newLine;	}
public static <T> Range<T> is(final T element, final Comparator<T> comparator) {	    return between(element, element, comparator);	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
public static boolean isEmpty(final CharSequence cs) {	    return cs == null || cs.length() == 0;	}
public String getNewLineText() {	    return newLine;	}
public void stop() {	    if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {	        throw new IllegalStateException("Stopwatch is not running. ");	    }	    if (this.runningState == STATE_RUNNING) {	        this.stopTime = System.nanoTime();	    }	    this.runningState = STATE_STOPPED;	}
public static String capitalize(final String str) {	    int strLen;	    if (str == null || (strLen = str.length()) == 0) {	        return str;	    }	    char firstChar = str.charAt(0);	    if (Character.isTitleCase(firstChar)) {	        return str;	    }	    return new StringBuilder(strLen).append(Character.toTitleCase(firstChar)).append(str.substring(1)).toString();	}
public StrBuilder appendFixedWidthPadRight(final int value, final int width, final char padChar) {	    return appendFixedWidthPadRight(String.valueOf(value), width, padChar);	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
public static Class<?> getRawType(final Type type, final Type assigningType) {	    if (type instanceof Class<?>) {	        return (Class<?>) type;	    }	    if (type instanceof ParameterizedType) {	        return getRawType((ParameterizedType) type);	    }	    if (type instanceof TypeVariable<?>) {	        if (assigningType == null) {	            return null;	        }	        final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration();	        if (!(genericDeclaration instanceof Class<?>)) {	            return null;	        }	        final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType, (Class<?>) genericDeclaration);	        if (typeVarAssigns == null) {	            return null;	        }	        final Type typeArgument = typeVarAssigns.get(type);	        if (typeArgument == null) {	            return null;	        }	        return getRawType(typeArgument, assigningType);	    }	    if (type instanceof GenericArrayType) {	        final Class<?> rawComponentType = getRawType(((GenericArrayType) type).getGenericComponentType(), assigningType);	        return Array.newInstance(rawComponentType, 0).getClass();	    }	    if (type instanceof WildcardType) {	        return null;	    }	    throw new IllegalArgumentException("unknown type: " + type);	}
public int toComparison() {	    return comparison;	}
public String getNewLineText() {	    return newLine;	}
public static <T> Range<T> is(final T element, final Comparator<T> comparator) {	    return between(element, element, comparator);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof MutableBoolean) {	        return value == ((MutableBoolean) obj).booleanValue();	    }	    return false;	}
protected String getNullText() {	    return nullText;	}
private static String[] splitByCharacterType(final String str, final boolean camelCase) {	    if (str == null) {	        return null;	    }	    if (str.isEmpty()) {	        return ArrayUtils.EMPTY_STRING_ARRAY;	    }	    final char[] c = str.toCharArray();	    final List<String> list = new ArrayList<String>();	    int tokenStart = 0;	    int currentType = Character.getType(c[tokenStart]);	    for (int pos = tokenStart + 1; pos < c.length; pos++) {	        final int type = Character.getType(c[pos]);	        if (type == currentType) {	            continue;	        }	        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {	            final int newTokenStart = pos - 1;	            if (newTokenStart != tokenStart) {	                list.add(new String(c, tokenStart, newTokenStart - tokenStart));	                tokenStart = newTokenStart;	            }	        } else {	            list.add(new String(c, tokenStart, pos - tokenStart));	            tokenStart = pos;	        }	        currentType = type;	    }	    list.add(new String(c, tokenStart, c.length - tokenStart));	    return list.toArray(new String[list.size()]);	}
public StrBuilder deleteFirst(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, 1);	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public String nextToken() {	    if (hasNext()) {	        return tokens[tokenPos++];	    }	    return null;	}
public static String rightPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return rightPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return str.concat(padStr);	    } else if (pads < padLen) {	        return str.concat(padStr.substring(0, pads));	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return str.concat(new String(padding));	    }	}
public StrTokenizer setDelimiterMatcher(final StrMatcher delim) {	    if (delim == null) {	        this.delimMatcher = StrMatcher.noneMatcher();	    } else {	        this.delimMatcher = delim;	    }	    return this;	}
public StrTokenizer setQuoteChar(final char quote) {	    return setQuoteMatcher(StrMatcher.charMatcher(quote));	}
public int toComparison() {	    return comparison;	}
public Writer asWriter() {	    return new StrBuilderWriter();	}
@Override	public boolean isCancelled() {	    return false;	}
public static Class<?> getClass(final String className, final boolean initialize) throws ClassNotFoundException {	    final ClassLoader contextCL = Thread.currentThread().getContextClassLoader();	    final ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL;	    return getClass(loader, className, initialize);	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public static String appendIfMissing(final String str, final CharSequence suffix, final CharSequence... suffixes) {	    return appendIfMissing(str, suffix, false, suffixes);	}
@Override	public void setValue(final Number value) {	    this.value = value.doubleValue();	}
public HashCodeBuilder append(final short[] array) {	    if (array == null) {	        iTotal = iTotal * iConstant;	    } else {	        for (final short element : array) {	            append(element);	        }	    }	    return this;	}
public static <E extends Enum<E>> EnumSet<E> processBitVector(final Class<E> enumClass, final long value) {	    checkBitVectorable(enumClass).getEnumConstants();	    return processBitVectors(enumClass, value);	}
public static String overlay(final String str, String overlay, int start, int end) {	    if (str == null) {	        return null;	    }	    if (overlay == null) {	        overlay = EMPTY;	    }	    final int len = str.length();	    if (start < 0) {	        start = 0;	    }	    if (start > len) {	        start = len;	    }	    if (end < 0) {	        end = 0;	    }	    if (end > len) {	        end = len;	    }	    if (start > end) {	        final int temp = start;	        start = end;	        end = temp;	    }	    return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString();	}
public boolean contains(final StrMatcher matcher) {	    return indexOf(matcher, 0) >= 0;	}
@Override	public boolean hasPrevious() {	    checkTokenized();	    return tokenPos > 0;	}
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) {	    final StringBuilder buffer = new StringBuilder();	    boolean lastOutputSeconds = false;	    final int sz = tokens.length;	    for (int i = 0; i < sz; i++) {	        final Token token = tokens[i];	        final Object value = token.getValue();	        final int count = token.getCount();	        if (value instanceof StringBuilder) {	            buffer.append(value.toString());	        } else {	            if (value == y) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years));	                lastOutputSeconds = false;	            } else if (value == M) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months));	                lastOutputSeconds = false;	            } else if (value == d) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days));	                lastOutputSeconds = false;	            } else if (value == H) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours));	                lastOutputSeconds = false;	            } else if (value == m) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes));	                lastOutputSeconds = false;	            } else if (value == s) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds));	                lastOutputSeconds = true;	            } else if (value == S) {	                if (lastOutputSeconds) {	                    milliseconds += 1000;	                    final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds);	                    buffer.append(str.substring(1));	                } else {	                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds));	                }	                lastOutputSeconds = false;	            }	        }	    }	    return buffer.toString();	}
static Object removeAll(final Object array, final BitSet indices) {	    final int srcLength = ArrayUtils.getLength(array);	    final int removals = indices.cardinality();	    final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals);	    int srcIndex = 0;	    int destIndex = 0;	    int count;	    int set;	    while ((set = indices.nextSetBit(srcIndex)) != -1) {	        count = set - srcIndex;	        if (count > 0) {	            System.arraycopy(array, srcIndex, result, destIndex, count);	            destIndex += count;	        }	        srcIndex = indices.nextClearBit(set);	    }	    count = srcLength - srcIndex;	    if (count > 0) {	        System.arraycopy(array, srcIndex, result, destIndex, count);	    }	    return result;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof MutableByte) {	        return value == ((MutableByte) obj).byteValue();	    }	    return false;	}
public boolean isEmpty() {	    return size == 0;	}
public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {	    if (str == null || searchStr == null) {	        return INDEX_NOT_FOUND;	    }	    if (startPos > str.length() - searchStr.length()) {	        startPos = str.length() - searchStr.length();	    }	    if (startPos < 0) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return startPos;	    }	    for (int i = startPos; i >= 0; i--) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static <T extends CharSequence> T notEmpty(final T chars) {	    return notEmpty(chars, DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE);	}
public static short[] removeElement(final short[] array, final short element) {	    final int index = indexOf(array, element);	    if (index == INDEX_NOT_FOUND) {	        return clone(array);	    }	    return remove(array, index);	}
public String getNullText() {	    return nullText;	}
@Override	public long longValue() {	    return value;	}
public HashCodeBuilder append(final short[] array) {	    if (array == null) {	        iTotal = iTotal * iConstant;	    } else {	        for (final short element : array) {	            append(element);	        }	    }	    return this;	}
public static float min(final float a, final float b) {	    if (Float.isNaN(a)) {	        return b;	    } else if (Float.isNaN(b)) {	        return a;	    } else {	        return Math.min(a, b);	    }	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
protected boolean isUseIdentityHashCode() {	    return useIdentityHashCode;	}
@Override	public T call() throws Exception {	    try {	        return initialize();	    } finally {	        if (execFinally != null) {	            execFinally.shutdown();	        }	    }	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
@Override	public Integer build() {	    return Integer.valueOf(toHashCode());	}
public int elementCompareTo(final T element) {	    if (element == null) {	        throw new NullPointerException("Element is null");	    }	    if (isAfter(element)) {	        return -1;	    } else if (isBefore(element)) {	        return 1;	    } else {	        return 0;	    }	}
static void register(final Object value) {	    synchronized (HashCodeBuilder.class) {	        if (getRegistry() == null) {	            REGISTRY.set(new HashSet<IDKey>());	        }	    }	    getRegistry().add(new IDKey(value));	}
public StrBuilder ensureCapacity(final int capacity) {	    if (capacity > buffer.length) {	        final char[] old = buffer;	        buffer = new char[capacity * 2];	        System.arraycopy(old, 0, buffer, 0, size);	    }	    return this;	}
public String getNullText() {	    return nullText;	}
public int setValue(final int holder, final int value) {	    return (holder & ~_mask) | ((value << _shift_count) & _mask);	}
public static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    final int beSrcPos = src.length - 1 - srcPos;	    final int srcLen = Math.min(4, beSrcPos + 1);	    final boolean[] paddedSrc = new boolean[4];	    System.arraycopy(src, beSrcPos + 1 - srcLen, paddedSrc, 4 - srcLen, srcLen);	    src = paddedSrc;	    srcPos = 0;	    if (src[srcPos]) {	        if (src.length > srcPos + 1 && src[srcPos + 1]) {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 1 && src[srcPos + 1]) {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
public static String random(final int count, final char... chars) {	    if (chars == null) {	        return random(count, 0, 0, false, false, null, RANDOM);	    }	    return random(count, 0, chars.length, false, false, chars, RANDOM);	}
public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {	    if (str == null || searchStr == null) {	        return INDEX_NOT_FOUND;	    }	    if (startPos > str.length() - searchStr.length()) {	        startPos = str.length() - searchStr.length();	    }	    if (startPos < 0) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return startPos;	    }	    for (int i = startPos; i >= 0; i--) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public int toHashCode() {	    return iTotal;	}
public static boolean isAsciiAlphaLower(final char ch) {	    return ch >= 'a' && ch <= 'z';	}
protected String getSummaryObjectEndText() {	    return summaryObjectEndText;	}
public static String chop(final String str) {	    if (str == null) {	        return null;	    }	    final int strLen = str.length();	    if (strLen < 2) {	        return EMPTY;	    }	    final int lastIdx = strLen - 1;	    final String ret = str.substring(0, lastIdx);	    final char last = str.charAt(lastIdx);	    if (last == CharUtils.LF && ret.charAt(lastIdx - 1) == CharUtils.CR) {	        return ret.substring(0, lastIdx - 1);	    }	    return ret;	}
public StrBuilder reverse() {	    if (size == 0) {	        return this;	    }	    final int half = size / 2;	    final char[] buf = buffer;	    for (int leftIdx = 0, rightIdx = size - 1; leftIdx < half; leftIdx++, rightIdx--) {	        final char swap = buf[leftIdx];	        buf[leftIdx] = buf[rightIdx];	        buf[rightIdx] = swap;	    }	    return this;	}
public static <T extends CharSequence> T defaultIfEmpty(final T str, final T defaultStr) {	    return StringUtils.isEmpty(str) ? defaultStr : str;	}
public String getNullText() {	    return nullText;	}
public static StrTokenizer getTSVInstance(final char[] input) {	    final StrTokenizer tok = getTSVClone();	    tok.reset(input);	    return tok;	}
public static boolean containsNone(final CharSequence cs, final String invalidChars) {	    if (cs == null || invalidChars == null) {	        return true;	    }	    return containsNone(cs, invalidChars.toCharArray());	}
public void subtract(final Number operand) {	    this.value -= operand.longValue();	}
public int size() {	    return size;	}
public static String[] stripAll(final String[] strs, final String stripChars) {	    int strsLen;	    if (strs == null || (strsLen = strs.length) == 0) {	        return strs;	    }	    final String[] newArr = new String[strsLen];	    for (int i = 0; i < strsLen; i++) {	        newArr[i] = strip(strs[i], stripChars);	    }	    return newArr;	}
public int size() {	    return size;	}
public static String random(final int count, final char... chars) {	    if (chars == null) {	        return random(count, 0, 0, false, false, null, RANDOM);	    }	    return random(count, 0, chars.length, false, false, chars, RANDOM);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) {	    if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {	        return text;	    }	    if (timeToLive < 0) {	        throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another");	    }	    final int searchLength = searchList.length;	    final int replacementLength = replacementList.length;	    if (searchLength != replacementLength) {	        throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength);	    }	    final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];	    int textIndex = -1;	    int replaceIndex = -1;	    int tempIndex = -1;	    for (int i = 0; i < searchLength; i++) {	        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {	            continue;	        }	        tempIndex = text.indexOf(searchList[i]);	        if (tempIndex == -1) {	            noMoreMatchesForReplIndex[i] = true;	        } else {	            if (textIndex == -1 || tempIndex < textIndex) {	                textIndex = tempIndex;	                replaceIndex = i;	            }	        }	    }	    if (textIndex == -1) {	        return text;	    }	    int start = 0;	    int increase = 0;	    for (int i = 0; i < searchList.length; i++) {	        if (searchList[i] == null || replacementList[i] == null) {	            continue;	        }	        final int greater = replacementList[i].length() - searchList[i].length();	        if (greater > 0) {	            increase += 3 * greater;	        }	    }	    increase = Math.min(increase, text.length() / 5);	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (textIndex != -1) {	        for (int i = start; i < textIndex; i++) {	            buf.append(text.charAt(i));	        }	        buf.append(replacementList[replaceIndex]);	        start = textIndex + searchList[replaceIndex].length();	        textIndex = -1;	        replaceIndex = -1;	        tempIndex = -1;	        for (int i = 0; i < searchLength; i++) {	            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {	                continue;	            }	            tempIndex = text.indexOf(searchList[i], start);	            if (tempIndex == -1) {	                noMoreMatchesForReplIndex[i] = true;	            } else {	                if (textIndex == -1 || tempIndex < textIndex) {	                    textIndex = tempIndex;	                    replaceIndex = i;	                }	            }	        }	    }	    final int textLength = text.length();	    for (int i = start; i < textLength; i++) {	        buf.append(text.charAt(i));	    }	    final String result = buf.toString();	    if (!repeat) {	        return result;	    }	    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public int getNumerator() {	    return numerator;	}
@Override	public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) {	    return formatter.format(obj, toAppendTo, pos);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    buffer.append(arrayStart);	    for (int i = 0; i < array.length; i++) {	        if (i > 0) {	            buffer.append(arraySeparator);	        }	        appendDetail(buffer, fieldName, array[i]);	    }	    buffer.append(arrayEnd);	}
private static Date set(final Date date, final int calendarField, final int amount) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final Calendar c = Calendar.getInstance();	    c.setLenient(false);	    c.setTime(date);	    c.set(calendarField, amount);	    return c.getTime();	}
@Override	public boolean equals(final Object obj) {	    if (obj == this) {	        return true;	    } else if (obj == null || obj.getClass() != getClass()) {	        return false;	    } else {	        @SuppressWarnings("unchecked")	        final Range<T> range = (Range<T>) obj;	        return minimum.equals(range.minimum) && maximum.equals(range.maximum);	    }	}
protected String getArraySeparator() {	    return arraySeparator;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public int toComparison() {	    return comparison;	}
private static boolean isAssignable(final Type type, final TypeVariable<?> toTypeVariable, final Map<TypeVariable<?>, Type> typeVarAssigns) {	    if (type == null) {	        return true;	    }	    if (toTypeVariable == null) {	        return false;	    }	    if (toTypeVariable.equals(type)) {	        return true;	    }	    if (type instanceof TypeVariable<?>) {	        final Type[] bounds = getImplicitBounds((TypeVariable<?>) type);	        for (final Type bound : bounds) {	            if (isAssignable(bound, toTypeVariable, typeVarAssigns)) {	                return true;	            }	        }	    }	    if (type instanceof Class<?> || type instanceof ParameterizedType || type instanceof GenericArrayType || type instanceof WildcardType) {	        return false;	    }	    throw new IllegalStateException("found an unhandled type: " + type);	}
protected String getArrayStart() {	    return arrayStart;	}
@Override	public int length() {	    return size;	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static boolean isAsciiAlphaUpper(final char ch) {	    return ch >= 'A' && ch <= 'Z';	}
@Override	public void mark(final int readAheadLimit) {	    mark = pos;	}
public String getNullText() {	    return nullText;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
public static boolean[] removeElements(final boolean[] array, final boolean... values) {	    if (isEmpty(array) || isEmpty(values)) {	        return clone(array);	    }	    final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2);	    for (final boolean v : values) {	        final Boolean boxed = Boolean.valueOf(v);	        final MutableInt count = occurrences.get(boxed);	        if (count == null) {	            occurrences.put(boxed, new MutableInt(1));	        } else {	            count.increment();	        }	    }	    final BitSet toRemove = new BitSet();	    for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) {	        final Boolean v = e.getKey();	        int found = 0;	        for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {	            found = indexOf(array, v.booleanValue(), found);	            if (found < 0) {	                break;	            }	            toRemove.set(found++);	        }	    }	    return (boolean[]) removeAll(array, toRemove);	}
public static <T> void exclusiveBetween(final T start, final T end, final Comparable<T> value, final String message, final Object... values) {	    if (value.compareTo(start) <= 0 || value.compareTo(end) >= 0) {	        throw new IllegalArgumentException(String.format(message, values));	    }	}
public static String trim(final String str) {	    return str == null ? null : str.trim();	}
public int set(final int holder) {	    return holder | _mask;	}
public long getSplitNanoTime() {	    if (this.splitState != STATE_SPLIT) {	        throw new IllegalStateException("Stopwatch must be split to get the split time. ");	    }	    return this.stopTime - this.startTime;	}
public static String[] splitByWholeSeparatorPreserveAllTokens(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, true);	}
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) {	    style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));	    return this;	}
@Override	public String toString() {	    if (this.getObject() == null) {	        return this.getStyle().getNullText();	    }	    Class<?> clazz = this.getObject().getClass();	    this.appendFieldsIn(clazz);	    while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {	        clazz = clazz.getSuperclass();	        this.appendFieldsIn(clazz);	    }	    return super.toString();	}
public static boolean isSameDay(final Calendar cal1, final Calendar cal2) {	    if (cal1 == null || cal2 == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    return (cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR));	}
public String getContent() {	    if (chars == null) {	        return null;	    }	    return new String(chars);	}
public static Map<TypeVariable<?>, Type> determineTypeArguments(final Class<?> cls, final ParameterizedType superType) {	    final Class<?> superClass = getRawType(superType);	    if (!isAssignable(cls, superClass)) {	        return null;	    }	    if (cls.equals(superClass)) {	        return getTypeArguments(superType, superClass, null);	    }	    final Type midType = getClosestParentType(cls, superClass);	    if (midType instanceof Class<?>) {	        return determineTypeArguments((Class<?>) midType, superType);	    }	    final ParameterizedType midParameterizedType = (ParameterizedType) midType;	    final Class<?> midClass = getRawType(midParameterizedType);	    final Map<TypeVariable<?>, Type> typeVarAssigns = determineTypeArguments(midClass, superType);	    mapTypeVariablesToArguments(cls, midParameterizedType, typeVarAssigns);	    return typeVarAssigns;	}
public static String formatDurationHMS(final long durationMillis) {	    return formatDuration(durationMillis, "H:mm:ss.SSS");	}
public static String prependIfMissing(final String str, final CharSequence prefix, final CharSequence... prefixes) {	    return prependIfMissing(str, prefix, false, prefixes);	}
public static CharRange is(final char ch) {	    return new CharRange(ch, ch, false);	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
protected void setFieldSeparator(String fieldSeparator) {	    if (fieldSeparator == null) {	        fieldSeparator = "";	    }	    this.fieldSeparator = fieldSeparator;	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public static String[] splitByWholeSeparatorPreserveAllTokens(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, true);	}
public static <T extends CharSequence> T notEmpty(final T chars) {	    return notEmpty(chars, DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE);	}
public Builder namingPattern(final String pattern) {	    if (pattern == null) {	        throw new NullPointerException("Naming pattern must not be null!");	    }	    namingPattern = pattern;	    return this;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static String trim(final String str) {	    return str == null ? null : str.trim();	}
public static void reverse(final boolean[] array) {	    if (array == null) {	        return;	    }	    int i = 0;	    int j = array.length - 1;	    boolean tmp;	    while (j > i) {	        tmp = array[j];	        array[j] = array[i];	        array[i] = tmp;	        j--;	        i++;	    }	}
protected String parseToken(final String pattern, final int[] indexRef) {	    final StringBuilder buf = new StringBuilder();	    int i = indexRef[0];	    final int length = pattern.length();	    char c = pattern.charAt(i);	    if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {	        buf.append(c);	        while (i + 1 < length) {	            final char peek = pattern.charAt(i + 1);	            if (peek == c) {	                buf.append(c);	                i++;	            } else {	                break;	            }	        }	    } else {	        buf.append('\'');	        boolean inLiteral = false;	        for (; i < length; i++) {	            c = pattern.charAt(i);	            if (c == '\'') {	                if (i + 1 < length && pattern.charAt(i + 1) == '\'') {	                    i++;	                    buf.append(c);	                } else {	                    inLiteral = !inLiteral;	                }	            } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {	                i--;	                break;	            } else {	                buf.append(c);	            }	        }	    }	    indexRef[0] = i;	    return buf.toString();	}
public static StrTokenizer getCSVInstance(final char[] input) {	    final StrTokenizer tok = getCSVClone();	    tok.reset(input);	    return tok;	}
public char getEnd() {	    return this.end;	}
public static Class<?>[] toClass(final Object... array) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return ArrayUtils.EMPTY_CLASS_ARRAY;	    }	    final Class<?>[] classes = new Class[array.length];	    for (int i = 0; i < array.length; i++) {	        classes[i] = array[i] == null ? null : array[i].getClass();	    }	    return classes;	}
protected String getSummaryObjectEndText() {	    return summaryObjectEndText;	}
public StrTokenizer reset(final char[] input) {	    reset();	    this.chars = ArrayUtils.clone(input);	    return this;	}
@Override	public int length() {	    return size;	}
public static int lastIndexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = INDEX_NOT_FOUND;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.lastIndexOf(str, search, str.length());	        if (tmp > ret) {	            ret = tmp;	        }	    }	    return ret;	}
public static boolean containsAny(final CharSequence cs, final CharSequence searchChars) {	    if (searchChars == null) {	        return false;	    }	    return containsAny(cs, CharSequenceUtils.toCharArray(searchChars));	}
@Override	public int compare(final Object obj1, final Object obj2) {	    return ((Comparable) obj1).compareTo(obj2);	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public String getNullText() {	    return nullText;	}
@Override	public void mark(final int readAheadLimit) {	    mark = pos;	}
@Override	public int compareTo(final Fraction other) {	    if (this == other) {	        return 0;	    }	    if (numerator == other.numerator && denominator == other.denominator) {	        return 0;	    }	    final long first = (long) numerator * (long) other.denominator;	    final long second = (long) other.numerator * (long) denominator;	    if (first == second) {	        return 0;	    } else if (first < second) {	        return -1;	    } else {	        return 1;	    }	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
private static boolean isAssignable(final Type type, final TypeVariable<?> toTypeVariable, final Map<TypeVariable<?>, Type> typeVarAssigns) {	    if (type == null) {	        return true;	    }	    if (toTypeVariable == null) {	        return false;	    }	    if (toTypeVariable.equals(type)) {	        return true;	    }	    if (type instanceof TypeVariable<?>) {	        final Type[] bounds = getImplicitBounds((TypeVariable<?>) type);	        for (final Type bound : bounds) {	            if (isAssignable(bound, toTypeVariable, typeVarAssigns)) {	                return true;	            }	        }	    }	    if (type instanceof Class<?> || type instanceof ParameterizedType || type instanceof GenericArrayType || type instanceof WildcardType) {	        return false;	    }	    throw new IllegalStateException("found an unhandled type: " + type);	}
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) {	    if (str == null) {	        if (trueString == null) {	            return Boolean.TRUE;	        }	        if (falseString == null) {	            return Boolean.FALSE;	        }	        if (nullString == null) {	            return null;	        }	    } else if (str.equals(trueString)) {	        return Boolean.TRUE;	    } else if (str.equals(falseString)) {	        return Boolean.FALSE;	    } else if (str.equals(nullString)) {	        return null;	    }	    throw new IllegalArgumentException("The String did not match any specified value");	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public static String removeEndIgnoreCase(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (endsWithIgnoreCase(str, remove)) {	        return str.substring(0, str.length() - remove.length());	    }	    return str;	}
@Override	public int length() {	    return size;	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
protected void setUseClassName(final boolean useClassName) {	    this.useClassName = useClassName;	}
public static double[] addAll(final double[] array1, final double... array2) {	    if (array1 == null) {	        return clone(array2);	    } else if (array2 == null) {	        return clone(array1);	    }	    final double[] joinedArray = new double[array1.length + array2.length];	    System.arraycopy(array1, 0, joinedArray, 0, array1.length);	    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);	    return joinedArray;	}
public static <T> Constructor<T> getMatchingAccessibleConstructor(final Class<T> cls, final Class<?>... parameterTypes) {	    try {	        final Constructor<T> ctor = cls.getConstructor(parameterTypes);	        MemberUtils.setAccessibleWorkaround(ctor);	        return ctor;	    } catch (final NoSuchMethodException e) {	    }	    Constructor<T> result = null;	    final Constructor<?>[] ctors = cls.getConstructors();	    for (Constructor<?> ctor : ctors) {	        if (ClassUtils.isAssignable(parameterTypes, ctor.getParameterTypes(), true)) {	            ctor = getAccessibleConstructor(ctor);	            if (ctor != null) {	                MemberUtils.setAccessibleWorkaround(ctor);	                if (result == null || MemberUtils.compareParameterTypes(ctor.getParameterTypes(), result.getParameterTypes(), parameterTypes) < 0) {	                    @SuppressWarnings("unchecked")	                    final Constructor<T> constructor = (Constructor<T>) ctor;	                    result = constructor;	                }	            }	        }	    }	    return result;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static float min(final float a, final float b) {	    if (Float.isNaN(a)) {	        return b;	    } else if (Float.isNaN(b)) {	        return a;	    } else {	        return Math.min(a, b);	    }	}
protected String getFieldSeparator() {	    return fieldSeparator;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts) {	    if ((src.length == 0 && srcPos == 0) || 0 == nInts) {	        return dstInit;	    }	    if ((nInts - 1) * 32 + dstPos >= 64) {	        throw new IllegalArgumentException("(nInts-1)*32+dstPos is greather or equal to than 64");	    }	    long out = dstInit;	    int shift = 0;	    for (int i = 0; i < nInts; i++) {	        shift = i * 32 + dstPos;	        final long bits = ((0xffffffffL & src[i + srcPos]) << shift);	        final long mask = 0xffffffffL << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
public boolean contains(final CharRange range) {	    if (range == null) {	        throw new IllegalArgumentException("The Range must not be null");	    }	    if (negated) {	        if (range.negated) {	            return start >= range.start && end <= range.end;	        }	        return range.end < start || range.start > end;	    }	    if (range.negated) {	        return start == 0 && end == Character.MAX_VALUE;	    }	    return start <= range.start && end >= range.end;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
public static Fraction getReducedFraction(int numerator, int denominator) {	    if (denominator == 0) {	        throw new ArithmeticException("The denominator must not be zero");	    }	    if (numerator == 0) {	        return ZERO;	    }	    if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) {	        numerator /= 2;	        denominator /= 2;	    }	    if (denominator < 0) {	        if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {	            throw new ArithmeticException("overflow: can't negate");	        }	        numerator = -numerator;	        denominator = -denominator;	    }	    final int gcd = greatestCommonDivisor(numerator, denominator);	    numerator /= gcd;	    denominator /= gcd;	    return new Fraction(numerator, denominator);	}
protected boolean isFieldSeparatorAtStart() {	    return fieldSeparatorAtStart;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static boolean isAscii(final char ch) {	    return ch < 128;	}
public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale) {	    return cache.getInstance(pattern, timeZone, locale);	}
@Override	public int compareTo(final MutableFloat other) {	    final float anotherVal = other.value;	    return Float.compare(value, anotherVal);	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public String getNullText() {	    return nullText;	}
public boolean isEmpty() {	    return size == 0;	}
public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale) {	    return cache.getTimeInstance(style, timeZone, locale);	}
public StrBuilder setLength(final int length) {	    if (length < 0) {	        throw new StringIndexOutOfBoundsException(length);	    }	    if (length < size) {	        size = length;	    } else if (length > size) {	        ensureCapacity(length);	        final int oldEnd = size;	        final int newEnd = length;	        size = length;	        for (int i = oldEnd; i < newEnd; i++) {	            buffer[i] = '\0';	        }	    }	    return this;	}
public static <L, R> Pair<L, R> of(final L left, final R right) {	    return new ImmutablePair<L, R>(left, right);	}
@Override	public String toString() {	    return "FastDateParser[" + pattern + "," + locale + "," + timeZone.getID() + "]";	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static boolean isAlpha(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static char intToHexDigit(final int nibble) {	    final char c = Character.forDigit(nibble, 16);	    if (c == Character.MIN_VALUE) {	        throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble);	    }	    return c;	}
protected String getSummaryObjectStartText() {	    return summaryObjectStartText;	}
@Override	public Calendar next() {	    if (spot.equals(endFinal)) {	        throw new NoSuchElementException();	    }	    spot.add(Calendar.DATE, 1);	    return (Calendar) spot.clone();	}
@Override	public Integer build() {	    return Integer.valueOf(toHashCode());	}
public static int hexDigitMsb0ToInt(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return 0x0;	        case '1':	            return 0x8;	        case '2':	            return 0x4;	        case '3':	            return 0xC;	        case '4':	            return 0x2;	        case '5':	            return 0xA;	        case '6':	            return 0x6;	        case '7':	            return 0xE;	        case '8':	            return 0x1;	        case '9':	            return 0x9;	        case 'a':	        case 'A':	            return 0x5;	        case 'b':	        case 'B':	            return 0xD;	        case 'c':	        case 'C':	            return 0x3;	        case 'd':	        case 'D':	            return 0xB;	        case 'e':	        case 'E':	            return 0x7;	        case 'f':	        case 'F':	            return 0xF;	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public String getNullText() {	    return nullText;	}
public int size() {	    return size;	}
public boolean isEmpty() {	    return size == 0;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static String stripToEmpty(final String str) {	    return str == null ? EMPTY : strip(str, null);	}
public static String upperCase(final String str, final Locale locale) {	    if (str == null) {	        return null;	    }	    return str.toUpperCase(locale);	}
public static Object invokeStaticMethod(final Class<?> cls, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {	    if (parameterTypes == null) {	        parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;	    }	    if (args == null) {	        args = ArrayUtils.EMPTY_OBJECT_ARRAY;	    }	    final Method method = getMatchingAccessibleMethod(cls, methodName, parameterTypes);	    if (method == null) {	        throw new NoSuchMethodException("No such accessible method: " + methodName + "() on class: " + cls.getName());	    }	    return method.invoke(null, args);	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    if (input.charAt(index) == '\\' && index < (input.length() - 1) && Character.isDigit(input.charAt(index + 1))) {	        final int start = index + 1;	        int end = index + 2;	        while (end < input.length() && Character.isDigit(input.charAt(end))) {	            end++;	            if (Integer.parseInt(input.subSequence(start, end).toString(), 10) > OCTAL_MAX) {	                end--;	                break;	            }	        }	        out.write(Integer.parseInt(input.subSequence(start, end).toString(), 8));	        return 1 + end - start;	    }	    return 0;	}
@Override	public boolean markSupported() {	    return true;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof MutableShort) {	        return value == ((MutableShort) obj).shortValue();	    }	    return false;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public int capacity() {	    return buffer.length;	}
protected boolean isFieldSeparatorAtEnd() {	    return fieldSeparatorAtEnd;	}
public static String[][] APOS_UNESCAPE() {	    return APOS_UNESCAPE.clone();	}
protected boolean isArrayContentDetail() {	    return arrayContentDetail;	}
public String getNullText() {	    return nullText;	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) {	    final Token[] tokens = lexx(format);	    final Calendar start = Calendar.getInstance(timezone);	    start.setTime(new Date(startMillis));	    final Calendar end = Calendar.getInstance(timezone);	    end.setTime(new Date(endMillis));	    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);	    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);	    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);	    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);	    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);	    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);	    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);	    while (milliseconds < 0) {	        milliseconds += 1000;	        seconds -= 1;	    }	    while (seconds < 0) {	        seconds += 60;	        minutes -= 1;	    }	    while (minutes < 0) {	        minutes += 60;	        hours -= 1;	    }	    while (hours < 0) {	        hours += 24;	        days -= 1;	    }	    if (Token.containsTokenWithValue(tokens, M)) {	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	        while (months < 0) {	            months += 12;	            years -= 1;	        }	        if (!Token.containsTokenWithValue(tokens, y) && years != 0) {	            while (years != 0) {	                months += 12 * years;	                years = 0;	            }	        }	    } else {	        if (!Token.containsTokenWithValue(tokens, y)) {	            int target = end.get(Calendar.YEAR);	            if (months < 0) {	                target -= 1;	            }	            while (start.get(Calendar.YEAR) != target) {	                days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);	                if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) {	                    days += 1;	                }	                start.add(Calendar.YEAR, 1);	                days += start.get(Calendar.DAY_OF_YEAR);	            }	            years = 0;	        }	        while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            start.add(Calendar.MONTH, 1);	        }	        months = 0;	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	    }	    if (!Token.containsTokenWithValue(tokens, d)) {	        hours += 24 * days;	        days = 0;	    }	    if (!Token.containsTokenWithValue(tokens, H)) {	        minutes += 60 * hours;	        hours = 0;	    }	    if (!Token.containsTokenWithValue(tokens, m)) {	        seconds += 60 * minutes;	        minutes = 0;	    }	    if (!Token.containsTokenWithValue(tokens, s)) {	        milliseconds += 1000 * seconds;	        seconds = 0;	    }	    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
public void add(final Number operand) {	    this.value += operand.doubleValue();	}
public static short[] removeElement(final short[] array, final short element) {	    final int index = indexOf(array, element);	    if (index == INDEX_NOT_FOUND) {	        return clone(array);	    }	    return remove(array, index);	}
public static Class<?> wrapperToPrimitive(final Class<?> cls) {	    return wrapperPrimitiveMap.get(cls);	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
static void register(final Object lhs, final Object rhs) {	    synchronized (EqualsBuilder.class) {	        if (getRegistry() == null) {	            REGISTRY.set(new HashSet<Pair<IDKey, IDKey>>());	        }	    }	    final Set<Pair<IDKey, IDKey>> registry = getRegistry();	    final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);	    registry.add(pair);	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public boolean isEmpty() {	    return size == 0;	}
public static String stripStart(final String str, final String stripChars) {	    int strLen;	    if (str == null || (strLen = str.length()) == 0) {	        return str;	    }	    int start = 0;	    if (stripChars == null) {	        while (start != strLen && Character.isWhitespace(str.charAt(start))) {	            start++;	        }	    } else if (stripChars.isEmpty()) {	        return str;	    } else {	        while (start != strLen && stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND) {	            start++;	        }	    }	    return str.substring(start);	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
protected boolean isUseClassName() {	    return useClassName;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public static short[] removeElement(final short[] array, final short element) {	    final int index = indexOf(array, element);	    if (index == INDEX_NOT_FOUND) {	        return clone(array);	    }	    return remove(array, index);	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public static boolean isEmpty(final boolean[] array) {	    return array == null || array.length == 0;	}
protected String getSummaryObjectEndText() {	    return summaryObjectEndText;	}
private static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal, final boolean lastIndex) {	    if (str == null || searchStr == null || ordinal <= 0) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return lastIndex ? str.length() : 0;	    }	    int found = 0;	    int index = lastIndex ? str.length() : INDEX_NOT_FOUND;	    do {	        if (lastIndex) {	            index = CharSequenceUtils.lastIndexOf(str, searchStr, index - 1);	        } else {	            index = CharSequenceUtils.indexOf(str, searchStr, index + 1);	        }	        if (index < 0) {	            return index;	        }	        found++;	    } while (found < ordinal);	    return index;	}
public static String right(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(str.length() - len);	}
public int capacity() {	    return buffer.length;	}
protected boolean isUseShortClassName() {	    return useShortClassName;	}
public static Boolean or(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
static void register(final Object value) {	    if (value != null) {	        final Map<Object, Object> m = getRegistry();	        if (m == null) {	            REGISTRY.set(new WeakHashMap<Object, Object>());	        }	        getRegistry().put(value, null);	    }	}
@Override	public Date parse(final String source, final ParsePosition pos) {	    final int offset = pos.getIndex();	    final Matcher matcher = parsePattern.matcher(source.substring(offset));	    if (!matcher.lookingAt()) {	        return null;	    }	    final Calendar cal = Calendar.getInstance(timeZone, locale);	    cal.clear();	    for (int i = 0; i < strategies.length; ) {	        final Strategy strategy = strategies[i++];	        strategy.setCalendar(this, cal, matcher.group(i));	    }	    pos.setIndex(offset + matcher.end());	    return cal.getTime();	}
public StrBuilder setNewLineText(final String newLine) {	    this.newLine = newLine;	    return this;	}
public static boolean isNotEmpty(final boolean[] array) {	    return (array != null && array.length != 0);	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
public static String uncapitalize(final String str) {	    int strLen;	    if (str == null || (strLen = str.length()) == 0) {	        return str;	    }	    char firstChar = str.charAt(0);	    if (Character.isLowerCase(firstChar)) {	        return str;	    }	    return new StringBuilder(strLen).append(Character.toLowerCase(firstChar)).append(str.substring(1)).toString();	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) {	    if (it != null) {	        separator = ObjectUtils.toString(separator);	        while (it.hasNext()) {	            append(it.next());	            if (it.hasNext()) {	                append(separator);	            }	        }	    }	    return this;	}
public int getMaxLengthEstimate() {	    return mMaxLengthEstimate;	}
public int capacity() {	    return buffer.length;	}
public static boolean equals(final Object object1, final Object object2) {	    if (object1 == object2) {	        return true;	    }	    if (object1 == null || object2 == null) {	        return false;	    }	    return object1.equals(object2);	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
public static String right(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(str.length() - len);	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
protected String getSummaryObjectEndText() {	    return summaryObjectEndText;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public Fraction subtract(final Fraction fraction) {	    return addSub(fraction, false);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static boolean containsNone(final CharSequence cs, final String invalidChars) {	    if (cs == null || invalidChars == null) {	        return true;	    }	    return containsNone(cs, invalidChars.toCharArray());	}
@Override	public String getFormattedExceptionMessage(final String baseMessage) {	    final StringBuilder buffer = new StringBuilder(256);	    if (baseMessage != null) {	        buffer.append(baseMessage);	    }	    if (contextValues.size() > 0) {	        if (buffer.length() > 0) {	            buffer.append('\n');	        }	        buffer.append("Exception Context:\n");	        int i = 0;	        for (final Pair<String, Object> pair : contextValues) {	            buffer.append("\t[");	            buffer.append(++i);	            buffer.append(':');	            buffer.append(pair.getKey());	            buffer.append("=");	            final Object value = pair.getValue();	            if (value == null) {	                buffer.append("null");	            } else {	                String valueStr;	                try {	                    valueStr = value.toString();	                } catch (final Exception e) {	                    valueStr = "Exception thrown on toString(): " + ExceptionUtils.getStackTrace(e);	                }	                buffer.append(valueStr);	            }	            buffer.append("]\n");	        }	        buffer.append("---------------------------------");	    }	    return buffer.toString();	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
@Override	public int length() {	    return size;	}
public static boolean equals(final Annotation a1, final Annotation a2) {	    if (a1 == a2) {	        return true;	    }	    if (a1 == null || a2 == null) {	        return false;	    }	    final Class<? extends Annotation> type = a1.annotationType();	    final Class<? extends Annotation> type2 = a2.annotationType();	    Validate.notNull(type, "Annotation %s with null annotationType()", a1);	    Validate.notNull(type2, "Annotation %s with null annotationType()", a2);	    if (!type.equals(type2)) {	        return false;	    }	    try {	        for (final Method m : type.getDeclaredMethods()) {	            if (m.getParameterTypes().length == 0 && isValidAnnotationMemberType(m.getReturnType())) {	                final Object v1 = m.invoke(a1);	                final Object v2 = m.invoke(a2);	                if (!memberEquals(m.getReturnType(), v1, v2)) {	                    return false;	                }	            }	        }	    } catch (final IllegalAccessException ex) {	        return false;	    } catch (final InvocationTargetException ex) {	        return false;	    }	    return true;	}
@Override	public CharSequence subSequence(final int startIndex, final int endIndex) {	    if (startIndex < 0) {	        throw new StringIndexOutOfBoundsException(startIndex);	    }	    if (endIndex > size) {	        throw new StringIndexOutOfBoundsException(endIndex);	    }	    if (startIndex > endIndex) {	        throw new StringIndexOutOfBoundsException(endIndex - startIndex);	    }	    return substring(startIndex, endIndex);	}
public boolean isEmpty() {	    return size == 0;	}
public static boolean isAscii(final char ch) {	    return ch < 128;	}
public static String appendIfMissing(final String str, final CharSequence suffix, final CharSequence... suffixes) {	    return appendIfMissing(str, suffix, false, suffixes);	}
public static String formatDurationISO(final long durationMillis) {	    return formatDuration(durationMillis, ISO_EXTENDED_FORMAT_PATTERN, false);	}
public StrBuilder setLength(final int length) {	    if (length < 0) {	        throw new StringIndexOutOfBoundsException(length);	    }	    if (length < size) {	        size = length;	    } else if (length > size) {	        ensureCapacity(length);	        final int oldEnd = size;	        final int newEnd = length;	        size = length;	        for (int i = oldEnd; i < newEnd; i++) {	            buffer[i] = '\0';	        }	    }	    return this;	}
public static boolean isAllUpperCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isUpperCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static void reverse(final boolean[] array) {	    if (array == null) {	        return;	    }	    int i = 0;	    int j = array.length - 1;	    boolean tmp;	    while (j > i) {	        tmp = array[j];	        array[j] = array[i];	        array[i] = tmp;	        j--;	        i++;	    }	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
@Override	protected MultiBackgroundInitializerResults initialize() throws Exception {	    Map<String, BackgroundInitializer<?>> inits;	    synchronized (this) {	        inits = new HashMap<String, BackgroundInitializer<?>>(childInitializers);	    }	    final ExecutorService exec = getActiveExecutor();	    for (final BackgroundInitializer<?> bi : inits.values()) {	        if (bi.getExternalExecutor() == null) {	            bi.setExternalExecutor(exec);	        }	        bi.start();	    }	    final Map<String, Object> results = new HashMap<String, Object>();	    final Map<String, ConcurrentException> excepts = new HashMap<String, ConcurrentException>();	    for (final Map.Entry<String, BackgroundInitializer<?>> e : inits.entrySet()) {	        try {	            results.put(e.getKey(), e.getValue().get());	        } catch (final ConcurrentException cex) {	            excepts.put(e.getKey(), cex);	        }	    }	    return new MultiBackgroundInitializerResults(inits, results, excepts);	}
public static Date truncate(final Object date, final int field) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (date instanceof Date) {	        return truncate((Date) date, field);	    } else if (date instanceof Calendar) {	        return truncate((Calendar) date, field).getTime();	    } else {	        throw new ClassCastException("Could not truncate " + date);	    }	}
public static Boolean xor(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return xor(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) {	    final Token[] tokens = lexx(format);	    final Calendar start = Calendar.getInstance(timezone);	    start.setTime(new Date(startMillis));	    final Calendar end = Calendar.getInstance(timezone);	    end.setTime(new Date(endMillis));	    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);	    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);	    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);	    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);	    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);	    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);	    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);	    while (milliseconds < 0) {	        milliseconds += 1000;	        seconds -= 1;	    }	    while (seconds < 0) {	        seconds += 60;	        minutes -= 1;	    }	    while (minutes < 0) {	        minutes += 60;	        hours -= 1;	    }	    while (hours < 0) {	        hours += 24;	        days -= 1;	    }	    if (Token.containsTokenWithValue(tokens, M)) {	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	        while (months < 0) {	            months += 12;	            years -= 1;	        }	        if (!Token.containsTokenWithValue(tokens, y) && years != 0) {	            while (years != 0) {	                months += 12 * years;	                years = 0;	            }	        }	    } else {	        if (!Token.containsTokenWithValue(tokens, y)) {	            int target = end.get(Calendar.YEAR);	            if (months < 0) {	                target -= 1;	            }	            while (start.get(Calendar.YEAR) != target) {	                days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);	                if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) {	                    days += 1;	                }	                start.add(Calendar.YEAR, 1);	                days += start.get(Calendar.DAY_OF_YEAR);	            }	            years = 0;	        }	        while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            start.add(Calendar.MONTH, 1);	        }	        months = 0;	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	    }	    if (!Token.containsTokenWithValue(tokens, d)) {	        hours += 24 * days;	        days = 0;	    }	    if (!Token.containsTokenWithValue(tokens, H)) {	        minutes += 60 * hours;	        hours = 0;	    }	    if (!Token.containsTokenWithValue(tokens, m)) {	        seconds += 60 * minutes;	        minutes = 0;	    }	    if (!Token.containsTokenWithValue(tokens, s)) {	        milliseconds += 1000 * seconds;	        seconds = 0;	    }	    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
public StrSubstitutor setVariableSuffix(final String suffix) {	    if (suffix == null) {	        throw new IllegalArgumentException("Variable suffix must not be null!");	    }	    return setVariableSuffixMatcher(StrMatcher.stringMatcher(suffix));	}
public char getStart() {	    return this.start;	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static boolean containsOnly(final CharSequence cs, final String validChars) {	    if (cs == null || validChars == null) {	        return false;	    }	    return containsOnly(cs, validChars.toCharArray());	}
public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) {	    if (s == null || t == null) {	        throw new IllegalArgumentException("Strings must not be null");	    }	    if (threshold < 0) {	        throw new IllegalArgumentException("Threshold must not be negative");	    }	    int n = s.length();	    int m = t.length();	    if (n == 0) {	        return m <= threshold ? m : -1;	    } else if (m == 0) {	        return n <= threshold ? n : -1;	    }	    if (n > m) {	        final CharSequence tmp = s;	        s = t;	        t = tmp;	        n = m;	        m = t.length();	    }	    int[] p = new int[n + 1];	    int[] d = new int[n + 1];	    int[] _d;	    final int boundary = Math.min(n, threshold) + 1;	    for (int i = 0; i < boundary; i++) {	        p[i] = i;	    }	    Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);	    Arrays.fill(d, Integer.MAX_VALUE);	    for (int j = 1; j <= m; j++) {	        final char t_j = t.charAt(j - 1);	        d[0] = j;	        final int min = Math.max(1, j - threshold);	        final int max = Math.min(n, j + threshold);	        if (min > max) {	            return -1;	        }	        if (min > 1) {	            d[min - 1] = Integer.MAX_VALUE;	        }	        for (int i = min; i <= max; i++) {	            if (s.charAt(i - 1) == t_j) {	                d[i] = p[i - 1];	            } else {	                d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);	            }	        }	        _d = p;	        p = d;	        d = _d;	    }	    if (p[n] <= threshold) {	        return p[n];	    }	    return -1;	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public boolean isEmpty() {	    return size == 0;	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static Object invokeExactMethod(final Object object, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {	    if (args == null) {	        args = ArrayUtils.EMPTY_OBJECT_ARRAY;	    }	    if (parameterTypes == null) {	        parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;	    }	    final Method method = getAccessibleMethod(object.getClass(), methodName, parameterTypes);	    if (method == null) {	        throw new NoSuchMethodException("No such accessible method: " + methodName + "() on object: " + object.getClass().getName());	    }	    return method.invoke(object, args);	}
public synchronized boolean start() {	    if (!isStarted()) {	        ExecutorService tempExec;	        executor = getExternalExecutor();	        if (executor == null) {	            executor = tempExec = createExecutor();	        } else {	            tempExec = null;	        }	        future = executor.submit(createTask(tempExec));	        return true;	    }	    return false;	}
protected String getArrayStart() {	    return arrayStart;	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public Short toShort() {	    return Short.valueOf(shortValue());	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public char getStart() {	    return this.start;	}
@Override	public double doubleValue() {	    return value;	}
public static void reverse(final boolean[] array) {	    if (array == null) {	        return;	    }	    int i = 0;	    int j = array.length - 1;	    boolean tmp;	    while (j > i) {	        tmp = array[j];	        array[j] = array[i];	        array[i] = tmp;	        j--;	        i++;	    }	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
public static Double createDouble(final String str) {	    if (str == null) {	        return null;	    }	    return Double.valueOf(str);	}
public static <T extends CharSequence> T notBlank(final T chars) {	    return notBlank(chars, DEFAULT_NOT_BLANK_EX_MESSAGE);	}
public String getNullText() {	    return nullText;	}
public static boolean isAllLowerCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLowerCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
@Override	public boolean ready() {	    return pos < StrBuilder.this.size();	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
public static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts) {	    if ((src.length == 0 && srcPos == 0) || 0 == nShorts) {	        return dstInit;	    }	    if ((nShorts - 1) * 16 + dstPos >= 64) {	        throw new IllegalArgumentException("(nShorts-1)*16+dstPos is greather or equal to than 64");	    }	    long out = dstInit;	    int shift = 0;	    for (int i = 0; i < nShorts; i++) {	        shift = i * 16 + dstPos;	        final long bits = (0xffffL & src[i + srcPos]) << shift;	        final long mask = 0xffffL << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
public void decrement() {	    value--;	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    if (index != 0) {	        throw new IllegalStateException("CsvUnescaper should never reach the [1] index");	    }	    if (input.charAt(0) != CSV_QUOTE || input.charAt(input.length() - 1) != CSV_QUOTE) {	        out.write(input.toString());	        return input.length();	    }	    final String quoteless = input.subSequence(1, input.length() - 1).toString();	    if (StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS)) {	        out.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR));	    } else {	        out.write(input.toString());	    }	    return input.length();	}
public EqualsBuilder appendSuper(final boolean superEquals) {	    if (isEquals == false) {	        return this;	    }	    isEquals = superEquals;	    return this;	}
public boolean contains(final StrMatcher matcher) {	    return indexOf(matcher, 0) >= 0;	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
public static boolean isEmpty(final boolean[] array) {	    return array == null || array.length == 0;	}
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, true);	}
public static String right(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(str.length() - len);	}
protected String getSizeEndText() {	    return sizeEndText;	}
public static ConcurrentRuntimeException extractCauseUnchecked(final ExecutionException ex) {	    if (ex == null || ex.getCause() == null) {	        return null;	    }	    throwCause(ex);	    return new ConcurrentRuntimeException(ex.getMessage(), ex.getCause());	}
public static float max(final float a, final float b, final float c) {	    return Math.max(Math.max(a, b), c);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public static long getFragmentInHours(final Calendar calendar, final int fragment) {	    return getFragment(calendar, fragment, Calendar.HOUR_OF_DAY);	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
public StrBuilder appendFixedWidthPadRight(final int value, final int width, final char padChar) {	    return appendFixedWidthPadRight(String.valueOf(value), width, padChar);	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public boolean isEmpty() {	    return size == 0;	}
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) {	    return new Range<T>(fromInclusive, toInclusive, comparator);	}
public static <T extends Comparable<? super T>> int compare(final T c1, final T c2, final boolean nullGreater) {	    if (c1 == c2) {	        return 0;	    } else if (c1 == null) {	        return nullGreater ? 1 : -1;	    } else if (c2 == null) {	        return nullGreater ? -1 : 1;	    }	    return c1.compareTo(c2);	}
public static int indexOfDifference(final CharSequence... css) {	    if (css == null || css.length <= 1) {	        return INDEX_NOT_FOUND;	    }	    boolean anyStringNull = false;	    boolean allStringsNull = true;	    final int arrayLen = css.length;	    int shortestStrLen = Integer.MAX_VALUE;	    int longestStrLen = 0;	    for (int i = 0; i < arrayLen; i++) {	        if (css[i] == null) {	            anyStringNull = true;	            shortestStrLen = 0;	        } else {	            allStringsNull = false;	            shortestStrLen = Math.min(css[i].length(), shortestStrLen);	            longestStrLen = Math.max(css[i].length(), longestStrLen);	        }	    }	    if (allStringsNull || longestStrLen == 0 && !anyStringNull) {	        return INDEX_NOT_FOUND;	    }	    if (shortestStrLen == 0) {	        return 0;	    }	    int firstDiff = -1;	    for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {	        final char comparisonChar = css[0].charAt(stringPos);	        for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {	            if (css[arrayPos].charAt(stringPos) != comparisonChar) {	                firstDiff = stringPos;	                break;	            }	        }	        if (firstDiff != -1) {	            break;	        }	    }	    if (firstDiff == -1 && shortestStrLen != longestStrLen) {	        return shortestStrLen;	    }	    return firstDiff;	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) {	    if (toClass == null) {	        return false;	    }	    if (cls == null) {	        return !toClass.isPrimitive();	    }	    if (autoboxing) {	        if (cls.isPrimitive() && !toClass.isPrimitive()) {	            cls = primitiveToWrapper(cls);	            if (cls == null) {	                return false;	            }	        }	        if (toClass.isPrimitive() && !cls.isPrimitive()) {	            cls = wrapperToPrimitive(cls);	            if (cls == null) {	                return false;	            }	        }	    }	    if (cls.equals(toClass)) {	        return true;	    }	    if (cls.isPrimitive()) {	        if (toClass.isPrimitive() == false) {	            return false;	        }	        if (Integer.TYPE.equals(cls)) {	            return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Long.TYPE.equals(cls)) {	            return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Boolean.TYPE.equals(cls)) {	            return false;	        }	        if (Double.TYPE.equals(cls)) {	            return false;	        }	        if (Float.TYPE.equals(cls)) {	            return Double.TYPE.equals(toClass);	        }	        if (Character.TYPE.equals(cls)) {	            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Short.TYPE.equals(cls)) {	            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Byte.TYPE.equals(cls)) {	            return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        return false;	    }	    return toClass.isAssignableFrom(cls);	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static boolean isAscii(final char ch) {	    return ch < 128;	}
public static CharRange isIn(final char start, final char end) {	    return new CharRange(start, end, false);	}
public String getNewLineText() {	    return newLine;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
@Override	public int length() {	    return size;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public int size() {	    return size;	}
public String getNullText() {	    return nullText;	}
public static int hashCode(final Object obj) {	    return obj == null ? 0 : obj.hashCode();	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
public int capacity() {	    return buffer.length;	}
@Override	public String toString() {	    return "FastDateFormat[" + printer.getPattern() + "," + printer.getLocale() + "," + printer.getTimeZone().getID() + "]";	}
@Override	public List<Pair<String, Object>> getContextEntries() {	    return contextValues;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static <T> T initialize(final ConcurrentInitializer<T> initializer) throws ConcurrentException {	    return initializer != null ? initializer.get() : null;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static boolean containsNone(final CharSequence cs, final String invalidChars) {	    if (cs == null || invalidChars == null) {	        return true;	    }	    return containsNone(cs, invalidChars.toCharArray());	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
@Override	public T call() throws Exception {	    try {	        return initialize();	    } finally {	        if (execFinally != null) {	            execFinally.shutdown();	        }	    }	}
public static Date addSeconds(final Date date, final int amount) {	    return add(date, Calendar.SECOND, amount);	}
public StrTokenizer setTrimmerMatcher(final StrMatcher trimmer) {	    if (trimmer != null) {	        this.trimmerMatcher = trimmer;	    }	    return this;	}
public String getNullText() {	    return nullText;	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public int capacity() {	    return buffer.length;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
public static <T extends CharSequence> T defaultIfBlank(final T str, final T defaultStr) {	    return StringUtils.isBlank(str) ? defaultStr : str;	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public synchronized Future<T> getFuture() {	    if (future == null) {	        throw new IllegalStateException("start() must be called first!");	    }	    return future;	}
public boolean isEmpty() {	    return size == 0;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, 1);	}
public static String center(String str, final int size, String padStr) {	    if (str == null || size <= 0) {	        return str;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    str = leftPad(str, strLen + pads / 2, padStr);	    str = rightPad(str, size, padStr);	    return str;	}
public StrTokenizer reset(final char[] input) {	    reset();	    this.chars = ArrayUtils.clone(input);	    return this;	}
public static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {	    if (str == null || searchStr == null) {	        return INDEX_NOT_FOUND;	    }	    if (startPos < 0) {	        startPos = 0;	    }	    final int endLimit = str.length() - searchStr.length() + 1;	    if (startPos > endLimit) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return startPos;	    }	    for (int i = startPos; i < endLimit; i++) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static boolean isEmpty(final CharSequence cs) {	    return cs == null || cs.length() == 0;	}
public int size() {	    return size;	}
@Override	public String toString() {	    return StringUtils.repeat(this.value.toString(), this.count);	}
public static <T> Range<T> is(final T element, final Comparator<T> comparator) {	    return between(element, element, comparator);	}
@Override	public float floatValue() {	    return (float) numerator / (float) denominator;	}
public int size() {	    return size;	}
public char getStart() {	    return this.start;	}
protected String getContentEnd() {	    return contentEnd;	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public static Locale toLocale(final String str) {	    if (str == null) {	        return null;	    }	    if (str.contains("#")) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final int len = str.length();	    if (len < 2) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final char ch0 = str.charAt(0);	    if (ch0 == '_') {	        if (len < 3) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        final char ch1 = str.charAt(1);	        final char ch2 = str.charAt(2);	        if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        if (len == 3) {	            return new Locale("", str.substring(1, 3));	        }	        if (len < 5) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        if (str.charAt(3) != '_') {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        return new Locale("", str.substring(1, 3), str.substring(4));	    }	    final char ch1 = str.charAt(1);	    if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (len == 2) {	        return new Locale(str);	    }	    if (len < 5) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (str.charAt(2) != '_') {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final char ch3 = str.charAt(3);	    if (ch3 == '_') {	        return new Locale(str.substring(0, 2), "", str.substring(4));	    }	    final char ch4 = str.charAt(4);	    if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (len == 5) {	        return new Locale(str.substring(0, 2), str.substring(3, 5));	    }	    if (len < 7) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (str.charAt(5) != '_') {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));	}
public static boolean isNotEmpty(final boolean[] array) {	    return (array != null && array.length != 0);	}
public static char toChar(final String str, final char defaultValue) {	    if (StringUtils.isEmpty(str)) {	        return defaultValue;	    }	    return str.charAt(0);	}
public int capacity() {	    return buffer.length;	}
@Override	public ContextedException addContextValue(final String label, final Object value) {	    exceptionContext.addContextValue(label, value);	    return this;	}
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = Integer.MAX_VALUE;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.indexOf(str, search, 0);	        if (tmp == INDEX_NOT_FOUND) {	            continue;	        }	        if (tmp < ret) {	            ret = tmp;	        }	    }	    return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;	}
public String getNewLineText() {	    return newLine;	}
protected String getSizeStartText() {	    return sizeStartText;	}
protected String getSummaryObjectEndText() {	    return summaryObjectEndText;	}
@Override	public boolean isUseFieldNames() {	    return super.isUseFieldNames();	}
public static void reverse(final boolean[] array) {	    if (array == null) {	        return;	    }	    int i = 0;	    int j = array.length - 1;	    boolean tmp;	    while (j > i) {	        tmp = array[j];	        array[j] = array[i];	        array[i] = tmp;	        j--;	        i++;	    }	}
public boolean isEmpty() {	    return size == 0;	}
static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale) {	    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);	    String value = cTimeZoneDisplayCache.get(key);	    if (value == null) {	        value = tz.getDisplayName(daylight, style, locale);	        final String prior = cTimeZoneDisplayCache.putIfAbsent(key, value);	        if (prior != null) {	            value = prior;	        }	    }	    return value;	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
@Override	public String next() {	    if (hasNext()) {	        return tokens[tokenPos++];	    }	    throw new NoSuchElementException();	}
public static boolean containsOnly(final CharSequence cs, final String validChars) {	    if (cs == null || validChars == null) {	        return false;	    }	    return containsOnly(cs, validChars.toCharArray());	}
public static void handleCause(final ExecutionException ex) throws ConcurrentException {	    final ConcurrentException cex = extractCause(ex);	    if (cex != null) {	        throw cex;	    }	}
public static CharRange is(final char ch) {	    return new CharRange(ch, ch, false);	}
protected String getContentEnd() {	    return contentEnd;	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
public static long getFragmentInHours(final Calendar calendar, final int fragment) {	    return getFragment(calendar, fragment, Calendar.HOUR_OF_DAY);	}
@Override	public int length() {	    return size;	}
@Override	public float floatValue() {	    return (float) numerator / (float) denominator;	}
public static CharRange isNotIn(final char start, final char end) {	    return new CharRange(start, end, true);	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public static StrMatcher charSetMatcher(final String chars) {	    if (StringUtils.isEmpty(chars)) {	        return NONE_MATCHER;	    }	    if (chars.length() == 1) {	        return new CharMatcher(chars.charAt(0));	    }	    return new CharSetMatcher(chars.toCharArray());	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
@Override	public void close() {	}
public boolean isNaturalOrdering() {	    return comparator == ComparableComparator.INSTANCE;	}
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, true);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
protected int validateRange(final int startIndex, int endIndex) {	    if (startIndex < 0) {	        throw new StringIndexOutOfBoundsException(startIndex);	    }	    if (endIndex > size) {	        endIndex = size;	    }	    if (startIndex > endIndex) {	        throw new StringIndexOutOfBoundsException("end < start");	    }	    return endIndex;	}
public static String replaceChars(final String str, final String searchChars, String replaceChars) {	    if (isEmpty(str) || isEmpty(searchChars)) {	        return str;	    }	    if (replaceChars == null) {	        replaceChars = EMPTY;	    }	    boolean modified = false;	    final int replaceCharsLength = replaceChars.length();	    final int strLength = str.length();	    final StringBuilder buf = new StringBuilder(strLength);	    for (int i = 0; i < strLength; i++) {	        final char ch = str.charAt(i);	        final int index = searchChars.indexOf(ch);	        if (index >= 0) {	            modified = true;	            if (index < replaceCharsLength) {	                buf.append(replaceChars.charAt(index));	            }	        } else {	            buf.append(ch);	        }	    }	    if (modified) {	        return buf.toString();	    }	    return str;	}
public static Type[] getImplicitLowerBounds(final WildcardType wildcardType) {	    final Type[] bounds = wildcardType.getLowerBounds();	    return bounds.length == 0 ? new Type[] { null } : bounds;	}
public static int lastOrdinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal) {	    return ordinalIndexOf(str, searchStr, ordinal, true);	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return 0;	    }	    if (lhs == null || rhs == null) {	        throw new NullPointerException();	    }	    Class<?> lhsClazz = lhs.getClass();	    if (!lhsClazz.isInstance(rhs)) {	        throw new ClassCastException();	    }	    final CompareToBuilder compareToBuilder = new CompareToBuilder();	    reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);	    while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) {	        lhsClazz = lhsClazz.getSuperclass();	        reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);	    }	    return compareToBuilder.toComparison();	}
public static <T> T initialize(final ConcurrentInitializer<T> initializer) throws ConcurrentException {	    return initializer != null ? initializer.get() : null;	}
protected String getArraySeparator() {	    return arraySeparator;	}
public static char binaryToHexDigit(final boolean[] src, final int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    if (src.length > srcPos + 3 && src[srcPos + 3]) {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src[srcPos]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
public StrBuilder setNullText(String nullText) {	    if (nullText != null && nullText.isEmpty()) {	        nullText = null;	    }	    this.nullText = nullText;	    return this;	}
public static String center(String str, final int size, String padStr) {	    if (str == null || size <= 0) {	        return str;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    str = leftPad(str, strLen + pads / 2, padStr);	    str = rightPad(str, size, padStr);	    return str;	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static String trim(final String str) {	    return str == null ? null : str.trim();	}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    buffer.append(arrayStart);	    for (int i = 0; i < array.length; i++) {	        if (i > 0) {	            buffer.append(arraySeparator);	        }	        appendDetail(buffer, fieldName, array[i]);	    }	    buffer.append(arrayEnd);	}
@Override	public boolean markSupported() {	    return true;	}
public static Boolean[] toObject(final boolean[] array) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    final Boolean[] result = new Boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        result[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE);	    }	    return result;	}
public static String chop(final String str) {	    if (str == null) {	        return null;	    }	    final int strLen = str.length();	    if (strLen < 2) {	        return EMPTY;	    }	    final int lastIdx = strLen - 1;	    final String ret = str.substring(0, lastIdx);	    final char last = str.charAt(lastIdx);	    if (last == CharUtils.LF && ret.charAt(lastIdx - 1) == CharUtils.CR) {	        return ret.substring(0, lastIdx - 1);	    }	    return ret;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static boolean isAlphanumeric(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetterOrDigit(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public StrBuilder appendSeparator(final char separator, final int loopIndex) {	    if (loopIndex > 0) {	        append(separator);	    }	    return this;	}
@Override	public boolean ready() {	    return pos < StrBuilder.this.size();	}
@Override	public long longValue() {	    return value;	}
public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex) {	    return indexOf(throwable, type, fromIndex, true);	}
public static String abbreviate(final String str, int offset, final int maxWidth) {	    if (str == null) {	        return null;	    }	    if (maxWidth < 4) {	        throw new IllegalArgumentException("Minimum abbreviation width is 4");	    }	    if (str.length() <= maxWidth) {	        return str;	    }	    if (offset > str.length()) {	        offset = str.length();	    }	    if (str.length() - offset < maxWidth - 3) {	        offset = str.length() - (maxWidth - 3);	    }	    final String abrevMarker = "...";	    if (offset <= 4) {	        return str.substring(0, maxWidth - 3) + abrevMarker;	    }	    if (maxWidth < 7) {	        throw new IllegalArgumentException("Minimum abbreviation width with offset is 7");	    }	    if (offset + maxWidth - 3 < str.length()) {	        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);	    }	    return abrevMarker + str.substring(str.length() - (maxWidth - 3));	}
public Reader asReader() {	    return new StrBuilderReader();	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public boolean isEmpty() {	    return size == 0;	}
public static char toChar(final String str, final char defaultValue) {	    if (StringUtils.isEmpty(str)) {	        return defaultValue;	    }	    return str.charAt(0);	}
public static String removeEnd(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.endsWith(remove)) {	        return str.substring(0, str.length() - remove.length());	    }	    return str;	}
@Override	public String next() {	    if (hasNext()) {	        return tokens[tokenPos++];	    }	    throw new NoSuchElementException();	}
public static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {	    if (str == null || searchStr == null) {	        return INDEX_NOT_FOUND;	    }	    if (startPos < 0) {	        startPos = 0;	    }	    final int endLimit = str.length() - searchStr.length() + 1;	    if (startPos > endLimit) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return startPos;	    }	    for (int i = startPos; i < endLimit; i++) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static boolean isSameDay(final Calendar cal1, final Calendar cal2) {	    if (cal1 == null || cal2 == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    return (cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR));	}
public char getEscapeChar() {	    return this.escapeChar;	}
protected String getSummaryObjectStartText() {	    return summaryObjectStartText;	}
public String getNullText() {	    return nullText;	}
@Override	public boolean translate(final int codepoint, final Writer out) throws IOException {	    if (between) {	        if (codepoint < below || codepoint > above) {	            return false;	        }	    } else {	        if (codepoint >= below && codepoint <= above) {	            return false;	        }	    }	    out.write("&#");	    out.write(Integer.toString(codepoint, 10));	    out.write(';');	    return true;	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase) {	    if (str == null || prefix == null) {	        return str == null && prefix == null;	    }	    if (prefix.length() > str.length()) {	        return false;	    }	    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());	}
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException {	    return charsetName == null ? new String(bytes) : new String(bytes, charsetName);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public StrTokenizer setEmptyTokenAsNull(final boolean emptyAsNull) {	    this.emptyAsNull = emptyAsNull;	    return this;	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
public HashCodeBuilder append(final short[] array) {	    if (array == null) {	        iTotal = iTotal * iConstant;	    } else {	        for (final short element : array) {	            append(element);	        }	    }	    return this;	}
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] result = new boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        final Boolean b = array[i];	        result[i] = (b == null ? valueForNull : b.booleanValue());	    }	    return result;	}
public static String right(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(str.length() - len);	}
public static boolean isAsciiPrintable(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static UnicodeEscaper outsideOf(final int codepointLow, final int codepointHigh) {	    return new UnicodeEscaper(codepointLow, codepointHigh, false);	}
public char getEscapeChar() {	    return this.escapeChar;	}
public String getNullText() {	    return nullText;	}
public StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, 1);	}
public static <T> T CONST(final T v) {	    return v;	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public static Field[] getAllFields(Class<?> cls) {	    final List<Field> allFieldsList = getAllFieldsList(cls);	    return allFieldsList.toArray(new Field[allFieldsList.size()]);	}
public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final E... values) {	    Validate.noNullElements(values);	    return generateBitVector(enumClass, Arrays.<E>asList(values));	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return true;	    }	    if (lhs == null || rhs == null) {	        return false;	    }	    final Class<?> lhsClass = lhs.getClass();	    final Class<?> rhsClass = rhs.getClass();	    Class<?> testClass;	    if (lhsClass.isInstance(rhs)) {	        testClass = lhsClass;	        if (!rhsClass.isInstance(lhs)) {	            testClass = rhsClass;	        }	    } else if (rhsClass.isInstance(lhs)) {	        testClass = rhsClass;	        if (!lhsClass.isInstance(rhs)) {	            testClass = lhsClass;	        }	    } else {	        return false;	    }	    final EqualsBuilder equalsBuilder = new EqualsBuilder();	    try {	        reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {	            testClass = testClass.getSuperclass();	            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        }	    } catch (final IllegalArgumentException e) {	        return false;	    }	    return equalsBuilder.isEquals();	}
public String getNewLineText() {	    return newLine;	}
public String getNewLineText() {	    return newLine;	}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    buffer.append(arrayStart);	    for (int i = 0; i < array.length; i++) {	        if (i > 0) {	            buffer.append(arraySeparator);	        }	        appendDetail(buffer, fieldName, array[i]);	    }	    buffer.append(arrayEnd);	}
protected abstract T initialize() throws Exception;
public static List<Class<?>> getAllSuperclasses(final Class<?> cls) {	    if (cls == null) {	        return null;	    }	    final List<Class<?>> classes = new ArrayList<Class<?>>();	    Class<?> superclass = cls.getSuperclass();	    while (superclass != null) {	        classes.add(superclass);	        superclass = superclass.getSuperclass();	    }	    return classes;	}
public static Integer createInteger(final String str) {	    if (str == null) {	        return null;	    }	    return Integer.decode(str);	}
protected boolean isUseFieldNames() {	    return useFieldNames;	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
@Override	public boolean ready() {	    return pos < StrBuilder.this.size();	}
@Override	public int length() {	    return size;	}
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return 0;	    }	    if (lhs == null || rhs == null) {	        throw new NullPointerException();	    }	    Class<?> lhsClazz = lhs.getClass();	    if (!lhsClazz.isInstance(rhs)) {	        throw new ClassCastException();	    }	    final CompareToBuilder compareToBuilder = new CompareToBuilder();	    reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);	    while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) {	        lhsClazz = lhsClazz.getSuperclass();	        reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);	    }	    return compareToBuilder.toComparison();	}
public static <T> T CONST(final T v) {	    return v;	}
public int size() {	    return size;	}
public StrBuilder deleteCharAt(final int index) {	    if (index < 0 || index >= size) {	        throw new StringIndexOutOfBoundsException(index);	    }	    deleteImpl(index, index + 1, 1);	    return this;	}
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] result = new boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        final Boolean b = array[i];	        result[i] = (b == null ? valueForNull : b.booleanValue());	    }	    return result;	}
public static Date round(final Object date, final int field) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (date instanceof Date) {	        return round((Date) date, field);	    } else if (date instanceof Calendar) {	        return round((Calendar) date, field).getTime();	    } else {	        throw new ClassCastException("Could not round " + date);	    }	}
public StrBuilder setLength(final int length) {	    if (length < 0) {	        throw new StringIndexOutOfBoundsException(length);	    }	    if (length < size) {	        size = length;	    } else if (length > size) {	        ensureCapacity(length);	        final int oldEnd = size;	        final int newEnd = length;	        size = length;	        for (int i = oldEnd; i < newEnd; i++) {	            buffer[i] = '\0';	        }	    }	    return this;	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
@Override	public Integer getValue() {	    return Integer.valueOf(this.value);	}
public static String getCommonPrefix(final String... strs) {	    if (strs == null || strs.length == 0) {	        return EMPTY;	    }	    final int smallestIndexOfDiff = indexOfDifference(strs);	    if (smallestIndexOfDiff == INDEX_NOT_FOUND) {	        if (strs[0] == null) {	            return EMPTY;	        }	        return strs[0];	    } else if (smallestIndexOfDiff == 0) {	        return EMPTY;	    } else {	        return strs[0].substring(0, smallestIndexOfDiff);	    }	}
@Override	public String toString() {	    if (this.getObject() == null) {	        return this.getStyle().getNullText();	    }	    Class<?> clazz = this.getObject().getClass();	    this.appendFieldsIn(clazz);	    while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {	        clazz = clazz.getSuperclass();	        this.appendFieldsIn(clazz);	    }	    return super.toString();	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public boolean contains(final CharRange range) {	    if (range == null) {	        throw new IllegalArgumentException("The Range must not be null");	    }	    if (negated) {	        if (range.negated) {	            return start >= range.start && end <= range.end;	        }	        return range.end < start || range.start > end;	    }	    if (range.negated) {	        return start == 0 && end == Character.MAX_VALUE;	    }	    return start <= range.start && end >= range.end;	}
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] result = new boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        final Boolean b = array[i];	        result[i] = (b == null ? valueForNull : b.booleanValue());	    }	    return result;	}
@Override	public Date parse(final String source, final ParsePosition pos) {	    final int offset = pos.getIndex();	    final Matcher matcher = parsePattern.matcher(source.substring(offset));	    if (!matcher.lookingAt()) {	        return null;	    }	    final Calendar cal = Calendar.getInstance(timeZone, locale);	    cal.clear();	    for (int i = 0; i < strategies.length; ) {	        final Strategy strategy = strategies[i++];	        strategy.setCalendar(this, cal, matcher.group(i));	    }	    pos.setIndex(offset + matcher.end());	    return cal.getTime();	}
public static String formatUTC(final Date date, final String pattern, final Locale locale) {	    return format(date, pattern, UTC_TIME_ZONE, locale);	}
public char[] toCharArray(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len == 0) {	        return ArrayUtils.EMPTY_CHAR_ARRAY;	    }	    final char[] chars = new char[len];	    System.arraycopy(buffer, startIndex, chars, 0, len);	    return chars;	}
protected String getSizeStartText() {	    return sizeStartText;	}
public static String prependIfMissingIgnoreCase(final String str, final CharSequence prefix, final CharSequence... prefixes) {	    return prependIfMissing(str, prefix, true, prefixes);	}
public int size() {	    return size;	}
public static <T extends CharSequence> T validIndex(final T chars, final int index) {	    return validIndex(chars, index, DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE, Integer.valueOf(index));	}
public static String appendIfMissingIgnoreCase(final String str, final CharSequence suffix, final CharSequence... suffixes) {	    return appendIfMissing(str, suffix, true, suffixes);	}
public StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, 1);	}
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, true);	}
protected boolean isUseClassName() {	    return useClassName;	}
public static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) {	    if (0 == nHexs) {	        return dstInit;	    }	    if ((nHexs - 1) * 4 + srcPos >= 32) {	        throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 32");	    }	    final StringBuilder sb = new StringBuilder(dstInit);	    int shift = 0;	    int append = sb.length();	    for (int i = 0; i < nHexs; i++) {	        shift = i * 4 + srcPos;	        final int bits = 0xF & (src >> shift);	        if (dstPos + i == append) {	            ++append;	            sb.append(intToHexDigit(bits));	        } else {	            sb.setCharAt(dstPos + i, intToHexDigit(bits));	        }	    }	    return sb.toString();	}
public StrTokenizer setDelimiterMatcher(final StrMatcher delim) {	    if (delim == null) {	        this.delimMatcher = StrMatcher.noneMatcher();	    } else {	        this.delimMatcher = delim;	    }	    return this;	}
protected String getSizeStartText() {	    return sizeStartText;	}
private static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal, final boolean lastIndex) {	    if (str == null || searchStr == null || ordinal <= 0) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return lastIndex ? str.length() : 0;	    }	    int found = 0;	    int index = lastIndex ? str.length() : INDEX_NOT_FOUND;	    do {	        if (lastIndex) {	            index = CharSequenceUtils.lastIndexOf(str, searchStr, index - 1);	        } else {	            index = CharSequenceUtils.indexOf(str, searchStr, index + 1);	        }	        if (index < 0) {	            return index;	        }	        found++;	    } while (found < ordinal);	    return index;	}
public static boolean containsOnly(final CharSequence cs, final String validChars) {	    if (cs == null || validChars == null) {	        return false;	    }	    return containsOnly(cs, validChars.toCharArray());	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public StrBuilder trim() {	    if (size == 0) {	        return this;	    }	    int len = size;	    final char[] buf = buffer;	    int pos = 0;	    while (pos < len && buf[pos] <= ' ') {	        pos++;	    }	    while (pos < len && buf[len - 1] <= ' ') {	        len--;	    }	    if (len < size) {	        delete(len, size);	    }	    if (pos > 0) {	        delete(0, pos);	    }	    return this;	}
public void decrement() {	    value--;	}
public int size() {	    return size;	}
public static String getSimpleName(final Object object, final String valueIfNull) {	    if (object == null) {	        return valueIfNull;	    }	    return getSimpleName(object.getClass());	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public String getNullText() {	    return nullText;	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static boolean isInstance(final Object value, final Type type) {	    if (type == null) {	        return false;	    }	    return value == null ? !(type instanceof Class<?>) || !((Class<?>) type).isPrimitive() : isAssignable(value.getClass(), type, null);	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static Integer toIntegerObject(final Boolean bool, final Integer trueValue, final Integer falseValue, final Integer nullValue) {	    if (bool == null) {	        return nullValue;	    }	    return bool.booleanValue() ? trueValue : falseValue;	}
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] result = new boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        final Boolean b = array[i];	        result[i] = (b == null ? valueForNull : b.booleanValue());	    }	    return result;	}
public abstract R getRight();
public char getEscapeChar() {	    return this.escapeChar;	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
@Override	public double doubleValue() {	    return (double) numerator / (double) denominator;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] result = new boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        final Boolean b = array[i];	        result[i] = (b == null ? valueForNull : b.booleanValue());	    }	    return result;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
@Override	public double doubleValue() {	    return value;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public boolean isEmpty() {	    return size == 0;	}
public static boolean isSameDay(final Calendar cal1, final Calendar cal2) {	    if (cal1 == null || cal2 == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    return (cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR));	}
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, true);	}
@Deprecated	public static Throwable getCause(final Throwable throwable, String[] methodNames) {	    if (throwable == null) {	        return null;	    }	    if (methodNames == null) {	        methodNames = CAUSE_METHOD_NAMES;	    }	    for (final String methodName : methodNames) {	        if (methodName != null) {	            final Throwable cause = getCauseUsingMethodName(throwable, methodName);	            if (cause != null) {	                return cause;	            }	        }	    }	    return null;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public static long getFragmentInDays(final Calendar calendar, final int fragment) {	    return getFragment(calendar, fragment, Calendar.DAY_OF_YEAR);	}
public Fraction multiplyBy(final Fraction fraction) {	    if (fraction == null) {	        throw new IllegalArgumentException("The fraction must not be null");	    }	    if (numerator == 0 || fraction.numerator == 0) {	        return ZERO;	    }	    final int d1 = greatestCommonDivisor(numerator, fraction.denominator);	    final int d2 = greatestCommonDivisor(fraction.numerator, denominator);	    return getReducedFraction(mulAndCheck(numerator / d1, fraction.numerator / d2), mulPosAndCheck(denominator / d2, fraction.denominator / d1));	}
@Override	public String toString() {	    return StringUtils.repeat(this.value.toString(), this.count);	}
@Override	protected List<String> tokenize(final char[] chars, final int offset, final int count) {	    if (chars == null) {	        return super.tokenize(StrBuilder.this.buffer, 0, StrBuilder.this.size());	    }	    return super.tokenize(chars, offset, count);	}
@Override	public String lookup(final String key) {	    if (map == null) {	        return null;	    }	    final Object obj = map.get(key);	    if (obj == null) {	        return null;	    }	    return obj.toString();	}
public static long getFragmentInDays(final Calendar calendar, final int fragment) {	    return getFragment(calendar, fragment, Calendar.DAY_OF_YEAR);	}
protected String getSummaryObjectStartText() {	    return summaryObjectStartText;	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public static String random(final int count, final char... chars) {	    if (chars == null) {	        return random(count, 0, 0, false, false, null, RANDOM);	    }	    return random(count, 0, chars.length, false, false, chars, RANDOM);	}
public static String leftPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return leftPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return padStr.concat(str);	    } else if (pads < padLen) {	        return padStr.substring(0, pads).concat(str);	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return new String(padding).concat(str);	    }	}
public static <K, V> V createIfAbsent(final ConcurrentMap<K, V> map, final K key, final ConcurrentInitializer<V> init) throws ConcurrentException {	    if (map == null || init == null) {	        return null;	    }	    final V value = map.get(key);	    if (value == null) {	        return putIfAbsent(map, key, init.get());	    }	    return value;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static boolean isNotFalse(final Boolean bool) {	    return !isFalse(bool);	}
static Set<Pair<IDKey, IDKey>> getRegistry() {	    return REGISTRY.get();	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static boolean isAsciiAlpha(final char ch) {	    return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');	}
public int size() {	    return size;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
protected String getSizeStartText() {	    return sizeStartText;	}
public int capacity() {	    return buffer.length;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public char[] toCharArray(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len == 0) {	        return ArrayUtils.EMPTY_CHAR_ARRAY;	    }	    final char[] chars = new char[len];	    System.arraycopy(buffer, startIndex, chars, 0, len);	    return chars;	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public StrBuilder trim() {	    if (size == 0) {	        return this;	    }	    int len = size;	    final char[] buf = buffer;	    int pos = 0;	    while (pos < len && buf[pos] <= ' ') {	        pos++;	    }	    while (pos < len && buf[len - 1] <= ' ') {	        len--;	    }	    if (len < size) {	        delete(len, size);	    }	    if (pos > 0) {	        delete(0, pos);	    }	    return this;	}
public static <T> T invokeConstructor(final Class<T> cls, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {	    if (parameterTypes == null) {	        parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;	    }	    if (args == null) {	        args = ArrayUtils.EMPTY_OBJECT_ARRAY;	    }	    final Constructor<T> ctor = getMatchingAccessibleConstructor(cls, parameterTypes);	    if (ctor == null) {	        throw new NoSuchMethodException("No such accessible constructor on object: " + cls.getName());	    }	    return ctor.newInstance(args);	}
public Reader asReader() {	    return new StrBuilderReader();	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public char getEnd() {	    return this.end;	}
public static Throwable getRootCause(final Throwable throwable) {	    final List<Throwable> list = getThrowableList(throwable);	    return list.size() < 2 ? null : (Throwable) list.get(list.size() - 1);	}
public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final E... values) {	    Validate.noNullElements(values);	    return generateBitVector(enumClass, Arrays.<E>asList(values));	}
public static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools) {	    if ((src.length == 0 && srcPos == 0) || 0 == nBools) {	        return dstInit;	    }	    if (nBools - 1 + dstPos >= 8) {	        throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 8");	    }	    byte out = dstInit;	    int shift = 0;	    for (int i = 0; i < nBools; i++) {	        shift = i * 1 + dstPos;	        final int bits = (src[i + srcPos] ? 1 : 0) << shift;	        final int mask = 0x1 << shift;	        out = (byte) ((out & ~mask) | bits);	    }	    return out;	}
public static void handleCause(final ExecutionException ex) throws ConcurrentException {	    final ConcurrentException cex = extractCause(ex);	    if (cex != null) {	        throw cex;	    }	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, true);	}
public static String capitalize(final String str) {	    int strLen;	    if (str == null || (strLen = str.length()) == 0) {	        return str;	    }	    char firstChar = str.charAt(0);	    if (Character.isTitleCase(firstChar)) {	        return str;	    }	    return new StringBuilder(strLen).append(Character.toTitleCase(firstChar)).append(str.substring(1)).toString();	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public CompareToBuilder appendSuper(final int superCompareTo) {	    if (comparison != 0) {	        return this;	    }	    comparison = superCompareTo;	    return this;	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
protected String getContentStart() {	    return contentStart;	}
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) {	    final StringBuilder buffer = new StringBuilder();	    boolean lastOutputSeconds = false;	    final int sz = tokens.length;	    for (int i = 0; i < sz; i++) {	        final Token token = tokens[i];	        final Object value = token.getValue();	        final int count = token.getCount();	        if (value instanceof StringBuilder) {	            buffer.append(value.toString());	        } else {	            if (value == y) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years));	                lastOutputSeconds = false;	            } else if (value == M) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months));	                lastOutputSeconds = false;	            } else if (value == d) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days));	                lastOutputSeconds = false;	            } else if (value == H) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours));	                lastOutputSeconds = false;	            } else if (value == m) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes));	                lastOutputSeconds = false;	            } else if (value == s) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds));	                lastOutputSeconds = true;	            } else if (value == S) {	                if (lastOutputSeconds) {	                    milliseconds += 1000;	                    final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds);	                    buffer.append(str.substring(1));	                } else {	                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds));	                }	                lastOutputSeconds = false;	            }	        }	    }	    return buffer.toString();	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static String leftPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return leftPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return padStr.concat(str);	    } else if (pads < padLen) {	        return padStr.substring(0, pads).concat(str);	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return new String(padding).concat(str);	    }	}
protected String getFieldSeparator() {	    return fieldSeparator;	}
public static Boolean xor(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return xor(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
public StringBuilder toStringBuilder() {	    return new StringBuilder(size).append(buffer, 0, size);	}
public static String prependIfMissing(final String str, final CharSequence prefix, final CharSequence... prefixes) {	    return prependIfMissing(str, prefix, false, prefixes);	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public boolean isEmpty() {	    return size == 0;	}
@Override	public M getMiddle() {	    return middle;	}
protected String getFieldNameValueSeparator() {	    return fieldNameValueSeparator;	}
public static final String escapeJava(final String input) {	    return ESCAPE_JAVA.translate(input);	}
public static int indexOfDifference(final CharSequence... css) {	    if (css == null || css.length <= 1) {	        return INDEX_NOT_FOUND;	    }	    boolean anyStringNull = false;	    boolean allStringsNull = true;	    final int arrayLen = css.length;	    int shortestStrLen = Integer.MAX_VALUE;	    int longestStrLen = 0;	    for (int i = 0; i < arrayLen; i++) {	        if (css[i] == null) {	            anyStringNull = true;	            shortestStrLen = 0;	        } else {	            allStringsNull = false;	            shortestStrLen = Math.min(css[i].length(), shortestStrLen);	            longestStrLen = Math.max(css[i].length(), longestStrLen);	        }	    }	    if (allStringsNull || longestStrLen == 0 && !anyStringNull) {	        return INDEX_NOT_FOUND;	    }	    if (shortestStrLen == 0) {	        return 0;	    }	    int firstDiff = -1;	    for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {	        final char comparisonChar = css[0].charAt(stringPos);	        for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {	            if (css[arrayPos].charAt(stringPos) != comparisonChar) {	                firstDiff = stringPos;	                break;	            }	        }	        if (firstDiff != -1) {	            break;	        }	    }	    if (firstDiff == -1 && shortestStrLen != longestStrLen) {	        return shortestStrLen;	    }	    return firstDiff;	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
public boolean contains(final StrMatcher matcher) {	    return indexOf(matcher, 0) >= 0;	}
@Override	public String previous() {	    if (hasPrevious()) {	        return tokens[--tokenPos];	    }	    throw new NoSuchElementException();	}
public boolean isAppendStatics() {	    return this.appendStatics;	}
public static Boolean and(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return and(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
public static Boolean or(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
public static boolean isNotEmpty(final CharSequence cs) {	    return !StringUtils.isEmpty(cs);	}
public static float min(final float a, final float b, final float c) {	    return Math.min(Math.min(a, b), c);	}
public String getNullText() {	    return nullText;	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
@Override	public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) {	    return buffer[pos] <= 32 ? 1 : 0;	}
@Deprecated	public static String chomp(final String str, final String separator) {	    return removeEnd(str, separator);	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
@Override	public int hashCode() {	    return toHashCode();	}
@Override	public int compare(final Object obj1, final Object obj2) {	    return ((Comparable) obj1).compareTo(obj2);	}
public StrTokenizer setDelimiterString(final String delim) {	    return setDelimiterMatcher(StrMatcher.stringMatcher(delim));	}
public String getNewLineText() {	    return newLine;	}
public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) {	    if (s == null || t == null) {	        throw new IllegalArgumentException("Strings must not be null");	    }	    if (threshold < 0) {	        throw new IllegalArgumentException("Threshold must not be negative");	    }	    int n = s.length();	    int m = t.length();	    if (n == 0) {	        return m <= threshold ? m : -1;	    } else if (m == 0) {	        return n <= threshold ? n : -1;	    }	    if (n > m) {	        final CharSequence tmp = s;	        s = t;	        t = tmp;	        n = m;	        m = t.length();	    }	    int[] p = new int[n + 1];	    int[] d = new int[n + 1];	    int[] _d;	    final int boundary = Math.min(n, threshold) + 1;	    for (int i = 0; i < boundary; i++) {	        p[i] = i;	    }	    Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);	    Arrays.fill(d, Integer.MAX_VALUE);	    for (int j = 1; j <= m; j++) {	        final char t_j = t.charAt(j - 1);	        d[0] = j;	        final int min = Math.max(1, j - threshold);	        final int max = Math.min(n, j + threshold);	        if (min > max) {	            return -1;	        }	        if (min > 1) {	            d[min - 1] = Integer.MAX_VALUE;	        }	        for (int i = min; i <= max; i++) {	            if (s.charAt(i - 1) == t_j) {	                d[i] = p[i - 1];	            } else {	                d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);	            }	        }	        _d = p;	        p = d;	        d = _d;	    }	    if (p[n] <= threshold) {	        return p[n];	    }	    return -1;	}
public String getNullText() {	    return nullText;	}
public static short[] removeElement(final short[] array, final short element) {	    final int index = indexOf(array, element);	    if (index == INDEX_NOT_FOUND) {	        return clone(array);	    }	    return remove(array, index);	}
public static <T> T firstNonNull(final T... values) {	    if (values != null) {	        for (final T val : values) {	            if (val != null) {	                return val;	            }	        }	    }	    return null;	}
protected String getContentEnd() {	    return contentEnd;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof MutableBoolean) {	        return value == ((MutableBoolean) obj).booleanValue();	    }	    return false;	}
static List<String> getStackFrameList(final Throwable t) {	    final String stackTrace = getStackTrace(t);	    final String linebreak = SystemUtils.LINE_SEPARATOR;	    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);	    final List<String> list = new ArrayList<String>();	    boolean traceStarted = false;	    while (frames.hasMoreTokens()) {	        final String token = frames.nextToken();	        final int at = token.indexOf("at");	        if (at != -1 && token.substring(0, at).trim().isEmpty()) {	            traceStarted = true;	            list.add(token);	        } else if (traceStarted) {	            break;	        }	    }	    return list;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public int toHashCode() {	    return iTotal;	}
@Override	public int hashCode() {	    return toHashCode();	}
public static String capitalize(final String str, final char... delimiters) {	    final int delimLen = delimiters == null ? -1 : delimiters.length;	    if (StringUtils.isEmpty(str) || delimLen == 0) {	        return str;	    }	    final char[] buffer = str.toCharArray();	    boolean capitalizeNext = true;	    for (int i = 0; i < buffer.length; i++) {	        final char ch = buffer[i];	        if (isDelimiter(ch, delimiters)) {	            capitalizeNext = true;	        } else if (capitalizeNext) {	            buffer[i] = Character.toTitleCase(ch);	            capitalizeNext = false;	        }	    }	    return new String(buffer);	}
public static boolean isAlpha(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return 0;	    }	    if (lhs == null || rhs == null) {	        throw new NullPointerException();	    }	    Class<?> lhsClazz = lhs.getClass();	    if (!lhsClazz.isInstance(rhs)) {	        throw new ClassCastException();	    }	    final CompareToBuilder compareToBuilder = new CompareToBuilder();	    reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);	    while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) {	        lhsClazz = lhsClazz.getSuperclass();	        reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);	    }	    return compareToBuilder.toComparison();	}
@Override	public List<Pair<String, Object>> getContextEntries() {	    return this.exceptionContext.getContextEntries();	}
public int toComparison() {	    return comparison;	}
public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale) {	    return cache.getInstance(pattern, timeZone, locale);	}
@Override	public T call() throws Exception {	    try {	        return initialize();	    } finally {	        if (execFinally != null) {	            execFinally.shutdown();	        }	    }	}
protected String getNullText() {	    return nullText;	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
public static List<Locale> localeLookupList(final Locale locale, final Locale defaultLocale) {	    final List<Locale> list = new ArrayList<Locale>(4);	    if (locale != null) {	        list.add(locale);	        if (locale.getVariant().length() > 0) {	            list.add(new Locale(locale.getLanguage(), locale.getCountry()));	        }	        if (locale.getCountry().length() > 0) {	            list.add(new Locale(locale.getLanguage(), ""));	        }	        if (list.contains(defaultLocale) == false) {	            list.add(defaultLocale);	        }	    }	    return Collections.unmodifiableList(list);	}
public static float max(final float a, final float b, final float c) {	    return Math.max(Math.max(a, b), c);	}
public StrBuilder trim() {	    if (size == 0) {	        return this;	    }	    int len = size;	    final char[] buf = buffer;	    int pos = 0;	    while (pos < len && buf[pos] <= ' ') {	        pos++;	    }	    while (pos < len && buf[len - 1] <= ' ') {	        len--;	    }	    if (len < size) {	        delete(len, size);	    }	    if (pos > 0) {	        delete(0, pos);	    }	    return this;	}
protected String getSizeStartText() {	    return sizeStartText;	}
protected boolean isUseClassName() {	    return useClassName;	}
@Override	public int compareTo(final Pair<L, R> other) {	    return new CompareToBuilder().append(getLeft(), other.getLeft()).append(getRight(), other.getRight()).toComparison();	}
private static Date set(final Date date, final int calendarField, final int amount) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final Calendar c = Calendar.getInstance();	    c.setLenient(false);	    c.setTime(date);	    c.set(calendarField, amount);	    return c.getTime();	}
public static String removeStart(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.startsWith(remove)) {	        return str.substring(remove.length());	    }	    return str;	}
@Override	public byte byteValue() {	    return value;	}
public boolean isEnableSubstitutionInVariables() {	    return enableSubstitutionInVariables;	}
public static float max(final float a, final float b) {	    if (Float.isNaN(a)) {	        return b;	    } else if (Float.isNaN(b)) {	        return a;	    } else {	        return Math.max(a, b);	    }	}
public static String reverse(final String str) {	    if (str == null) {	        return null;	    }	    return new StringBuilder(str).reverse().toString();	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
public static String trim(final String str) {	    return str == null ? null : str.trim();	}
@Override	public TimeZone getTimeZone() {	    return timeZone;	}
public int indexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex < 0 ? 0 : startIndex);	    if (matcher == null || startIndex >= size) {	        return -1;	    }	    final int len = size;	    final char[] buf = buffer;	    for (int i = startIndex; i < len; i++) {	        if (matcher.isMatch(buf, i, startIndex, len) > 0) {	            return i;	        }	    }	    return -1;	}
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] result = new boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        final Boolean b = array[i];	        result[i] = (b == null ? valueForNull : b.booleanValue());	    }	    return result;	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public boolean contains(final StrMatcher matcher) {	    return indexOf(matcher, 0) >= 0;	}
public String getNewLineText() {	    return newLine;	}
public boolean isEmpty() {	    return size == 0;	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public static boolean isNumeric(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isDigit(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
@Override	public boolean equals(final Object obj) {	    if (obj == this) {	        return true;	    }	    if (obj instanceof Map.Entry<?, ?>) {	        final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;	        return ObjectUtils.equals(getKey(), other.getKey()) && ObjectUtils.equals(getValue(), other.getValue());	    }	    return false;	}
@Override	public Date parse(final String source, final ParsePosition pos) {	    final int offset = pos.getIndex();	    final Matcher matcher = parsePattern.matcher(source.substring(offset));	    if (!matcher.lookingAt()) {	        return null;	    }	    final Calendar cal = Calendar.getInstance(timeZone, locale);	    cal.clear();	    for (int i = 0; i < strategies.length; ) {	        final Strategy strategy = strategies[i++];	        strategy.setCalendar(this, cal, matcher.group(i));	    }	    pos.setIndex(offset + matcher.end());	    return cal.getTime();	}
@Override	public Object getFirstContextValue(final String label) {	    return this.exceptionContext.getFirstContextValue(label);	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public final void translate(final CharSequence input, final Writer out) throws IOException {	    if (out == null) {	        throw new IllegalArgumentException("The Writer must not be null");	    }	    if (input == null) {	        return;	    }	    int pos = 0;	    final int len = input.length();	    while (pos < len) {	        final int consumed = translate(input, pos, out);	        if (consumed == 0) {	            final char[] c = Character.toChars(Character.codePointAt(input, pos));	            out.write(c);	            pos += c.length;	            continue;	        }	        for (int pt = 0; pt < consumed; pt++) {	            pos += Character.charCount(Character.codePointAt(input, pt));	        }	    }	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException {	    return parseDateWithLeniency(str, null, parsePatterns, false);	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof MutableShort) {	        return value == ((MutableShort) obj).shortValue();	    }	    return false;	}
public synchronized double getAverageCallsPerPeriod() {	    return periodCount == 0 ? 0 : (double) totalAcquireCount / (double) periodCount;	}
public static void validState(final boolean expression, final String message, final Object... values) {	    if (expression == false) {	        throw new IllegalStateException(String.format(message, values));	    }	}
@Override	public int length() {	    return size;	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public String getNewLineText() {	    return newLine;	}
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) {	    if (bool == null) {	        return nullValue;	    }	    return bool.booleanValue() ? trueValue : falseValue;	}
public StrTokenizer setTrimmerMatcher(final StrMatcher trimmer) {	    if (trimmer != null) {	        this.trimmerMatcher = trimmer;	    }	    return this;	}
public int size() {	    return size;	}
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {	    if (array == null) {	        if (index != 0) {	            throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0");	        }	        final Object joinedArray = Array.newInstance(clss, 1);	        Array.set(joinedArray, 0, element);	        return joinedArray;	    }	    final int length = Array.getLength(array);	    if (index > length || index < 0) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(clss, length + 1);	    System.arraycopy(array, 0, result, 0, index);	    Array.set(result, index, element);	    if (index < length) {	        System.arraycopy(array, index, result, index + 1, length - index);	    }	    return result;	}
public static <T> Range<T> is(final T element, final Comparator<T> comparator) {	    return between(element, element, comparator);	}
public static boolean isSameLength(final boolean[] array1, final boolean[] array2) {	    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {	        return false;	    }	    return true;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public String getNewLineText() {	    return newLine;	}
public static void matchesPattern(final CharSequence input, final String pattern, final String message, final Object... values) {	    if (Pattern.matches(pattern, input) == false) {	        throw new IllegalArgumentException(String.format(message, values));	    }	}
@Override	public boolean ready() {	    return pos < StrBuilder.this.size();	}
protected boolean isDefaultFullDetail() {	    return defaultFullDetail;	}
public int size() {	    return size;	}
public static char binaryToHexDigit(final boolean[] src, final int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    if (src.length > srcPos + 3 && src[srcPos + 3]) {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src[srcPos]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
public static String removePattern(final String source, final String regex) {	    return replacePattern(source, regex, StringUtils.EMPTY);	}
public int size() {	    return size;	}
public int getDenominator() {	    return denominator;	}
@Override	public int hashCode() {	    return toHashCode();	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public static String replaceOnce(final String text, final String searchString, final String replacement) {	    return replace(text, searchString, replacement, 1);	}
public static float max(final float a, final float b, final float c) {	    return Math.max(Math.max(a, b), c);	}
public static boolean isSameType(final Object array1, final Object array2) {	    if (array1 == null || array2 == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    return array1.getClass().getName().equals(array2.getClass().getName());	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
@Override	public int length() {	    return size;	}
public static String substringBeforeLast(final String str, final String separator) {	    if (isEmpty(str) || isEmpty(separator)) {	        return str;	    }	    final int pos = str.lastIndexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return str;	    }	    return str.substring(0, pos);	}
public static String prependIfMissingIgnoreCase(final String str, final CharSequence prefix, final CharSequence... prefixes) {	    return prependIfMissing(str, prefix, true, prefixes);	}
public static String randomNumeric(final int count) {	    return random(count, false, true);	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
Object cloneReset() throws CloneNotSupportedException {	    final StrTokenizer cloned = (StrTokenizer) super.clone();	    if (cloned.chars != null) {	        cloned.chars = cloned.chars.clone();	    }	    cloned.reset();	    return cloned;	}
public static boolean containsOnly(final CharSequence cs, final String validChars) {	    if (cs == null || validChars == null) {	        return false;	    }	    return containsOnly(cs, validChars.toCharArray());	}
public static String deleteWhitespace(final String str) {	    if (isEmpty(str)) {	        return str;	    }	    final int sz = str.length();	    final char[] chs = new char[sz];	    int count = 0;	    for (int i = 0; i < sz; i++) {	        if (!Character.isWhitespace(str.charAt(i))) {	            chs[count++] = str.charAt(i);	        }	    }	    if (count == sz) {	        return str;	    }	    return new String(chs, 0, count);	}
public static String getPackageCanonicalName(final String canonicalName) {	    return ClassUtils.getPackageName(getCanonicalName(canonicalName));	}
static JavaVersion get(final String nom) {	    if ("0.9".equals(nom)) {	        return JAVA_0_9;	    } else if ("1.1".equals(nom)) {	        return JAVA_1_1;	    } else if ("1.2".equals(nom)) {	        return JAVA_1_2;	    } else if ("1.3".equals(nom)) {	        return JAVA_1_3;	    } else if ("1.4".equals(nom)) {	        return JAVA_1_4;	    } else if ("1.5".equals(nom)) {	        return JAVA_1_5;	    } else if ("1.6".equals(nom)) {	        return JAVA_1_6;	    } else if ("1.7".equals(nom)) {	        return JAVA_1_7;	    } else if ("1.8".equals(nom)) {	        return JAVA_1_8;	    } else {	        return null;	    }	}
public static Fraction getReducedFraction(int numerator, int denominator) {	    if (denominator == 0) {	        throw new ArithmeticException("The denominator must not be zero");	    }	    if (numerator == 0) {	        return ZERO;	    }	    if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) {	        numerator /= 2;	        denominator /= 2;	    }	    if (denominator < 0) {	        if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {	            throw new ArithmeticException("overflow: can't negate");	        }	        numerator = -numerator;	        denominator = -denominator;	    }	    final int gcd = greatestCommonDivisor(numerator, denominator);	    numerator /= gcd;	    denominator /= gcd;	    return new Fraction(numerator, denominator);	}
public void subtract(final Number operand) {	    this.value -= operand.doubleValue();	}
@Override	public int length() {	    return size;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
@Override	public ContextedRuntimeException addContextValue(final String label, final Object value) {	    exceptionContext.addContextValue(label, value);	    return this;	}
@Override	public int hashCode() {	    return toHashCode();	}
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, true);	}
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) {	    style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));	    return this;	}
public static Boolean xor(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return xor(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) {	    if (s == null || t == null) {	        throw new IllegalArgumentException("Strings must not be null");	    }	    if (threshold < 0) {	        throw new IllegalArgumentException("Threshold must not be negative");	    }	    int n = s.length();	    int m = t.length();	    if (n == 0) {	        return m <= threshold ? m : -1;	    } else if (m == 0) {	        return n <= threshold ? n : -1;	    }	    if (n > m) {	        final CharSequence tmp = s;	        s = t;	        t = tmp;	        n = m;	        m = t.length();	    }	    int[] p = new int[n + 1];	    int[] d = new int[n + 1];	    int[] _d;	    final int boundary = Math.min(n, threshold) + 1;	    for (int i = 0; i < boundary; i++) {	        p[i] = i;	    }	    Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);	    Arrays.fill(d, Integer.MAX_VALUE);	    for (int j = 1; j <= m; j++) {	        final char t_j = t.charAt(j - 1);	        d[0] = j;	        final int min = Math.max(1, j - threshold);	        final int max = Math.min(n, j + threshold);	        if (min > max) {	            return -1;	        }	        if (min > 1) {	            d[min - 1] = Integer.MAX_VALUE;	        }	        for (int i = min; i <= max; i++) {	            if (s.charAt(i - 1) == t_j) {	                d[i] = p[i - 1];	            } else {	                d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);	            }	        }	        _d = p;	        p = d;	        d = _d;	    }	    if (p[n] <= threshold) {	        return p[n];	    }	    return -1;	}
public static boolean startsWithAny(final CharSequence string, final CharSequence... searchStrings) {	    if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {	        return false;	    }	    for (final CharSequence searchString : searchStrings) {	        if (StringUtils.startsWith(string, searchString)) {	            return true;	        }	    }	    return false;	}
public static void identityToString(final StringBuilder builder, final Object object) {	    if (object == null) {	        throw new NullPointerException("Cannot get the toString of a null identity");	    }	    builder.append(object.getClass().getName()).append('@').append(Integer.toHexString(System.identityHashCode(object)));	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
protected void setArraySeparator(String arraySeparator) {	    if (arraySeparator == null) {	        arraySeparator = "";	    }	    this.arraySeparator = arraySeparator;	}
public static String removeEnd(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.endsWith(remove)) {	        return str.substring(0, str.length() - remove.length());	    }	    return str;	}
@Override	public TimeZone getTimeZone() {	    return timeZone;	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public synchronized boolean isStarted() {	    return future != null;	}
protected boolean isUseShortClassName() {	    return useShortClassName;	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
@Override	public Integer build() {	    return Integer.valueOf(toHashCode());	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
@Override	public int intValue() {	    return (int) value;	}
public void appendSuper(final StringBuffer buffer, final String superToString) {	    appendToString(buffer, superToString);	}
protected String getSummaryObjectEndText() {	    return summaryObjectEndText;	}
public static char toChar(final String str, final char defaultValue) {	    if (StringUtils.isEmpty(str)) {	        return defaultValue;	    }	    return str.charAt(0);	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public boolean isEmpty() {	    return size == 0;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException {	    return charsetName == null ? new String(bytes) : new String(bytes, charsetName);	}
protected boolean isArrayContentDetail() {	    return arrayContentDetail;	}
public final synchronized void setLimit(final int limit) {	    this.limit = limit;	}
@Override	public String toString() {	    return StringUtils.repeat(this.value.toString(), this.count);	}
public static boolean isAlphanumeric(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetterOrDigit(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public int lastIndexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex >= size ? size - 1 : startIndex);	    if (matcher == null || startIndex < 0) {	        return -1;	    }	    final char[] buf = buffer;	    final int endIndex = startIndex + 1;	    for (int i = startIndex; i >= 0; i--) {	        if (matcher.isMatch(buf, i, 0, endIndex) > 0) {	            return i;	        }	    }	    return -1;	}
@Override	public String toString() {	    return String.valueOf(value);	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public boolean isEmpty() {	    return size == 0;	}
public static final String unescapeEcmaScript(final String input) {	    return UNESCAPE_ECMASCRIPT.translate(input);	}
public StrBuilder appendPadding(final int length, final char padChar) {	    if (length >= 0) {	        ensureCapacity(size + length);	        for (int i = 0; i < length; i++) {	            buffer[size++] = padChar;	        }	    }	    return this;	}
@Override	public T get(final long timeout, final TimeUnit unit) {	    return value;	}
@Override	public boolean equals(final Object obj) {	    if (obj == null) {	        return false;	    }	    if (this == obj) {	        return true;	    }	    if (this.getClass() == obj.getClass()) {	        final MutableObject<?> that = (MutableObject<?>) obj;	        return this.value.equals(that.value);	    } else {	        return false;	    }	}
public boolean isEquals() {	    return this.isEquals;	}
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) {	    if (bool == null) {	        return nullValue;	    }	    return bool.booleanValue() ? trueValue : falseValue;	}
@Override	public Locale getLocale() {	    return locale;	}
public static String stripEnd(final String str, final String stripChars) {	    int end;	    if (str == null || (end = str.length()) == 0) {	        return str;	    }	    if (stripChars == null) {	        while (end != 0 && Character.isWhitespace(str.charAt(end - 1))) {	            end--;	        }	    } else if (stripChars.isEmpty()) {	        return str;	    } else {	        while (end != 0 && stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND) {	            end--;	        }	    }	    return str.substring(0, end);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public boolean isEmpty() {	    return size == 0;	}
public static boolean isEmpty(final boolean[] array) {	    return array == null || array.length == 0;	}
public static float min(final float a, final float b, final float c) {	    return Math.min(Math.min(a, b), c);	}
@Override	public int intValue() {	    return (int) value;	}
public int toComparison() {	    return comparison;	}
static int lastIndexOf(final CharSequence cs, final CharSequence searchChar, final int start) {	    return cs.toString().lastIndexOf(searchChar.toString(), start);	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static Class<?> getRawType(final Type type, final Type assigningType) {	    if (type instanceof Class<?>) {	        return (Class<?>) type;	    }	    if (type instanceof ParameterizedType) {	        return getRawType((ParameterizedType) type);	    }	    if (type instanceof TypeVariable<?>) {	        if (assigningType == null) {	            return null;	        }	        final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration();	        if (!(genericDeclaration instanceof Class<?>)) {	            return null;	        }	        final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType, (Class<?>) genericDeclaration);	        if (typeVarAssigns == null) {	            return null;	        }	        final Type typeArgument = typeVarAssigns.get(type);	        if (typeArgument == null) {	            return null;	        }	        return getRawType(typeArgument, assigningType);	    }	    if (type instanceof GenericArrayType) {	        final Class<?> rawComponentType = getRawType(((GenericArrayType) type).getGenericComponentType(), assigningType);	        return Array.newInstance(rawComponentType, 0).getClass();	    }	    if (type instanceof WildcardType) {	        return null;	    }	    throw new IllegalArgumentException("unknown type: " + type);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static <T> Constructor<T> getAccessibleConstructor(final Constructor<T> ctor) {	    return MemberUtils.isAccessible(ctor) && Modifier.isPublic(ctor.getDeclaringClass().getModifiers()) ? ctor : null;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
public boolean isEmpty() {	    return size == 0;	}
public void start() {	    if (this.runningState == STATE_STOPPED) {	        throw new IllegalStateException("Stopwatch must be reset before being restarted. ");	    }	    if (this.runningState != STATE_UNSTARTED) {	        throw new IllegalStateException("Stopwatch already started. ");	    }	    this.startTime = System.nanoTime();	    this.startTimeMillis = System.currentTimeMillis();	    this.runningState = STATE_RUNNING;	}
static Object removeAll(final Object array, final BitSet indices) {	    final int srcLength = ArrayUtils.getLength(array);	    final int removals = indices.cardinality();	    final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals);	    int srcIndex = 0;	    int destIndex = 0;	    int count;	    int set;	    while ((set = indices.nextSetBit(srcIndex)) != -1) {	        count = set - srcIndex;	        if (count > 0) {	            System.arraycopy(array, srcIndex, result, destIndex, count);	            destIndex += count;	        }	        srcIndex = indices.nextClearBit(set);	    }	    count = srcLength - srcIndex;	    if (count > 0) {	        System.arraycopy(array, srcIndex, result, destIndex, count);	    }	    return result;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public static String abbreviate(final String str, int offset, final int maxWidth) {	    if (str == null) {	        return null;	    }	    if (maxWidth < 4) {	        throw new IllegalArgumentException("Minimum abbreviation width is 4");	    }	    if (str.length() <= maxWidth) {	        return str;	    }	    if (offset > str.length()) {	        offset = str.length();	    }	    if (str.length() - offset < maxWidth - 3) {	        offset = str.length() - (maxWidth - 3);	    }	    final String abrevMarker = "...";	    if (offset <= 4) {	        return str.substring(0, maxWidth - 3) + abrevMarker;	    }	    if (maxWidth < 7) {	        throw new IllegalArgumentException("Minimum abbreviation width with offset is 7");	    }	    if (offset + maxWidth - 3 < str.length()) {	        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);	    }	    return abrevMarker + str.substring(str.length() - (maxWidth - 3));	}
public static char intToHexDigitMsb0(final int nibble) {	    switch(nibble) {	        case 0x0:	            return '0';	        case 0x1:	            return '8';	        case 0x2:	            return '4';	        case 0x3:	            return 'c';	        case 0x4:	            return '2';	        case 0x5:	            return 'a';	        case 0x6:	            return '6';	        case 0x7:	            return 'e';	        case 0x8:	            return '1';	        case 0x9:	            return '9';	        case 0xA:	            return '5';	        case 0xB:	            return 'd';	        case 0xC:	            return '3';	        case 0xD:	            return 'b';	        case 0xE:	            return '7';	        case 0xF:	            return 'f';	        default:	            throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble);	    }	}
public int capacity() {	    return buffer.length;	}
public int capacity() {	    return buffer.length;	}
protected String getFieldSeparator() {	    return fieldSeparator;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
protected String getNullText() {	    return nullText;	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static boolean endsWithIgnoreCase(final CharSequence str, final CharSequence suffix) {	    return endsWith(str, suffix, true);	}
@Override	public long longValue() {	    return (long) numerator / denominator;	}
public Integer toInteger() {	    return Integer.valueOf(intValue());	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public boolean isEquals() {	    return this.isEquals;	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
public boolean isEquals() {	    return this.isEquals;	}
static Object removeAll(final Object array, final BitSet indices) {	    final int srcLength = ArrayUtils.getLength(array);	    final int removals = indices.cardinality();	    final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals);	    int srcIndex = 0;	    int destIndex = 0;	    int count;	    int set;	    while ((set = indices.nextSetBit(srcIndex)) != -1) {	        count = set - srcIndex;	        if (count > 0) {	            System.arraycopy(array, srcIndex, result, destIndex, count);	            destIndex += count;	        }	        srcIndex = indices.nextClearBit(set);	    }	    count = srcLength - srcIndex;	    if (count > 0) {	        System.arraycopy(array, srcIndex, result, destIndex, count);	    }	    return result;	}
static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {	    final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);	    String pattern = cDateTimeInstanceCache.get(key);	    if (pattern == null) {	        try {	            DateFormat formatter;	            if (dateStyle == null) {	                formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);	            } else if (timeStyle == null) {	                formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);	            } else {	                formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);	            }	            pattern = ((SimpleDateFormat) formatter).toPattern();	            final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);	            if (previous != null) {	                pattern = previous;	            }	        } catch (final ClassCastException ex) {	            throw new IllegalArgumentException("No date time pattern for locale: " + locale);	        }	    }	    return pattern;	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
protected String getContentStart() {	    return contentStart;	}
protected String getSizeStartText() {	    return sizeStartText;	}
@Override	public boolean ready() {	    return pos < StrBuilder.this.size();	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static <L, M, R> ImmutableTriple<L, M, R> of(final L left, final M middle, final R right) {	    return new ImmutableTriple<L, M, R>(left, middle, right);	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public boolean contains(final CharRange range) {	    if (range == null) {	        throw new IllegalArgumentException("The Range must not be null");	    }	    if (negated) {	        if (range.negated) {	            return start >= range.start && end <= range.end;	        }	        return range.end < start || range.start > end;	    }	    if (range.negated) {	        return start == 0 && end == Character.MAX_VALUE;	    }	    return start <= range.start && end >= range.end;	}
protected boolean isUseShortClassName() {	    return useShortClassName;	}
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) {	    style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));	    return this;	}
public static char binaryToHexDigit(final boolean[] src, final int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    if (src.length > srcPos + 3 && src[srcPos + 3]) {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src[srcPos]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
@Override	public int length() {	    return size;	}
public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException {	    return parseDateWithLeniency(str, null, parsePatterns, false);	}
public static char binaryToHexDigit(final boolean[] src, final int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    if (src.length > srcPos + 3 && src[srcPos + 3]) {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src[srcPos]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public String getNullText() {	    return nullText;	}
public static char toChar(final String str, final char defaultValue) {	    if (StringUtils.isEmpty(str)) {	        return defaultValue;	    }	    return str.charAt(0);	}
public StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, 1);	}
public boolean isEmptyTokenAsNull() {	    return this.emptyAsNull;	}
public static final String escapeXml(final String input) {	    return ESCAPE_XML.translate(input);	}
public static String reverseDelimited(final String str, final char separatorChar) {	    if (str == null) {	        return null;	    }	    final String[] strs = split(str, separatorChar);	    ArrayUtils.reverse(strs);	    return join(strs, separatorChar);	}
public String getNewLineText() {	    return newLine;	}
public abstract L getLeft();
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
@Deprecated	public static Throwable getCause(final Throwable throwable, String[] methodNames) {	    if (throwable == null) {	        return null;	    }	    if (methodNames == null) {	        methodNames = CAUSE_METHOD_NAMES;	    }	    for (final String methodName : methodNames) {	        if (methodName != null) {	            final Throwable cause = getCauseUsingMethodName(throwable, methodName);	            if (cause != null) {	                return cause;	            }	        }	    }	    return null;	}
public static boolean containsIgnoreCase(final CharSequence str, final CharSequence searchStr) {	    if (str == null || searchStr == null) {	        return false;	    }	    final int len = searchStr.length();	    final int max = str.length() - len;	    for (int i = 0; i <= max; i++) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, len)) {	            return true;	        }	    }	    return false;	}
public String getNullText() {	    return nullText;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public static Object invokeStaticMethod(final Class<?> cls, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {	    if (parameterTypes == null) {	        parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;	    }	    if (args == null) {	        args = ArrayUtils.EMPTY_OBJECT_ARRAY;	    }	    final Method method = getMatchingAccessibleMethod(cls, methodName, parameterTypes);	    if (method == null) {	        throw new NoSuchMethodException("No such accessible method: " + methodName + "() on class: " + cls.getName());	    }	    return method.invoke(null, args);	}
public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final E... values) {	    Validate.noNullElements(values);	    return generateBitVector(enumClass, Arrays.<E>asList(values));	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
@Override	public boolean equals(final Object obj) {	    if (obj == this) {	        return true;	    }	    if (obj instanceof CharRange == false) {	        return false;	    }	    final CharRange other = (CharRange) obj;	    return start == other.start && end == other.end && negated == other.negated;	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public StrBuilder appendSeparator(final char separator, final int loopIndex) {	    if (loopIndex > 0) {	        append(separator);	    }	    return this;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public String getNullText() {	    return nullText;	}
public static String rightPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return rightPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return str.concat(padStr);	    } else if (pads < padLen) {	        return str.concat(padStr.substring(0, pads));	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return str.concat(new String(padding));	    }	}
public boolean isEmpty() {	    return size == 0;	}
public static <T> T clone(final T obj) {	    if (obj instanceof Cloneable) {	        final Object result;	        if (obj.getClass().isArray()) {	            final Class<?> componentType = obj.getClass().getComponentType();	            if (!componentType.isPrimitive()) {	                result = ((Object[]) obj).clone();	            } else {	                int length = Array.getLength(obj);	                result = Array.newInstance(componentType, length);	                while (length-- > 0) {	                    Array.set(result, length, Array.get(obj, length));	                }	            }	        } else {	            try {	                final Method clone = obj.getClass().getMethod("clone");	                result = clone.invoke(obj);	            } catch (final NoSuchMethodException e) {	                throw new CloneFailedException("Cloneable type " + obj.getClass().getName() + " has no clone method", e);	            } catch (final IllegalAccessException e) {	                throw new CloneFailedException("Cannot clone Cloneable type " + obj.getClass().getName(), e);	            } catch (final InvocationTargetException e) {	                throw new CloneFailedException("Exception cloning Cloneable type " + obj.getClass().getName(), e.getCause());	            }	        }	        @SuppressWarnings("unchecked")	        final T checked = (T) result;	        return checked;	    }	    return null;	}
public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width, final int precision, final char padChar, final CharSequence ellipsis) {	    Validate.isTrue(ellipsis == null || precision < 0 || ellipsis.length() <= precision, "Specified ellipsis '%1$s' exceeds precision of %2$s", ellipsis, Integer.valueOf(precision));	    final StringBuilder buf = new StringBuilder(seq);	    if (precision >= 0 && precision < seq.length()) {	        final CharSequence _ellipsis = ObjectUtils.defaultIfNull(ellipsis, StringUtils.EMPTY);	        buf.replace(precision - _ellipsis.length(), seq.length(), _ellipsis.toString());	    }	    final boolean leftJustify = (flags & LEFT_JUSTIFY) == LEFT_JUSTIFY;	    for (int i = buf.length(); i < width; i++) {	        buf.insert(leftJustify ? i : 0, padChar);	    }	    formatter.format(buf.toString());	    return formatter;	}
public int capacity() {	    return buffer.length;	}
public Builder priority(final int prio) {	    priority = Integer.valueOf(prio);	    return this;	}
public String getNewLineText() {	    return newLine;	}
public static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    final int beSrcPos = src.length - 1 - srcPos;	    final int srcLen = Math.min(4, beSrcPos + 1);	    final boolean[] paddedSrc = new boolean[4];	    System.arraycopy(src, beSrcPos + 1 - srcLen, paddedSrc, 4 - srcLen, srcLen);	    src = paddedSrc;	    srcPos = 0;	    if (src[srcPos]) {	        if (src.length > srcPos + 1 && src[srcPos + 1]) {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 1 && src[srcPos + 1]) {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
public String getNullText() {	    return nullText;	}
Object getValue() {	    return value;	}
public static int hashCode(final Annotation a) {	    int result = 0;	    final Class<? extends Annotation> type = a.annotationType();	    for (final Method m : type.getDeclaredMethods()) {	        try {	            final Object value = m.invoke(a);	            if (value == null) {	                throw new IllegalStateException(String.format("Annotation method %s returned null", m));	            }	            result += hashMember(m.getName(), value);	        } catch (final RuntimeException ex) {	            throw ex;	        } catch (final Exception ex) {	            throw new RuntimeException(ex);	        }	    }	    return result;	}
public StrBuilder deleteFirst(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, 1);	}
public static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex) {	    if (0 == nHex) {	        return dstInit;	    }	    if ((nHex - 1) * 4 + dstPos >= 32) {	        throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 32");	    }	    int out = dstInit;	    int shift = 0;	    for (int i = 0; i < nHex; i++) {	        shift = i * 4 + dstPos;	        final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift;	        final int mask = 0xf << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
public boolean contains(final T element) {	    if (element == null) {	        return false;	    }	    return comparator.compare(element, minimum) > -1 && comparator.compare(element, maximum) < 1;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static Class<?> getRawType(final Type type, final Type assigningType) {	    if (type instanceof Class<?>) {	        return (Class<?>) type;	    }	    if (type instanceof ParameterizedType) {	        return getRawType((ParameterizedType) type);	    }	    if (type instanceof TypeVariable<?>) {	        if (assigningType == null) {	            return null;	        }	        final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration();	        if (!(genericDeclaration instanceof Class<?>)) {	            return null;	        }	        final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType, (Class<?>) genericDeclaration);	        if (typeVarAssigns == null) {	            return null;	        }	        final Type typeArgument = typeVarAssigns.get(type);	        if (typeArgument == null) {	            return null;	        }	        return getRawType(typeArgument, assigningType);	    }	    if (type instanceof GenericArrayType) {	        final Class<?> rawComponentType = getRawType(((GenericArrayType) type).getGenericComponentType(), assigningType);	        return Array.newInstance(rawComponentType, 0).getClass();	    }	    if (type instanceof WildcardType) {	        return null;	    }	    throw new IllegalArgumentException("unknown type: " + type);	}
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, true);	}
public int size() {	    return size;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public int size() {	    return size;	}
public String[] getExcludeFieldNames() {	    return this.excludeFieldNames.clone();	}
public char getEnd() {	    return this.end;	}
static JavaVersion get(final String nom) {	    if ("0.9".equals(nom)) {	        return JAVA_0_9;	    } else if ("1.1".equals(nom)) {	        return JAVA_1_1;	    } else if ("1.2".equals(nom)) {	        return JAVA_1_2;	    } else if ("1.3".equals(nom)) {	        return JAVA_1_3;	    } else if ("1.4".equals(nom)) {	        return JAVA_1_4;	    } else if ("1.5".equals(nom)) {	        return JAVA_1_5;	    } else if ("1.6".equals(nom)) {	        return JAVA_1_6;	    } else if ("1.7".equals(nom)) {	        return JAVA_1_7;	    } else if ("1.8".equals(nom)) {	        return JAVA_1_8;	    } else {	        return null;	    }	}
public static boolean isBlank(final CharSequence cs) {	    int strLen;	    if (cs == null || (strLen = cs.length()) == 0) {	        return true;	    }	    for (int i = 0; i < strLen; i++) {	        if (Character.isWhitespace(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static String substringAfterLast(final String str, final String separator) {	    if (isEmpty(str)) {	        return str;	    }	    if (isEmpty(separator)) {	        return EMPTY;	    }	    final int pos = str.lastIndexOf(separator);	    if (pos == INDEX_NOT_FOUND || pos == str.length() - separator.length()) {	        return EMPTY;	    }	    return str.substring(pos + separator.length());	}
public static String substringBefore(final String str, final String separator) {	    if (isEmpty(str) || separator == null) {	        return str;	    }	    if (separator.isEmpty()) {	        return EMPTY;	    }	    final int pos = str.indexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return str;	    }	    return str.substring(0, pos);	}
public static double[] addAll(final double[] array1, final double... array2) {	    if (array1 == null) {	        return clone(array2);	    } else if (array2 == null) {	        return clone(array1);	    }	    final double[] joinedArray = new double[array1.length + array2.length];	    System.arraycopy(array1, 0, joinedArray, 0, array1.length);	    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);	    return joinedArray;	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public String getNullText() {	    return nullText;	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
@Override	public StringBuffer format(final Calendar calendar, final StringBuffer buf) {	    return applyRules(calendar, buf);	}
@Override	public int length() {	    return size;	}
public static <T> T CONST(final T v) {	    return v;	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
protected String getArraySeparator() {	    return arraySeparator;	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
@Override	public String previous() {	    if (hasPrevious()) {	        return tokens[--tokenPos];	    }	    throw new NoSuchElementException();	}
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = Integer.MAX_VALUE;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.indexOf(str, search, 0);	        if (tmp == INDEX_NOT_FOUND) {	            continue;	        }	        if (tmp < ret) {	            ret = tmp;	        }	    }	    return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;	}
public static String substringAfter(final String str, final String separator) {	    if (isEmpty(str)) {	        return str;	    }	    if (separator == null) {	        return EMPTY;	    }	    final int pos = str.indexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return EMPTY;	    }	    return str.substring(pos + separator.length());	}
public boolean isEquals() {	    return this.isEquals;	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
protected String getSizeStartText() {	    return sizeStartText;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public void suspend() {	    if (this.runningState != STATE_RUNNING) {	        throw new IllegalStateException("Stopwatch must be running to suspend. ");	    }	    this.stopTime = System.nanoTime();	    this.runningState = STATE_SUSPENDED;	}
public static int toIntValue(final Character ch, final int defaultValue) {	    if (ch == null) {	        return defaultValue;	    }	    return toIntValue(ch.charValue(), defaultValue);	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts) {	    if ((src.length == 0 && srcPos == 0) || 0 == nInts) {	        return dstInit;	    }	    if ((nInts - 1) * 32 + dstPos >= 64) {	        throw new IllegalArgumentException("(nInts-1)*32+dstPos is greather or equal to than 64");	    }	    long out = dstInit;	    int shift = 0;	    for (int i = 0; i < nInts; i++) {	        shift = i * 32 + dstPos;	        final long bits = ((0xffffffffL & src[i + srcPos]) << shift);	        final long mask = 0xffffffffL << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
protected abstract T initialize() throws Exception;
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
@Override	public void mark(final int readAheadLimit) {	    mark = pos;	}
public StrTokenizer setDelimiterChar(final char delim) {	    return setDelimiterMatcher(StrMatcher.charMatcher(delim));	}
public static Date round(final Object date, final int field) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (date instanceof Date) {	        return round((Date) date, field);	    } else if (date instanceof Calendar) {	        return round((Calendar) date, field).getTime();	    } else {	        throw new ClassCastException("Could not round " + date);	    }	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static boolean isDigits(final String str) {	    if (StringUtils.isEmpty(str)) {	        return false;	    }	    for (int i = 0; i < str.length(); i++) {	        if (!Character.isDigit(str.charAt(i))) {	            return false;	        }	    }	    return true;	}
public StrBuilder ensureCapacity(final int capacity) {	    if (capacity > buffer.length) {	        final char[] old = buffer;	        buffer = new char[capacity * 2];	        System.arraycopy(old, 0, buffer, 0, size);	    }	    return this;	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
@Override	public T call() throws Exception {	    try {	        return initialize();	    } finally {	        if (execFinally != null) {	            execFinally.shutdown();	        }	    }	}
public StrBuilder deleteAll(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, -1);	}
private static Date add(final Date date, final int calendarField, final int amount) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final Calendar c = Calendar.getInstance();	    c.setTime(date);	    c.add(calendarField, amount);	    return c.getTime();	}
@Override	public int hashCode() {	    return (getLeft() == null ? 0 : getLeft().hashCode()) ^ (getMiddle() == null ? 0 : getMiddle().hashCode()) ^ (getRight() == null ? 0 : getRight().hashCode());	}
public int capacity() {	    return buffer.length;	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public boolean isEmpty() {	    return size == 0;	}
public Float toFloat() {	    return Float.valueOf(floatValue());	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public String getNullText() {	    return nullText;	}
public boolean isEmptyTokenAsNull() {	    return this.emptyAsNull;	}
public boolean isEmpty() {	    return size == 0;	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
public StrBuilder ensureCapacity(final int capacity) {	    if (capacity > buffer.length) {	        final char[] old = buffer;	        buffer = new char[capacity * 2];	        System.arraycopy(old, 0, buffer, 0, size);	    }	    return this;	}
protected boolean isUseClassName() {	    return useClassName;	}
public static boolean isNumeric(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isDigit(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
static boolean isRegistered(final Object lhs, final Object rhs) {	    final Set<Pair<IDKey, IDKey>> registry = getRegistry();	    final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);	    final Pair<IDKey, IDKey> swappedPair = Pair.of(pair.getLeft(), pair.getRight());	    return registry != null && (registry.contains(pair) || registry.contains(swappedPair));	}
public final synchronized void setExternalExecutor(final ExecutorService externalExecutor) {	    if (isStarted()) {	        throw new IllegalStateException("Cannot set ExecutorService after start()!");	    }	    this.externalExecutor = externalExecutor;	}
public Fraction pow(final int power) {	    if (power == 1) {	        return this;	    } else if (power == 0) {	        return ONE;	    } else if (power < 0) {	        if (power == Integer.MIN_VALUE) {	            return this.invert().pow(2).pow(-(power / 2));	        }	        return this.invert().pow(-power);	    } else {	        final Fraction f = this.multiplyBy(this);	        if (power % 2 == 0) {	            return f.pow(power / 2);	        } else {	            return f.pow(power / 2).multiplyBy(this);	        }	    }	}
public String getNewLineText() {	    return newLine;	}
public boolean isEquals() {	    return this.isEquals;	}
public char getEnd() {	    return this.end;	}
public String getNullText() {	    return nullText;	}
@Override	public String getPattern() {	    return mPattern;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static String abbreviateMiddle(final String str, final String middle, final int length) {	    if (isEmpty(str) || isEmpty(middle)) {	        return str;	    }	    if (length >= str.length() || length < middle.length() + 2) {	        return str;	    }	    final int targetSting = length - middle.length();	    final int startOffset = targetSting / 2 + targetSting % 2;	    final int endOffset = str.length() - targetSting / 2;	    final StringBuilder builder = new StringBuilder(length);	    builder.append(str.substring(0, startOffset));	    builder.append(middle);	    builder.append(str.substring(endOffset));	    return builder.toString();	}
public short getShortRawValue(final short holder) {	    return (short) getRawValue(holder);	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
public static String formatUTC(final Date date, final String pattern, final Locale locale) {	    return format(date, pattern, UTC_TIME_ZONE, locale);	}
public boolean isAppendStatics() {	    return this.appendStatics;	}
@Override	public boolean equals(final Object obj) {	    if (!(obj instanceof FastDateParser)) {	        return false;	    }	    final FastDateParser other = (FastDateParser) obj;	    return pattern.equals(other.pattern) && timeZone.equals(other.timeZone) && locale.equals(other.locale);	}
public HashCodeBuilder appendSuper(final int superHashCode) {	    iTotal = iTotal * iConstant + superHashCode;	    return this;	}
private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass) {	    if (throwable == null || type == null) {	        return -1;	    }	    if (fromIndex < 0) {	        fromIndex = 0;	    }	    final Throwable[] throwables = ExceptionUtils.getThrowables(throwable);	    if (fromIndex >= throwables.length) {	        return -1;	    }	    if (subclass) {	        for (int i = fromIndex; i < throwables.length; i++) {	            if (type.isAssignableFrom(throwables[i].getClass())) {	                return i;	            }	        }	    } else {	        for (int i = fromIndex; i < throwables.length; i++) {	            if (type.equals(throwables[i].getClass())) {	                return i;	            }	        }	    }	    return -1;	}
public static boolean containsNone(final CharSequence cs, final String invalidChars) {	    if (cs == null || invalidChars == null) {	        return true;	    }	    return containsNone(cs, invalidChars.toCharArray());	}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    buffer.append(arrayStart);	    for (int i = 0; i < array.length; i++) {	        if (i > 0) {	            buffer.append(arraySeparator);	        }	        appendDetail(buffer, fieldName, array[i]);	    }	    buffer.append(arrayEnd);	}
protected String getSizeStartText() {	    return sizeStartText;	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public StrBuilder replaceAll(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, -1);	}
protected String getArrayEnd() {	    return arrayEnd;	}
public static boolean[] clone(final boolean[] array) {	    if (array == null) {	        return null;	    }	    return array.clone();	}
@Override	public void mark(final int readAheadLimit) {	    mark = pos;	}
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = Integer.MAX_VALUE;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.indexOf(str, search, 0);	        if (tmp == INDEX_NOT_FOUND) {	            continue;	        }	        if (tmp < ret) {	            ret = tmp;	        }	    }	    return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;	}
public void increment() {	    value++;	}
public static String center(String str, final int size, String padStr) {	    if (str == null || size <= 0) {	        return str;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    str = leftPad(str, strLen + pads / 2, padStr);	    str = rightPad(str, size, padStr);	    return str;	}
public String getNewLineText() {	    return newLine;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public Fraction pow(final int power) {	    if (power == 1) {	        return this;	    } else if (power == 0) {	        return ONE;	    } else if (power < 0) {	        if (power == Integer.MIN_VALUE) {	            return this.invert().pow(2).pow(-(power / 2));	        }	        return this.invert().pow(-power);	    } else {	        final Fraction f = this.multiplyBy(this);	        if (power % 2 == 0) {	            return f.pow(power / 2);	        } else {	            return f.pow(power / 2).multiplyBy(this);	        }	    }	}
public static int indexOfAnyBut(final CharSequence seq, final CharSequence searchChars) {	    if (isEmpty(seq) || isEmpty(searchChars)) {	        return INDEX_NOT_FOUND;	    }	    final int strLen = seq.length();	    for (int i = 0; i < strLen; i++) {	        final char ch = seq.charAt(i);	        final boolean chFound = CharSequenceUtils.indexOf(searchChars, ch, 0) >= 0;	        if (i + 1 < strLen && Character.isHighSurrogate(ch)) {	            final char ch2 = seq.charAt(i + 1);	            if (chFound && CharSequenceUtils.indexOf(searchChars, ch2, 0) < 0) {	                return i;	            }	        } else {	            if (!chFound) {	                return i;	            }	        }	    }	    return INDEX_NOT_FOUND;	}
public char getEnd() {	    return this.end;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
private static Date add(final Date date, final int calendarField, final int amount) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final Calendar c = Calendar.getInstance();	    c.setTime(date);	    c.add(calendarField, amount);	    return c.getTime();	}
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException {	    return charsetName == null ? new String(bytes) : new String(bytes, charsetName);	}
public static String replacePattern(final String source, final String regex, final String replacement) {	    return Pattern.compile(regex, Pattern.DOTALL).matcher(source).replaceAll(replacement);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static final String escapeXml(final String input) {	    return ESCAPE_XML.translate(input);	}
public static boolean isJavaVersionAtLeast(final JavaVersion requiredVersion) {	    return JAVA_SPECIFICATION_VERSION_AS_ENUM.atLeast(requiredVersion);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public StringBuilder toStringBuilder() {	    return new StringBuilder(size).append(buffer, 0, size);	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static int reflectionHashCode(final Object object, final String... excludeFields) {	    return reflectionHashCode(17, 37, object, false, null, excludeFields);	}
protected String getSizeEndText() {	    return sizeEndText;	}
public boolean isEmpty() {	    return size == 0;	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public static Class<?>[] wrappersToPrimitives(final Class<?>... classes) {	    if (classes == null) {	        return null;	    }	    if (classes.length == 0) {	        return classes;	    }	    final Class<?>[] convertedClasses = new Class[classes.length];	    for (int i = 0; i < classes.length; i++) {	        convertedClasses[i] = wrapperToPrimitive(classes[i]);	    }	    return convertedClasses;	}
public void subtract(final Number operand) {	    this.value -= operand.shortValue();	}
public boolean isEmptyTokenAsNull() {	    return this.emptyAsNull;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static Class<?> primitiveToWrapper(final Class<?> cls) {	    Class<?> convertedClass = cls;	    if (cls != null && cls.isPrimitive()) {	        convertedClass = primitiveWrapperMap.get(cls);	    }	    return convertedClass;	}
public static String trim(final String str) {	    return str == null ? null : str.trim();	}
public StrBuilder replaceAll(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, -1);	}
private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) {	    if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {	        return text;	    }	    if (timeToLive < 0) {	        throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another");	    }	    final int searchLength = searchList.length;	    final int replacementLength = replacementList.length;	    if (searchLength != replacementLength) {	        throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength);	    }	    final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];	    int textIndex = -1;	    int replaceIndex = -1;	    int tempIndex = -1;	    for (int i = 0; i < searchLength; i++) {	        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {	            continue;	        }	        tempIndex = text.indexOf(searchList[i]);	        if (tempIndex == -1) {	            noMoreMatchesForReplIndex[i] = true;	        } else {	            if (textIndex == -1 || tempIndex < textIndex) {	                textIndex = tempIndex;	                replaceIndex = i;	            }	        }	    }	    if (textIndex == -1) {	        return text;	    }	    int start = 0;	    int increase = 0;	    for (int i = 0; i < searchList.length; i++) {	        if (searchList[i] == null || replacementList[i] == null) {	            continue;	        }	        final int greater = replacementList[i].length() - searchList[i].length();	        if (greater > 0) {	            increase += 3 * greater;	        }	    }	    increase = Math.min(increase, text.length() / 5);	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (textIndex != -1) {	        for (int i = start; i < textIndex; i++) {	            buf.append(text.charAt(i));	        }	        buf.append(replacementList[replaceIndex]);	        start = textIndex + searchList[replaceIndex].length();	        textIndex = -1;	        replaceIndex = -1;	        tempIndex = -1;	        for (int i = 0; i < searchLength; i++) {	            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {	                continue;	            }	            tempIndex = text.indexOf(searchList[i], start);	            if (tempIndex == -1) {	                noMoreMatchesForReplIndex[i] = true;	            } else {	                if (textIndex == -1 || tempIndex < textIndex) {	                    textIndex = tempIndex;	                    replaceIndex = i;	                }	            }	        }	    }	    final int textLength = text.length();	    for (int i = start; i < textLength; i++) {	        buf.append(text.charAt(i));	    }	    final String result = buf.toString();	    if (!repeat) {	        return result;	    }	    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static boolean isAlphaSpace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false && cs.charAt(i) != ' ') {	            return false;	        }	    }	    return true;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
private static String[] splitByCharacterType(final String str, final boolean camelCase) {	    if (str == null) {	        return null;	    }	    if (str.isEmpty()) {	        return ArrayUtils.EMPTY_STRING_ARRAY;	    }	    final char[] c = str.toCharArray();	    final List<String> list = new ArrayList<String>();	    int tokenStart = 0;	    int currentType = Character.getType(c[tokenStart]);	    for (int pos = tokenStart + 1; pos < c.length; pos++) {	        final int type = Character.getType(c[pos]);	        if (type == currentType) {	            continue;	        }	        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {	            final int newTokenStart = pos - 1;	            if (newTokenStart != tokenStart) {	                list.add(new String(c, tokenStart, newTokenStart - tokenStart));	                tokenStart = newTokenStart;	            }	        } else {	            list.add(new String(c, tokenStart, pos - tokenStart));	            tokenStart = pos;	        }	        currentType = type;	    }	    list.add(new String(c, tokenStart, c.length - tokenStart));	    return list.toArray(new String[list.size()]);	}
public static boolean isSameType(final Object array1, final Object array2) {	    if (array1 == null || array2 == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    return array1.getClass().getName().equals(array2.getClass().getName());	}
public static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) {	    if (0 == nBools) {	        return dst;	    }	    if (nBools - 1 + srcPos >= 32) {	        throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 32");	    }	    int shift = 0;	    for (int i = 0; i < nBools; i++) {	        shift = i * 1 + srcPos;	        dst[dstPos + i] = ((0x1 & (src >> shift)) != 0);	    }	    return dst;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
@Override	public int compareTo(final MutableLong other) {	    final long anotherVal = other.value;	    return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1);	}
public char getStart() {	    return this.start;	}
public static String[] stripAll(final String[] strs, final String stripChars) {	    int strsLen;	    if (strs == null || (strsLen = strs.length) == 0) {	        return strs;	    }	    final String[] newArr = new String[strsLen];	    for (int i = 0; i < strsLen; i++) {	        newArr[i] = strip(strs[i], stripChars);	    }	    return newArr;	}
public static String randomAscii(final int count) {	    return random(count, 32, 127, false, false);	}
public String getNullText() {	    return nullText;	}
public static final String escapeJava(final String input) {	    return ESCAPE_JAVA.translate(input);	}
@Override	public Date parse(final String source, final ParsePosition pos) {	    final int offset = pos.getIndex();	    final Matcher matcher = parsePattern.matcher(source.substring(offset));	    if (!matcher.lookingAt()) {	        return null;	    }	    final Calendar cal = Calendar.getInstance(timeZone, locale);	    cal.clear();	    for (int i = 0; i < strategies.length; ) {	        final Strategy strategy = strategies[i++];	        strategy.setCalendar(this, cal, matcher.group(i));	    }	    pos.setIndex(offset + matcher.end());	    return cal.getTime();	}
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = Integer.MAX_VALUE;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.indexOf(str, search, 0);	        if (tmp == INDEX_NOT_FOUND) {	            continue;	        }	        if (tmp < ret) {	            ret = tmp;	        }	    }	    return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;	}
public String getNewLineText() {	    return newLine;	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static int reflectionHashCode(final Object object, final String... excludeFields) {	    return reflectionHashCode(17, 37, object, false, null, excludeFields);	}
public void start() {	    if (this.runningState == STATE_STOPPED) {	        throw new IllegalStateException("Stopwatch must be reset before being restarted. ");	    }	    if (this.runningState != STATE_UNSTARTED) {	        throw new IllegalStateException("Stopwatch already started. ");	    }	    this.startTime = System.nanoTime();	    this.startTimeMillis = System.currentTimeMillis();	    this.runningState = STATE_RUNNING;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public int size() {	    return size;	}
public StrBuilder reverse() {	    if (size == 0) {	        return this;	    }	    final int half = size / 2;	    final char[] buf = buffer;	    for (int leftIdx = 0, rightIdx = size - 1; leftIdx < half; leftIdx++, rightIdx--) {	        final char swap = buf[leftIdx];	        buf[leftIdx] = buf[rightIdx];	        buf[rightIdx] = swap;	    }	    return this;	}
public static char binaryToHexDigit(final boolean[] src, final int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    if (src.length > srcPos + 3 && src[srcPos + 3]) {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src[srcPos]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
@Override	public int length() {	    return size;	}
public static ConcurrentException extractCause(final ExecutionException ex) {	    if (ex == null || ex.getCause() == null) {	        return null;	    }	    throwCause(ex);	    return new ConcurrentException(ex.getMessage(), ex.getCause());	}
public static int toInt(final String str, final int defaultValue) {	    if (str == null) {	        return defaultValue;	    }	    try {	        return Integer.parseInt(str);	    } catch (final NumberFormatException nfe) {	        return defaultValue;	    }	}
public static String center(String str, final int size, String padStr) {	    if (str == null || size <= 0) {	        return str;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    str = leftPad(str, strLen + pads / 2, padStr);	    str = rightPad(str, size, padStr);	    return str;	}
@Override	public int length() {	    return size;	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
public static float min(final float a, final float b, final float c) {	    return Math.min(Math.min(a, b), c);	}
public StrBuilder setNullText(String nullText) {	    if (nullText != null && nullText.isEmpty()) {	        nullText = null;	    }	    this.nullText = nullText;	    return this;	}
@Override	public boolean ready() {	    return pos < StrBuilder.this.size();	}
public int size() {	    return size;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public Writer asWriter() {	    return new StrBuilderWriter();	}
@Override	public void setFormats(final Format[] newFormats) {	    throw new UnsupportedOperationException();	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) {	    if (cls == null) {	        throw new IllegalArgumentException("The class must not be null");	    }	    if (fieldName == null) {	        throw new IllegalArgumentException("The field name must not be null");	    }	    for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) {	        try {	            final Field field = acls.getDeclaredField(fieldName);	            if (!Modifier.isPublic(field.getModifiers())) {	                if (forceAccess) {	                    field.setAccessible(true);	                } else {	                    continue;	                }	            }	            return field;	        } catch (final NoSuchFieldException ex) {	        }	    }	    Field match = null;	    for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) {	        try {	            final Field test = ((Class<?>) class1).getField(fieldName);	            if (match != null) {	                throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + "; a matching field exists on two or more implemented interfaces.");	            }	            match = test;	        } catch (final NoSuchFieldException ex) {	        }	    }	    return match;	}
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {	    if (array == null) {	        if (index != 0) {	            throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0");	        }	        final Object joinedArray = Array.newInstance(clss, 1);	        Array.set(joinedArray, 0, element);	        return joinedArray;	    }	    final int length = Array.getLength(array);	    if (index > length || index < 0) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(clss, length + 1);	    System.arraycopy(array, 0, result, 0, index);	    Array.set(result, index, element);	    if (index < length) {	        System.arraycopy(array, index, result, index + 1, length - index);	    }	    return result;	}
public static String getPackageName(String className) {	    if (StringUtils.isEmpty(className)) {	        return StringUtils.EMPTY;	    }	    while (className.charAt(0) == '[') {	        className = className.substring(1);	    }	    if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {	        className = className.substring(1);	    }	    final int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);	    if (i == -1) {	        return StringUtils.EMPTY;	    }	    return className.substring(0, i);	}
@Override	public void setValue(final Number value) {	    this.value = value.floatValue();	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static String prependIfMissingIgnoreCase(final String str, final CharSequence prefix, final CharSequence... prefixes) {	    return prependIfMissing(str, prefix, true, prefixes);	}
public StrSubstitutor setVariableSuffix(final String suffix) {	    if (suffix == null) {	        throw new IllegalArgumentException("Variable suffix must not be null!");	    }	    return setVariableSuffixMatcher(StrMatcher.stringMatcher(suffix));	}
public int size() {	    return size;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
protected String getSizeStartText() {	    return sizeStartText;	}
@Override	public int length() {	    return size;	}
public void stop() {	    if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {	        throw new IllegalStateException("Stopwatch is not running. ");	    }	    if (this.runningState == STATE_RUNNING) {	        this.stopTime = System.nanoTime();	    }	    this.runningState = STATE_STOPPED;	}
static void register(final Object lhs, final Object rhs) {	    synchronized (EqualsBuilder.class) {	        if (getRegistry() == null) {	            REGISTRY.set(new HashSet<Pair<IDKey, IDKey>>());	        }	    }	    final Set<Pair<IDKey, IDKey>> registry = getRegistry();	    final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);	    registry.add(pair);	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
protected String getContentStart() {	    return contentStart;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) {	    if (str == null) {	        if (trueString == null) {	            return Boolean.TRUE;	        }	        if (falseString == null) {	            return Boolean.FALSE;	        }	        if (nullString == null) {	            return null;	        }	    } else if (str.equals(trueString)) {	        return Boolean.TRUE;	    } else if (str.equals(falseString)) {	        return Boolean.FALSE;	    } else if (str.equals(nullString)) {	        return null;	    }	    throw new IllegalArgumentException("The String did not match any specified value");	}
public void stop() {	    if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {	        throw new IllegalStateException("Stopwatch is not running. ");	    }	    if (this.runningState == STATE_RUNNING) {	        this.stopTime = System.nanoTime();	    }	    this.runningState = STATE_STOPPED;	}
@Override	public Integer build() {	    return Integer.valueOf(toHashCode());	}
protected void appendClassName(final StringBuffer buffer, final Object object) {	    if (useClassName && object != null) {	        register(object);	        if (useShortClassName) {	            buffer.append(getShortClassName(object.getClass()));	        } else {	            buffer.append(object.getClass().getName());	        }	    }	}
public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) {	    if (toClass == null) {	        return false;	    }	    if (cls == null) {	        return !toClass.isPrimitive();	    }	    if (autoboxing) {	        if (cls.isPrimitive() && !toClass.isPrimitive()) {	            cls = primitiveToWrapper(cls);	            if (cls == null) {	                return false;	            }	        }	        if (toClass.isPrimitive() && !cls.isPrimitive()) {	            cls = wrapperToPrimitive(cls);	            if (cls == null) {	                return false;	            }	        }	    }	    if (cls.equals(toClass)) {	        return true;	    }	    if (cls.isPrimitive()) {	        if (toClass.isPrimitive() == false) {	            return false;	        }	        if (Integer.TYPE.equals(cls)) {	            return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Long.TYPE.equals(cls)) {	            return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Boolean.TYPE.equals(cls)) {	            return false;	        }	        if (Double.TYPE.equals(cls)) {	            return false;	        }	        if (Float.TYPE.equals(cls)) {	            return Double.TYPE.equals(toClass);	        }	        if (Character.TYPE.equals(cls)) {	            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Short.TYPE.equals(cls)) {	            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Byte.TYPE.equals(cls)) {	            return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        return false;	    }	    return toClass.isAssignableFrom(cls);	}
private static String[] splitByCharacterType(final String str, final boolean camelCase) {	    if (str == null) {	        return null;	    }	    if (str.isEmpty()) {	        return ArrayUtils.EMPTY_STRING_ARRAY;	    }	    final char[] c = str.toCharArray();	    final List<String> list = new ArrayList<String>();	    int tokenStart = 0;	    int currentType = Character.getType(c[tokenStart]);	    for (int pos = tokenStart + 1; pos < c.length; pos++) {	        final int type = Character.getType(c[pos]);	        if (type == currentType) {	            continue;	        }	        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {	            final int newTokenStart = pos - 1;	            if (newTokenStart != tokenStart) {	                list.add(new String(c, tokenStart, newTokenStart - tokenStart));	                tokenStart = newTokenStart;	            }	        } else {	            list.add(new String(c, tokenStart, pos - tokenStart));	            tokenStart = pos;	        }	        currentType = type;	    }	    list.add(new String(c, tokenStart, c.length - tokenStart));	    return list.toArray(new String[list.size()]);	}
public static boolean isAlpha(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
protected boolean isFieldSeparatorAtStart() {	    return fieldSeparatorAtStart;	}
protected void appendIdentityHashCode(final StringBuffer buffer, final Object object) {	    if (this.isUseIdentityHashCode() && object != null) {	        register(object);	        buffer.append('@');	        buffer.append(Integer.toHexString(System.identityHashCode(object)));	    }	}
public static boolean isSameLength(final boolean[] array1, final boolean[] array2) {	    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {	        return false;	    }	    return true;	}
public static String toStringYesNo(final boolean bool) {	    return toString(bool, "yes", "no");	}
protected String getArrayStart() {	    return arrayStart;	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public boolean isEmpty() {	    return size == 0;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public int toComparison() {	    return comparison;	}
public static int toIntValue(final Character ch, final int defaultValue) {	    if (ch == null) {	        return defaultValue;	    }	    return toIntValue(ch.charValue(), defaultValue);	}
public static boolean[] removeElements(final boolean[] array, final boolean... values) {	    if (isEmpty(array) || isEmpty(values)) {	        return clone(array);	    }	    final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2);	    for (final boolean v : values) {	        final Boolean boxed = Boolean.valueOf(v);	        final MutableInt count = occurrences.get(boxed);	        if (count == null) {	            occurrences.put(boxed, new MutableInt(1));	        } else {	            count.increment();	        }	    }	    final BitSet toRemove = new BitSet();	    for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) {	        final Boolean v = e.getKey();	        int found = 0;	        for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {	            found = indexOf(array, v.booleanValue(), found);	            if (found < 0) {	                break;	            }	            toRemove.set(found++);	        }	    }	    return (boolean[]) removeAll(array, toRemove);	}
public static String trim(final String str) {	    return str == null ? null : str.trim();	}
public static String getRootCauseMessage(final Throwable th) {	    Throwable root = ExceptionUtils.getRootCause(th);	    root = root == null ? th : root;	    return getMessage(root);	}
public static String stripToEmpty(final String str) {	    return str == null ? EMPTY : strip(str, null);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public StrBuilder deleteAll(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, -1);	}
public final Integer getPriority() {	    return priority;	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) {	    if (s == null || t == null) {	        throw new IllegalArgumentException("Strings must not be null");	    }	    if (threshold < 0) {	        throw new IllegalArgumentException("Threshold must not be negative");	    }	    int n = s.length();	    int m = t.length();	    if (n == 0) {	        return m <= threshold ? m : -1;	    } else if (m == 0) {	        return n <= threshold ? n : -1;	    }	    if (n > m) {	        final CharSequence tmp = s;	        s = t;	        t = tmp;	        n = m;	        m = t.length();	    }	    int[] p = new int[n + 1];	    int[] d = new int[n + 1];	    int[] _d;	    final int boundary = Math.min(n, threshold) + 1;	    for (int i = 0; i < boundary; i++) {	        p[i] = i;	    }	    Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);	    Arrays.fill(d, Integer.MAX_VALUE);	    for (int j = 1; j <= m; j++) {	        final char t_j = t.charAt(j - 1);	        d[0] = j;	        final int min = Math.max(1, j - threshold);	        final int max = Math.min(n, j + threshold);	        if (min > max) {	            return -1;	        }	        if (min > 1) {	            d[min - 1] = Integer.MAX_VALUE;	        }	        for (int i = min; i <= max; i++) {	            if (s.charAt(i - 1) == t_j) {	                d[i] = p[i - 1];	            } else {	                d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);	            }	        }	        _d = p;	        p = d;	        d = _d;	    }	    if (p[n] <= threshold) {	        return p[n];	    }	    return -1;	}
public static Boolean[] toObject(final boolean[] array) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    final Boolean[] result = new Boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        result[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE);	    }	    return result;	}
public String getNullText() {	    return nullText;	}
public static Class<?>[] primitivesToWrappers(final Class<?>... classes) {	    if (classes == null) {	        return null;	    }	    if (classes.length == 0) {	        return classes;	    }	    final Class<?>[] convertedClasses = new Class[classes.length];	    for (int i = 0; i < classes.length; i++) {	        convertedClasses[i] = primitiveToWrapper(classes[i]);	    }	    return convertedClasses;	}
public static void isTrue(final boolean expression) {	    if (expression == false) {	        throw new IllegalArgumentException(DEFAULT_IS_TRUE_EX_MESSAGE);	    }	}
public static boolean isAsciiAlpha(final char ch) {	    return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');	}
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] result = new boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        final Boolean b = array[i];	        result[i] = (b == null ? valueForNull : b.booleanValue());	    }	    return result;	}
protected boolean isArrayContentDetail() {	    return arrayContentDetail;	}
public static <T> T clone(final T obj) {	    if (obj instanceof Cloneable) {	        final Object result;	        if (obj.getClass().isArray()) {	            final Class<?> componentType = obj.getClass().getComponentType();	            if (!componentType.isPrimitive()) {	                result = ((Object[]) obj).clone();	            } else {	                int length = Array.getLength(obj);	                result = Array.newInstance(componentType, length);	                while (length-- > 0) {	                    Array.set(result, length, Array.get(obj, length));	                }	            }	        } else {	            try {	                final Method clone = obj.getClass().getMethod("clone");	                result = clone.invoke(obj);	            } catch (final NoSuchMethodException e) {	                throw new CloneFailedException("Cloneable type " + obj.getClass().getName() + " has no clone method", e);	            } catch (final IllegalAccessException e) {	                throw new CloneFailedException("Cannot clone Cloneable type " + obj.getClass().getName(), e);	            } catch (final InvocationTargetException e) {	                throw new CloneFailedException("Exception cloning Cloneable type " + obj.getClass().getName(), e.getCause());	            }	        }	        @SuppressWarnings("unchecked")	        final T checked = (T) result;	        return checked;	    }	    return null;	}
@Override	public String toString() {	    if (this.getObject() == null) {	        return this.getStyle().getNullText();	    }	    Class<?> clazz = this.getObject().getClass();	    this.appendFieldsIn(clazz);	    while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {	        clazz = clazz.getSuperclass();	        this.appendFieldsIn(clazz);	    }	    return super.toString();	}
public static ConcurrentException extractCause(final ExecutionException ex) {	    if (ex == null || ex.getCause() == null) {	        return null;	    }	    throwCause(ex);	    return new ConcurrentException(ex.getMessage(), ex.getCause());	}
public static boolean isEmpty(final boolean[] array) {	    return array == null || array.length == 0;	}
public static String repeat(final char ch, final int repeat) {	    final char[] buf = new char[repeat];	    for (int i = repeat - 1; i >= 0; i--) {	        buf[i] = ch;	    }	    return new String(buf);	}
@Override	public int length() {	    return size;	}
@Override	public T call() throws Exception {	    try {	        return initialize();	    } finally {	        if (execFinally != null) {	            execFinally.shutdown();	        }	    }	}
public char getEscapeChar() {	    return this.escapeChar;	}
public char getEscapeChar() {	    return this.escapeChar;	}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    buffer.append(arrayStart);	    for (int i = 0; i < array.length; i++) {	        if (i > 0) {	            buffer.append(arraySeparator);	        }	        appendDetail(buffer, fieldName, array[i]);	    }	    buffer.append(arrayEnd);	}
public final synchronized void setLimit(final int limit) {	    this.limit = limit;	}
public static <T extends CharSequence> T validIndex(final T chars, final int index) {	    return validIndex(chars, index, DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE, Integer.valueOf(index));	}
public static boolean containsOnly(final CharSequence cs, final String validChars) {	    if (cs == null || validChars == null) {	        return false;	    }	    return containsOnly(cs, validChars.toCharArray());	}
public static boolean startsWithIgnoreCase(final CharSequence str, final CharSequence prefix) {	    return startsWith(str, prefix, true);	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static String lowerCase(final String str, final Locale locale) {	    if (str == null) {	        return null;	    }	    return str.toLowerCase(locale);	}
protected boolean isFieldSeparatorAtStart() {	    return fieldSeparatorAtStart;	}
public static int indexOfDifference(final CharSequence... css) {	    if (css == null || css.length <= 1) {	        return INDEX_NOT_FOUND;	    }	    boolean anyStringNull = false;	    boolean allStringsNull = true;	    final int arrayLen = css.length;	    int shortestStrLen = Integer.MAX_VALUE;	    int longestStrLen = 0;	    for (int i = 0; i < arrayLen; i++) {	        if (css[i] == null) {	            anyStringNull = true;	            shortestStrLen = 0;	        } else {	            allStringsNull = false;	            shortestStrLen = Math.min(css[i].length(), shortestStrLen);	            longestStrLen = Math.max(css[i].length(), longestStrLen);	        }	    }	    if (allStringsNull || longestStrLen == 0 && !anyStringNull) {	        return INDEX_NOT_FOUND;	    }	    if (shortestStrLen == 0) {	        return 0;	    }	    int firstDiff = -1;	    for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {	        final char comparisonChar = css[0].charAt(stringPos);	        for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {	            if (css[arrayPos].charAt(stringPos) != comparisonChar) {	                firstDiff = stringPos;	                break;	            }	        }	        if (firstDiff != -1) {	            break;	        }	    }	    if (firstDiff == -1 && shortestStrLen != longestStrLen) {	        return shortestStrLen;	    }	    return firstDiff;	}
protected String getFieldSeparator() {	    return fieldSeparator;	}
protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    appendSummarySize(buffer, fieldName, array.length);	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static Boolean[] toObject(final boolean[] array) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    final Boolean[] result = new Boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        result[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE);	    }	    return result;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
private static Date add(final Date date, final int calendarField, final int amount) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final Calendar c = Calendar.getInstance();	    c.setTime(date);	    c.add(calendarField, amount);	    return c.getTime();	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public StrTokenizer setQuoteMatcher(final StrMatcher quote) {	    if (quote != null) {	        this.quoteMatcher = quote;	    }	    return this;	}
public StrBuilder appendSeparator(final char separator, final int loopIndex) {	    if (loopIndex > 0) {	        append(separator);	    }	    return this;	}
public boolean isEquals() {	    return this.isEquals;	}
protected List<String> tokenize(final char[] chars, final int offset, final int count) {	    if (chars == null || count == 0) {	        return Collections.emptyList();	    }	    final StrBuilder buf = new StrBuilder();	    final List<String> tokens = new ArrayList<String>();	    int pos = offset;	    while (pos >= 0 && pos < count) {	        pos = readNextToken(chars, pos, count, buf, tokens);	        if (pos >= count) {	            addToken(tokens, "");	        }	    }	    return tokens;	}
protected String getArrayEnd() {	    return arrayEnd;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {	    if (str == null || searchStr == null) {	        return INDEX_NOT_FOUND;	    }	    if (startPos > str.length() - searchStr.length()) {	        startPos = str.length() - searchStr.length();	    }	    if (startPos < 0) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return startPos;	    }	    for (int i = startPos; i >= 0; i--) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
protected String getSizeEndText() {	    return sizeEndText;	}
public String getNullText() {	    return nullText;	}
@Override	public int hashCode() {	    if (hashCode == 0) {	        hashCode = 37 * (37 * 17 + getNumerator()) + getDenominator();	    }	    return hashCode;	}
public static boolean contains(final boolean[] array, final boolean valueToFind) {	    return indexOf(array, valueToFind) != INDEX_NOT_FOUND;	}
public int capacity() {	    return buffer.length;	}
public static String stripToEmpty(final String str) {	    return str == null ? EMPTY : strip(str, null);	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
public String getRawMessage() {	    return super.getMessage();	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public static String formatPeriodISO(final long startMillis, final long endMillis) {	    return formatPeriod(startMillis, endMillis, ISO_EXTENDED_FORMAT_PATTERN, false, TimeZone.getDefault());	}
protected String getContentEnd() {	    return contentEnd;	}
public int lastIndexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex >= size ? size - 1 : startIndex);	    if (matcher == null || startIndex < 0) {	        return -1;	    }	    final char[] buf = buffer;	    final int endIndex = startIndex + 1;	    for (int i = startIndex; i >= 0; i--) {	        if (matcher.isMatch(buf, i, 0, endIndex) > 0) {	            return i;	        }	    }	    return -1;	}
public int size() {	    return size;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public static Boolean or(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
@Override	public int length() {	    return size;	}
public static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    final int beSrcPos = src.length - 1 - srcPos;	    final int srcLen = Math.min(4, beSrcPos + 1);	    final boolean[] paddedSrc = new boolean[4];	    System.arraycopy(src, beSrcPos + 1 - srcLen, paddedSrc, 4 - srcLen, srcLen);	    src = paddedSrc;	    srcPos = 0;	    if (src[srcPos]) {	        if (src.length > srcPos + 1 && src[srcPos + 1]) {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 1 && src[srcPos + 1]) {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
protected boolean isUseShortClassName() {	    return useShortClassName;	}
public static float max(final float a, final float b) {	    if (Float.isNaN(a)) {	        return b;	    } else if (Float.isNaN(b)) {	        return a;	    } else {	        return Math.max(a, b);	    }	}
public int lastIndexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex >= size ? size - 1 : startIndex);	    if (matcher == null || startIndex < 0) {	        return -1;	    }	    final char[] buf = buffer;	    final int endIndex = startIndex + 1;	    for (int i = startIndex; i >= 0; i--) {	        if (matcher.isMatch(buf, i, 0, endIndex) > 0) {	            return i;	        }	    }	    return -1;	}
@Override	public List<Object> getContextValues(final String label) {	    final List<Object> values = new ArrayList<Object>();	    for (final Pair<String, Object> pair : contextValues) {	        if (StringUtils.equals(label, pair.getKey())) {	            values.add(pair.getValue());	        }	    }	    return values;	}
public static String mid(final String str, int pos, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0 || pos > str.length()) {	        return EMPTY;	    }	    if (pos < 0) {	        pos = 0;	    }	    if (str.length() <= pos + len) {	        return str.substring(pos);	    }	    return str.substring(pos, pos + len);	}
protected String getContentStart() {	    return contentStart;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public static <T> T CONST(final T v) {	    return v;	}
protected void setNullText(String nullText) {	    if (nullText == null) {	        nullText = "";	    }	    this.nullText = nullText;	}
public int lastIndexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex >= size ? size - 1 : startIndex);	    if (matcher == null || startIndex < 0) {	        return -1;	    }	    final char[] buf = buffer;	    final int endIndex = startIndex + 1;	    for (int i = startIndex; i >= 0; i--) {	        if (matcher.isMatch(buf, i, 0, endIndex) > 0) {	            return i;	        }	    }	    return -1;	}
public static <T> Range<T> is(final T element, final Comparator<T> comparator) {	    return between(element, element, comparator);	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
@Override	public R setValue(final R value) {	    final R result = getRight();	    setRight(value);	    return result;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
protected String getSummaryObjectStartText() {	    return summaryObjectStartText;	}
public char getEnd() {	    return this.end;	}
@Override	public int read(final char[] b, final int off, int len) {	    if (off < 0 || len < 0 || off > b.length || (off + len) > b.length || (off + len) < 0) {	        throw new IndexOutOfBoundsException();	    }	    if (len == 0) {	        return 0;	    }	    if (pos >= StrBuilder.this.size()) {	        return -1;	    }	    if (pos + len > size()) {	        len = StrBuilder.this.size() - pos;	    }	    StrBuilder.this.getChars(pos, pos + len, b, off);	    pos += len;	    return len;	}
@Override	public int length() {	    return size;	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
public String leftString(final int length) {	    if (length <= 0) {	        return "";	    } else if (length >= size) {	        return new String(buffer, 0, size);	    } else {	        return new String(buffer, 0, length);	    }	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static String removeEnd(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.endsWith(remove)) {	        return str.substring(0, str.length() - remove.length());	    }	    return str;	}
public static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) {	    if (0 == nBools) {	        return dst;	    }	    if (nBools - 1 + srcPos >= 64) {	        throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 64");	    }	    int shift = 0;	    for (int i = 0; i < nBools; i++) {	        shift = i * 1 + srcPos;	        dst[dstPos + i] = ((0x1 & (src >> shift)) != 0);	    }	    return dst;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static boolean isSameLength(final boolean[] array1, final boolean[] array2) {	    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {	        return false;	    }	    return true;	}
protected String getFieldNameValueSeparator() {	    return fieldNameValueSeparator;	}
public static Date round(final Object date, final int field) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (date instanceof Date) {	        return round((Date) date, field);	    } else if (date instanceof Calendar) {	        return round((Calendar) date, field).getTime();	    } else {	        throw new ClassCastException("Could not round " + date);	    }	}
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) {	    return new Range<T>(fromInclusive, toInclusive, comparator);	}
public int toHashCode() {	    return iTotal;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public String getNewLineText() {	    return newLine;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public char getEscapeChar() {	    return this.escapeChar;	}
@Override	public double doubleValue() {	    return (double) numerator / (double) denominator;	}
@Override	public Double getValue() {	    return Double.valueOf(this.value);	}
private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass) {	    if (throwable == null || type == null) {	        return -1;	    }	    if (fromIndex < 0) {	        fromIndex = 0;	    }	    final Throwable[] throwables = ExceptionUtils.getThrowables(throwable);	    if (fromIndex >= throwables.length) {	        return -1;	    }	    if (subclass) {	        for (int i = fromIndex; i < throwables.length; i++) {	            if (type.isAssignableFrom(throwables[i].getClass())) {	                return i;	            }	        }	    } else {	        for (int i = fromIndex; i < throwables.length; i++) {	            if (type.equals(throwables[i].getClass())) {	                return i;	            }	        }	    }	    return -1;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public void stop() {	    if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {	        throw new IllegalStateException("Stopwatch is not running. ");	    }	    if (this.runningState == STATE_RUNNING) {	        this.stopTime = System.nanoTime();	    }	    this.runningState = STATE_STOPPED;	}
private static Date add(final Date date, final int calendarField, final int amount) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final Calendar c = Calendar.getInstance();	    c.setTime(date);	    c.add(calendarField, amount);	    return c.getTime();	}
public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) {	    final Token[] tokens = lexx(format);	    final Calendar start = Calendar.getInstance(timezone);	    start.setTime(new Date(startMillis));	    final Calendar end = Calendar.getInstance(timezone);	    end.setTime(new Date(endMillis));	    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);	    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);	    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);	    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);	    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);	    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);	    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);	    while (milliseconds < 0) {	        milliseconds += 1000;	        seconds -= 1;	    }	    while (seconds < 0) {	        seconds += 60;	        minutes -= 1;	    }	    while (minutes < 0) {	        minutes += 60;	        hours -= 1;	    }	    while (hours < 0) {	        hours += 24;	        days -= 1;	    }	    if (Token.containsTokenWithValue(tokens, M)) {	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	        while (months < 0) {	            months += 12;	            years -= 1;	        }	        if (!Token.containsTokenWithValue(tokens, y) && years != 0) {	            while (years != 0) {	                months += 12 * years;	                years = 0;	            }	        }	    } else {	        if (!Token.containsTokenWithValue(tokens, y)) {	            int target = end.get(Calendar.YEAR);	            if (months < 0) {	                target -= 1;	            }	            while (start.get(Calendar.YEAR) != target) {	                days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);	                if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) {	                    days += 1;	                }	                start.add(Calendar.YEAR, 1);	                days += start.get(Calendar.DAY_OF_YEAR);	            }	            years = 0;	        }	        while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            start.add(Calendar.MONTH, 1);	        }	        months = 0;	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	    }	    if (!Token.containsTokenWithValue(tokens, d)) {	        hours += 24 * days;	        days = 0;	    }	    if (!Token.containsTokenWithValue(tokens, H)) {	        minutes += 60 * hours;	        hours = 0;	    }	    if (!Token.containsTokenWithValue(tokens, m)) {	        seconds += 60 * minutes;	        minutes = 0;	    }	    if (!Token.containsTokenWithValue(tokens, s)) {	        milliseconds += 1000 * seconds;	        seconds = 0;	    }	    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public StrBuilder deleteCharAt(final int index) {	    if (index < 0 || index >= size) {	        throw new StringIndexOutOfBoundsException(index);	    }	    deleteImpl(index, index + 1, 1);	    return this;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {	    if (array == null) {	        if (index != 0) {	            throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0");	        }	        final Object joinedArray = Array.newInstance(clss, 1);	        Array.set(joinedArray, 0, element);	        return joinedArray;	    }	    final int length = Array.getLength(array);	    if (index > length || index < 0) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(clss, length + 1);	    System.arraycopy(array, 0, result, 0, index);	    Array.set(result, index, element);	    if (index < length) {	        System.arraycopy(array, index, result, index + 1, length - index);	    }	    return result;	}
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) {	    style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));	    return this;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
@Override	public int nextIndex() {	    return tokenPos;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public static String stripEnd(final String str, final String stripChars) {	    int end;	    if (str == null || (end = str.length()) == 0) {	        return str;	    }	    if (stripChars == null) {	        while (end != 0 && Character.isWhitespace(str.charAt(end - 1))) {	            end--;	        }	    } else if (stripChars.isEmpty()) {	        return str;	    } else {	        while (end != 0 && stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND) {	            end--;	        }	    }	    return str.substring(0, end);	}
public static char binaryToHexDigit(final boolean[] src, final int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    if (src.length > srcPos + 3 && src[srcPos + 3]) {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src[srcPos]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
public int indexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex < 0 ? 0 : startIndex);	    if (matcher == null || startIndex >= size) {	        return -1;	    }	    final int len = size;	    final char[] buf = buffer;	    for (int i = startIndex; i < len; i++) {	        if (matcher.isMatch(buf, i, startIndex, len) > 0) {	            return i;	        }	    }	    return -1;	}
public static boolean[] hexDigitToBinary(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return new boolean[] { false, false, false, false };	        case '1':	            return new boolean[] { true, false, false, false };	        case '2':	            return new boolean[] { false, true, false, false };	        case '3':	            return new boolean[] { true, true, false, false };	        case '4':	            return new boolean[] { false, false, true, false };	        case '5':	            return new boolean[] { true, false, true, false };	        case '6':	            return new boolean[] { false, true, true, false };	        case '7':	            return new boolean[] { true, true, true, false };	        case '8':	            return new boolean[] { false, false, false, true };	        case '9':	            return new boolean[] { true, false, false, true };	        case 'a':	        case 'A':	            return new boolean[] { false, true, false, true };	        case 'b':	        case 'B':	            return new boolean[] { true, true, false, true };	        case 'c':	        case 'C':	            return new boolean[] { false, false, true, true };	        case 'd':	        case 'D':	            return new boolean[] { true, false, true, true };	        case 'e':	        case 'E':	            return new boolean[] { false, true, true, true };	        case 'f':	        case 'F':	            return new boolean[] { true, true, true, true };	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public static boolean isNumericSpace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isDigit(cs.charAt(i)) == false && cs.charAt(i) != ' ') {	            return false;	        }	    }	    return true;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public static boolean[] clone(final boolean[] array) {	    if (array == null) {	        return null;	    }	    return array.clone();	}
public static boolean isBlank(final CharSequence cs) {	    int strLen;	    if (cs == null || (strLen = cs.length()) == 0) {	        return true;	    }	    for (int i = 0; i < strLen; i++) {	        if (Character.isWhitespace(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static boolean isAscii(final char ch) {	    return ch < 128;	}
public static File getJavaHome() {	    return new File(System.getProperty(JAVA_HOME_KEY));	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public static short[] removeElement(final short[] array, final short element) {	    final int index = indexOf(array, element);	    if (index == INDEX_NOT_FOUND) {	        return clone(array);	    }	    return remove(array, index);	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
@Override	public int length() {	    return size;	}
public static <L, R> Pair<L, R> of(final L left, final R right) {	    return new ImmutablePair<L, R>(left, right);	}
public char getEscapeChar() {	    return this.escapeChar;	}
private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase) {	    if (str == null || prefix == null) {	        return str == null && prefix == null;	    }	    if (prefix.length() > str.length()) {	        return false;	    }	    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    for (final CharSequenceTranslator translator : translators) {	        final int consumed = translator.translate(input, index, out);	        if (consumed != 0) {	            return consumed;	        }	    }	    return 0;	}
public int size() {	    return size;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public int size() {	    return size;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
protected String getFieldSeparator() {	    return fieldSeparator;	}
public static <T> Constructor<T> getAccessibleConstructor(final Constructor<T> ctor) {	    return MemberUtils.isAccessible(ctor) && Modifier.isPublic(ctor.getDeclaringClass().getModifiers()) ? ctor : null;	}
public char getStart() {	    return this.start;	}
public int capacity() {	    return buffer.length;	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    if (index != 0) {	        throw new IllegalStateException("CsvUnescaper should never reach the [1] index");	    }	    if (input.charAt(0) != CSV_QUOTE || input.charAt(input.length() - 1) != CSV_QUOTE) {	        out.write(input.toString());	        return input.length();	    }	    final String quoteless = input.subSequence(1, input.length() - 1).toString();	    if (StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS)) {	        out.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR));	    } else {	        out.write(input.toString());	    }	    return input.length();	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public void stop() {	    if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {	        throw new IllegalStateException("Stopwatch is not running. ");	    }	    if (this.runningState == STATE_RUNNING) {	        this.stopTime = System.nanoTime();	    }	    this.runningState = STATE_STOPPED;	}
public static String capitalize(final String str) {	    int strLen;	    if (str == null || (strLen = str.length()) == 0) {	        return str;	    }	    char firstChar = str.charAt(0);	    if (Character.isTitleCase(firstChar)) {	        return str;	    }	    return new StringBuilder(strLen).append(Character.toTitleCase(firstChar)).append(str.substring(1)).toString();	}
@Override	public Integer build() {	    return Integer.valueOf(toHashCode());	}
public static boolean containsOnly(final CharSequence cs, final String validChars) {	    if (cs == null || validChars == null) {	        return false;	    }	    return containsOnly(cs, validChars.toCharArray());	}
public static float max(final float a, final float b) {	    if (Float.isNaN(a)) {	        return b;	    } else if (Float.isNaN(b)) {	        return a;	    } else {	        return Math.max(a, b);	    }	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public String getNewLineText() {	    return newLine;	}
public static boolean isAlphaSpace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false && cs.charAt(i) != ' ') {	            return false;	        }	    }	    return true;	}
public boolean isEmpty() {	    return size == 0;	}
protected void appendFieldsIn(final Class<?> clazz) {	    if (clazz.isArray()) {	        this.reflectionAppendArray(this.getObject());	        return;	    }	    final Field[] fields = clazz.getDeclaredFields();	    AccessibleObject.setAccessible(fields, true);	    for (final Field field : fields) {	        final String fieldName = field.getName();	        if (this.accept(field)) {	            try {	                final Object fieldValue = this.getValue(field);	                this.append(fieldName, fieldValue);	            } catch (final IllegalAccessException ex) {	                throw new InternalError("Unexpected IllegalAccessException: " + ex.getMessage());	            }	        }	    }	}
public int capacity() {	    return buffer.length;	}
public static String appendIfMissing(final String str, final CharSequence suffix, final CharSequence... suffixes) {	    return appendIfMissing(str, suffix, false, suffixes);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public String nextToken() {	    if (hasNext()) {	        return tokens[tokenPos++];	    }	    return null;	}
public static <K, V> V putIfAbsent(final ConcurrentMap<K, V> map, final K key, final V value) {	    if (map == null) {	        return null;	    }	    final V result = map.putIfAbsent(key, value);	    return result != null ? result : value;	}
public final Integer getPriority() {	    return priority;	}
protected String getFieldNameValueSeparator() {	    return fieldNameValueSeparator;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static StrMatcher stringMatcher(final String str) {	    if (StringUtils.isEmpty(str)) {	        return NONE_MATCHER;	    }	    return new StringMatcher(str);	}
@Override	public TimeZone getTimeZone() {	    return mTimeZone;	}
public static <T> T invokeConstructor(final Class<T> cls, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {	    if (parameterTypes == null) {	        parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;	    }	    if (args == null) {	        args = ArrayUtils.EMPTY_OBJECT_ARRAY;	    }	    final Constructor<T> ctor = getMatchingAccessibleConstructor(cls, parameterTypes);	    if (ctor == null) {	        throw new NoSuchMethodException("No such accessible constructor on object: " + cls.getName());	    }	    return ctor.newInstance(args);	}
public static String removeEnd(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.endsWith(remove)) {	        return str.substring(0, str.length() - remove.length());	    }	    return str;	}
protected String getFieldNameValueSeparator() {	    return fieldNameValueSeparator;	}
private static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal, final boolean lastIndex) {	    if (str == null || searchStr == null || ordinal <= 0) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return lastIndex ? str.length() : 0;	    }	    int found = 0;	    int index = lastIndex ? str.length() : INDEX_NOT_FOUND;	    do {	        if (lastIndex) {	            index = CharSequenceUtils.lastIndexOf(str, searchStr, index - 1);	        } else {	            index = CharSequenceUtils.indexOf(str, searchStr, index + 1);	        }	        if (index < 0) {	            return index;	        }	        found++;	    } while (found < ordinal);	    return index;	}
public StrTokenizer setEmptyTokenAsNull(final boolean emptyAsNull) {	    this.emptyAsNull = emptyAsNull;	    return this;	}
public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale) {	    return cache.getDateTimeInstance(dateStyle, timeStyle, timeZone, locale);	}
public static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts) {	    if (0 == nShorts) {	        return dst;	    }	    if ((nShorts - 1) * 16 + srcPos >= 32) {	        throw new IllegalArgumentException("(nShorts-1)*16+srcPos is greather or equal to than 32");	    }	    int shift = 0;	    for (int i = 0; i < nShorts; i++) {	        shift = i * 16 + srcPos;	        dst[dstPos + i] = (short) (0xffff & (src >> shift));	    }	    return dst;	}
public static float min(final float a, final float b, final float c) {	    return Math.min(Math.min(a, b), c);	}
public static double[] addAll(final double[] array1, final double... array2) {	    if (array1 == null) {	        return clone(array2);	    } else if (array2 == null) {	        return clone(array1);	    }	    final double[] joinedArray = new double[array1.length + array2.length];	    System.arraycopy(array1, 0, joinedArray, 0, array1.length);	    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);	    return joinedArray;	}
public int size() {	    return size;	}
@Override	public int length() {	    return size;	}
public int set(final int holder) {	    return holder | _mask;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) {	    if (it != null) {	        separator = ObjectUtils.toString(separator);	        while (it.hasNext()) {	            append(it.next());	            if (it.hasNext()) {	                append(separator);	            }	        }	    }	    return this;	}
public static String substringBefore(final String str, final String separator) {	    if (isEmpty(str) || separator == null) {	        return str;	    }	    if (separator.isEmpty()) {	        return EMPTY;	    }	    final int pos = str.indexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return str;	    }	    return str.substring(0, pos);	}
public int size() {	    return size;	}
@Override	public String getSummaryObjectEndText() {	    return super.getSummaryObjectEndText();	}
public static String formatDuration(long durationMillis, final String format, final boolean padWithZeros) {	    final Token[] tokens = lexx(format);	    int days = 0;	    int hours = 0;	    int minutes = 0;	    int seconds = 0;	    int milliseconds = 0;	    if (Token.containsTokenWithValue(tokens, d)) {	        days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY);	        durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY);	    }	    if (Token.containsTokenWithValue(tokens, H)) {	        hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR);	        durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR);	    }	    if (Token.containsTokenWithValue(tokens, m)) {	        minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE);	        durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE);	    }	    if (Token.containsTokenWithValue(tokens, s)) {	        seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND);	        durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND);	    }	    if (Token.containsTokenWithValue(tokens, S)) {	        milliseconds = (int) durationMillis;	    }	    return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) {	    if (it != null) {	        separator = ObjectUtils.toString(separator);	        while (it.hasNext()) {	            append(it.next());	            if (it.hasNext()) {	                append(separator);	            }	        }	    }	    return this;	}
public static String rightPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return rightPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return str.concat(padStr);	    } else if (pads < padLen) {	        return str.concat(padStr.substring(0, pads));	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return str.concat(new String(padding));	    }	}
public String getNewLineText() {	    return newLine;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public int capacity() {	    return buffer.length;	}
public short setShort(final short holder) {	    return (short) set(holder);	}
private static boolean endsWith(final CharSequence str, final CharSequence suffix, final boolean ignoreCase) {	    if (str == null || suffix == null) {	        return str == null && suffix == null;	    }	    if (suffix.length() > str.length()) {	        return false;	    }	    final int strOffset = str.length() - suffix.length();	    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, suffix, 0, suffix.length());	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
@Override	public Set<String> getContextLabels() {	    return exceptionContext.getContextLabels();	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static boolean isAsciiAlpha(final char ch) {	    return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');	}
public static String getPackageCanonicalName(final String canonicalName) {	    return ClassUtils.getPackageName(getCanonicalName(canonicalName));	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return 0;	    }	    if (lhs == null || rhs == null) {	        throw new NullPointerException();	    }	    Class<?> lhsClazz = lhs.getClass();	    if (!lhsClazz.isInstance(rhs)) {	        throw new ClassCastException();	    }	    final CompareToBuilder compareToBuilder = new CompareToBuilder();	    reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);	    while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) {	        lhsClazz = lhsClazz.getSuperclass();	        reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);	    }	    return compareToBuilder.toComparison();	}
public static String uncapitalize(final String str, final char... delimiters) {	    final int delimLen = delimiters == null ? -1 : delimiters.length;	    if (StringUtils.isEmpty(str) || delimLen == 0) {	        return str;	    }	    final char[] buffer = str.toCharArray();	    boolean uncapitalizeNext = true;	    for (int i = 0; i < buffer.length; i++) {	        final char ch = buffer[i];	        if (isDelimiter(ch, delimiters)) {	            uncapitalizeNext = true;	        } else if (uncapitalizeNext) {	            buffer[i] = Character.toLowerCase(ch);	            uncapitalizeNext = false;	        }	    }	    return new String(buffer);	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException {	    return charsetName == null ? new String(bytes) : new String(bytes, charsetName);	}
public static boolean isAlphaSpace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false && cs.charAt(i) != ' ') {	            return false;	        }	    }	    return true;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
@Override	public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) {	    return buffer[pos] <= 32 ? 1 : 0;	}
public static Integer createInteger(final String str) {	    if (str == null) {	        return null;	    }	    return Integer.decode(str);	}
public static boolean containsNone(final CharSequence cs, final String invalidChars) {	    if (cs == null || invalidChars == null) {	        return true;	    }	    return containsNone(cs, invalidChars.toCharArray());	}
protected String getContentEnd() {	    return contentEnd;	}
public static <T> T CONST(final T v) {	    return v;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public static Date ceiling(final Object date, final int field) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (date instanceof Date) {	        return ceiling((Date) date, field);	    } else if (date instanceof Calendar) {	        return ceiling((Calendar) date, field).getTime();	    } else {	        throw new ClassCastException("Could not find ceiling of for type: " + date.getClass());	    }	}
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, true);	}
public int toComparison() {	    return comparison;	}
public static Locale toLocale(final String str) {	    if (str == null) {	        return null;	    }	    if (str.contains("#")) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final int len = str.length();	    if (len < 2) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final char ch0 = str.charAt(0);	    if (ch0 == '_') {	        if (len < 3) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        final char ch1 = str.charAt(1);	        final char ch2 = str.charAt(2);	        if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        if (len == 3) {	            return new Locale("", str.substring(1, 3));	        }	        if (len < 5) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        if (str.charAt(3) != '_') {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        return new Locale("", str.substring(1, 3), str.substring(4));	    }	    final char ch1 = str.charAt(1);	    if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (len == 2) {	        return new Locale(str);	    }	    if (len < 5) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (str.charAt(2) != '_') {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final char ch3 = str.charAt(3);	    if (ch3 == '_') {	        return new Locale(str.substring(0, 2), "", str.substring(4));	    }	    final char ch4 = str.charAt(4);	    if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (len == 5) {	        return new Locale(str.substring(0, 2), str.substring(3, 5));	    }	    if (len < 7) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (str.charAt(5) != '_') {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));	}
public boolean isBeforeRange(final Range<T> otherRange) {	    if (otherRange == null) {	        return false;	    }	    return isBefore(otherRange.minimum);	}
public void subtract(final Number operand) {	    this.value -= operand.shortValue();	}
public Reader asReader() {	    return new StrBuilderReader();	}
protected boolean isFieldSeparatorAtEnd() {	    return fieldSeparatorAtEnd;	}
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException {	    return charsetName == null ? new String(bytes) : new String(bytes, charsetName);	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public static String formatDurationISO(final long durationMillis) {	    return formatDuration(durationMillis, ISO_EXTENDED_FORMAT_PATTERN, false);	}
public static CharRange is(final char ch) {	    return new CharRange(ch, ch, false);	}
public static String formatPeriodISO(final long startMillis, final long endMillis) {	    return formatPeriod(startMillis, endMillis, ISO_EXTENDED_FORMAT_PATTERN, false, TimeZone.getDefault());	}
synchronized void endOfPeriod() {	    lastCallsPerPeriod = acquireCount;	    totalAcquireCount += acquireCount;	    periodCount++;	    acquireCount = 0;	    notifyAll();	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public static boolean startsWithAny(final CharSequence string, final CharSequence... searchStrings) {	    if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {	        return false;	    }	    for (final CharSequence searchString : searchStrings) {	        if (StringUtils.startsWith(string, searchString)) {	            return true;	        }	    }	    return false;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
@Override	public int intValue() {	    return (int) value;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
@Override	public void mark(final int readAheadLimit) {	    mark = pos;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static <T> T invokeExactConstructor(final Class<T> cls, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {	    if (args == null) {	        args = ArrayUtils.EMPTY_OBJECT_ARRAY;	    }	    if (parameterTypes == null) {	        parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;	    }	    final Constructor<T> ctor = getAccessibleConstructor(cls, parameterTypes);	    if (ctor == null) {	        throw new NoSuchMethodException("No such accessible constructor on object: " + cls.getName());	    }	    return ctor.newInstance(args);	}
protected boolean isDefaultFullDetail() {	    return defaultFullDetail;	}
protected String getArraySeparator() {	    return arraySeparator;	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) {	    String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'");	    if (suppressLeadingZeroElements) {	        duration = " " + duration;	        String tmp = StringUtils.replaceOnce(duration, " 0 days", "");	        if (tmp.length() != duration.length()) {	            duration = tmp;	            tmp = StringUtils.replaceOnce(duration, " 0 hours", "");	            if (tmp.length() != duration.length()) {	                duration = tmp;	                tmp = StringUtils.replaceOnce(duration, " 0 minutes", "");	                duration = tmp;	                if (tmp.length() != duration.length()) {	                    duration = StringUtils.replaceOnce(tmp, " 0 seconds", "");	                }	            }	        }	        if (duration.length() != 0) {	            duration = duration.substring(1);	        }	    }	    if (suppressTrailingZeroElements) {	        String tmp = StringUtils.replaceOnce(duration, " 0 seconds", "");	        if (tmp.length() != duration.length()) {	            duration = tmp;	            tmp = StringUtils.replaceOnce(duration, " 0 minutes", "");	            if (tmp.length() != duration.length()) {	                duration = tmp;	                tmp = StringUtils.replaceOnce(duration, " 0 hours", "");	                if (tmp.length() != duration.length()) {	                    duration = StringUtils.replaceOnce(tmp, " 0 days", "");	                }	            }	        }	    }	    duration = " " + duration;	    duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second");	    duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute");	    duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour");	    duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day");	    return duration.trim();	}
protected boolean isFieldSeparatorAtStart() {	    return fieldSeparatorAtStart;	}
public boolean isOverlappedBy(final Range<T> otherRange) {	    if (otherRange == null) {	        return false;	    }	    return otherRange.contains(minimum) || otherRange.contains(maximum) || contains(otherRange.minimum);	}
public static <T extends CharSequence> T defaultIfBlank(final T str, final T defaultStr) {	    return StringUtils.isBlank(str) ? defaultStr : str;	}
public static <E extends Enum<E>> E getEnum(final Class<E> enumClass, final String enumName) {	    if (enumName == null) {	        return null;	    }	    try {	        return Enum.valueOf(enumClass, enumName);	    } catch (final IllegalArgumentException ex) {	        return null;	    }	}
public static String formatUTC(final Date date, final String pattern, final Locale locale) {	    return format(date, pattern, UTC_TIME_ZONE, locale);	}
@Override	public int length() {	    return size;	}
@Override	public int length() {	    return size;	}
public int size() {	    return size;	}
public static Date round(final Object date, final int field) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (date instanceof Date) {	        return round((Date) date, field);	    } else if (date instanceof Calendar) {	        return round((Calendar) date, field).getTime();	    } else {	        throw new ClassCastException("Could not round " + date);	    }	}
public char getEscapeChar() {	    return this.escapeChar;	}
protected boolean isUseIdentityHashCode() {	    return useIdentityHashCode;	}
public static boolean isWhitespace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isWhitespace(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static String replacePattern(final String source, final String regex, final String replacement) {	    return Pattern.compile(regex, Pattern.DOTALL).matcher(source).replaceAll(replacement);	}
@Override	public BasicThreadFactory build() {	    final BasicThreadFactory factory = new BasicThreadFactory(this);	    reset();	    return factory;	}
public static Object invokeExactStaticMethod(final Class<?> cls, final String methodName, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {	    if (args == null) {	        args = ArrayUtils.EMPTY_OBJECT_ARRAY;	    }	    final Class<?>[] parameterTypes = ClassUtils.toClass(args);	    return invokeExactStaticMethod(cls, methodName, args, parameterTypes);	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
public int size() {	    return size;	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static String leftPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return leftPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return padStr.concat(str);	    } else if (pads < padLen) {	        return padStr.substring(0, pads).concat(str);	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return new String(padding).concat(str);	    }	}
public boolean isEmpty() {	    return size == 0;	}
public int capacity() {	    return buffer.length;	}
public static List<Class<?>> getAllSuperclasses(final Class<?> cls) {	    if (cls == null) {	        return null;	    }	    final List<Class<?>> classes = new ArrayList<Class<?>>();	    Class<?> superclass = cls.getSuperclass();	    while (superclass != null) {	        classes.add(superclass);	        superclass = superclass.getSuperclass();	    }	    return classes;	}
public static String initials(final String str, final char... delimiters) {	    if (StringUtils.isEmpty(str)) {	        return str;	    }	    if (delimiters != null && delimiters.length == 0) {	        return "";	    }	    final int strLen = str.length();	    final char[] buf = new char[strLen / 2 + 1];	    int count = 0;	    boolean lastWasGap = true;	    for (int i = 0; i < strLen; i++) {	        final char ch = str.charAt(i);	        if (isDelimiter(ch, delimiters)) {	            lastWasGap = true;	        } else if (lastWasGap) {	            buf[count++] = ch;	            lastWasGap = false;	        } else {	            continue;	        }	    }	    return new String(buf, 0, count);	}
public static Boolean or(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public int toHashCode() {	    return iTotal;	}
public boolean isEmpty() {	    return size == 0;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
@Override	public int length() {	    return size;	}
@Override	public int length() {	    return size;	}
public static short[] removeElement(final short[] array, final short element) {	    final int index = indexOf(array, element);	    if (index == INDEX_NOT_FOUND) {	        return clone(array);	    }	    return remove(array, index);	}
@Override	public int length() {	    return size;	}
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) {	    return new Range<T>(fromInclusive, toInclusive, comparator);	}
protected boolean isDefaultFullDetail() {	    return defaultFullDetail;	}
public static <T extends CharSequence> T notEmpty(final T chars) {	    return notEmpty(chars, DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE);	}
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, true);	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
public static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes) {	    if (0 == nBytes) {	        return dst;	    }	    if ((nBytes - 1) * 8 + srcPos >= 64) {	        throw new IllegalArgumentException("(nBytes-1)*8+srcPos is greather or equal to than 64");	    }	    int shift = 0;	    for (int i = 0; i < nBytes; i++) {	        shift = i * 8 + srcPos;	        dst[dstPos + i] = (byte) (0xff & (src >> shift));	    }	    return dst;	}
@Override	public boolean markSupported() {	    return true;	}
public boolean isEmpty() {	    return size == 0;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static boolean isSameLength(final boolean[] array1, final boolean[] array2) {	    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {	        return false;	    }	    return true;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public String getNullText() {	    return nullText;	}
public int capacity() {	    return buffer.length;	}
@Override	public boolean isDone() {	    return true;	}
@Override	public T get() throws ConcurrentException {	    try {	        return getFuture().get();	    } catch (final ExecutionException execex) {	        ConcurrentUtils.handleCause(execex);	        return null;	    } catch (final InterruptedException iex) {	        Thread.currentThread().interrupt();	        throw new ConcurrentException(iex);	    }	}
protected String getNullText() {	    return nullText;	}
public byte setByte(final byte holder) {	    return (byte) set(holder);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
protected String getNullText() {	    return nullText;	}
public StrBuilder replaceAll(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, -1);	}
public int size() {	    return size;	}
@Override	public boolean isUseIdentityHashCode() {	    return super.isUseIdentityHashCode();	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
public static float min(final float a, final float b) {	    if (Float.isNaN(a)) {	        return b;	    } else if (Float.isNaN(b)) {	        return a;	    } else {	        return Math.min(a, b);	    }	}
public static String overlay(final String str, String overlay, int start, int end) {	    if (str == null) {	        return null;	    }	    if (overlay == null) {	        overlay = EMPTY;	    }	    final int len = str.length();	    if (start < 0) {	        start = 0;	    }	    if (start > len) {	        start = len;	    }	    if (end < 0) {	        end = 0;	    }	    if (end > len) {	        end = len;	    }	    if (start > end) {	        final int temp = start;	        start = end;	        end = temp;	    }	    return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString();	}
public char getStart() {	    return this.start;	}
public static String replaceEachRepeatedly(final String text, final String[] searchList, final String[] replacementList) {	    final int timeToLive = searchList == null ? 0 : searchList.length;	    return replaceEach(text, searchList, replacementList, true, timeToLive);	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
@Override	public int hashCode() {	    return (getKey() == null ? 0 : getKey().hashCode()) ^ (getValue() == null ? 0 : getValue().hashCode());	}
public StrSubstitutor setVariablePrefix(final String prefix) {	    if (prefix == null) {	        throw new IllegalArgumentException("Variable prefix must not be null!");	    }	    return setVariablePrefixMatcher(StrMatcher.stringMatcher(prefix));	}
public String getNewLineText() {	    return newLine;	}
@Override	public boolean translate(final int codepoint, final Writer out) throws IOException {	    if (between) {	        if (codepoint < below || codepoint > above) {	            return false;	        }	    } else {	        if (codepoint >= below && codepoint <= above) {	            return false;	        }	    }	    if (codepoint > 0xffff) {	        out.write(toUtf16Escape(codepoint));	    } else if (codepoint > 0xfff) {	        out.write("\\u" + hex(codepoint));	    } else if (codepoint > 0xff) {	        out.write("\\u0" + hex(codepoint));	    } else if (codepoint > 0xf) {	        out.write("\\u00" + hex(codepoint));	    } else {	        out.write("\\u000" + hex(codepoint));	    }	    return true;	}
@Override	public String next() {	    if (hasNext()) {	        return tokens[tokenPos++];	    }	    throw new NoSuchElementException();	}
public static CharRange isNot(final char ch) {	    return new CharRange(ch, ch, true);	}
protected String getNullText() {	    return nullText;	}
public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final E... values) {	    Validate.noNullElements(values);	    return generateBitVector(enumClass, Arrays.<E>asList(values));	}
public String reformat(final String input) throws ParseException {	    return format(parseObject(input));	}
@Override	public Set<String> getContextLabels() {	    return exceptionContext.getContextLabels();	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public StrBuilder setLength(final int length) {	    if (length < 0) {	        throw new StringIndexOutOfBoundsException(length);	    }	    if (length < size) {	        size = length;	    } else if (length > size) {	        ensureCapacity(length);	        final int oldEnd = size;	        final int newEnd = length;	        size = length;	        for (int i = oldEnd; i < newEnd; i++) {	            buffer[i] = '\0';	        }	    }	    return this;	}
public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {	    if (str == null || searchStr == null) {	        return INDEX_NOT_FOUND;	    }	    if (startPos > str.length() - searchStr.length()) {	        startPos = str.length() - searchStr.length();	    }	    if (startPos < 0) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return startPos;	    }	    for (int i = startPos; i >= 0; i--) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public boolean isEnableSubstitutionInVariables() {	    return enableSubstitutionInVariables;	}
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) {	    final StringBuilder buffer = new StringBuilder();	    boolean lastOutputSeconds = false;	    final int sz = tokens.length;	    for (int i = 0; i < sz; i++) {	        final Token token = tokens[i];	        final Object value = token.getValue();	        final int count = token.getCount();	        if (value instanceof StringBuilder) {	            buffer.append(value.toString());	        } else {	            if (value == y) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years));	                lastOutputSeconds = false;	            } else if (value == M) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months));	                lastOutputSeconds = false;	            } else if (value == d) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days));	                lastOutputSeconds = false;	            } else if (value == H) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours));	                lastOutputSeconds = false;	            } else if (value == m) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes));	                lastOutputSeconds = false;	            } else if (value == s) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds));	                lastOutputSeconds = true;	            } else if (value == S) {	                if (lastOutputSeconds) {	                    milliseconds += 1000;	                    final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds);	                    buffer.append(str.substring(1));	                } else {	                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds));	                }	                lastOutputSeconds = false;	            }	        }	    }	    return buffer.toString();	}
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = Integer.MAX_VALUE;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.indexOf(str, search, 0);	        if (tmp == INDEX_NOT_FOUND) {	            continue;	        }	        if (tmp < ret) {	            ret = tmp;	        }	    }	    return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;	}
public static String defaultString(final String str, final String defaultStr) {	    return str == null ? defaultStr : str;	}
@Override	public List<Pair<String, Object>> getContextEntries() {	    return contextValues;	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
public static boolean isFalse(final Boolean bool) {	    return Boolean.FALSE.equals(bool);	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
private static boolean endsWith(final CharSequence str, final CharSequence suffix, final boolean ignoreCase) {	    if (str == null || suffix == null) {	        return str == null && suffix == null;	    }	    if (suffix.length() > str.length()) {	        return false;	    }	    final int strOffset = str.length() - suffix.length();	    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, suffix, 0, suffix.length());	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static <T> Range<T> is(final T element, final Comparator<T> comparator) {	    return between(element, element, comparator);	}
@Override	public M getMiddle() {	    return middle;	}
public static String upperCase(final String str, final Locale locale) {	    if (str == null) {	        return null;	    }	    return str.toUpperCase(locale);	}
@Override	public float floatValue() {	    return value;	}
public static ConcurrentRuntimeException extractCauseUnchecked(final ExecutionException ex) {	    if (ex == null || ex.getCause() == null) {	        return null;	    }	    throwCause(ex);	    return new ConcurrentRuntimeException(ex.getMessage(), ex.getCause());	}
@Override	public TimeZone getTimeZone() {	    return mTimeZone;	}
public static String[][] invert(final String[][] array) {	    final String[][] newarray = new String[array.length][2];	    for (int i = 0; i < array.length; i++) {	        newarray[i][0] = array[i][1];	        newarray[i][1] = array[i][0];	    }	    return newarray;	}
public String getNewLineText() {	    return newLine;	}
public static boolean[] removeElements(final boolean[] array, final boolean... values) {	    if (isEmpty(array) || isEmpty(values)) {	        return clone(array);	    }	    final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2);	    for (final boolean v : values) {	        final Boolean boxed = Boolean.valueOf(v);	        final MutableInt count = occurrences.get(boxed);	        if (count == null) {	            occurrences.put(boxed, new MutableInt(1));	        } else {	            count.increment();	        }	    }	    final BitSet toRemove = new BitSet();	    for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) {	        final Boolean v = e.getKey();	        int found = 0;	        for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {	            found = indexOf(array, v.booleanValue(), found);	            if (found < 0) {	                break;	            }	            toRemove.set(found++);	        }	    }	    return (boolean[]) removeAll(array, toRemove);	}
public String getNullText() {	    return nullText;	}
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) {	    if (str == null) {	        if (trueString == null) {	            return Boolean.TRUE;	        }	        if (falseString == null) {	            return Boolean.FALSE;	        }	        if (nullString == null) {	            return null;	        }	    } else if (str.equals(trueString)) {	        return Boolean.TRUE;	    } else if (str.equals(falseString)) {	        return Boolean.FALSE;	    } else if (str.equals(nullString)) {	        return null;	    }	    throw new IllegalArgumentException("The String did not match any specified value");	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
public static List<Locale> localeLookupList(final Locale locale, final Locale defaultLocale) {	    final List<Locale> list = new ArrayList<Locale>(4);	    if (locale != null) {	        list.add(locale);	        if (locale.getVariant().length() > 0) {	            list.add(new Locale(locale.getLanguage(), locale.getCountry()));	        }	        if (locale.getCountry().length() > 0) {	            list.add(new Locale(locale.getLanguage(), ""));	        }	        if (list.contains(defaultLocale) == false) {	            list.add(defaultLocale);	        }	    }	    return Collections.unmodifiableList(list);	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public String getNullText() {	    return nullText;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return true;	    }	    if (lhs == null || rhs == null) {	        return false;	    }	    final Class<?> lhsClass = lhs.getClass();	    final Class<?> rhsClass = rhs.getClass();	    Class<?> testClass;	    if (lhsClass.isInstance(rhs)) {	        testClass = lhsClass;	        if (!rhsClass.isInstance(lhs)) {	            testClass = rhsClass;	        }	    } else if (rhsClass.isInstance(lhs)) {	        testClass = rhsClass;	        if (!lhsClass.isInstance(rhs)) {	            testClass = lhsClass;	        }	    } else {	        return false;	    }	    final EqualsBuilder equalsBuilder = new EqualsBuilder();	    try {	        reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {	            testClass = testClass.getSuperclass();	            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        }	    } catch (final IllegalArgumentException e) {	        return false;	    }	    return equalsBuilder.isEquals();	}
public static Boolean or(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
public static String toString(final Character ch) {	    if (ch == null) {	        return null;	    }	    return toString(ch.charValue());	}
public static boolean containsNone(final CharSequence cs, final String invalidChars) {	    if (cs == null || invalidChars == null) {	        return true;	    }	    return containsNone(cs, invalidChars.toCharArray());	}
public int capacity() {	    return buffer.length;	}
public static CharRange isNotIn(final char start, final char end) {	    return new CharRange(start, end, true);	}
public int size() {	    return size;	}
public static String formatPeriodISO(final long startMillis, final long endMillis) {	    return formatPeriod(startMillis, endMillis, ISO_EXTENDED_FORMAT_PATTERN, false, TimeZone.getDefault());	}
public static Object readDeclaredStaticField(final Class<?> cls, final String fieldName, final boolean forceAccess) throws IllegalAccessException {	    final Field field = getDeclaredField(cls, fieldName, forceAccess);	    if (field == null) {	        throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName);	    }	    return readStaticField(field, false);	}
static Object removeAll(final Object array, final BitSet indices) {	    final int srcLength = ArrayUtils.getLength(array);	    final int removals = indices.cardinality();	    final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals);	    int srcIndex = 0;	    int destIndex = 0;	    int count;	    int set;	    while ((set = indices.nextSetBit(srcIndex)) != -1) {	        count = set - srcIndex;	        if (count > 0) {	            System.arraycopy(array, srcIndex, result, destIndex, count);	            destIndex += count;	        }	        srcIndex = indices.nextClearBit(set);	    }	    count = srcLength - srcIndex;	    if (count > 0) {	        System.arraycopy(array, srcIndex, result, destIndex, count);	    }	    return result;	}
public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables) {	    this.enableSubstitutionInVariables = enableSubstitutionInVariables;	}
public int capacity() {	    return buffer.length;	}
@Override	public float floatValue() {	    return value;	}
public int size() {	    return size;	}
public static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes) {	    if (0 == nBytes) {	        return dst;	    }	    if ((nBytes - 1) * 8 + srcPos >= 16) {	        throw new IllegalArgumentException("(nBytes-1)*8+srcPos is greather or equal to than 16");	    }	    int shift = 0;	    for (int i = 0; i < nBytes; i++) {	        shift = i * 8 + srcPos;	        dst[dstPos + i] = (byte) (0xff & (src >> shift));	    }	    return dst;	}
public static <T extends Comparable<? super T>> T min(final T... values) {	    T result = null;	    if (values != null) {	        for (final T value : values) {	            if (compare(value, result, true) < 0) {	                result = value;	            }	        }	    }	    return result;	}
protected boolean isDefaultFullDetail() {	    return defaultFullDetail;	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public static <T> Range<T> is(final T element, final Comparator<T> comparator) {	    return between(element, element, comparator);	}
public static float max(final float a, final float b, final float c) {	    return Math.max(Math.max(a, b), c);	}
public String substring(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    return new String(buffer, startIndex, endIndex - startIndex);	}
public boolean isEquals() {	    return this.isEquals;	}
public static String lowerCase(final String str, final Locale locale) {	    if (str == null) {	        return null;	    }	    return str.toLowerCase(locale);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] result = new boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        final Boolean b = array[i];	        result[i] = (b == null ? valueForNull : b.booleanValue());	    }	    return result;	}
public static void handleCause(final ExecutionException ex) throws ConcurrentException {	    final ConcurrentException cex = extractCause(ex);	    if (cex != null) {	        throw cex;	    }	}
public static String stripEnd(final String str, final String stripChars) {	    int end;	    if (str == null || (end = str.length()) == 0) {	        return str;	    }	    if (stripChars == null) {	        while (end != 0 && Character.isWhitespace(str.charAt(end - 1))) {	            end--;	        }	    } else if (stripChars.isEmpty()) {	        return str;	    } else {	        while (end != 0 && stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND) {	            end--;	        }	    }	    return str.substring(0, end);	}
@Override	public int length() {	    return size;	}
public String getNewLineText() {	    return newLine;	}
public int capacity() {	    return buffer.length;	}
public char getStart() {	    return this.start;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
public boolean isIgnoreEmptyTokens() {	    return ignoreEmptyTokens;	}
public int size() {	    return size;	}
protected String getContentEnd() {	    return contentEnd;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public static char binaryToHexDigit(final boolean[] src, final int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    if (src.length > srcPos + 3 && src[srcPos + 3]) {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src[srcPos]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static boolean[] clone(final boolean[] array) {	    if (array == null) {	        return null;	    }	    return array.clone();	}
private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) {	    if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {	        return text;	    }	    if (timeToLive < 0) {	        throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another");	    }	    final int searchLength = searchList.length;	    final int replacementLength = replacementList.length;	    if (searchLength != replacementLength) {	        throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength);	    }	    final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];	    int textIndex = -1;	    int replaceIndex = -1;	    int tempIndex = -1;	    for (int i = 0; i < searchLength; i++) {	        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {	            continue;	        }	        tempIndex = text.indexOf(searchList[i]);	        if (tempIndex == -1) {	            noMoreMatchesForReplIndex[i] = true;	        } else {	            if (textIndex == -1 || tempIndex < textIndex) {	                textIndex = tempIndex;	                replaceIndex = i;	            }	        }	    }	    if (textIndex == -1) {	        return text;	    }	    int start = 0;	    int increase = 0;	    for (int i = 0; i < searchList.length; i++) {	        if (searchList[i] == null || replacementList[i] == null) {	            continue;	        }	        final int greater = replacementList[i].length() - searchList[i].length();	        if (greater > 0) {	            increase += 3 * greater;	        }	    }	    increase = Math.min(increase, text.length() / 5);	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (textIndex != -1) {	        for (int i = start; i < textIndex; i++) {	            buf.append(text.charAt(i));	        }	        buf.append(replacementList[replaceIndex]);	        start = textIndex + searchList[replaceIndex].length();	        textIndex = -1;	        replaceIndex = -1;	        tempIndex = -1;	        for (int i = 0; i < searchLength; i++) {	            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {	                continue;	            }	            tempIndex = text.indexOf(searchList[i], start);	            if (tempIndex == -1) {	                noMoreMatchesForReplIndex[i] = true;	            } else {	                if (textIndex == -1 || tempIndex < textIndex) {	                    textIndex = tempIndex;	                    replaceIndex = i;	                }	            }	        }	    }	    final int textLength = text.length();	    for (int i = start; i < textLength; i++) {	        buf.append(text.charAt(i));	    }	    final String result = buf.toString();	    if (!repeat) {	        return result;	    }	    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);	}
public static String upperCase(final String str, final Locale locale) {	    if (str == null) {	        return null;	    }	    return str.toUpperCase(locale);	}
public static String toString(final boolean bool, final String trueString, final String falseString) {	    return bool ? trueString : falseString;	}
public String getNullText() {	    return nullText;	}
public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) {	    if (src.length > 8) {	        throw new IllegalArgumentException("src.length>8: src.length=" + src.length);	    }	    if (src.length - srcPos < 4) {	        throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos);	    }	    if (src[srcPos + 3]) {	        if (src[srcPos + 2]) {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return '7';	                }	            } else {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return '3';	                }	            }	        } else {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return '5';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '1';	                }	            }	        }	    } else {	        if (src[srcPos + 2]) {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'e';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return 'a';	                } else {	                    return '2';	                }	            }	        } else {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'c';	                } else {	                    return '4';	                }	            } else {	                if (src[srcPos]) {	                    return '8';	                } else {	                    return '0';	                }	            }	        }	    }	}
protected boolean isUseShortClassName() {	    return useShortClassName;	}
public boolean contains(final CharRange range) {	    if (range == null) {	        throw new IllegalArgumentException("The Range must not be null");	    }	    if (negated) {	        if (range.negated) {	            return start >= range.start && end <= range.end;	        }	        return range.end < start || range.start > end;	    }	    if (range.negated) {	        return start == 0 && end == Character.MAX_VALUE;	    }	    return start <= range.start && end >= range.end;	}
public static String replaceOnce(final String text, final String searchString, final String replacement) {	    return replace(text, searchString, replacement, 1);	}
@Override	public String toString() {	    return "FastDateFormat[" + printer.getPattern() + "," + printer.getLocale() + "," + printer.getTimeZone().getID() + "]";	}
public static String random(final int count, final char... chars) {	    if (chars == null) {	        return random(count, 0, 0, false, false, null, RANDOM);	    }	    return random(count, 0, chars.length, false, false, chars, RANDOM);	}
public static boolean[] hexDigitToBinary(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return new boolean[] { false, false, false, false };	        case '1':	            return new boolean[] { true, false, false, false };	        case '2':	            return new boolean[] { false, true, false, false };	        case '3':	            return new boolean[] { true, true, false, false };	        case '4':	            return new boolean[] { false, false, true, false };	        case '5':	            return new boolean[] { true, false, true, false };	        case '6':	            return new boolean[] { false, true, true, false };	        case '7':	            return new boolean[] { true, true, true, false };	        case '8':	            return new boolean[] { false, false, false, true };	        case '9':	            return new boolean[] { true, false, false, true };	        case 'a':	        case 'A':	            return new boolean[] { false, true, false, true };	        case 'b':	        case 'B':	            return new boolean[] { true, true, false, true };	        case 'c':	        case 'C':	            return new boolean[] { false, false, true, true };	        case 'd':	        case 'D':	            return new boolean[] { true, false, true, true };	        case 'e':	        case 'E':	            return new boolean[] { false, true, true, true };	        case 'f':	        case 'F':	            return new boolean[] { true, true, true, true };	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public static String overlay(final String str, String overlay, int start, int end) {	    if (str == null) {	        return null;	    }	    if (overlay == null) {	        overlay = EMPTY;	    }	    final int len = str.length();	    if (start < 0) {	        start = 0;	    }	    if (start > len) {	        start = len;	    }	    if (end < 0) {	        end = 0;	    }	    if (end > len) {	        end = len;	    }	    if (start > end) {	        final int temp = start;	        start = end;	        end = temp;	    }	    return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString();	}
static Pair<IDKey, IDKey> getRegisterPair(final Object lhs, final Object rhs) {	    final IDKey left = new IDKey(lhs);	    final IDKey right = new IDKey(rhs);	    return Pair.of(left, right);	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static byte[] serialize(final Serializable obj) {	    final ByteArrayOutputStream baos = new ByteArrayOutputStream(512);	    serialize(obj, baos);	    return baos.toByteArray();	}
protected boolean isUseFieldNames() {	    return useFieldNames;	}
protected String getSummaryObjectEndText() {	    return summaryObjectEndText;	}
public int size() {	    return size;	}
public static Boolean[] nullToEmpty(final Boolean[] array) {	    if (array == null || array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    return array;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static boolean startsWithAny(final CharSequence string, final CharSequence... searchStrings) {	    if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {	        return false;	    }	    for (final CharSequence searchString : searchStrings) {	        if (StringUtils.startsWith(string, searchString)) {	            return true;	        }	    }	    return false;	}
public static String reverse(final String str) {	    if (str == null) {	        return null;	    }	    return new StringBuilder(str).reverse().toString();	}
@Override	public TimeZone getTimeZone() {	    return printer.getTimeZone();	}
public static <L, R> Pair<L, R> of(final L left, final R right) {	    return new ImmutablePair<L, R>(left, right);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
@Override	public boolean ready() {	    return pos < StrBuilder.this.size();	}
public static Object invokeStaticMethod(final Class<?> cls, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {	    if (parameterTypes == null) {	        parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;	    }	    if (args == null) {	        args = ArrayUtils.EMPTY_OBJECT_ARRAY;	    }	    final Method method = getMatchingAccessibleMethod(cls, methodName, parameterTypes);	    if (method == null) {	        throw new NoSuchMethodException("No such accessible method: " + methodName + "() on class: " + cls.getName());	    }	    return method.invoke(null, args);	}
public static boolean isWhitespace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isWhitespace(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static boolean endsWithIgnoreCase(final CharSequence str, final CharSequence suffix) {	    return endsWith(str, suffix, true);	}
public StrTokenizer setEmptyTokenAsNull(final boolean emptyAsNull) {	    this.emptyAsNull = emptyAsNull;	    return this;	}
protected boolean isUseClassName() {	    return useClassName;	}
@Override	public Set<String> getContextLabels() {	    return exceptionContext.getContextLabels();	}
public static boolean equals(final Object object1, final Object object2) {	    if (object1 == object2) {	        return true;	    }	    if (object1 == null || object2 == null) {	        return false;	    }	    return object1.equals(object2);	}
public int size() {	    return size;	}
protected boolean isUseFieldNames() {	    return useFieldNames;	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public StrBuilder setLength(final int length) {	    if (length < 0) {	        throw new StringIndexOutOfBoundsException(length);	    }	    if (length < size) {	        size = length;	    } else if (length > size) {	        ensureCapacity(length);	        final int oldEnd = size;	        final int newEnd = length;	        size = length;	        for (int i = oldEnd; i < newEnd; i++) {	            buffer[i] = '\0';	        }	    }	    return this;	}
public int set(final int holder) {	    return holder | _mask;	}
public static String difference(final String str1, final String str2) {	    if (str1 == null) {	        return str2;	    }	    if (str2 == null) {	        return str1;	    }	    final int at = indexOfDifference(str1, str2);	    if (at == INDEX_NOT_FOUND) {	        return EMPTY;	    }	    return str2.substring(at);	}
public int size() {	    return size;	}
protected String getSummaryObjectStartText() {	    return summaryObjectStartText;	}
public static Boolean or(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
public static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {	    if (str == null || searchStr == null) {	        return INDEX_NOT_FOUND;	    }	    if (startPos < 0) {	        startPos = 0;	    }	    final int endLimit = str.length() - searchStr.length() + 1;	    if (startPos > endLimit) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return startPos;	    }	    for (int i = startPos; i < endLimit; i++) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
Object getValue() {	    return value;	}
public boolean isEmpty() {	    return size == 0;	}
@Override	public void close() {	}
@Override	public float floatValue() {	    return (float) numerator / (float) denominator;	}
public static float max(final float a, final float b, final float c) {	    return Math.max(Math.max(a, b), c);	}
public boolean replaceIn(final StrBuilder source, final int offset, final int length) {	    if (source == null) {	        return false;	    }	    return substitute(source, offset, length);	}
public void getChars(final int startIndex, final int endIndex, final char[] destination, final int destinationIndex) {	    if (startIndex < 0) {	        throw new StringIndexOutOfBoundsException(startIndex);	    }	    if (endIndex < 0 || endIndex > length()) {	        throw new StringIndexOutOfBoundsException(endIndex);	    }	    if (startIndex > endIndex) {	        throw new StringIndexOutOfBoundsException("end < start");	    }	    System.arraycopy(buffer, startIndex, destination, destinationIndex, endIndex - startIndex);	}
public static String repeat(final char ch, final int repeat) {	    final char[] buf = new char[repeat];	    for (int i = repeat - 1; i >= 0; i--) {	        buf[i] = ch;	    }	    return new String(buf);	}
public static <T extends Comparable<? super T>> int compare(final T c1, final T c2, final boolean nullGreater) {	    if (c1 == c2) {	        return 0;	    } else if (c1 == null) {	        return nullGreater ? 1 : -1;	    } else if (c2 == null) {	        return nullGreater ? -1 : 1;	    }	    return c1.compareTo(c2);	}
protected boolean isUseShortClassName() {	    return useShortClassName;	}
public static String toString(final boolean bool, final String trueString, final String falseString) {	    return bool ? trueString : falseString;	}
@Override	public List<Pair<String, Object>> getContextEntries() {	    return this.exceptionContext.getContextEntries();	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public static String substringAfterLast(final String str, final String separator) {	    if (isEmpty(str)) {	        return str;	    }	    if (isEmpty(separator)) {	        return EMPTY;	    }	    final int pos = str.lastIndexOf(separator);	    if (pos == INDEX_NOT_FOUND || pos == str.length() - separator.length()) {	        return EMPTY;	    }	    return str.substring(pos + separator.length());	}
public static StrMatcher charSetMatcher(final String chars) {	    if (StringUtils.isEmpty(chars)) {	        return NONE_MATCHER;	    }	    if (chars.length() == 1) {	        return new CharMatcher(chars.charAt(0));	    }	    return new CharSetMatcher(chars.toCharArray());	}
@Override	public boolean markSupported() {	    return true;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public int set(final int holder) {	    return holder | _mask;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public synchronized int getAcquireCount() {	    return acquireCount;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
protected String getArrayEnd() {	    return arrayEnd;	}
@Override	public boolean equals(final Object obj) {	    return obj instanceof MutableDouble && Double.doubleToLongBits(((MutableDouble) obj).value) == Double.doubleToLongBits(value);	}
public static String prependIfMissingIgnoreCase(final String str, final CharSequence prefix, final CharSequence... prefixes) {	    return prependIfMissing(str, prefix, true, prefixes);	}
public int capacity() {	    return buffer.length;	}
@Override	public String toString() {	    return "FastDateFormat[" + printer.getPattern() + "," + printer.getLocale() + "," + printer.getTimeZone().getID() + "]";	}
public static String formatUTC(final Date date, final String pattern, final Locale locale) {	    return format(date, pattern, UTC_TIME_ZONE, locale);	}
@Override	public double doubleValue() {	    return (double) numerator / (double) denominator;	}
public int capacity() {	    return buffer.length;	}
public String getNewLineText() {	    return newLine;	}
protected String getSizeEndText() {	    return sizeEndText;	}
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = Integer.MAX_VALUE;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.indexOf(str, search, 0);	        if (tmp == INDEX_NOT_FOUND) {	            continue;	        }	        if (tmp < ret) {	            ret = tmp;	        }	    }	    return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;	}
public static <T> T initializeUnchecked(final ConcurrentInitializer<T> initializer) {	    try {	        return initialize(initializer);	    } catch (final ConcurrentException cex) {	        throw new ConcurrentRuntimeException(cex.getCause());	    }	}
public int size() {	    return size;	}
public boolean isEmpty() {	    return size == 0;	}
public static String swapCase(final String str) {	    if (StringUtils.isEmpty(str)) {	        return str;	    }	    final char[] buffer = str.toCharArray();	    for (int i = 0; i < buffer.length; i++) {	        final char ch = buffer[i];	        if (Character.isUpperCase(ch)) {	            buffer[i] = Character.toLowerCase(ch);	        } else if (Character.isTitleCase(ch)) {	            buffer[i] = Character.toLowerCase(ch);	        } else if (Character.isLowerCase(ch)) {	            buffer[i] = Character.toUpperCase(ch);	        }	    }	    return new String(buffer);	}
public static String repeat(final char ch, final int repeat) {	    final char[] buf = new char[repeat];	    for (int i = repeat - 1; i >= 0; i--) {	        buf[i] = ch;	    }	    return new String(buf);	}
public static String right(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(str.length() - len);	}
public static int hexDigitMsb0ToInt(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return 0x0;	        case '1':	            return 0x8;	        case '2':	            return 0x4;	        case '3':	            return 0xC;	        case '4':	            return 0x2;	        case '5':	            return 0xA;	        case '6':	            return 0x6;	        case '7':	            return 0xE;	        case '8':	            return 0x1;	        case '9':	            return 0x9;	        case 'a':	        case 'A':	            return 0x5;	        case 'b':	        case 'B':	            return 0xD;	        case 'c':	        case 'C':	            return 0x3;	        case 'd':	        case 'D':	            return 0xB;	        case 'e':	        case 'E':	            return 0x7;	        case 'f':	        case 'F':	            return 0xF;	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public static boolean isAlpha(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static ConcurrentRuntimeException extractCauseUnchecked(final ExecutionException ex) {	    if (ex == null || ex.getCause() == null) {	        return null;	    }	    throwCause(ex);	    return new ConcurrentRuntimeException(ex.getMessage(), ex.getCause());	}
public static String random(final int count, final char... chars) {	    if (chars == null) {	        return random(count, 0, 0, false, false, null, RANDOM);	    }	    return random(count, 0, chars.length, false, false, chars, RANDOM);	}
public static String formatUTC(final Date date, final String pattern, final Locale locale) {	    return format(date, pattern, UTC_TIME_ZONE, locale);	}
public static CharRange isIn(final char start, final char end) {	    return new CharRange(start, end, false);	}
protected boolean isFieldSeparatorAtEnd() {	    return fieldSeparatorAtEnd;	}
public static int indexOfAnyBut(final CharSequence seq, final CharSequence searchChars) {	    if (isEmpty(seq) || isEmpty(searchChars)) {	        return INDEX_NOT_FOUND;	    }	    final int strLen = seq.length();	    for (int i = 0; i < strLen; i++) {	        final char ch = seq.charAt(i);	        final boolean chFound = CharSequenceUtils.indexOf(searchChars, ch, 0) >= 0;	        if (i + 1 < strLen && Character.isHighSurrogate(ch)) {	            final char ch2 = seq.charAt(i + 1);	            if (chFound && CharSequenceUtils.indexOf(searchChars, ch2, 0) < 0) {	                return i;	            }	        } else {	            if (!chFound) {	                return i;	            }	        }	    }	    return INDEX_NOT_FOUND;	}
public static Class<?> getClass(final String className, final boolean initialize) throws ClassNotFoundException {	    final ClassLoader contextCL = Thread.currentThread().getContextClassLoader();	    final ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL;	    return getClass(loader, className, initialize);	}
public static String normalizeSpace(final String str) {	    if (str == null) {	        return null;	    }	    return WHITESPACE_PATTERN.matcher(trim(str)).replaceAll(SPACE);	}
public static boolean containsNone(final CharSequence cs, final String invalidChars) {	    if (cs == null || invalidChars == null) {	        return true;	    }	    return containsNone(cs, invalidChars.toCharArray());	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
@Override	public T get() throws ConcurrentException {	    try {	        return getFuture().get();	    } catch (final ExecutionException execex) {	        ConcurrentUtils.handleCause(execex);	        return null;	    } catch (final InterruptedException iex) {	        Thread.currentThread().interrupt();	        throw new ConcurrentException(iex);	    }	}
public static String keep(final String str, final String... set) {	    if (str == null) {	        return null;	    }	    if (str.isEmpty() || deepEmpty(set)) {	        return StringUtils.EMPTY;	    }	    return modify(str, set, true);	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static Class<?> wrapperToPrimitive(final Class<?> cls) {	    return wrapperPrimitiveMap.get(cls);	}
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, true);	}
public static Fraction getReducedFraction(int numerator, int denominator) {	    if (denominator == 0) {	        throw new ArithmeticException("The denominator must not be zero");	    }	    if (numerator == 0) {	        return ZERO;	    }	    if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) {	        numerator /= 2;	        denominator /= 2;	    }	    if (denominator < 0) {	        if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {	            throw new ArithmeticException("overflow: can't negate");	        }	        numerator = -numerator;	        denominator = -denominator;	    }	    final int gcd = greatestCommonDivisor(numerator, denominator);	    numerator /= gcd;	    denominator /= gcd;	    return new Fraction(numerator, denominator);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public int getDenominator() {	    return denominator;	}
public static String random(final int count, final char... chars) {	    if (chars == null) {	        return random(count, 0, 0, false, false, null, RANDOM);	    }	    return random(count, 0, chars.length, false, false, chars, RANDOM);	}
public boolean isIgnoreEmptyTokens() {	    return ignoreEmptyTokens;	}
@Override	public int length() {	    return size;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static String prependIfMissingIgnoreCase(final String str, final CharSequence prefix, final CharSequence... prefixes) {	    return prependIfMissing(str, prefix, true, prefixes);	}
protected boolean isUseShortClassName() {	    return useShortClassName;	}
public String getNewLineText() {	    return newLine;	}
public boolean booleanValue() {	    return value;	}
public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment) {	    return getFragment(calendar, fragment, Calendar.MILLISECOND);	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    if (input.charAt(index) == '\\' && index < (input.length() - 1) && Character.isDigit(input.charAt(index + 1))) {	        final int start = index + 1;	        int end = index + 2;	        while (end < input.length() && Character.isDigit(input.charAt(end))) {	            end++;	            if (Integer.parseInt(input.subSequence(start, end).toString(), 10) > OCTAL_MAX) {	                end--;	                break;	            }	        }	        out.write(Integer.parseInt(input.subSequence(start, end).toString(), 8));	        return 1 + end - start;	    }	    return 0;	}
public Range<T> intersectionWith(final Range<T> other) {	    if (!this.isOverlappedBy(other)) {	        throw new IllegalArgumentException(String.format("Cannot calculate intersection with non-overlapping range %s", other));	    }	    if (this.equals(other)) {	        return this;	    }	    final T min = getComparator().compare(minimum, other.minimum) < 0 ? other.minimum : minimum;	    final T max = getComparator().compare(maximum, other.maximum) < 0 ? maximum : other.maximum;	    return between(min, max, getComparator());	}
@Override	public boolean isCancelled() {	    return false;	}
public static BigInteger createBigInteger(final String str) {	    if (str == null) {	        return null;	    }	    int pos = 0;	    int radix = 10;	    boolean negate = false;	    if (str.startsWith("-")) {	        negate = true;	        pos = 1;	    }	    if (str.startsWith("0x", pos) || str.startsWith("0x", pos)) {	        radix = 16;	        pos += 2;	    } else if (str.startsWith("#", pos)) {	        radix = 16;	        pos++;	    } else if (str.startsWith("0", pos) && str.length() > pos + 1) {	        radix = 8;	        pos++;	    }	    final BigInteger value = new BigInteger(str.substring(pos), radix);	    return negate ? value.negate() : value;	}
public String getNullText() {	    return nullText;	}
public static String lowerCase(final String str, final Locale locale) {	    if (str == null) {	        return null;	    }	    return str.toLowerCase(locale);	}
@Override	public int hashCode() {	    int result = super.hashCode();	    result = HASH_SEED * result + ObjectUtils.hashCode(registry);	    result = HASH_SEED * result + ObjectUtils.hashCode(toPattern);	    return result;	}
public static String swapCase(final String str) {	    if (StringUtils.isEmpty(str)) {	        return str;	    }	    final char[] buffer = str.toCharArray();	    for (int i = 0; i < buffer.length; i++) {	        final char ch = buffer[i];	        if (Character.isUpperCase(ch)) {	            buffer[i] = Character.toLowerCase(ch);	        } else if (Character.isTitleCase(ch)) {	            buffer[i] = Character.toLowerCase(ch);	        } else if (Character.isLowerCase(ch)) {	            buffer[i] = Character.toUpperCase(ch);	        }	    }	    return new String(buffer);	}
public String getNewLineText() {	    return newLine;	}
public static String leftPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return leftPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return padStr.concat(str);	    } else if (pads < padLen) {	        return padStr.substring(0, pads).concat(str);	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return new String(padding).concat(str);	    }	}
public boolean isEmpty() {	    return size == 0;	}
public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale) {	    return cache.getDateTimeInstance(dateStyle, timeStyle, timeZone, locale);	}
@Override	public StringBuffer format(final Calendar calendar, final StringBuffer buf) {	    return applyRules(calendar, buf);	}
public char[] toCharArray(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len == 0) {	        return ArrayUtils.EMPTY_CHAR_ARRAY;	    }	    final char[] chars = new char[len];	    System.arraycopy(buffer, startIndex, chars, 0, len);	    return chars;	}
public static double[] addAll(final double[] array1, final double... array2) {	    if (array1 == null) {	        return clone(array2);	    } else if (array2 == null) {	        return clone(array1);	    }	    final double[] joinedArray = new double[array1.length + array2.length];	    System.arraycopy(array1, 0, joinedArray, 0, array1.length);	    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);	    return joinedArray;	}
public static StrTokenizer getTSVInstance(final char[] input) {	    final StrTokenizer tok = getTSVClone();	    tok.reset(input);	    return tok;	}
@Override	public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) {	    return buffer[pos] <= 32 ? 1 : 0;	}
@Override	public void mark(final int readAheadLimit) {	    mark = pos;	}
public static String rightPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return rightPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return str.concat(padStr);	    } else if (pads < padLen) {	        return str.concat(padStr.substring(0, pads));	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return str.concat(new String(padding));	    }	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public static float min(final float a, final float b) {	    if (Float.isNaN(a)) {	        return b;	    } else if (Float.isNaN(b)) {	        return a;	    } else {	        return Math.min(a, b);	    }	}
public boolean isEmpty() {	    return size == 0;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public static String center(String str, final int size, String padStr) {	    if (str == null || size <= 0) {	        return str;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    str = leftPad(str, strLen + pads / 2, padStr);	    str = rightPad(str, size, padStr);	    return str;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static String substringAfter(final String str, final String separator) {	    if (isEmpty(str)) {	        return str;	    }	    if (separator == null) {	        return EMPTY;	    }	    final int pos = str.indexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return EMPTY;	    }	    return str.substring(pos + separator.length());	}
public String getNullText() {	    return nullText;	}
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, true);	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public static String toString(final Object obj, final String nullStr) {	    return obj == null ? nullStr : obj.toString();	}
public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width, final int precision, final char padChar, final CharSequence ellipsis) {	    Validate.isTrue(ellipsis == null || precision < 0 || ellipsis.length() <= precision, "Specified ellipsis '%1$s' exceeds precision of %2$s", ellipsis, Integer.valueOf(precision));	    final StringBuilder buf = new StringBuilder(seq);	    if (precision >= 0 && precision < seq.length()) {	        final CharSequence _ellipsis = ObjectUtils.defaultIfNull(ellipsis, StringUtils.EMPTY);	        buf.replace(precision - _ellipsis.length(), seq.length(), _ellipsis.toString());	    }	    final boolean leftJustify = (flags & LEFT_JUSTIFY) == LEFT_JUSTIFY;	    for (int i = buf.length(); i < width; i++) {	        buf.insert(leftJustify ? i : 0, padChar);	    }	    formatter.format(buf.toString());	    return formatter;	}
@Override	public int length() {	    return size;	}
public final synchronized void setExternalExecutor(final ExecutorService externalExecutor) {	    if (isStarted()) {	        throw new IllegalStateException("Cannot set ExecutorService after start()!");	    }	    this.externalExecutor = externalExecutor;	}
public static String trim(final String str) {	    return str == null ? null : str.trim();	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) {	    style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));	    return this;	}
public static boolean isWhitespace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isWhitespace(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
protected boolean isFieldSeparatorAtEnd() {	    return fieldSeparatorAtEnd;	}
public static String trim(final String str) {	    return str == null ? null : str.trim();	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public static String overlay(final String str, String overlay, int start, int end) {	    if (str == null) {	        return null;	    }	    if (overlay == null) {	        overlay = EMPTY;	    }	    final int len = str.length();	    if (start < 0) {	        start = 0;	    }	    if (start > len) {	        start = len;	    }	    if (end < 0) {	        end = 0;	    }	    if (end > len) {	        end = len;	    }	    if (start > end) {	        final int temp = start;	        start = end;	        end = temp;	    }	    return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString();	}
public boolean isEmpty() {	    return size == 0;	}
@Override	public boolean ready() {	    return pos < StrBuilder.this.size();	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public String getNullText() {	    return nullText;	}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    buffer.append(arrayStart);	    for (int i = 0; i < array.length; i++) {	        if (i > 0) {	            buffer.append(arraySeparator);	        }	        appendDetail(buffer, fieldName, array[i]);	    }	    buffer.append(arrayEnd);	}
@Override	public int nextIndex() {	    return tokenPos;	}
public static String substringAfter(final String str, final String separator) {	    if (isEmpty(str)) {	        return str;	    }	    if (separator == null) {	        return EMPTY;	    }	    final int pos = str.indexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return EMPTY;	    }	    return str.substring(pos + separator.length());	}
public StrTokenizer setDelimiterMatcher(final StrMatcher delim) {	    if (delim == null) {	        this.delimMatcher = StrMatcher.noneMatcher();	    } else {	        this.delimMatcher = delim;	    }	    return this;	}
public Fraction multiplyBy(final Fraction fraction) {	    if (fraction == null) {	        throw new IllegalArgumentException("The fraction must not be null");	    }	    if (numerator == 0 || fraction.numerator == 0) {	        return ZERO;	    }	    final int d1 = greatestCommonDivisor(numerator, fraction.denominator);	    final int d2 = greatestCommonDivisor(fraction.numerator, denominator);	    return getReducedFraction(mulAndCheck(numerator / d1, fraction.numerator / d2), mulPosAndCheck(denominator / d2, fraction.denominator / d1));	}
public static boolean isAlpha(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public int indexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex < 0 ? 0 : startIndex);	    if (matcher == null || startIndex >= size) {	        return -1;	    }	    final int len = size;	    final char[] buf = buffer;	    for (int i = startIndex; i < len; i++) {	        if (matcher.isMatch(buf, i, startIndex, len) > 0) {	            return i;	        }	    }	    return -1;	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
public static int count(final String str, final String... set) {	    if (StringUtils.isEmpty(str) || deepEmpty(set)) {	        return 0;	    }	    final CharSet chars = CharSet.getInstance(set);	    int count = 0;	    for (final char c : str.toCharArray()) {	        if (chars.contains(c)) {	            count++;	        }	    }	    return count;	}
public String toString(final String format) {	    return String.format(format, minimum, maximum, comparator);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public int capacity() {	    return buffer.length;	}
static boolean isJavaVersionMatch(final String version, final String versionPrefix) {	    if (version == null) {	        return false;	    }	    return version.startsWith(versionPrefix);	}
public boolean isEmpty() {	    return size == 0;	}
@Override	public void write(final String str, final int off, final int len) {	    StrBuilder.this.append(str, off, len);	}
public static String center(String str, final int size, String padStr) {	    if (str == null || size <= 0) {	        return str;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    str = leftPad(str, strLen + pads / 2, padStr);	    str = rightPad(str, size, padStr);	    return str;	}
public static boolean notEqual(final Object object1, final Object object2) {	    return ObjectUtils.equals(object1, object2) == false;	}
@Override	public String build() {	    return toString();	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public void increment() {	    value++;	}
public String getNullText() {	    return nullText;	}
public short setShort(final short holder) {	    return (short) set(holder);	}
public int capacity() {	    return buffer.length;	}
protected boolean isDefaultFullDetail() {	    return defaultFullDetail;	}
public static String getShortCanonicalName(final String canonicalName) {	    return ClassUtils.getShortClassName(getCanonicalName(canonicalName));	}
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, true);	}
public static String substringBefore(final String str, final String separator) {	    if (isEmpty(str) || separator == null) {	        return str;	    }	    if (separator.isEmpty()) {	        return EMPTY;	    }	    final int pos = str.indexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return str;	    }	    return str.substring(0, pos);	}
public static short CONST_SHORT(final int v) throws IllegalArgumentException {	    if (v < Short.MIN_VALUE || v > Short.MAX_VALUE) {	        throw new IllegalArgumentException("Supplied value must be a valid byte literal between -32768 and 32767: [" + v + "]");	    }	    return (short) v;	}
protected String getArrayEnd() {	    return arrayEnd;	}
@Override	public ContextedRuntimeException setContextValue(final String label, final Object value) {	    exceptionContext.setContextValue(label, value);	    return this;	}
public static boolean typesSatisfyVariables(final Map<TypeVariable<?>, Type> typeVarAssigns) {	    for (final Map.Entry<TypeVariable<?>, Type> entry : typeVarAssigns.entrySet()) {	        final TypeVariable<?> typeVar = entry.getKey();	        final Type type = entry.getValue();	        for (final Type bound : getImplicitBounds(typeVar)) {	            if (!isAssignable(type, substituteTypeVariables(bound, typeVarAssigns), typeVarAssigns)) {	                return false;	            }	        }	    }	    return true;	}
synchronized void endOfPeriod() {	    lastCallsPerPeriod = acquireCount;	    totalAcquireCount += acquireCount;	    periodCount++;	    acquireCount = 0;	    notifyAll();	}
public StrTokenizer reset(final char[] input) {	    reset();	    this.chars = ArrayUtils.clone(input);	    return this;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public static Method getAccessibleMethod(Method method) {	    if (!MemberUtils.isAccessible(method)) {	        return null;	    }	    final Class<?> cls = method.getDeclaringClass();	    if (Modifier.isPublic(cls.getModifiers())) {	        return method;	    }	    final String methodName = method.getName();	    final Class<?>[] parameterTypes = method.getParameterTypes();	    method = getAccessibleMethodFromInterfaceNest(cls, methodName, parameterTypes);	    if (method == null) {	        method = getAccessibleMethodFromSuperclass(cls, methodName, parameterTypes);	    }	    return method;	}
public boolean isEquals() {	    return this.isEquals;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public Fraction multiplyBy(final Fraction fraction) {	    if (fraction == null) {	        throw new IllegalArgumentException("The fraction must not be null");	    }	    if (numerator == 0 || fraction.numerator == 0) {	        return ZERO;	    }	    final int d1 = greatestCommonDivisor(numerator, fraction.denominator);	    final int d2 = greatestCommonDivisor(fraction.numerator, denominator);	    return getReducedFraction(mulAndCheck(numerator / d1, fraction.numerator / d2), mulPosAndCheck(denominator / d2, fraction.denominator / d1));	}
@Override	public long longValue() {	    return (long) numerator / denominator;	}
public static String uncapitalize(final String str) {	    int strLen;	    if (str == null || (strLen = str.length()) == 0) {	        return str;	    }	    char firstChar = str.charAt(0);	    if (Character.isLowerCase(firstChar)) {	        return str;	    }	    return new StringBuilder(strLen).append(Character.toLowerCase(firstChar)).append(str.substring(1)).toString();	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static String random(final int count, final char... chars) {	    if (chars == null) {	        return random(count, 0, 0, false, false, null, RANDOM);	    }	    return random(count, 0, chars.length, false, false, chars, RANDOM);	}
public static float min(final float a, final float b, final float c) {	    return Math.min(Math.min(a, b), c);	}
public static File getUserHome() {	    return new File(System.getProperty(USER_HOME_KEY));	}
@Override	public StringBuffer format(final Calendar calendar, final StringBuffer buf) {	    return printer.format(calendar, buf);	}
public static String leftPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return leftPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return padStr.concat(str);	    } else if (pads < padLen) {	        return padStr.substring(0, pads).concat(str);	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return new String(padding).concat(str);	    }	}
@Override	public void reset() {	    pos = mark;	}
protected boolean isUseClassName() {	    return useClassName;	}
public static boolean isAllUpperCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isUpperCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public String getNewLineText() {	    return newLine;	}
public int size() {	    return size;	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    if (input.charAt(index) == '\\' && index < (input.length() - 1) && Character.isDigit(input.charAt(index + 1))) {	        final int start = index + 1;	        int end = index + 2;	        while (end < input.length() && Character.isDigit(input.charAt(end))) {	            end++;	            if (Integer.parseInt(input.subSequence(start, end).toString(), 10) > OCTAL_MAX) {	                end--;	                break;	            }	        }	        out.write(Integer.parseInt(input.subSequence(start, end).toString(), 8));	        return 1 + end - start;	    }	    return 0;	}
@Override	public String previous() {	    if (hasPrevious()) {	        return tokens[--tokenPos];	    }	    throw new NoSuchElementException();	}
protected String getContentStart() {	    return contentStart;	}
public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) {	    if (array == null) {	        return null;	    }	    if (startIndexInclusive < 0) {	        startIndexInclusive = 0;	    }	    if (endIndexExclusive > array.length) {	        endIndexExclusive = array.length;	    }	    final int newSize = endIndexExclusive - startIndexInclusive;	    if (newSize <= 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] subarray = new boolean[newSize];	    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);	    return subarray;	}
public static <T extends Comparable<? super T>> int compare(final T c1, final T c2, final boolean nullGreater) {	    if (c1 == c2) {	        return 0;	    } else if (c1 == null) {	        return nullGreater ? 1 : -1;	    } else if (c2 == null) {	        return nullGreater ? -1 : 1;	    }	    return c1.compareTo(c2);	}
protected int getTaskCount() {	    return 1;	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public static void isInstanceOf(final Class<?> type, final Object obj, final String message, final Object... values) {	    if (type.isInstance(obj) == false) {	        throw new IllegalArgumentException(String.format(message, values));	    }	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public StrBuilder appendSeparator(final char separator, final int loopIndex) {	    if (loopIndex > 0) {	        append(separator);	    }	    return this;	}
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) {	    return new Range<T>(fromInclusive, toInclusive, comparator);	}
public static StrMatcher trimMatcher() {	    return TRIM_MATCHER;	}
public static <T extends CharSequence> T notEmpty(final T chars) {	    return notEmpty(chars, DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE);	}
public static boolean isAsciiAlphaLower(final char ch) {	    return ch >= 'a' && ch <= 'z';	}
public int size() {	    return size;	}
public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale) {	    return cache.getInstance(pattern, timeZone, locale);	}
public static int lastIndexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = INDEX_NOT_FOUND;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.lastIndexOf(str, search, str.length());	        if (tmp > ret) {	            ret = tmp;	        }	    }	    return ret;	}
public static String toString(final Object obj, final String nullStr) {	    return obj == null ? nullStr : obj.toString();	}
public StrBuilder replaceAll(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, -1);	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public boolean isEquals() {	    return this.isEquals;	}
public int size() {	    return size;	}
public static boolean isAsciiAlphaUpper(final char ch) {	    return ch >= 'A' && ch <= 'Z';	}
@Override	public String toString() {	    if (this.getObject() == null) {	        return this.getStyle().getNullText();	    }	    Class<?> clazz = this.getObject().getClass();	    this.appendFieldsIn(clazz);	    while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {	        clazz = clazz.getSuperclass();	        this.appendFieldsIn(clazz);	    }	    return super.toString();	}
public boolean isEmpty() {	    return size == 0;	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) {	    final StrMatcher prefixMatcher = getVariablePrefixMatcher();	    final StrMatcher suffixMatcher = getVariableSuffixMatcher();	    final char escape = getEscapeChar();	    final boolean top = priorVariables == null;	    boolean altered = false;	    int lengthChange = 0;	    char[] chars = buf.buffer;	    int bufEnd = offset + length;	    int pos = offset;	    while (pos < bufEnd) {	        final int startMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd);	        if (startMatchLen == 0) {	            pos++;	        } else {	            if (pos > offset && chars[pos - 1] == escape) {	                buf.deleteCharAt(pos - 1);	                chars = buf.buffer;	                lengthChange--;	                altered = true;	                bufEnd--;	            } else {	                final int startPos = pos;	                pos += startMatchLen;	                int endMatchLen = 0;	                int nestedVarCount = 0;	                while (pos < bufEnd) {	                    if (isEnableSubstitutionInVariables() && (endMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd)) != 0) {	                        nestedVarCount++;	                        pos += endMatchLen;	                        continue;	                    }	                    endMatchLen = suffixMatcher.isMatch(chars, pos, offset, bufEnd);	                    if (endMatchLen == 0) {	                        pos++;	                    } else {	                        if (nestedVarCount == 0) {	                            String varName = new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen);	                            if (isEnableSubstitutionInVariables()) {	                                final StrBuilder bufName = new StrBuilder(varName);	                                substitute(bufName, 0, bufName.length());	                                varName = bufName.toString();	                            }	                            pos += endMatchLen;	                            final int endPos = pos;	                            if (priorVariables == null) {	                                priorVariables = new ArrayList<String>();	                                priorVariables.add(new String(chars, offset, length));	                            }	                            checkCyclicSubstitution(varName, priorVariables);	                            priorVariables.add(varName);	                            final String varValue = resolveVariable(varName, buf, startPos, endPos);	                            if (varValue != null) {	                                final int varLen = varValue.length();	                                buf.replace(startPos, endPos, varValue);	                                altered = true;	                                int change = substitute(buf, startPos, varLen, priorVariables);	                                change = change + varLen - (endPos - startPos);	                                pos += change;	                                bufEnd += change;	                                lengthChange += change;	                                chars = buf.buffer;	                            }	                            priorVariables.remove(priorVariables.size() - 1);	                            break;	                        } else {	                            nestedVarCount--;	                            pos += endMatchLen;	                        }	                    }	                }	            }	        }	    }	    if (top) {	        return altered ? 1 : 0;	    }	    return lengthChange;	}
public static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) {	    if (0 == nHexs) {	        return dstInit;	    }	    if ((nHexs - 1) * 4 + srcPos >= 32) {	        throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 32");	    }	    final StringBuilder sb = new StringBuilder(dstInit);	    int shift = 0;	    int append = sb.length();	    for (int i = 0; i < nHexs; i++) {	        shift = i * 4 + srcPos;	        final int bits = 0xF & (src >> shift);	        if (dstPos + i == append) {	            ++append;	            sb.append(intToHexDigit(bits));	        } else {	            sb.setCharAt(dstPos + i, intToHexDigit(bits));	        }	    }	    return sb.toString();	}
public boolean isEmptyTokenAsNull() {	    return this.emptyAsNull;	}
@Override	public int length() {	    return size;	}
public Fraction negate() {	    if (numerator == Integer.MIN_VALUE) {	        throw new ArithmeticException("overflow: too large to negate");	    }	    return new Fraction(-numerator, denominator);	}
public abstract boolean translate(int codepoint, Writer out) throws IOException;
public StrBuilder setLength(final int length) {	    if (length < 0) {	        throw new StringIndexOutOfBoundsException(length);	    }	    if (length < size) {	        size = length;	    } else if (length > size) {	        ensureCapacity(length);	        final int oldEnd = size;	        final int newEnd = length;	        size = length;	        for (int i = oldEnd; i < newEnd; i++) {	            buffer[i] = '\0';	        }	    }	    return this;	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
public StrBuilder deleteAll(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, -1);	}
public static final String escapeEcmaScript(final String input) {	    return ESCAPE_ECMASCRIPT.translate(input);	}
public static short[] removeElement(final short[] array, final short element) {	    final int index = indexOf(array, element);	    if (index == INDEX_NOT_FOUND) {	        return clone(array);	    }	    return remove(array, index);	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public String getNewLineText() {	    return newLine;	}
public boolean isNegated() {	    return negated;	}
public StringBuffer toStringBuffer() {	    return new StringBuffer(size).append(buffer, 0, size);	}
public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) {	    if (array == null) {	        return null;	    }	    if (startIndexInclusive < 0) {	        startIndexInclusive = 0;	    }	    if (endIndexExclusive > array.length) {	        endIndexExclusive = array.length;	    }	    final int newSize = endIndexExclusive - startIndexInclusive;	    if (newSize <= 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] subarray = new boolean[newSize];	    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);	    return subarray;	}
public static boolean isNotEmpty(final boolean[] array) {	    return (array != null && array.length != 0);	}
public String getNewLineText() {	    return newLine;	}
public static CharRange is(final char ch) {	    return new CharRange(ch, ch, false);	}
public static char binaryToHexDigit(final boolean[] src, final int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    if (src.length > srcPos + 3 && src[srcPos + 3]) {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src[srcPos]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
public String getNewLineText() {	    return newLine;	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public void stop() {	    if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {	        throw new IllegalStateException("Stopwatch is not running. ");	    }	    if (this.runningState == STATE_RUNNING) {	        this.stopTime = System.nanoTime();	    }	    this.runningState = STATE_STOPPED;	}
static int lastIndexOf(final CharSequence cs, final CharSequence searchChar, final int start) {	    return cs.toString().lastIndexOf(searchChar.toString(), start);	}
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, true);	}
public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) {	    if (it != null) {	        separator = ObjectUtils.toString(separator);	        while (it.hasNext()) {	            append(it.next());	            if (it.hasNext()) {	                append(separator);	            }	        }	    }	    return this;	}
public static float max(final float a, final float b, final float c) {	    return Math.max(Math.max(a, b), c);	}
@Override	public int length() {	    return size;	}
public static String upperCase(final String str, final Locale locale) {	    if (str == null) {	        return null;	    }	    return str.toUpperCase(locale);	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public int size() {	    return size;	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public String getNullText() {	    return nullText;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
protected ScheduledFuture<?> startTimer() {	    return getExecutorService().scheduleAtFixedRate(new Runnable() {		        @Override	        public void run() {	            endOfPeriod();	        }	    }, getPeriod(), getPeriod(), getUnit());	}
public static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {	    if (str == null || searchStr == null) {	        return INDEX_NOT_FOUND;	    }	    if (startPos < 0) {	        startPos = 0;	    }	    final int endLimit = str.length() - searchStr.length() + 1;	    if (startPos > endLimit) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return startPos;	    }	    for (int i = startPos; i < endLimit; i++) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static String replaceEachRepeatedly(final String text, final String[] searchList, final String[] replacementList) {	    final int timeToLive = searchList == null ? 0 : searchList.length;	    return replaceEach(text, searchList, replacementList, true, timeToLive);	}
public static String chop(final String str) {	    if (str == null) {	        return null;	    }	    final int strLen = str.length();	    if (strLen < 2) {	        return EMPTY;	    }	    final int lastIdx = strLen - 1;	    final String ret = str.substring(0, lastIdx);	    final char last = str.charAt(lastIdx);	    if (last == CharUtils.LF && ret.charAt(lastIdx - 1) == CharUtils.CR) {	        return ret.substring(0, lastIdx - 1);	    }	    return ret;	}
public boolean isFalse() {	    return value == false;	}
public boolean isEmpty() {	    return size == 0;	}
public static String rightPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return rightPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return str.concat(padStr);	    } else if (pads < padLen) {	        return str.concat(padStr.substring(0, pads));	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return str.concat(new String(padding));	    }	}
public static String substringBetween(final String str, final String open, final String close) {	    if (str == null || open == null || close == null) {	        return null;	    }	    final int start = str.indexOf(open);	    if (start != INDEX_NOT_FOUND) {	        final int end = str.indexOf(close, start + open.length());	        if (end != INDEX_NOT_FOUND) {	            return str.substring(start + open.length(), end);	        }	    }	    return null;	}
public String getNullText() {	    return nullText;	}
@Override	public double doubleValue() {	    return (double) numerator / (double) denominator;	}
public static Boolean or(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
public static String trim(final String str) {	    return str == null ? null : str.trim();	}
public StrBuilder appendSeparator(final char separator, final int loopIndex) {	    if (loopIndex > 0) {	        append(separator);	    }	    return this;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
@Override	public void write(final String str, final int off, final int len) {	    StrBuilder.this.append(str, off, len);	}
public static Boolean[] nullToEmpty(final Boolean[] array) {	    if (array == null || array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    return array;	}
public int toHashCode() {	    return iTotal;	}
public char getEnd() {	    return this.end;	}
public int capacity() {	    return buffer.length;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static String substringBefore(final String str, final String separator) {	    if (isEmpty(str) || separator == null) {	        return str;	    }	    if (separator.isEmpty()) {	        return EMPTY;	    }	    final int pos = str.indexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return str;	    }	    return str.substring(0, pos);	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
protected String getSummaryObjectStartText() {	    return summaryObjectStartText;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public StrTokenizer setIgnoreEmptyTokens(final boolean ignoreEmptyTokens) {	    this.ignoreEmptyTokens = ignoreEmptyTokens;	    return this;	}
protected boolean isUseClassName() {	    return useClassName;	}
public static String getCommonPrefix(final String... strs) {	    if (strs == null || strs.length == 0) {	        return EMPTY;	    }	    final int smallestIndexOfDiff = indexOfDifference(strs);	    if (smallestIndexOfDiff == INDEX_NOT_FOUND) {	        if (strs[0] == null) {	            return EMPTY;	        }	        return strs[0];	    } else if (smallestIndexOfDiff == 0) {	        return EMPTY;	    } else {	        return strs[0].substring(0, smallestIndexOfDiff);	    }	}
public static String formatDurationISO(final long durationMillis) {	    return formatDuration(durationMillis, ISO_EXTENDED_FORMAT_PATTERN, false);	}
protected String getContentEnd() {	    return contentEnd;	}
public static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts) {	    if (0 == nShorts) {	        return dst;	    }	    if ((nShorts - 1) * 16 + srcPos >= 64) {	        throw new IllegalArgumentException("(nShorts-1)*16+srcPos is greather or equal to than 64");	    }	    int shift = 0;	    for (int i = 0; i < nShorts; i++) {	        shift = i * 16 + srcPos;	        dst[dstPos + i] = (short) (0xffff & (src >> shift));	    }	    return dst;	}
protected boolean isUseClassName() {	    return useClassName;	}
public short getShortValue(final short holder) {	    return (short) getValue(holder);	}
public static BigDecimal createBigDecimal(final String str) {	    if (str == null) {	        return null;	    }	    if (StringUtils.isBlank(str)) {	        throw new NumberFormatException("A blank string is not a valid number");	    }	    if (str.trim().startsWith("--")) {	        throw new NumberFormatException(str + " is not a valid number.");	    }	    return new BigDecimal(str);	}
public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width, final int precision, final char padChar, final CharSequence ellipsis) {	    Validate.isTrue(ellipsis == null || precision < 0 || ellipsis.length() <= precision, "Specified ellipsis '%1$s' exceeds precision of %2$s", ellipsis, Integer.valueOf(precision));	    final StringBuilder buf = new StringBuilder(seq);	    if (precision >= 0 && precision < seq.length()) {	        final CharSequence _ellipsis = ObjectUtils.defaultIfNull(ellipsis, StringUtils.EMPTY);	        buf.replace(precision - _ellipsis.length(), seq.length(), _ellipsis.toString());	    }	    final boolean leftJustify = (flags & LEFT_JUSTIFY) == LEFT_JUSTIFY;	    for (int i = buf.length(); i < width; i++) {	        buf.insert(leftJustify ? i : 0, padChar);	    }	    formatter.format(buf.toString());	    return formatter;	}
public static char binaryToHexDigit(final boolean[] src, final int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    if (src.length > srcPos + 3 && src[srcPos + 3]) {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src[srcPos]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
public static boolean containsNone(final CharSequence cs, final String invalidChars) {	    if (cs == null || invalidChars == null) {	        return true;	    }	    return containsNone(cs, invalidChars.toCharArray());	}
@Override	public int length() {	    return size;	}
@Override	public boolean ready() {	    return pos < StrBuilder.this.size();	}
public static boolean isAllLowerCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLowerCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public int getDenominator() {	    return denominator;	}
public boolean isEquals() {	    return this.isEquals;	}
public int capacity() {	    return buffer.length;	}
public static <T> T notNull(final T object, final String message, final Object... values) {	    if (object == null) {	        throw new NullPointerException(String.format(message, values));	    }	    return object;	}
@Override	public int compare(final Object obj1, final Object obj2) {	    return ((Comparable) obj1).compareTo(obj2);	}
public static CharRange is(final char ch) {	    return new CharRange(ch, ch, false);	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public String getNewLineText() {	    return newLine;	}
public static boolean isEmpty(final CharSequence cs) {	    return cs == null || cs.length() == 0;	}
public static Date addMinutes(final Date date, final int amount) {	    return add(date, Calendar.MINUTE, amount);	}
public boolean isEmpty() {	    return size == 0;	}
public static Date truncate(final Object date, final int field) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (date instanceof Date) {	        return truncate((Date) date, field);	    } else if (date instanceof Calendar) {	        return truncate((Calendar) date, field).getTime();	    } else {	        throw new ClassCastException("Could not truncate " + date);	    }	}
protected String getArraySeparator() {	    return arraySeparator;	}
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) {	    if (bool == null) {	        return nullValue;	    }	    return bool.booleanValue() ? trueValue : falseValue;	}
public static String reverse(final String str) {	    if (str == null) {	        return null;	    }	    return new StringBuilder(str).reverse().toString();	}
public StrBuilder trim() {	    if (size == 0) {	        return this;	    }	    int len = size;	    final char[] buf = buffer;	    int pos = 0;	    while (pos < len && buf[pos] <= ' ') {	        pos++;	    }	    while (pos < len && buf[len - 1] <= ' ') {	        len--;	    }	    if (len < size) {	        delete(len, size);	    }	    if (pos > 0) {	        delete(0, pos);	    }	    return this;	}
public boolean isEmpty() {	    return size == 0;	}
protected String getSummaryObjectEndText() {	    return summaryObjectEndText;	}
@Override	public TimeZone getTimeZone() {	    return mTimeZone;	}
public StrBuilder deleteAll(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, -1);	}
protected String getSizeStartText() {	    return sizeStartText;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
public boolean isIgnoreEmptyTokens() {	    return ignoreEmptyTokens;	}
public boolean isEmpty() {	    return size == 0;	}
@Override	public T call() throws Exception {	    try {	        return initialize();	    } finally {	        if (execFinally != null) {	            execFinally.shutdown();	        }	    }	}
protected void appendContentStart(final StringBuffer buffer) {	    buffer.append(contentStart);	}
public static boolean toBooleanDefaultIfNull(final Boolean bool, final boolean valueIfNull) {	    if (bool == null) {	        return valueIfNull;	    }	    return bool.booleanValue();	}
public static String formatDurationISO(final long durationMillis) {	    return formatDuration(durationMillis, ISO_EXTENDED_FORMAT_PATTERN, false);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
public int size() {	    return size;	}
protected void setEquals(final boolean isEquals) {	    this.isEquals = isEquals;	}
@Override	public float floatValue() {	    return (float) numerator / (float) denominator;	}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    buffer.append(arrayStart);	    for (int i = 0; i < array.length; i++) {	        if (i > 0) {	            buffer.append(arraySeparator);	        }	        appendDetail(buffer, fieldName, array[i]);	    }	    buffer.append(arrayEnd);	}
public int toComparison() {	    return comparison;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public static boolean isAllUpperCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isUpperCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
@Override	public boolean equals(final Object obj) {	    if (obj == this) {	        return true;	    } else if (obj == null || obj.getClass() != getClass()) {	        return false;	    } else {	        @SuppressWarnings("unchecked")	        final Range<T> range = (Range<T>) obj;	        return minimum.equals(range.minimum) && maximum.equals(range.maximum);	    }	}
public String getNewLineText() {	    return newLine;	}
@Override	public int hashCode() {	    return 89 + set.hashCode();	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale) {	    return cache.getInstance(pattern, timeZone, locale);	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static <T extends Iterable<?>> T noNullElements(final T iterable) {	    return noNullElements(iterable, DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE);	}
public static boolean isAscii(final char ch) {	    return ch < 128;	}
public static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex) {	    if (0 == nHex) {	        return dstInit;	    }	    if ((nHex - 1) * 4 + dstPos >= 8) {	        throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 8");	    }	    byte out = dstInit;	    int shift = 0;	    for (int i = 0; i < nHex; i++) {	        shift = i * 4 + dstPos;	        final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift;	        final int mask = 0xf << shift;	        out = (byte) ((out & ~mask) | bits);	    }	    return out;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public int lastIndexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex >= size ? size - 1 : startIndex);	    if (matcher == null || startIndex < 0) {	        return -1;	    }	    final char[] buf = buffer;	    final int endIndex = startIndex + 1;	    for (int i = startIndex; i >= 0; i--) {	        if (matcher.isMatch(buf, i, 0, endIndex) > 0) {	            return i;	        }	    }	    return -1;	}
static JavaVersion getJavaVersion(final String nom) {	    return get(nom);	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
public String getNullText() {	    return nullText;	}
static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {	    final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);	    String pattern = cDateTimeInstanceCache.get(key);	    if (pattern == null) {	        try {	            DateFormat formatter;	            if (dateStyle == null) {	                formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);	            } else if (timeStyle == null) {	                formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);	            } else {	                formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);	            }	            pattern = ((SimpleDateFormat) formatter).toPattern();	            final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);	            if (previous != null) {	                pattern = previous;	            }	        } catch (final ClassCastException ex) {	            throw new IllegalArgumentException("No date time pattern for locale: " + locale);	        }	    }	    return pattern;	}
public static Class<?> getClass(final String className, final boolean initialize) throws ClassNotFoundException {	    final ClassLoader contextCL = Thread.currentThread().getContextClassLoader();	    final ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL;	    return getClass(loader, className, initialize);	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public static List<Locale> languagesByCountry(final String countryCode) {	    if (countryCode == null) {	        return Collections.emptyList();	    }	    List<Locale> langs = cLanguagesByCountry.get(countryCode);	    if (langs == null) {	        langs = new ArrayList<Locale>();	        final List<Locale> locales = availableLocaleList();	        for (int i = 0; i < locales.size(); i++) {	            final Locale locale = locales.get(i);	            if (countryCode.equals(locale.getCountry()) && locale.getVariant().isEmpty()) {	                langs.add(locale);	            }	        }	        langs = Collections.unmodifiableList(langs);	        cLanguagesByCountry.putIfAbsent(countryCode, langs);	        langs = cLanguagesByCountry.get(countryCode);	    }	    return langs;	}
public static ConcurrentException extractCause(final ExecutionException ex) {	    if (ex == null || ex.getCause() == null) {	        return null;	    }	    throwCause(ex);	    return new ConcurrentException(ex.getMessage(), ex.getCause());	}
public static boolean isEmpty(final boolean[] array) {	    return array == null || array.length == 0;	}
public StrBuilder deleteFirst(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, 1);	}
public static boolean contains(final boolean[] array, final boolean valueToFind) {	    return indexOf(array, valueToFind) != INDEX_NOT_FOUND;	}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    buffer.append(arrayStart);	    for (int i = 0; i < array.length; i++) {	        if (i > 0) {	            buffer.append(arraySeparator);	        }	        appendDetail(buffer, fieldName, array[i]);	    }	    buffer.append(arrayEnd);	}
@Override	public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) {	    return buffer[pos] <= 32 ? 1 : 0;	}
public StrBuilder trim() {	    if (size == 0) {	        return this;	    }	    int len = size;	    final char[] buf = buffer;	    int pos = 0;	    while (pos < len && buf[pos] <= ' ') {	        pos++;	    }	    while (pos < len && buf[len - 1] <= ' ') {	        len--;	    }	    if (len < size) {	        delete(len, size);	    }	    if (pos > 0) {	        delete(0, pos);	    }	    return this;	}
public static boolean isAsciiPrintable(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public int size() {	    return size;	}
public HashCodeBuilder append(final short[] array) {	    if (array == null) {	        iTotal = iTotal * iConstant;	    } else {	        for (final short element : array) {	            append(element);	        }	    }	    return this;	}
private static boolean endsWith(final CharSequence str, final CharSequence suffix, final boolean ignoreCase) {	    if (str == null || suffix == null) {	        return str == null && suffix == null;	    }	    if (suffix.length() > str.length()) {	        return false;	    }	    final int strOffset = str.length() - suffix.length();	    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, suffix, 0, suffix.length());	}
public void increment() {	    value++;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public int capacity() {	    return buffer.length;	}
@Override	public void mark(final int readAheadLimit) {	    mark = pos;	}
public StrBuilder appendSeparator(final char separator, final int loopIndex) {	    if (loopIndex > 0) {	        append(separator);	    }	    return this;	}
public static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) {	    if (0 == nHexs) {	        return dstInit;	    }	    if ((nHexs - 1) * 4 + srcPos >= 16) {	        throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 16");	    }	    final StringBuilder sb = new StringBuilder(dstInit);	    int shift = 0;	    int append = sb.length();	    for (int i = 0; i < nHexs; i++) {	        shift = i * 4 + srcPos;	        final int bits = 0xF & (src >> shift);	        if (dstPos + i == append) {	            ++append;	            sb.append(intToHexDigit(bits));	        } else {	            sb.setCharAt(dstPos + i, intToHexDigit(bits));	        }	    }	    return sb.toString();	}
public String nextToken() {	    if (hasNext()) {	        return tokens[tokenPos++];	    }	    return null;	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public String getNullText() {	    return nullText;	}
public static Iterator<?> iterator(final Object focus, final int rangeStyle) {	    if (focus == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (focus instanceof Date) {	        return iterator((Date) focus, rangeStyle);	    } else if (focus instanceof Calendar) {	        return iterator((Calendar) focus, rangeStyle);	    } else {	        throw new ClassCastException("Could not iterate based on " + focus);	    }	}
public static boolean containsOnly(final CharSequence cs, final String validChars) {	    if (cs == null || validChars == null) {	        return false;	    }	    return containsOnly(cs, validChars.toCharArray());	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public int setBoolean(final int holder, final boolean flag) {	    return flag ? set(holder) : clear(holder);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
@Override	public void flush() {	}
@Override	public boolean equals(final Object obj) {	    if (obj == this) {	        return true;	    }	    if (obj instanceof Map.Entry<?, ?>) {	        final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;	        return ObjectUtils.equals(getKey(), other.getKey()) && ObjectUtils.equals(getValue(), other.getValue());	    }	    return false;	}
static void register(final Object lhs, final Object rhs) {	    synchronized (EqualsBuilder.class) {	        if (getRegistry() == null) {	            REGISTRY.set(new HashSet<Pair<IDKey, IDKey>>());	        }	    }	    final Set<Pair<IDKey, IDKey>> registry = getRegistry();	    final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);	    registry.add(pair);	}
public static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) {	    if (0 == nHexs) {	        return dstInit;	    }	    if ((nHexs - 1) * 4 + srcPos >= 32) {	        throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 32");	    }	    final StringBuilder sb = new StringBuilder(dstInit);	    int shift = 0;	    int append = sb.length();	    for (int i = 0; i < nHexs; i++) {	        shift = i * 4 + srcPos;	        final int bits = 0xF & (src >> shift);	        if (dstPos + i == append) {	            ++append;	            sb.append(intToHexDigit(bits));	        } else {	            sb.setCharAt(dstPos + i, intToHexDigit(bits));	        }	    }	    return sb.toString();	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
public int size() {	    return size;	}
public static boolean isEmpty(final CharSequence cs) {	    return cs == null || cs.length() == 0;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
protected ScheduledFuture<?> startTimer() {	    return getExecutorService().scheduleAtFixedRate(new Runnable() {		        @Override	        public void run() {	            endOfPeriod();	        }	    }, getPeriod(), getPeriod(), getUnit());	}
public static String[] splitByWholeSeparatorPreserveAllTokens(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, true);	}
public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException {	    if (target == null) {	        throw new IllegalArgumentException("target object must not be null");	    }	    final Class<?> cls = target.getClass();	    final Field field = getDeclaredField(cls, fieldName, forceAccess);	    if (field == null) {	        throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName);	    }	    return readField(field, target);	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public boolean isEquals() {	    return this.isEquals;	}
private static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal, final boolean lastIndex) {	    if (str == null || searchStr == null || ordinal <= 0) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return lastIndex ? str.length() : 0;	    }	    int found = 0;	    int index = lastIndex ? str.length() : INDEX_NOT_FOUND;	    do {	        if (lastIndex) {	            index = CharSequenceUtils.lastIndexOf(str, searchStr, index - 1);	        } else {	            index = CharSequenceUtils.indexOf(str, searchStr, index + 1);	        }	        if (index < 0) {	            return index;	        }	        found++;	    } while (found < ordinal);	    return index;	}
public static boolean[] removeElements(final boolean[] array, final boolean... values) {	    if (isEmpty(array) || isEmpty(values)) {	        return clone(array);	    }	    final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2);	    for (final boolean v : values) {	        final Boolean boxed = Boolean.valueOf(v);	        final MutableInt count = occurrences.get(boxed);	        if (count == null) {	            occurrences.put(boxed, new MutableInt(1));	        } else {	            count.increment();	        }	    }	    final BitSet toRemove = new BitSet();	    for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) {	        final Boolean v = e.getKey();	        int found = 0;	        for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {	            found = indexOf(array, v.booleanValue(), found);	            if (found < 0) {	                break;	            }	            toRemove.set(found++);	        }	    }	    return (boolean[]) removeAll(array, toRemove);	}
public static String lowerCase(final String str, final Locale locale) {	    if (str == null) {	        return null;	    }	    return str.toLowerCase(locale);	}
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) {	    return new Range<T>(fromInclusive, toInclusive, comparator);	}
public boolean isTrue() {	    return value == true;	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
public static Object readStaticField(final Class<?> cls, final String fieldName, final boolean forceAccess) throws IllegalAccessException {	    final Field field = getField(cls, fieldName, forceAccess);	    if (field == null) {	        throw new IllegalArgumentException("Cannot locate field " + fieldName + " on " + cls);	    }	    return readStaticField(field, false);	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static Boolean[] nullToEmpty(final Boolean[] array) {	    if (array == null || array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    return array;	}
@Override	public int length() {	    return size;	}
public StrBuilder deleteAll(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, -1);	}
public int indexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex < 0 ? 0 : startIndex);	    if (matcher == null || startIndex >= size) {	        return -1;	    }	    final int len = size;	    final char[] buf = buffer;	    for (int i = startIndex; i < len; i++) {	        if (matcher.isMatch(buf, i, startIndex, len) > 0) {	            return i;	        }	    }	    return -1;	}
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) {	    final StringBuilder buffer = new StringBuilder();	    boolean lastOutputSeconds = false;	    final int sz = tokens.length;	    for (int i = 0; i < sz; i++) {	        final Token token = tokens[i];	        final Object value = token.getValue();	        final int count = token.getCount();	        if (value instanceof StringBuilder) {	            buffer.append(value.toString());	        } else {	            if (value == y) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years));	                lastOutputSeconds = false;	            } else if (value == M) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months));	                lastOutputSeconds = false;	            } else if (value == d) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days));	                lastOutputSeconds = false;	            } else if (value == H) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours));	                lastOutputSeconds = false;	            } else if (value == m) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes));	                lastOutputSeconds = false;	            } else if (value == s) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds));	                lastOutputSeconds = true;	            } else if (value == S) {	                if (lastOutputSeconds) {	                    milliseconds += 1000;	                    final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds);	                    buffer.append(str.substring(1));	                } else {	                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds));	                }	                lastOutputSeconds = false;	            }	        }	    }	    return buffer.toString();	}
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] result = new boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        final Boolean b = array[i];	        result[i] = (b == null ? valueForNull : b.booleanValue());	    }	    return result;	}
public static boolean containsNone(final CharSequence cs, final String invalidChars) {	    if (cs == null || invalidChars == null) {	        return true;	    }	    return containsNone(cs, invalidChars.toCharArray());	}
public static String getSimpleName(final Object object, final String valueIfNull) {	    if (object == null) {	        return valueIfNull;	    }	    return getSimpleName(object.getClass());	}
protected String getFieldNameValueSeparator() {	    return fieldNameValueSeparator;	}
public String getNullText() {	    return nullText;	}
public static boolean isNotBlank(final CharSequence cs) {	    return !StringUtils.isBlank(cs);	}
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return true;	    }	    if (lhs == null || rhs == null) {	        return false;	    }	    final Class<?> lhsClass = lhs.getClass();	    final Class<?> rhsClass = rhs.getClass();	    Class<?> testClass;	    if (lhsClass.isInstance(rhs)) {	        testClass = lhsClass;	        if (!rhsClass.isInstance(lhs)) {	            testClass = rhsClass;	        }	    } else if (rhsClass.isInstance(lhs)) {	        testClass = rhsClass;	        if (!lhsClass.isInstance(rhs)) {	            testClass = lhsClass;	        }	    } else {	        return false;	    }	    final EqualsBuilder equalsBuilder = new EqualsBuilder();	    try {	        reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {	            testClass = testClass.getSuperclass();	            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        }	    } catch (final IllegalArgumentException e) {	        return false;	    }	    return equalsBuilder.isEquals();	}
public static boolean[] removeElements(final boolean[] array, final boolean... values) {	    if (isEmpty(array) || isEmpty(values)) {	        return clone(array);	    }	    final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2);	    for (final boolean v : values) {	        final Boolean boxed = Boolean.valueOf(v);	        final MutableInt count = occurrences.get(boxed);	        if (count == null) {	            occurrences.put(boxed, new MutableInt(1));	        } else {	            count.increment();	        }	    }	    final BitSet toRemove = new BitSet();	    for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) {	        final Boolean v = e.getKey();	        int found = 0;	        for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {	            found = indexOf(array, v.booleanValue(), found);	            if (found < 0) {	                break;	            }	            toRemove.set(found++);	        }	    }	    return (boolean[]) removeAll(array, toRemove);	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static float min(final float a, final float b, final float c) {	    return Math.min(Math.min(a, b), c);	}
public static char binaryToHexDigit(final boolean[] src, final int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    if (src.length > srcPos + 3 && src[srcPos + 3]) {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src[srcPos]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public String getNewLineText() {	    return newLine;	}
protected String getContentEnd() {	    return contentEnd;	}
@Override	public int compare(final Object obj1, final Object obj2) {	    return ((Comparable) obj1).compareTo(obj2);	}
@Override	public int previousIndex() {	    return tokenPos - 1;	}
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {	    if (array == null) {	        if (index != 0) {	            throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0");	        }	        final Object joinedArray = Array.newInstance(clss, 1);	        Array.set(joinedArray, 0, element);	        return joinedArray;	    }	    final int length = Array.getLength(array);	    if (index > length || index < 0) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(clss, length + 1);	    System.arraycopy(array, 0, result, 0, index);	    Array.set(result, index, element);	    if (index < length) {	        System.arraycopy(array, index, result, index + 1, length - index);	    }	    return result;	}
public static CharRange isNot(final char ch) {	    return new CharRange(ch, ch, true);	}
public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale) {	    return cache.getTimeInstance(style, timeZone, locale);	}
void increment() {	    count++;	}
@Override	public int length() {	    return size;	}
public void setLeft(final L left) {	    this.left = left;	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
protected String getArrayStart() {	    return arrayStart;	}
public static String wrap(final String str, int wrapLength, String newLineStr, final boolean wrapLongWords) {	    if (str == null) {	        return null;	    }	    if (newLineStr == null) {	        newLineStr = SystemUtils.LINE_SEPARATOR;	    }	    if (wrapLength < 1) {	        wrapLength = 1;	    }	    final int inputLineLength = str.length();	    int offset = 0;	    final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32);	    while (inputLineLength - offset > wrapLength) {	        if (str.charAt(offset) == ' ') {	            offset++;	            continue;	        }	        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);	        if (spaceToWrapAt >= offset) {	            wrappedLine.append(str.substring(offset, spaceToWrapAt));	            wrappedLine.append(newLineStr);	            offset = spaceToWrapAt + 1;	        } else {	            if (wrapLongWords) {	                wrappedLine.append(str.substring(offset, wrapLength + offset));	                wrappedLine.append(newLineStr);	                offset += wrapLength;	            } else {	                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);	                if (spaceToWrapAt >= 0) {	                    wrappedLine.append(str.substring(offset, spaceToWrapAt));	                    wrappedLine.append(newLineStr);	                    offset = spaceToWrapAt + 1;	                } else {	                    wrappedLine.append(str.substring(offset));	                    offset = inputLineLength;	                }	            }	        }	    }	    wrappedLine.append(str.substring(offset));	    return wrappedLine.toString();	}
protected String getContentEnd() {	    return contentEnd;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static <K, V> V createIfAbsent(final ConcurrentMap<K, V> map, final K key, final ConcurrentInitializer<V> init) throws ConcurrentException {	    if (map == null || init == null) {	        return null;	    }	    final V value = map.get(key);	    if (value == null) {	        return putIfAbsent(map, key, init.get());	    }	    return value;	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public boolean isSuccessful() {	    return exceptions.isEmpty();	}
@Override	public int length() {	    return size;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
protected boolean isUseIdentityHashCode() {	    return useIdentityHashCode;	}
public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) {	    if (it != null) {	        separator = ObjectUtils.toString(separator);	        while (it.hasNext()) {	            append(it.next());	            if (it.hasNext()) {	                append(separator);	            }	        }	    }	    return this;	}
public static String reverse(final String str) {	    if (str == null) {	        return null;	    }	    return new StringBuilder(str).reverse().toString();	}
@Override	public boolean ready() {	    return pos < StrBuilder.this.size();	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
protected boolean isDefaultFullDetail() {	    return defaultFullDetail;	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
@Override	public int compareTo(final Pair<L, R> other) {	    return new CompareToBuilder().append(getLeft(), other.getLeft()).append(getRight(), other.getRight()).toComparison();	}
public synchronized boolean start() {	    if (!isStarted()) {	        ExecutorService tempExec;	        executor = getExternalExecutor();	        if (executor == null) {	            executor = tempExec = createExecutor();	        } else {	            tempExec = null;	        }	        future = executor.submit(createTask(tempExec));	        return true;	    }	    return false;	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
@Override	public Integer build() {	    return Integer.valueOf(toHashCode());	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
public int capacity() {	    return buffer.length;	}
public static <T> Range<T> is(final T element, final Comparator<T> comparator) {	    return between(element, element, comparator);	}
@Override	public String next() {	    if (hasNext()) {	        return tokens[tokenPos++];	    }	    throw new NoSuchElementException();	}
public static String toString(final Object obj, final String nullStr) {	    return obj == null ? nullStr : obj.toString();	}
public StrBuilder setLength(final int length) {	    if (length < 0) {	        throw new StringIndexOutOfBoundsException(length);	    }	    if (length < size) {	        size = length;	    } else if (length > size) {	        ensureCapacity(length);	        final int oldEnd = size;	        final int newEnd = length;	        size = length;	        for (int i = oldEnd; i < newEnd; i++) {	            buffer[i] = '\0';	        }	    }	    return this;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static <T extends CharSequence> T validIndex(final T chars, final int index) {	    return validIndex(chars, index, DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE, Integer.valueOf(index));	}
static void register(final Object lhs, final Object rhs) {	    synchronized (EqualsBuilder.class) {	        if (getRegistry() == null) {	            REGISTRY.set(new HashSet<Pair<IDKey, IDKey>>());	        }	    }	    final Set<Pair<IDKey, IDKey>> registry = getRegistry();	    final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);	    registry.add(pair);	}
public static String formatDurationHMS(final long durationMillis) {	    return formatDuration(durationMillis, "H:mm:ss.SSS");	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof MutableInt) {	        return value == ((MutableInt) obj).intValue();	    }	    return false;	}
public static boolean containsOnly(final CharSequence cs, final String validChars) {	    if (cs == null || validChars == null) {	        return false;	    }	    return containsOnly(cs, validChars.toCharArray());	}
@Override	public int hashCode() {	    return toHashCode();	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public int capacity() {	    return buffer.length;	}
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) {	    final StringBuilder buffer = new StringBuilder();	    boolean lastOutputSeconds = false;	    final int sz = tokens.length;	    for (int i = 0; i < sz; i++) {	        final Token token = tokens[i];	        final Object value = token.getValue();	        final int count = token.getCount();	        if (value instanceof StringBuilder) {	            buffer.append(value.toString());	        } else {	            if (value == y) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years));	                lastOutputSeconds = false;	            } else if (value == M) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months));	                lastOutputSeconds = false;	            } else if (value == d) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days));	                lastOutputSeconds = false;	            } else if (value == H) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours));	                lastOutputSeconds = false;	            } else if (value == m) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes));	                lastOutputSeconds = false;	            } else if (value == s) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds));	                lastOutputSeconds = true;	            } else if (value == S) {	                if (lastOutputSeconds) {	                    milliseconds += 1000;	                    final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds);	                    buffer.append(str.substring(1));	                } else {	                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds));	                }	                lastOutputSeconds = false;	            }	        }	    }	    return buffer.toString();	}
public char getEscapeChar() {	    return this.escapeChar;	}
@Override	public void setValue(final Number value) {	    this.value = value.byteValue();	}
public StrTokenizer reset(final char[] input) {	    reset();	    this.chars = ArrayUtils.clone(input);	    return this;	}
private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) {	    if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {	        return text;	    }	    if (timeToLive < 0) {	        throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another");	    }	    final int searchLength = searchList.length;	    final int replacementLength = replacementList.length;	    if (searchLength != replacementLength) {	        throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength);	    }	    final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];	    int textIndex = -1;	    int replaceIndex = -1;	    int tempIndex = -1;	    for (int i = 0; i < searchLength; i++) {	        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {	            continue;	        }	        tempIndex = text.indexOf(searchList[i]);	        if (tempIndex == -1) {	            noMoreMatchesForReplIndex[i] = true;	        } else {	            if (textIndex == -1 || tempIndex < textIndex) {	                textIndex = tempIndex;	                replaceIndex = i;	            }	        }	    }	    if (textIndex == -1) {	        return text;	    }	    int start = 0;	    int increase = 0;	    for (int i = 0; i < searchList.length; i++) {	        if (searchList[i] == null || replacementList[i] == null) {	            continue;	        }	        final int greater = replacementList[i].length() - searchList[i].length();	        if (greater > 0) {	            increase += 3 * greater;	        }	    }	    increase = Math.min(increase, text.length() / 5);	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (textIndex != -1) {	        for (int i = start; i < textIndex; i++) {	            buf.append(text.charAt(i));	        }	        buf.append(replacementList[replaceIndex]);	        start = textIndex + searchList[replaceIndex].length();	        textIndex = -1;	        replaceIndex = -1;	        tempIndex = -1;	        for (int i = 0; i < searchLength; i++) {	            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {	                continue;	            }	            tempIndex = text.indexOf(searchList[i], start);	            if (tempIndex == -1) {	                noMoreMatchesForReplIndex[i] = true;	            } else {	                if (textIndex == -1 || tempIndex < textIndex) {	                    textIndex = tempIndex;	                    replaceIndex = i;	                }	            }	        }	    }	    final int textLength = text.length();	    for (int i = start; i < textLength; i++) {	        buf.append(text.charAt(i));	    }	    final String result = buf.toString();	    if (!repeat) {	        return result;	    }	    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
public short setShort(final short holder) {	    return (short) set(holder);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
protected boolean isUseShortClassName() {	    return useShortClassName;	}
protected boolean isFieldSeparatorAtStart() {	    return fieldSeparatorAtStart;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public StrBuilder deleteAll(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, -1);	}
@Override	public float floatValue() {	    return value;	}
public StrBuilder appendFixedWidthPadRight(final int value, final int width, final char padChar) {	    return appendFixedWidthPadRight(String.valueOf(value), width, padChar);	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static <T> Range<T> is(final T element, final Comparator<T> comparator) {	    return between(element, element, comparator);	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
@Override	public boolean ready() {	    return pos < StrBuilder.this.size();	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static boolean isSameLength(final boolean[] array1, final boolean[] array2) {	    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {	        return false;	    }	    return true;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public static void writeField(final Object target, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException {	    if (target == null) {	        throw new IllegalArgumentException("target object must not be null");	    }	    final Class<?> cls = target.getClass();	    final Field field = getField(cls, fieldName, forceAccess);	    if (field == null) {	        throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName);	    }	    writeField(field, target, value);	}
public static char binaryToHexDigit(final boolean[] src, final int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    if (src.length > srcPos + 3 && src[srcPos + 3]) {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src[srcPos]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public StrBuilder deleteAll(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, -1);	}
@Override	public String toString() {	    return String.valueOf(value);	}
public static String reverseDelimited(final String str, final char separatorChar) {	    if (str == null) {	        return null;	    }	    final String[] strs = split(str, separatorChar);	    ArrayUtils.reverse(strs);	    return join(strs, separatorChar);	}
public boolean contains(final StrMatcher matcher) {	    return indexOf(matcher, 0) >= 0;	}
public static float min(final float a, final float b, final float c) {	    return Math.min(Math.min(a, b), c);	}
static Pair<IDKey, IDKey> getRegisterPair(final Object lhs, final Object rhs) {	    final IDKey left = new IDKey(lhs);	    final IDKey right = new IDKey(rhs);	    return Pair.of(left, right);	}
public static boolean isSameLength(final boolean[] array1, final boolean[] array2) {	    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {	        return false;	    }	    return true;	}
public HashCodeBuilder appendSuper(final int superHashCode) {	    iTotal = iTotal * iConstant + superHashCode;	    return this;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static boolean isAsciiPrintable(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static void setDefaultStyle(final ToStringStyle style) {	    if (style == null) {	        throw new IllegalArgumentException("The style must not be null");	    }	    defaultStyle = style;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = Integer.MAX_VALUE;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.indexOf(str, search, 0);	        if (tmp == INDEX_NOT_FOUND) {	            continue;	        }	        if (tmp < ret) {	            ret = tmp;	        }	    }	    return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;	}
public static NumericEntityEscaper above(final int codepoint) {	    return outsideOf(0, codepoint);	}
protected String getArrayStart() {	    return arrayStart;	}
public static String[][] APOS_ESCAPE() {	    return APOS_ESCAPE.clone();	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static <T> T deserialize(final byte[] objectData) {	    if (objectData == null) {	        throw new IllegalArgumentException("The byte[] must not be null");	    }	    return SerializationUtils.<T>deserialize(new ByteArrayInputStream(objectData));	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static <T> T CONST(final T v) {	    return v;	}
public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) {	    if (src.length > 8) {	        throw new IllegalArgumentException("src.length>8: src.length=" + src.length);	    }	    if (src.length - srcPos < 4) {	        throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos);	    }	    if (src[srcPos + 3]) {	        if (src[srcPos + 2]) {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return '7';	                }	            } else {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return '3';	                }	            }	        } else {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return '5';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '1';	                }	            }	        }	    } else {	        if (src[srcPos + 2]) {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'e';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return 'a';	                } else {	                    return '2';	                }	            }	        } else {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'c';	                } else {	                    return '4';	                }	            } else {	                if (src[srcPos]) {	                    return '8';	                } else {	                    return '0';	                }	            }	        }	    }	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public int set(final int holder) {	    return holder | _mask;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
private static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns) {	    if (!isAssignable(cls, toClass)) {	        return null;	    }	    if (cls.isPrimitive()) {	        if (toClass.isPrimitive()) {	            return new HashMap<TypeVariable<?>, Type>();	        }	        cls = ClassUtils.primitiveToWrapper(cls);	    }	    final HashMap<TypeVariable<?>, Type> typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>() : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);	    if (toClass.equals(cls)) {	        return typeVarAssigns;	    }	    return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns);	}
public static String overlay(final String str, String overlay, int start, int end) {	    if (str == null) {	        return null;	    }	    if (overlay == null) {	        overlay = EMPTY;	    }	    final int len = str.length();	    if (start < 0) {	        start = 0;	    }	    if (start > len) {	        start = len;	    }	    if (end < 0) {	        end = 0;	    }	    if (end > len) {	        end = len;	    }	    if (start > end) {	        final int temp = start;	        start = end;	        end = temp;	    }	    return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString();	}
public static Map<Object, Object> toMap(final Object[] array) {	    if (array == null) {	        return null;	    }	    final Map<Object, Object> map = new HashMap<Object, Object>((int) (array.length * 1.5));	    for (int i = 0; i < array.length; i++) {	        final Object object = array[i];	        if (object instanceof Map.Entry<?, ?>) {	            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) object;	            map.put(entry.getKey(), entry.getValue());	        } else if (object instanceof Object[]) {	            final Object[] entry = (Object[]) object;	            if (entry.length < 2) {	                throw new IllegalArgumentException("Array element " + i + ", '" + object + "', has a length less than 2");	            }	            map.put(entry[0], entry[1]);	        } else {	            throw new IllegalArgumentException("Array element " + i + ", '" + object + "', is neither of type Map.Entry nor an Array");	        }	    }	    return map;	}
@Override	public Object getFirstContextValue(final String label) {	    for (final Pair<String, Object> pair : contextValues) {	        if (StringUtils.equals(label, pair.getKey())) {	            return pair.getValue();	        }	    }	    return null;	}
protected boolean isArrayContentDetail() {	    return arrayContentDetail;	}
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) {	    style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));	    return this;	}
public String getNullText() {	    return nullText;	}
public boolean isEmpty() {	    return size == 0;	}
public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException {	    return parseDateWithLeniency(str, locale, parsePatterns, true);	}
public static String removeStart(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.startsWith(remove)) {	        return str.substring(remove.length());	    }	    return str;	}
public boolean isEmpty() {	    return size == 0;	}
public static <T extends CharSequence> T notEmpty(final T chars) {	    return notEmpty(chars, DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE);	}
public static int hexDigitMsb0ToInt(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return 0x0;	        case '1':	            return 0x8;	        case '2':	            return 0x4;	        case '3':	            return 0xC;	        case '4':	            return 0x2;	        case '5':	            return 0xA;	        case '6':	            return 0x6;	        case '7':	            return 0xE;	        case '8':	            return 0x1;	        case '9':	            return 0x9;	        case 'a':	        case 'A':	            return 0x5;	        case 'b':	        case 'B':	            return 0xD;	        case 'c':	        case 'C':	            return 0x3;	        case 'd':	        case 'D':	            return 0xB;	        case 'e':	        case 'E':	            return 0x7;	        case 'f':	        case 'F':	            return 0xF;	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public StrTokenizer setQuoteMatcher(final StrMatcher quote) {	    if (quote != null) {	        this.quoteMatcher = quote;	    }	    return this;	}
@Override	public int compareTo(final MutableShort other) {	    final short anotherVal = other.value;	    return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1);	}
@Override	public Boolean getValue() {	    return Boolean.valueOf(this.value);	}
public static String getMessage(final Throwable th) {	    if (th == null) {	        return "";	    }	    final String clsName = ClassUtils.getShortClassName(th, null);	    final String msg = th.getMessage();	    return clsName + ": " + StringUtils.defaultString(msg);	}
@Override	public String toString() {	    return "FastDateParser[" + pattern + "," + locale + "," + timeZone.getID() + "]";	}
public boolean isIgnoreEmptyTokens() {	    return ignoreEmptyTokens;	}
public void setAppendTransients(final boolean appendTransients) {	    this.appendTransients = appendTransients;	}
public static boolean truncatedEquals(final Date date1, final Date date2, final int field) {	    return truncatedCompareTo(date1, date2, field) == 0;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public void setAppendStatics(final boolean appendStatics) {	    this.appendStatics = appendStatics;	}
protected String getSizeEndText() {	    return sizeEndText;	}
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException {	    return charsetName == null ? new String(bytes) : new String(bytes, charsetName);	}
protected String getArrayStart() {	    return arrayStart;	}
public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) {	    if (it != null) {	        separator = ObjectUtils.toString(separator);	        while (it.hasNext()) {	            append(it.next());	            if (it.hasNext()) {	                append(separator);	            }	        }	    }	    return this;	}
public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) {	    if (s == null || t == null) {	        throw new IllegalArgumentException("Strings must not be null");	    }	    if (threshold < 0) {	        throw new IllegalArgumentException("Threshold must not be negative");	    }	    int n = s.length();	    int m = t.length();	    if (n == 0) {	        return m <= threshold ? m : -1;	    } else if (m == 0) {	        return n <= threshold ? n : -1;	    }	    if (n > m) {	        final CharSequence tmp = s;	        s = t;	        t = tmp;	        n = m;	        m = t.length();	    }	    int[] p = new int[n + 1];	    int[] d = new int[n + 1];	    int[] _d;	    final int boundary = Math.min(n, threshold) + 1;	    for (int i = 0; i < boundary; i++) {	        p[i] = i;	    }	    Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);	    Arrays.fill(d, Integer.MAX_VALUE);	    for (int j = 1; j <= m; j++) {	        final char t_j = t.charAt(j - 1);	        d[0] = j;	        final int min = Math.max(1, j - threshold);	        final int max = Math.min(n, j + threshold);	        if (min > max) {	            return -1;	        }	        if (min > 1) {	            d[min - 1] = Integer.MAX_VALUE;	        }	        for (int i = min; i <= max; i++) {	            if (s.charAt(i - 1) == t_j) {	                d[i] = p[i - 1];	            } else {	                d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);	            }	        }	        _d = p;	        p = d;	        d = _d;	    }	    if (p[n] <= threshold) {	        return p[n];	    }	    return -1;	}
@Override	public int compare(final Object obj1, final Object obj2) {	    return ((Comparable) obj1).compareTo(obj2);	}
public abstract boolean translate(int codepoint, Writer out) throws IOException;
protected String getArrayStart() {	    return arrayStart;	}
static Object removeAll(final Object array, final BitSet indices) {	    final int srcLength = ArrayUtils.getLength(array);	    final int removals = indices.cardinality();	    final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals);	    int srcIndex = 0;	    int destIndex = 0;	    int count;	    int set;	    while ((set = indices.nextSetBit(srcIndex)) != -1) {	        count = set - srcIndex;	        if (count > 0) {	            System.arraycopy(array, srcIndex, result, destIndex, count);	            destIndex += count;	        }	        srcIndex = indices.nextClearBit(set);	    }	    count = srcLength - srcIndex;	    if (count > 0) {	        System.arraycopy(array, srcIndex, result, destIndex, count);	    }	    return result;	}
public boolean isEmpty() {	    return size == 0;	}
public synchronized double getAverageCallsPerPeriod() {	    return periodCount == 0 ? 0 : (double) totalAcquireCount / (double) periodCount;	}
public boolean contains(final StrMatcher matcher) {	    return indexOf(matcher, 0) >= 0;	}
public static <T extends CharSequence> T defaultIfBlank(final T str, final T defaultStr) {	    return StringUtils.isBlank(str) ? defaultStr : str;	}
protected String getSummaryObjectEndText() {	    return summaryObjectEndText;	}
public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException {	    return parseDateWithLeniency(str, null, parsePatterns, false);	}
protected boolean isUseClassName() {	    return useClassName;	}
public static <T extends CharSequence> T notEmpty(final T chars) {	    return notEmpty(chars, DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE);	}
protected String getFieldSeparator() {	    return fieldSeparator;	}
@Override	public long longValue() {	    return value;	}
public void setUpToClass(final Class<?> clazz) {	    if (clazz != null) {	        final Object object = getObject();	        if (object != null && clazz.isInstance(object) == false) {	            throw new IllegalArgumentException("Specified class is not a superclass of the object");	        }	    }	    this.upToClass = clazz;	}
public static boolean equalsIgnoreCase(final CharSequence str1, final CharSequence str2) {	    if (str1 == null || str2 == null) {	        return str1 == str2;	    } else if (str1 == str2) {	        return true;	    } else if (str1.length() != str2.length()) {	        return false;	    } else {	        return CharSequenceUtils.regionMatches(str1, true, 0, str2, 0, str1.length());	    }	}
static String[] getStackFrames(final String stackTrace) {	    final String linebreak = SystemUtils.LINE_SEPARATOR;	    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);	    final List<String> list = new ArrayList<String>();	    while (frames.hasMoreTokens()) {	        list.add(frames.nextToken());	    }	    return list.toArray(new String[list.size()]);	}
@Override	public double doubleValue() {	    return (double) numerator / (double) denominator;	}
public static <T> Range<T> is(final T element, final Comparator<T> comparator) {	    return between(element, element, comparator);	}
public EqualsBuilder appendSuper(final boolean superEquals) {	    if (isEquals == false) {	        return this;	    }	    isEquals = superEquals;	    return this;	}
public static boolean isAscii(final char ch) {	    return ch < 128;	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
@Override	public Date parse(final String source, final ParsePosition pos) {	    final int offset = pos.getIndex();	    final Matcher matcher = parsePattern.matcher(source.substring(offset));	    if (!matcher.lookingAt()) {	        return null;	    }	    final Calendar cal = Calendar.getInstance(timeZone, locale);	    cal.clear();	    for (int i = 0; i < strategies.length; ) {	        final Strategy strategy = strategies[i++];	        strategy.setCalendar(this, cal, matcher.group(i));	    }	    pos.setIndex(offset + matcher.end());	    return cal.getTime();	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public String rightString(final int length) {	    if (length <= 0) {	        return "";	    } else if (length >= size) {	        return new String(buffer, 0, size);	    } else {	        return new String(buffer, size - length, length);	    }	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
private static Date set(final Date date, final int calendarField, final int amount) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final Calendar c = Calendar.getInstance();	    c.setLenient(false);	    c.setTime(date);	    c.set(calendarField, amount);	    return c.getTime();	}
public boolean isEmpty() {	    return size == 0;	}
@Override	public int length() {	    return size;	}
public static boolean isAscii(final char ch) {	    return ch < 128;	}
public static Class<?> getRawType(final Type type, final Type assigningType) {	    if (type instanceof Class<?>) {	        return (Class<?>) type;	    }	    if (type instanceof ParameterizedType) {	        return getRawType((ParameterizedType) type);	    }	    if (type instanceof TypeVariable<?>) {	        if (assigningType == null) {	            return null;	        }	        final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration();	        if (!(genericDeclaration instanceof Class<?>)) {	            return null;	        }	        final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType, (Class<?>) genericDeclaration);	        if (typeVarAssigns == null) {	            return null;	        }	        final Type typeArgument = typeVarAssigns.get(type);	        if (typeArgument == null) {	            return null;	        }	        return getRawType(typeArgument, assigningType);	    }	    if (type instanceof GenericArrayType) {	        final Class<?> rawComponentType = getRawType(((GenericArrayType) type).getGenericComponentType(), assigningType);	        return Array.newInstance(rawComponentType, 0).getClass();	    }	    if (type instanceof WildcardType) {	        return null;	    }	    throw new IllegalArgumentException("unknown type: " + type);	}
public static boolean containsAny(final String str, final String... set) {	    if (StringUtils.isEmpty(str) || deepEmpty(set)) {	        return false;	    }	    final CharSet chars = CharSet.getInstance(set);	    for (final char c : str.toCharArray()) {	        if (chars.contains(c)) {	            return true;	        }	    }	    return false;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
@Override	public int length() {	    return size;	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public int getDenominator() {	    return denominator;	}
public int size() {	    return size;	}
public static boolean isInstance(final Object value, final Type type) {	    if (type == null) {	        return false;	    }	    return value == null ? !(type instanceof Class<?>) || !((Class<?>) type).isPrimitive() : isAssignable(value.getClass(), type, null);	}
public static boolean endsWithAny(final CharSequence string, final CharSequence... searchStrings) {	    if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {	        return false;	    }	    for (final CharSequence searchString : searchStrings) {	        if (StringUtils.endsWith(string, searchString)) {	            return true;	        }	    }	    return false;	}
public static <K, V> V createIfAbsent(final ConcurrentMap<K, V> map, final K key, final ConcurrentInitializer<V> init) throws ConcurrentException {	    if (map == null || init == null) {	        return null;	    }	    final V value = map.get(key);	    if (value == null) {	        return putIfAbsent(map, key, init.get());	    }	    return value;	}
public static <T extends CharSequence> T notBlank(final T chars) {	    return notBlank(chars, DEFAULT_NOT_BLANK_EX_MESSAGE);	}
@Override	public int compareTo(final MutableDouble other) {	    final double anotherVal = other.value;	    return Double.compare(value, anotherVal);	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public char getEnd() {	    return this.end;	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
static void setAccessibleWorkaround(final AccessibleObject o) {	    if (o == null || o.isAccessible()) {	        return;	    }	    final Member m = (Member) o;	    if (Modifier.isPublic(m.getModifiers()) && isPackageAccess(m.getDeclaringClass().getModifiers())) {	        try {	            o.setAccessible(true);	        } catch (final SecurityException e) {	        }	    }	}
protected String getFieldSeparator() {	    return fieldSeparator;	}
public static boolean[] hexDigitToBinary(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return new boolean[] { false, false, false, false };	        case '1':	            return new boolean[] { true, false, false, false };	        case '2':	            return new boolean[] { false, true, false, false };	        case '3':	            return new boolean[] { true, true, false, false };	        case '4':	            return new boolean[] { false, false, true, false };	        case '5':	            return new boolean[] { true, false, true, false };	        case '6':	            return new boolean[] { false, true, true, false };	        case '7':	            return new boolean[] { true, true, true, false };	        case '8':	            return new boolean[] { false, false, false, true };	        case '9':	            return new boolean[] { true, false, false, true };	        case 'a':	        case 'A':	            return new boolean[] { false, true, false, true };	        case 'b':	        case 'B':	            return new boolean[] { true, true, false, true };	        case 'c':	        case 'C':	            return new boolean[] { false, false, true, true };	        case 'd':	        case 'D':	            return new boolean[] { true, false, true, true };	        case 'e':	        case 'E':	            return new boolean[] { false, true, true, true };	        case 'f':	        case 'F':	            return new boolean[] { true, true, true, true };	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public static String right(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(str.length() - len);	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public String getNewLineText() {	    return newLine;	}
private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) {	    if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {	        return text;	    }	    if (timeToLive < 0) {	        throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another");	    }	    final int searchLength = searchList.length;	    final int replacementLength = replacementList.length;	    if (searchLength != replacementLength) {	        throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength);	    }	    final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];	    int textIndex = -1;	    int replaceIndex = -1;	    int tempIndex = -1;	    for (int i = 0; i < searchLength; i++) {	        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {	            continue;	        }	        tempIndex = text.indexOf(searchList[i]);	        if (tempIndex == -1) {	            noMoreMatchesForReplIndex[i] = true;	        } else {	            if (textIndex == -1 || tempIndex < textIndex) {	                textIndex = tempIndex;	                replaceIndex = i;	            }	        }	    }	    if (textIndex == -1) {	        return text;	    }	    int start = 0;	    int increase = 0;	    for (int i = 0; i < searchList.length; i++) {	        if (searchList[i] == null || replacementList[i] == null) {	            continue;	        }	        final int greater = replacementList[i].length() - searchList[i].length();	        if (greater > 0) {	            increase += 3 * greater;	        }	    }	    increase = Math.min(increase, text.length() / 5);	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (textIndex != -1) {	        for (int i = start; i < textIndex; i++) {	            buf.append(text.charAt(i));	        }	        buf.append(replacementList[replaceIndex]);	        start = textIndex + searchList[replaceIndex].length();	        textIndex = -1;	        replaceIndex = -1;	        tempIndex = -1;	        for (int i = 0; i < searchLength; i++) {	            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {	                continue;	            }	            tempIndex = text.indexOf(searchList[i], start);	            if (tempIndex == -1) {	                noMoreMatchesForReplIndex[i] = true;	            } else {	                if (textIndex == -1 || tempIndex < textIndex) {	                    textIndex = tempIndex;	                    replaceIndex = i;	                }	            }	        }	    }	    final int textLength = text.length();	    for (int i = start; i < textLength; i++) {	        buf.append(text.charAt(i));	    }	    final String result = buf.toString();	    if (!repeat) {	        return result;	    }	    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);	}
public StringBuilder toStringBuilder() {	    return new StringBuilder(size).append(buffer, 0, size);	}
@Override	public String toString() {	    return DurationFormatUtils.formatDurationHMS(getTime());	}
public static String deleteWhitespace(final String str) {	    if (isEmpty(str)) {	        return str;	    }	    final int sz = str.length();	    final char[] chs = new char[sz];	    int count = 0;	    for (int i = 0; i < sz; i++) {	        if (!Character.isWhitespace(str.charAt(i))) {	            chs[count++] = str.charAt(i);	        }	    }	    if (count == sz) {	        return str;	    }	    return new String(chs, 0, count);	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    if (input.charAt(index) == '\\' && index < (input.length() - 1) && Character.isDigit(input.charAt(index + 1))) {	        final int start = index + 1;	        int end = index + 2;	        while (end < input.length() && Character.isDigit(input.charAt(end))) {	            end++;	            if (Integer.parseInt(input.subSequence(start, end).toString(), 10) > OCTAL_MAX) {	                end--;	                break;	            }	        }	        out.write(Integer.parseInt(input.subSequence(start, end).toString(), 8));	        return 1 + end - start;	    }	    return 0;	}
public boolean isEnableSubstitutionInVariables() {	    return enableSubstitutionInVariables;	}
public static byte[] serialize(final Serializable obj) {	    final ByteArrayOutputStream baos = new ByteArrayOutputStream(512);	    serialize(obj, baos);	    return baos.toByteArray();	}
public static String removePattern(final String source, final String regex) {	    return replacePattern(source, regex, StringUtils.EMPTY);	}
public static boolean isEmpty(final CharSequence cs) {	    return cs == null || cs.length() == 0;	}
@Override	public int hashCode() {	    return toHashCode();	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
@Override	public double doubleValue() {	    return value;	}
@Override	public int hashCode() {	    return toHashCode();	}
public final synchronized ExecutorService getExternalExecutor() {	    return externalExecutor;	}
public synchronized void acquire() throws InterruptedException {	    if (isShutdown()) {	        throw new IllegalStateException("TimedSemaphore is shut down!");	    }	    if (task == null) {	        task = startTimer();	    }	    boolean canPass = false;	    do {	        canPass = getLimit() <= NO_LIMIT || acquireCount < getLimit();	        if (!canPass) {	            wait();	        } else {	            acquireCount++;	        }	    } while (!canPass);	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public static int hashCode(final Object array) {	    return new HashCodeBuilder().append(array).toHashCode();	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public String leftString(final int length) {	    if (length <= 0) {	        return "";	    } else if (length >= size) {	        return new String(buffer, 0, size);	    } else {	        return new String(buffer, 0, length);	    }	}
public static boolean isNumeric(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isDigit(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) {	    final StringBuilder buffer = new StringBuilder();	    boolean lastOutputSeconds = false;	    final int sz = tokens.length;	    for (int i = 0; i < sz; i++) {	        final Token token = tokens[i];	        final Object value = token.getValue();	        final int count = token.getCount();	        if (value instanceof StringBuilder) {	            buffer.append(value.toString());	        } else {	            if (value == y) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years));	                lastOutputSeconds = false;	            } else if (value == M) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months));	                lastOutputSeconds = false;	            } else if (value == d) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days));	                lastOutputSeconds = false;	            } else if (value == H) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours));	                lastOutputSeconds = false;	            } else if (value == m) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes));	                lastOutputSeconds = false;	            } else if (value == s) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds));	                lastOutputSeconds = true;	            } else if (value == S) {	                if (lastOutputSeconds) {	                    milliseconds += 1000;	                    final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds);	                    buffer.append(str.substring(1));	                } else {	                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds));	                }	                lastOutputSeconds = false;	            }	        }	    }	    return buffer.toString();	}
public static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    final int beSrcPos = src.length - 1 - srcPos;	    final int srcLen = Math.min(4, beSrcPos + 1);	    final boolean[] paddedSrc = new boolean[4];	    System.arraycopy(src, beSrcPos + 1 - srcLen, paddedSrc, 4 - srcLen, srcLen);	    src = paddedSrc;	    srcPos = 0;	    if (src[srcPos]) {	        if (src.length > srcPos + 1 && src[srcPos + 1]) {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 1 && src[srcPos + 1]) {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
public boolean isEmpty() {	    return size == 0;	}
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) {	    final StringBuilder buffer = new StringBuilder();	    boolean lastOutputSeconds = false;	    final int sz = tokens.length;	    for (int i = 0; i < sz; i++) {	        final Token token = tokens[i];	        final Object value = token.getValue();	        final int count = token.getCount();	        if (value instanceof StringBuilder) {	            buffer.append(value.toString());	        } else {	            if (value == y) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years));	                lastOutputSeconds = false;	            } else if (value == M) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months));	                lastOutputSeconds = false;	            } else if (value == d) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days));	                lastOutputSeconds = false;	            } else if (value == H) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours));	                lastOutputSeconds = false;	            } else if (value == m) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes));	                lastOutputSeconds = false;	            } else if (value == s) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds));	                lastOutputSeconds = true;	            } else if (value == S) {	                if (lastOutputSeconds) {	                    milliseconds += 1000;	                    final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds);	                    buffer.append(str.substring(1));	                } else {	                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds));	                }	                lastOutputSeconds = false;	            }	        }	    }	    return buffer.toString();	}
public static String getMessage(final Throwable th) {	    if (th == null) {	        return "";	    }	    final String clsName = ClassUtils.getShortClassName(th, null);	    final String msg = th.getMessage();	    return clsName + ": " + StringUtils.defaultString(msg);	}
public int size() {	    return size;	}
public static <L, M, R> Triple<L, M, R> of(final L left, final M middle, final R right) {	    return new ImmutableTriple<L, M, R>(left, middle, right);	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public int toComparison() {	    return comparison;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
protected boolean isFieldSeparatorAtStart() {	    return fieldSeparatorAtStart;	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public boolean isEmpty() {	    return size == 0;	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
@Override	public byte byteValue() {	    return value;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static String uncapitalize(final String str, final char... delimiters) {	    final int delimLen = delimiters == null ? -1 : delimiters.length;	    if (StringUtils.isEmpty(str) || delimLen == 0) {	        return str;	    }	    final char[] buffer = str.toCharArray();	    boolean uncapitalizeNext = true;	    for (int i = 0; i < buffer.length; i++) {	        final char ch = buffer[i];	        if (isDelimiter(ch, delimiters)) {	            uncapitalizeNext = true;	        } else if (uncapitalizeNext) {	            buffer[i] = Character.toLowerCase(ch);	            uncapitalizeNext = false;	        }	    }	    return new String(buffer);	}
public int size() {	    return size;	}
public static boolean equalsIgnoreCase(final CharSequence str1, final CharSequence str2) {	    if (str1 == null || str2 == null) {	        return str1 == str2;	    } else if (str1 == str2) {	        return true;	    } else if (str1.length() != str2.length()) {	        return false;	    } else {	        return CharSequenceUtils.regionMatches(str1, true, 0, str2, 0, str1.length());	    }	}
@Override	public int length() {	    return size;	}
public void stop() {	    if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {	        throw new IllegalStateException("Stopwatch is not running. ");	    }	    if (this.runningState == STATE_RUNNING) {	        this.stopTime = System.nanoTime();	    }	    this.runningState = STATE_STOPPED;	}
public int capacity() {	    return buffer.length;	}
protected boolean isUseIdentityHashCode() {	    return useIdentityHashCode;	}
@Override	public int length() {	    return size;	}
protected String getArraySeparator() {	    return arraySeparator;	}
public static int indexOfDifference(final CharSequence... css) {	    if (css == null || css.length <= 1) {	        return INDEX_NOT_FOUND;	    }	    boolean anyStringNull = false;	    boolean allStringsNull = true;	    final int arrayLen = css.length;	    int shortestStrLen = Integer.MAX_VALUE;	    int longestStrLen = 0;	    for (int i = 0; i < arrayLen; i++) {	        if (css[i] == null) {	            anyStringNull = true;	            shortestStrLen = 0;	        } else {	            allStringsNull = false;	            shortestStrLen = Math.min(css[i].length(), shortestStrLen);	            longestStrLen = Math.max(css[i].length(), longestStrLen);	        }	    }	    if (allStringsNull || longestStrLen == 0 && !anyStringNull) {	        return INDEX_NOT_FOUND;	    }	    if (shortestStrLen == 0) {	        return 0;	    }	    int firstDiff = -1;	    for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {	        final char comparisonChar = css[0].charAt(stringPos);	        for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {	            if (css[arrayPos].charAt(stringPos) != comparisonChar) {	                firstDiff = stringPos;	                break;	            }	        }	        if (firstDiff != -1) {	            break;	        }	    }	    if (firstDiff == -1 && shortestStrLen != longestStrLen) {	        return shortestStrLen;	    }	    return firstDiff;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public static int hexDigitToInt(final char hexDigit) {	    final int digit = Character.digit(hexDigit, 16);	    if (digit < 0) {	        throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	    return digit;	}
public static String[][] ISO8859_1_UNESCAPE() {	    return ISO8859_1_UNESCAPE.clone();	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
protected String getArraySeparator() {	    return arraySeparator;	}
public static String trim(final String str) {	    return str == null ? null : str.trim();	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools) {	    if ((src.length == 0 && srcPos == 0) || 0 == nBools) {	        return dstInit;	    }	    if (nBools - 1 + dstPos >= 32) {	        throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 32");	    }	    int out = dstInit;	    int shift = 0;	    for (int i = 0; i < nBools; i++) {	        shift = i * 1 + dstPos;	        final int bits = (src[i + srcPos] ? 1 : 0) << shift;	        final int mask = 0x1 << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
public static boolean isAlpha(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public boolean equalsIgnoreCase(final StrBuilder other) {	    if (this == other) {	        return true;	    }	    if (this.size != other.size) {	        return false;	    }	    final char[] thisBuf = this.buffer;	    final char[] otherBuf = other.buffer;	    for (int i = size - 1; i >= 0; i--) {	        final char c1 = thisBuf[i];	        final char c2 = otherBuf[i];	        if (c1 != c2 && Character.toUpperCase(c1) != Character.toUpperCase(c2)) {	            return false;	        }	    }	    return true;	}
public static String getCommonPrefix(final String... strs) {	    if (strs == null || strs.length == 0) {	        return EMPTY;	    }	    final int smallestIndexOfDiff = indexOfDifference(strs);	    if (smallestIndexOfDiff == INDEX_NOT_FOUND) {	        if (strs[0] == null) {	            return EMPTY;	        }	        return strs[0];	    } else if (smallestIndexOfDiff == 0) {	        return EMPTY;	    } else {	        return strs[0].substring(0, smallestIndexOfDiff);	    }	}
public static Date setMonths(final Date date, final int amount) {	    return set(date, Calendar.MONTH, amount);	}
@Override	public Float getValue() {	    return Float.valueOf(this.value);	}
@Override	public boolean translate(final int codepoint, final Writer out) throws IOException {	    if (between) {	        if (codepoint < below || codepoint > above) {	            return false;	        }	    } else {	        if (codepoint >= below && codepoint <= above) {	            return false;	        }	    }	    if (codepoint > 0xffff) {	        out.write(toUtf16Escape(codepoint));	    } else if (codepoint > 0xfff) {	        out.write("\\u" + hex(codepoint));	    } else if (codepoint > 0xff) {	        out.write("\\u0" + hex(codepoint));	    } else if (codepoint > 0xf) {	        out.write("\\u00" + hex(codepoint));	    } else {	        out.write("\\u000" + hex(codepoint));	    }	    return true;	}
public static char binaryToHexDigit(final boolean[] src, final int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    if (src.length > srcPos + 3 && src[srcPos + 3]) {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src[srcPos]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase) {	    if (str == null || prefix == null) {	        return str == null && prefix == null;	    }	    if (prefix.length() > str.length()) {	        return false;	    }	    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());	}
public static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts) {	    if ((src.length == 0 && srcPos == 0) || 0 == nInts) {	        return dstInit;	    }	    if ((nInts - 1) * 32 + dstPos >= 64) {	        throw new IllegalArgumentException("(nInts-1)*32+dstPos is greather or equal to than 64");	    }	    long out = dstInit;	    int shift = 0;	    for (int i = 0; i < nInts; i++) {	        shift = i * 32 + dstPos;	        final long bits = ((0xffffffffL & src[i + srcPos]) << shift);	        final long mask = 0xffffffffL << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
public static String removeStartIgnoreCase(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (startsWithIgnoreCase(str, remove)) {	        return str.substring(remove.length());	    }	    return str;	}
@Override	public final void applyPattern(final String pattern) {	    if (registry == null) {	        super.applyPattern(pattern);	        toPattern = super.toPattern();	        return;	    }	    final ArrayList<Format> foundFormats = new ArrayList<Format>();	    final ArrayList<String> foundDescriptions = new ArrayList<String>();	    final StringBuilder stripCustom = new StringBuilder(pattern.length());	    final ParsePosition pos = new ParsePosition(0);	    final char[] c = pattern.toCharArray();	    int fmtCount = 0;	    while (pos.getIndex() < pattern.length()) {	        switch(c[pos.getIndex()]) {	            case QUOTE:	                appendQuotedString(pattern, pos, stripCustom, true);	                break;	            case START_FE:	                fmtCount++;	                seekNonWs(pattern, pos);	                final int start = pos.getIndex();	                final int index = readArgumentIndex(pattern, next(pos));	                stripCustom.append(START_FE).append(index);	                seekNonWs(pattern, pos);	                Format format = null;	                String formatDescription = null;	                if (c[pos.getIndex()] == START_FMT) {	                    formatDescription = parseFormatDescription(pattern, next(pos));	                    format = getFormat(formatDescription);	                    if (format == null) {	                        stripCustom.append(START_FMT).append(formatDescription);	                    }	                }	                foundFormats.add(format);	                foundDescriptions.add(format == null ? null : formatDescription);	                Validate.isTrue(foundFormats.size() == fmtCount);	                Validate.isTrue(foundDescriptions.size() == fmtCount);	                if (c[pos.getIndex()] != END_FE) {	                    throw new IllegalArgumentException("Unreadable format element at position " + start);	                }	            default:	                stripCustom.append(c[pos.getIndex()]);	                next(pos);	        }	    }	    super.applyPattern(stripCustom.toString());	    toPattern = insertFormats(super.toPattern(), foundDescriptions);	    if (containsElements(foundFormats)) {	        final Format[] origFormats = getFormats();	        int i = 0;	        for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) {	            final Format f = it.next();	            if (f != null) {	                origFormats[i] = f;	            }	        }	        super.setFormats(origFormats);	    }	}
public static Class<?> getRawType(final Type type, final Type assigningType) {	    if (type instanceof Class<?>) {	        return (Class<?>) type;	    }	    if (type instanceof ParameterizedType) {	        return getRawType((ParameterizedType) type);	    }	    if (type instanceof TypeVariable<?>) {	        if (assigningType == null) {	            return null;	        }	        final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration();	        if (!(genericDeclaration instanceof Class<?>)) {	            return null;	        }	        final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType, (Class<?>) genericDeclaration);	        if (typeVarAssigns == null) {	            return null;	        }	        final Type typeArgument = typeVarAssigns.get(type);	        if (typeArgument == null) {	            return null;	        }	        return getRawType(typeArgument, assigningType);	    }	    if (type instanceof GenericArrayType) {	        final Class<?> rawComponentType = getRawType(((GenericArrayType) type).getGenericComponentType(), assigningType);	        return Array.newInstance(rawComponentType, 0).getClass();	    }	    if (type instanceof WildcardType) {	        return null;	    }	    throw new IllegalArgumentException("unknown type: " + type);	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public String getNullText() {	    return nullText;	}
public static void isInstanceOf(final Class<?> type, final Object obj, final String message, final Object... values) {	    if (type.isInstance(obj) == false) {	        throw new IllegalArgumentException(String.format(message, values));	    }	}
@Override	public int read(final char[] b, final int off, int len) {	    if (off < 0 || len < 0 || off > b.length || (off + len) > b.length || (off + len) < 0) {	        throw new IndexOutOfBoundsException();	    }	    if (len == 0) {	        return 0;	    }	    if (pos >= StrBuilder.this.size()) {	        return -1;	    }	    if (pos + len > size()) {	        len = StrBuilder.this.size() - pos;	    }	    StrBuilder.this.getChars(pos, pos + len, b, off);	    pos += len;	    return len;	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
public int indexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex < 0 ? 0 : startIndex);	    if (matcher == null || startIndex >= size) {	        return -1;	    }	    final int len = size;	    final char[] buf = buffer;	    for (int i = startIndex; i < len; i++) {	        if (matcher.isMatch(buf, i, startIndex, len) > 0) {	            return i;	        }	    }	    return -1;	}
public static String unicodeEscaped(final Character ch) {	    if (ch == null) {	        return null;	    }	    return unicodeEscaped(ch.charValue());	}
public static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) {	    if (0 == nBools) {	        return dst;	    }	    if (nBools - 1 + srcPos >= 64) {	        throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 64");	    }	    int shift = 0;	    for (int i = 0; i < nBools; i++) {	        shift = i * 1 + srcPos;	        dst[dstPos + i] = ((0x1 & (src >> shift)) != 0);	    }	    return dst;	}
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {	    if (array == null) {	        if (index != 0) {	            throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0");	        }	        final Object joinedArray = Array.newInstance(clss, 1);	        Array.set(joinedArray, 0, element);	        return joinedArray;	    }	    final int length = Array.getLength(array);	    if (index > length || index < 0) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(clss, length + 1);	    System.arraycopy(array, 0, result, 0, index);	    Array.set(result, index, element);	    if (index < length) {	        System.arraycopy(array, index, result, index + 1, length - index);	    }	    return result;	}
@Override	public double doubleValue() {	    return (double) numerator / (double) denominator;	}
public static void reverse(final boolean[] array) {	    if (array == null) {	        return;	    }	    int i = 0;	    int j = array.length - 1;	    boolean tmp;	    while (j > i) {	        tmp = array[j];	        array[j] = array[i];	        array[i] = tmp;	        j--;	        i++;	    }	}
private static boolean endsWith(final CharSequence str, final CharSequence suffix, final boolean ignoreCase) {	    if (str == null || suffix == null) {	        return str == null && suffix == null;	    }	    if (suffix.length() > str.length()) {	        return false;	    }	    final int strOffset = str.length() - suffix.length();	    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, suffix, 0, suffix.length());	}
@Override	public int length() {	    return size;	}
@Override	public T get(final long timeout, final TimeUnit unit) {	    return value;	}
public static boolean[] removeElements(final boolean[] array, final boolean... values) {	    if (isEmpty(array) || isEmpty(values)) {	        return clone(array);	    }	    final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2);	    for (final boolean v : values) {	        final Boolean boxed = Boolean.valueOf(v);	        final MutableInt count = occurrences.get(boxed);	        if (count == null) {	            occurrences.put(boxed, new MutableInt(1));	        } else {	            count.increment();	        }	    }	    final BitSet toRemove = new BitSet();	    for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) {	        final Boolean v = e.getKey();	        int found = 0;	        for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {	            found = indexOf(array, v.booleanValue(), found);	            if (found < 0) {	                break;	            }	            toRemove.set(found++);	        }	    }	    return (boolean[]) removeAll(array, toRemove);	}
public static void reverse(final boolean[] array) {	    if (array == null) {	        return;	    }	    int i = 0;	    int j = array.length - 1;	    boolean tmp;	    while (j > i) {	        tmp = array[j];	        array[j] = array[i];	        array[i] = tmp;	        j--;	        i++;	    }	}
public static Date ceiling(final Object date, final int field) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (date instanceof Date) {	        return ceiling((Date) date, field);	    } else if (date instanceof Calendar) {	        return ceiling((Calendar) date, field).getTime();	    } else {	        throw new ClassCastException("Could not find ceiling of for type: " + date.getClass());	    }	}
protected String getSummaryObjectStartText() {	    return summaryObjectStartText;	}
public boolean isEquals() {	    return this.isEquals;	}
@Override	public int length() {	    return size;	}
public boolean isEmpty() {	    return size == 0;	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
@Override	public void setUseClassName(final boolean useClassName) {	    super.setUseClassName(useClassName);	}
public int size() {	    return size;	}
public static <T> T CONST(final T v) {	    return v;	}
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) {	    final StringBuilder buffer = new StringBuilder();	    boolean lastOutputSeconds = false;	    final int sz = tokens.length;	    for (int i = 0; i < sz; i++) {	        final Token token = tokens[i];	        final Object value = token.getValue();	        final int count = token.getCount();	        if (value instanceof StringBuilder) {	            buffer.append(value.toString());	        } else {	            if (value == y) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years));	                lastOutputSeconds = false;	            } else if (value == M) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months));	                lastOutputSeconds = false;	            } else if (value == d) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days));	                lastOutputSeconds = false;	            } else if (value == H) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours));	                lastOutputSeconds = false;	            } else if (value == m) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes));	                lastOutputSeconds = false;	            } else if (value == s) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds));	                lastOutputSeconds = true;	            } else if (value == S) {	                if (lastOutputSeconds) {	                    milliseconds += 1000;	                    final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds);	                    buffer.append(str.substring(1));	                } else {	                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds));	                }	                lastOutputSeconds = false;	            }	        }	    }	    return buffer.toString();	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static String uncapitalize(final String str, final char... delimiters) {	    final int delimLen = delimiters == null ? -1 : delimiters.length;	    if (StringUtils.isEmpty(str) || delimLen == 0) {	        return str;	    }	    final char[] buffer = str.toCharArray();	    boolean uncapitalizeNext = true;	    for (int i = 0; i < buffer.length; i++) {	        final char ch = buffer[i];	        if (isDelimiter(ch, delimiters)) {	            uncapitalizeNext = true;	        } else if (uncapitalizeNext) {	            buffer[i] = Character.toLowerCase(ch);	            uncapitalizeNext = false;	        }	    }	    return new String(buffer);	}
public static String rightPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return rightPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return str.concat(padStr);	    } else if (pads < padLen) {	        return str.concat(padStr.substring(0, pads));	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return str.concat(new String(padding));	    }	}
public static String difference(final String str1, final String str2) {	    if (str1 == null) {	        return str2;	    }	    if (str2 == null) {	        return str1;	    }	    final int at = indexOfDifference(str1, str2);	    if (at == INDEX_NOT_FOUND) {	        return EMPTY;	    }	    return str2.substring(at);	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static String stripEnd(final String str, final String stripChars) {	    int end;	    if (str == null || (end = str.length()) == 0) {	        return str;	    }	    if (stripChars == null) {	        while (end != 0 && Character.isWhitespace(str.charAt(end - 1))) {	            end--;	        }	    } else if (stripChars.isEmpty()) {	        return str;	    } else {	        while (end != 0 && stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND) {	            end--;	        }	    }	    return str.substring(0, end);	}
public static int hexDigitToInt(final char hexDigit) {	    final int digit = Character.digit(hexDigit, 16);	    if (digit < 0) {	        throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	    return digit;	}
@Override	public byte byteValue() {	    return value;	}
private static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal, final boolean lastIndex) {	    if (str == null || searchStr == null || ordinal <= 0) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return lastIndex ? str.length() : 0;	    }	    int found = 0;	    int index = lastIndex ? str.length() : INDEX_NOT_FOUND;	    do {	        if (lastIndex) {	            index = CharSequenceUtils.lastIndexOf(str, searchStr, index - 1);	        } else {	            index = CharSequenceUtils.indexOf(str, searchStr, index + 1);	        }	        if (index < 0) {	            return index;	        }	        found++;	    } while (found < ordinal);	    return index;	}
public static String formatPeriodISO(final long startMillis, final long endMillis) {	    return formatPeriod(startMillis, endMillis, ISO_EXTENDED_FORMAT_PATTERN, false, TimeZone.getDefault());	}
@Override	public boolean markSupported() {	    return true;	}
public static String randomAscii(final int count) {	    return random(count, 32, 127, false, false);	}
public boolean isNaN() {	    return Double.isNaN(value);	}
protected String getFieldSeparator() {	    return fieldSeparator;	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static boolean containsNone(final CharSequence cs, final String invalidChars) {	    if (cs == null || invalidChars == null) {	        return true;	    }	    return containsNone(cs, invalidChars.toCharArray());	}
public boolean isNegated() {	    return negated;	}
public StrBuilder appendFixedWidthPadRight(final int value, final int width, final char padChar) {	    return appendFixedWidthPadRight(String.valueOf(value), width, padChar);	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return 0;	    }	    if (lhs == null || rhs == null) {	        throw new NullPointerException();	    }	    Class<?> lhsClazz = lhs.getClass();	    if (!lhsClazz.isInstance(rhs)) {	        throw new ClassCastException();	    }	    final CompareToBuilder compareToBuilder = new CompareToBuilder();	    reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);	    while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) {	        lhsClazz = lhsClazz.getSuperclass();	        reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);	    }	    return compareToBuilder.toComparison();	}
public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) {	    if (s == null || t == null) {	        throw new IllegalArgumentException("Strings must not be null");	    }	    if (threshold < 0) {	        throw new IllegalArgumentException("Threshold must not be negative");	    }	    int n = s.length();	    int m = t.length();	    if (n == 0) {	        return m <= threshold ? m : -1;	    } else if (m == 0) {	        return n <= threshold ? n : -1;	    }	    if (n > m) {	        final CharSequence tmp = s;	        s = t;	        t = tmp;	        n = m;	        m = t.length();	    }	    int[] p = new int[n + 1];	    int[] d = new int[n + 1];	    int[] _d;	    final int boundary = Math.min(n, threshold) + 1;	    for (int i = 0; i < boundary; i++) {	        p[i] = i;	    }	    Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);	    Arrays.fill(d, Integer.MAX_VALUE);	    for (int j = 1; j <= m; j++) {	        final char t_j = t.charAt(j - 1);	        d[0] = j;	        final int min = Math.max(1, j - threshold);	        final int max = Math.min(n, j + threshold);	        if (min > max) {	            return -1;	        }	        if (min > 1) {	            d[min - 1] = Integer.MAX_VALUE;	        }	        for (int i = min; i <= max; i++) {	            if (s.charAt(i - 1) == t_j) {	                d[i] = p[i - 1];	            } else {	                d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);	            }	        }	        _d = p;	        p = d;	        d = _d;	    }	    if (p[n] <= threshold) {	        return p[n];	    }	    return -1;	}
public static <T> T CONST(final T v) {	    return v;	}
public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) {	    String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'");	    if (suppressLeadingZeroElements) {	        duration = " " + duration;	        String tmp = StringUtils.replaceOnce(duration, " 0 days", "");	        if (tmp.length() != duration.length()) {	            duration = tmp;	            tmp = StringUtils.replaceOnce(duration, " 0 hours", "");	            if (tmp.length() != duration.length()) {	                duration = tmp;	                tmp = StringUtils.replaceOnce(duration, " 0 minutes", "");	                duration = tmp;	                if (tmp.length() != duration.length()) {	                    duration = StringUtils.replaceOnce(tmp, " 0 seconds", "");	                }	            }	        }	        if (duration.length() != 0) {	            duration = duration.substring(1);	        }	    }	    if (suppressTrailingZeroElements) {	        String tmp = StringUtils.replaceOnce(duration, " 0 seconds", "");	        if (tmp.length() != duration.length()) {	            duration = tmp;	            tmp = StringUtils.replaceOnce(duration, " 0 minutes", "");	            if (tmp.length() != duration.length()) {	                duration = tmp;	                tmp = StringUtils.replaceOnce(duration, " 0 hours", "");	                if (tmp.length() != duration.length()) {	                    duration = StringUtils.replaceOnce(tmp, " 0 days", "");	                }	            }	        }	    }	    duration = " " + duration;	    duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second");	    duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute");	    duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour");	    duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day");	    return duration.trim();	}
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) {	    final StringBuilder buffer = new StringBuilder();	    boolean lastOutputSeconds = false;	    final int sz = tokens.length;	    for (int i = 0; i < sz; i++) {	        final Token token = tokens[i];	        final Object value = token.getValue();	        final int count = token.getCount();	        if (value instanceof StringBuilder) {	            buffer.append(value.toString());	        } else {	            if (value == y) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years));	                lastOutputSeconds = false;	            } else if (value == M) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months));	                lastOutputSeconds = false;	            } else if (value == d) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days));	                lastOutputSeconds = false;	            } else if (value == H) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours));	                lastOutputSeconds = false;	            } else if (value == m) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes));	                lastOutputSeconds = false;	            } else if (value == s) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds));	                lastOutputSeconds = true;	            } else if (value == S) {	                if (lastOutputSeconds) {	                    milliseconds += 1000;	                    final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds);	                    buffer.append(str.substring(1));	                } else {	                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds));	                }	                lastOutputSeconds = false;	            }	        }	    }	    return buffer.toString();	}
public static String randomAlphabetic(final int count) {	    return random(count, true, false);	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public boolean isEquals() {	    return this.isEquals;	}
@Override	public List<Object> getContextValues(final String label) {	    return this.exceptionContext.getContextValues(label);	}
private static long getFragment(final Calendar calendar, final int fragment, final int unit) {	    if (calendar == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final long millisPerUnit = getMillisPerUnit(unit);	    long result = 0;	    switch(fragment) {	        case Calendar.YEAR:	            result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit;	            break;	        case Calendar.MONTH:	            result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit;	            break;	    }	    switch(fragment) {	        case Calendar.YEAR:	        case Calendar.MONTH:	        case Calendar.DAY_OF_YEAR:	        case Calendar.DATE:	            result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit;	        case Calendar.HOUR_OF_DAY:	            result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit;	        case Calendar.MINUTE:	            result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit;	        case Calendar.SECOND:	            result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit;	            break;	        case Calendar.MILLISECOND:	            break;	        default:	            throw new IllegalArgumentException("The fragment " + fragment + " is not supported");	    }	    return result;	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
protected String getSizeStartText() {	    return sizeStartText;	}
public boolean contains(final StrMatcher matcher) {	    return indexOf(matcher, 0) >= 0;	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public String getNullText() {	    return nullText;	}
protected String getContentEnd() {	    return contentEnd;	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
public EqualsBuilder appendSuper(final boolean superEquals) {	    if (isEquals == false) {	        return this;	    }	    isEquals = superEquals;	    return this;	}
@Override	public String next() {	    if (hasNext()) {	        return tokens[tokenPos++];	    }	    throw new NoSuchElementException();	}
protected boolean isDefaultFullDetail() {	    return defaultFullDetail;	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
public static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes) {	    if ((src.length == 0 && srcPos == 0) || 0 == nBytes) {	        return dstInit;	    }	    if ((nBytes - 1) * 8 + dstPos >= 32) {	        throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 32");	    }	    int out = dstInit;	    int shift = 0;	    for (int i = 0; i < nBytes; i++) {	        shift = i * 8 + dstPos;	        final int bits = (0xff & src[i + srcPos]) << shift;	        final int mask = 0xff << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
public Set<String> initializerNames() {	    return Collections.unmodifiableSet(initializers.keySet());	}
public static boolean isAlpha(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
private static long getFragment(final Calendar calendar, final int fragment, final int unit) {	    if (calendar == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final long millisPerUnit = getMillisPerUnit(unit);	    long result = 0;	    switch(fragment) {	        case Calendar.YEAR:	            result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit;	            break;	        case Calendar.MONTH:	            result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit;	            break;	    }	    switch(fragment) {	        case Calendar.YEAR:	        case Calendar.MONTH:	        case Calendar.DAY_OF_YEAR:	        case Calendar.DATE:	            result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit;	        case Calendar.HOUR_OF_DAY:	            result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit;	        case Calendar.MINUTE:	            result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit;	        case Calendar.SECOND:	            result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit;	            break;	        case Calendar.MILLISECOND:	            break;	        default:	            throw new IllegalArgumentException("The fragment " + fragment + " is not supported");	    }	    return result;	}
public static <T extends CharSequence> T validIndex(final T chars, final int index) {	    return validIndex(chars, index, DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE, Integer.valueOf(index));	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase) {	    if (str == null || prefix == null) {	        return str == null && prefix == null;	    }	    if (prefix.length() > str.length()) {	        return false;	    }	    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
void increment() {	    count++;	}
public static Date addMinutes(final Date date, final int amount) {	    return add(date, Calendar.MINUTE, amount);	}
public static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools) {	    if ((src.length == 0 && srcPos == 0) || 0 == nBools) {	        return dstInit;	    }	    if (nBools - 1 + dstPos >= 64) {	        throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 64");	    }	    long out = dstInit;	    int shift = 0;	    for (int i = 0; i < nBools; i++) {	        shift = i * 1 + dstPos;	        final long bits = (src[i + srcPos] ? 1L : 0) << shift;	        final long mask = 0x1L << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
public static Integer toIntegerObject(final Boolean bool, final Integer trueValue, final Integer falseValue, final Integer nullValue) {	    if (bool == null) {	        return nullValue;	    }	    return bool.booleanValue() ? trueValue : falseValue;	}
protected boolean isFieldSeparatorAtStart() {	    return fieldSeparatorAtStart;	}
public static String removeEnd(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.endsWith(remove)) {	        return str.substring(0, str.length() - remove.length());	    }	    return str;	}
public static boolean isNotTrue(final Boolean bool) {	    return !isTrue(bool);	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) {	    if (src.length > 8) {	        throw new IllegalArgumentException("src.length>8: src.length=" + src.length);	    }	    if (src.length - srcPos < 4) {	        throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos);	    }	    if (src[srcPos + 3]) {	        if (src[srcPos + 2]) {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return '7';	                }	            } else {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return '3';	                }	            }	        } else {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return '5';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '1';	                }	            }	        }	    } else {	        if (src[srcPos + 2]) {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'e';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return 'a';	                } else {	                    return '2';	                }	            }	        } else {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'c';	                } else {	                    return '4';	                }	            } else {	                if (src[srcPos]) {	                    return '8';	                } else {	                    return '0';	                }	            }	        }	    }	}
public static String right(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(str.length() - len);	}
private static boolean endsWith(final CharSequence str, final CharSequence suffix, final boolean ignoreCase) {	    if (str == null || suffix == null) {	        return str == null && suffix == null;	    }	    if (suffix.length() > str.length()) {	        return false;	    }	    final int strOffset = str.length() - suffix.length();	    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, suffix, 0, suffix.length());	}
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return true;	    }	    if (lhs == null || rhs == null) {	        return false;	    }	    final Class<?> lhsClass = lhs.getClass();	    final Class<?> rhsClass = rhs.getClass();	    Class<?> testClass;	    if (lhsClass.isInstance(rhs)) {	        testClass = lhsClass;	        if (!rhsClass.isInstance(lhs)) {	            testClass = rhsClass;	        }	    } else if (rhsClass.isInstance(lhs)) {	        testClass = rhsClass;	        if (!lhsClass.isInstance(rhs)) {	            testClass = lhsClass;	        }	    } else {	        return false;	    }	    final EqualsBuilder equalsBuilder = new EqualsBuilder();	    try {	        reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {	            testClass = testClass.getSuperclass();	            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        }	    } catch (final IllegalArgumentException e) {	        return false;	    }	    return equalsBuilder.isEquals();	}
@Override	public int length() {	    return size;	}
public int capacity() {	    return buffer.length;	}
public void stop() {	    if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {	        throw new IllegalStateException("Stopwatch is not running. ");	    }	    if (this.runningState == STATE_RUNNING) {	        this.stopTime = System.nanoTime();	    }	    this.runningState = STATE_STOPPED;	}
protected boolean isFieldSeparatorAtEnd() {	    return fieldSeparatorAtEnd;	}
public static <T extends CharSequence> T notEmpty(final T chars) {	    return notEmpty(chars, DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static float min(final float a, final float b) {	    if (Float.isNaN(a)) {	        return b;	    } else if (Float.isNaN(b)) {	        return a;	    } else {	        return Math.min(a, b);	    }	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
@Override	public long longValue() {	    return value;	}
public static Object invokeExactStaticMethod(final Class<?> cls, final String methodName, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {	    if (args == null) {	        args = ArrayUtils.EMPTY_OBJECT_ARRAY;	    }	    final Class<?>[] parameterTypes = ClassUtils.toClass(args);	    return invokeExactStaticMethod(cls, methodName, args, parameterTypes);	}
public static Locale toLocale(final String str) {	    if (str == null) {	        return null;	    }	    if (str.contains("#")) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final int len = str.length();	    if (len < 2) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final char ch0 = str.charAt(0);	    if (ch0 == '_') {	        if (len < 3) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        final char ch1 = str.charAt(1);	        final char ch2 = str.charAt(2);	        if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        if (len == 3) {	            return new Locale("", str.substring(1, 3));	        }	        if (len < 5) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        if (str.charAt(3) != '_') {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        return new Locale("", str.substring(1, 3), str.substring(4));	    }	    final char ch1 = str.charAt(1);	    if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (len == 2) {	        return new Locale(str);	    }	    if (len < 5) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (str.charAt(2) != '_') {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final char ch3 = str.charAt(3);	    if (ch3 == '_') {	        return new Locale(str.substring(0, 2), "", str.substring(4));	    }	    final char ch4 = str.charAt(4);	    if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (len == 5) {	        return new Locale(str.substring(0, 2), str.substring(3, 5));	    }	    if (len < 7) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (str.charAt(5) != '_') {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
@Override	public long longValue() {	    return value;	}
public boolean isAfterRange(final Range<T> otherRange) {	    if (otherRange == null) {	        return false;	    }	    return isAfter(otherRange.maximum);	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
@Override	public T get(final long timeout, final TimeUnit unit) {	    return value;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
@Override	public int length() {	    return size;	}
public Fraction negate() {	    if (numerator == Integer.MIN_VALUE) {	        throw new ArithmeticException("overflow: too large to negate");	    }	    return new Fraction(-numerator, denominator);	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public String getNewLineText() {	    return newLine;	}
public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final E... values) {	    Validate.noNullElements(values);	    return generateBitVector(enumClass, Arrays.<E>asList(values));	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
protected String getArrayEnd() {	    return arrayEnd;	}
public static String overlay(final String str, String overlay, int start, int end) {	    if (str == null) {	        return null;	    }	    if (overlay == null) {	        overlay = EMPTY;	    }	    final int len = str.length();	    if (start < 0) {	        start = 0;	    }	    if (start > len) {	        start = len;	    }	    if (end < 0) {	        end = 0;	    }	    if (end > len) {	        end = len;	    }	    if (start > end) {	        final int temp = start;	        start = end;	        end = temp;	    }	    return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString();	}
protected void removeLastFieldSeparator(final StringBuffer buffer) {	    final int len = buffer.length();	    final int sepLen = fieldSeparator.length();	    if (len > 0 && sepLen > 0 && len >= sepLen) {	        boolean match = true;	        for (int i = 0; i < sepLen; i++) {	            if (buffer.charAt(len - 1 - i) != fieldSeparator.charAt(sepLen - 1 - i)) {	                match = false;	                break;	            }	        }	        if (match) {	            buffer.setLength(len - sepLen);	        }	    }	}
public void increment() {	    value++;	}
protected String getFieldNameValueSeparator() {	    return fieldNameValueSeparator;	}
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] result = new boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        final Boolean b = array[i];	        result[i] = (b == null ? valueForNull : b.booleanValue());	    }	    return result;	}
public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) {	    if (it != null) {	        separator = ObjectUtils.toString(separator);	        while (it.hasNext()) {	            append(it.next());	            if (it.hasNext()) {	                append(separator);	            }	        }	    }	    return this;	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
public static String substringBefore(final String str, final String separator) {	    if (isEmpty(str) || separator == null) {	        return str;	    }	    if (separator.isEmpty()) {	        return EMPTY;	    }	    final int pos = str.indexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return str;	    }	    return str.substring(0, pos);	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
public static String rightPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return rightPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return str.concat(padStr);	    } else if (pads < padLen) {	        return str.concat(padStr.substring(0, pads));	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return str.concat(new String(padding));	    }	}
@Override	public void setSizeStartText(final String sizeStartText) {	    super.setSizeStartText(sizeStartText);	}
public StrBuilder setNewLineText(final String newLine) {	    this.newLine = newLine;	    return this;	}
public static int truncatedCompareTo(final Date date1, final Date date2, final int field) {	    final Date truncatedDate1 = truncate(date1, field);	    final Date truncatedDate2 = truncate(date2, field);	    return truncatedDate1.compareTo(truncatedDate2);	}
public EqualsBuilder appendSuper(final boolean superEquals) {	    if (isEquals == false) {	        return this;	    }	    isEquals = superEquals;	    return this;	}
public static String leftPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return leftPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return padStr.concat(str);	    } else if (pads < padLen) {	        return padStr.substring(0, pads).concat(str);	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return new String(padding).concat(str);	    }	}
public void appendStart(final StringBuffer buffer, final Object object) {	    if (object != null) {	        appendClassName(buffer, object);	        appendIdentityHashCode(buffer, object);	        appendContentStart(buffer);	        if (fieldSeparatorAtStart) {	            appendFieldSeparator(buffer);	        }	    }	}
private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase) {	    if (str == null || prefix == null) {	        return str == null && prefix == null;	    }	    if (prefix.length() > str.length()) {	        return false;	    }	    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());	}
public static boolean startsWithIgnoreCase(final CharSequence str, final CharSequence prefix) {	    return startsWith(str, prefix, true);	}
protected void setSizeEndText(String sizeEndText) {	    if (sizeEndText == null) {	        sizeEndText = "";	    }	    this.sizeEndText = sizeEndText;	}
public final synchronized void setLimit(final int limit) {	    this.limit = limit;	}
@Override	public TimeZone getTimeZone() {	    return mTimeZone;	}
@Override	public String toString() {	    return String.valueOf(value);	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static UnicodeEscaper below(final int codepoint) {	    return outsideOf(codepoint, Integer.MAX_VALUE);	}
public static final String escapeXml(final String input) {	    return ESCAPE_XML.translate(input);	}
public static Date truncate(final Object date, final int field) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (date instanceof Date) {	        return truncate((Date) date, field);	    } else if (date instanceof Calendar) {	        return truncate((Calendar) date, field).getTime();	    } else {	        throw new ClassCastException("Could not truncate " + date);	    }	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
private static Date add(final Date date, final int calendarField, final int amount) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final Calendar c = Calendar.getInstance();	    c.setTime(date);	    c.add(calendarField, amount);	    return c.getTime();	}
@Override	public void setFormat(final int formatElementIndex, final Format newFormat) {	    throw new UnsupportedOperationException();	}
public synchronized boolean isShutdown() {	    return shutdown;	}
public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) {	    if (src.length > 8) {	        throw new IllegalArgumentException("src.length>8: src.length=" + src.length);	    }	    if (src.length - srcPos < 4) {	        throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos);	    }	    if (src[srcPos + 3]) {	        if (src[srcPos + 2]) {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return '7';	                }	            } else {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return '3';	                }	            }	        } else {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return '5';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '1';	                }	            }	        }	    } else {	        if (src[srcPos + 2]) {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'e';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return 'a';	                } else {	                    return '2';	                }	            }	        } else {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'c';	                } else {	                    return '4';	                }	            } else {	                if (src[srcPos]) {	                    return '8';	                } else {	                    return '0';	                }	            }	        }	    }	}
protected String getArraySeparator() {	    return arraySeparator;	}
public boolean isEmpty() {	    return size == 0;	}
public static boolean isNumeric(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isDigit(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final E... values) {	    asEnum(enumClass);	    Validate.noNullElements(values);	    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);	    Collections.addAll(condensed, values);	    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];	    for (final E value : condensed) {	        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);	    }	    ArrayUtils.reverse(result);	    return result;	}
public static int indexOfDifference(final CharSequence... css) {	    if (css == null || css.length <= 1) {	        return INDEX_NOT_FOUND;	    }	    boolean anyStringNull = false;	    boolean allStringsNull = true;	    final int arrayLen = css.length;	    int shortestStrLen = Integer.MAX_VALUE;	    int longestStrLen = 0;	    for (int i = 0; i < arrayLen; i++) {	        if (css[i] == null) {	            anyStringNull = true;	            shortestStrLen = 0;	        } else {	            allStringsNull = false;	            shortestStrLen = Math.min(css[i].length(), shortestStrLen);	            longestStrLen = Math.max(css[i].length(), longestStrLen);	        }	    }	    if (allStringsNull || longestStrLen == 0 && !anyStringNull) {	        return INDEX_NOT_FOUND;	    }	    if (shortestStrLen == 0) {	        return 0;	    }	    int firstDiff = -1;	    for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {	        final char comparisonChar = css[0].charAt(stringPos);	        for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {	            if (css[arrayPos].charAt(stringPos) != comparisonChar) {	                firstDiff = stringPos;	                break;	            }	        }	        if (firstDiff != -1) {	            break;	        }	    }	    if (firstDiff == -1 && shortestStrLen != longestStrLen) {	        return shortestStrLen;	    }	    return firstDiff;	}
public static boolean contains(final boolean[] array, final boolean valueToFind) {	    return indexOf(array, valueToFind) != INDEX_NOT_FOUND;	}
public String getNullText() {	    return nullText;	}
public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException {	    return parseDateWithLeniency(str, locale, parsePatterns, true);	}
public static String stripStart(final String str, final String stripChars) {	    int strLen;	    if (str == null || (strLen = str.length()) == 0) {	        return str;	    }	    int start = 0;	    if (stripChars == null) {	        while (start != strLen && Character.isWhitespace(str.charAt(start))) {	            start++;	        }	    } else if (stripChars.isEmpty()) {	        return str;	    } else {	        while (start != strLen && stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND) {	            start++;	        }	    }	    return str.substring(start);	}
public static short[] removeElement(final short[] array, final short element) {	    final int index = indexOf(array, element);	    if (index == INDEX_NOT_FOUND) {	        return clone(array);	    }	    return remove(array, index);	}
@Override	public int length() {	    return size;	}
public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) {	    if (cls == null) {	        throw new IllegalArgumentException("The class must not be null");	    }	    if (fieldName == null) {	        throw new IllegalArgumentException("The field name must not be null");	    }	    for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) {	        try {	            final Field field = acls.getDeclaredField(fieldName);	            if (!Modifier.isPublic(field.getModifiers())) {	                if (forceAccess) {	                    field.setAccessible(true);	                } else {	                    continue;	                }	            }	            return field;	        } catch (final NoSuchFieldException ex) {	        }	    }	    Field match = null;	    for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) {	        try {	            final Field test = ((Class<?>) class1).getField(fieldName);	            if (match != null) {	                throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + "; a matching field exists on two or more implemented interfaces.");	            }	            match = test;	        } catch (final NoSuchFieldException ex) {	        }	    }	    return match;	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
@Override	public long skip(long n) {	    if (pos + n > StrBuilder.this.size()) {	        n = StrBuilder.this.size() - pos;	    }	    if (n < 0) {	        return 0;	    }	    pos += n;	    return n;	}
public static <T> T CONST(final T v) {	    return v;	}
public String getNullText() {	    return nullText;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static boolean[] hexDigitToBinary(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return new boolean[] { false, false, false, false };	        case '1':	            return new boolean[] { true, false, false, false };	        case '2':	            return new boolean[] { false, true, false, false };	        case '3':	            return new boolean[] { true, true, false, false };	        case '4':	            return new boolean[] { false, false, true, false };	        case '5':	            return new boolean[] { true, false, true, false };	        case '6':	            return new boolean[] { false, true, true, false };	        case '7':	            return new boolean[] { true, true, true, false };	        case '8':	            return new boolean[] { false, false, false, true };	        case '9':	            return new boolean[] { true, false, false, true };	        case 'a':	        case 'A':	            return new boolean[] { false, true, false, true };	        case 'b':	        case 'B':	            return new boolean[] { true, true, false, true };	        case 'c':	        case 'C':	            return new boolean[] { false, false, true, true };	        case 'd':	        case 'D':	            return new boolean[] { true, false, true, true };	        case 'e':	        case 'E':	            return new boolean[] { false, true, true, true };	        case 'f':	        case 'F':	            return new boolean[] { true, true, true, true };	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public boolean isEmpty() {	    return size == 0;	}
public static String[] substringsBetween(final String str, final String open, final String close) {	    if (str == null || isEmpty(open) || isEmpty(close)) {	        return null;	    }	    final int strLen = str.length();	    if (strLen == 0) {	        return ArrayUtils.EMPTY_STRING_ARRAY;	    }	    final int closeLen = close.length();	    final int openLen = open.length();	    final List<String> list = new ArrayList<String>();	    int pos = 0;	    while (pos < strLen - closeLen) {	        int start = str.indexOf(open, pos);	        if (start < 0) {	            break;	        }	        start += openLen;	        final int end = str.indexOf(close, start);	        if (end < 0) {	            break;	        }	        list.add(str.substring(start, end));	        pos = end + closeLen;	    }	    if (list.isEmpty()) {	        return null;	    }	    return list.toArray(new String[list.size()]);	}
static void unregister(final Object lhs, final Object rhs) {	    Set<Pair<IDKey, IDKey>> registry = getRegistry();	    if (registry != null) {	        final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);	        registry.remove(pair);	        synchronized (EqualsBuilder.class) {	            registry = getRegistry();	            if (registry != null && registry.isEmpty()) {	                REGISTRY.remove();	            }	        }	    }	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
protected String getSizeEndText() {	    return sizeEndText;	}
public StrBuilder deleteFirst(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, 1);	}
@Override	public Float getValue() {	    return Float.valueOf(this.value);	}
@Override	public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) {	    return buffer[pos] <= 32 ? 1 : 0;	}
public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width, final int precision, final char padChar, final CharSequence ellipsis) {	    Validate.isTrue(ellipsis == null || precision < 0 || ellipsis.length() <= precision, "Specified ellipsis '%1$s' exceeds precision of %2$s", ellipsis, Integer.valueOf(precision));	    final StringBuilder buf = new StringBuilder(seq);	    if (precision >= 0 && precision < seq.length()) {	        final CharSequence _ellipsis = ObjectUtils.defaultIfNull(ellipsis, StringUtils.EMPTY);	        buf.replace(precision - _ellipsis.length(), seq.length(), _ellipsis.toString());	    }	    final boolean leftJustify = (flags & LEFT_JUSTIFY) == LEFT_JUSTIFY;	    for (int i = buf.length(); i < width; i++) {	        buf.insert(leftJustify ? i : 0, padChar);	    }	    formatter.format(buf.toString());	    return formatter;	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public static String appendIfMissingIgnoreCase(final String str, final CharSequence suffix, final CharSequence... suffixes) {	    return appendIfMissing(str, suffix, true, suffixes);	}
protected String getSummaryObjectEndText() {	    return summaryObjectEndText;	}
public static String prependIfMissing(final String str, final CharSequence prefix, final CharSequence... prefixes) {	    return prependIfMissing(str, prefix, false, prefixes);	}
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) {	    return new Range<T>(fromInclusive, toInclusive, comparator);	}
public static boolean isAsciiAlpha(final char ch) {	    return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) {	    if (bool == null) {	        return nullValue;	    }	    return bool.booleanValue() ? trueValue : falseValue;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static String substringBetween(final String str, final String open, final String close) {	    if (str == null || open == null || close == null) {	        return null;	    }	    final int start = str.indexOf(open);	    if (start != INDEX_NOT_FOUND) {	        final int end = str.indexOf(close, start + open.length());	        if (end != INDEX_NOT_FOUND) {	            return str.substring(start + open.length(), end);	        }	    }	    return null;	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
@Override	public double doubleValue() {	    return (double) numerator / (double) denominator;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static String right(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(str.length() - len);	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static CharRange isNotIn(final char start, final char end) {	    return new CharRange(start, end, true);	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
@Override	public void setUseShortClassName(final boolean useShortClassName) {	    super.setUseShortClassName(useShortClassName);	}
public boolean isEmpty() {	    return size == 0;	}
protected int getTaskCount() {	    return 1;	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return true;	    }	    if (lhs == null || rhs == null) {	        return false;	    }	    final Class<?> lhsClass = lhs.getClass();	    final Class<?> rhsClass = rhs.getClass();	    Class<?> testClass;	    if (lhsClass.isInstance(rhs)) {	        testClass = lhsClass;	        if (!rhsClass.isInstance(lhs)) {	            testClass = rhsClass;	        }	    } else if (rhsClass.isInstance(lhs)) {	        testClass = rhsClass;	        if (!lhsClass.isInstance(rhs)) {	            testClass = lhsClass;	        }	    } else {	        return false;	    }	    final EqualsBuilder equalsBuilder = new EqualsBuilder();	    try {	        reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {	            testClass = testClass.getSuperclass();	            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        }	    } catch (final IllegalArgumentException e) {	        return false;	    }	    return equalsBuilder.isEquals();	}
public static boolean isEquals(final Object array1, final Object array2) {	    return new EqualsBuilder().append(array1, array2).isEquals();	}
public static <T extends Serializable> T clone(final T object) {	    if (object == null) {	        return null;	    }	    final byte[] objectData = serialize(object);	    final ByteArrayInputStream bais = new ByteArrayInputStream(objectData);	    ClassLoaderAwareObjectInputStream in = null;	    try {	        in = new ClassLoaderAwareObjectInputStream(bais, object.getClass().getClassLoader());	        @SuppressWarnings("unchecked")	        final T readObject = (T) in.readObject();	        return readObject;	    } catch (final ClassNotFoundException ex) {	        throw new SerializationException("ClassNotFoundException while reading cloned object data", ex);	    } catch (final IOException ex) {	        throw new SerializationException("IOException while reading cloned object data", ex);	    } finally {	        try {	            if (in != null) {	                in.close();	            }	        } catch (final IOException ex) {	            throw new SerializationException("IOException on closing cloned object data InputStream.", ex);	        }	    }	}
public boolean isEmpty() {	    return size == 0;	}
public static boolean isPrimitiveOrWrapper(final Class<?> type) {	    if (type == null) {	        return false;	    }	    return type.isPrimitive() || isPrimitiveWrapper(type);	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
@Override	public TimeZone getTimeZone() {	    return timeZone;	}
public static boolean isAsciiPrintable(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public final synchronized ExecutorService getExternalExecutor() {	    return externalExecutor;	}
public boolean isEmpty() {	    return size == 0;	}
public StrTokenizer setIgnoredMatcher(final StrMatcher ignored) {	    if (ignored != null) {	        this.ignoredMatcher = ignored;	    }	    return this;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static String delete(final String str, final String... set) {	    if (StringUtils.isEmpty(str) || deepEmpty(set)) {	        return str;	    }	    return modify(str, set, false);	}
@Override	public int hashCode() {	    return toHashCode();	}
public static float max(final float a, final float b) {	    if (Float.isNaN(a)) {	        return b;	    } else if (Float.isNaN(b)) {	        return a;	    } else {	        return Math.max(a, b);	    }	}
public static short[] removeElement(final short[] array, final short element) {	    final int index = indexOf(array, element);	    if (index == INDEX_NOT_FOUND) {	        return clone(array);	    }	    return remove(array, index);	}
public static <L, R> ImmutablePair<L, R> of(final L left, final R right) {	    return new ImmutablePair<L, R>(left, right);	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
@Override	public boolean ready() {	    return pos < StrBuilder.this.size();	}
public static Object invokeExactMethod(final Object object, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {	    if (args == null) {	        args = ArrayUtils.EMPTY_OBJECT_ARRAY;	    }	    if (parameterTypes == null) {	        parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;	    }	    final Method method = getAccessibleMethod(object.getClass(), methodName, parameterTypes);	    if (method == null) {	        throw new NoSuchMethodException("No such accessible method: " + methodName + "() on object: " + object.getClass().getName());	    }	    return method.invoke(object, args);	}
public static <T> Range<T> is(final T element, final Comparator<T> comparator) {	    return between(element, element, comparator);	}
@Override	public StringBuffer format(final Calendar calendar, final StringBuffer buf) {	    return applyRules(calendar, buf);	}
private static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal, final boolean lastIndex) {	    if (str == null || searchStr == null || ordinal <= 0) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return lastIndex ? str.length() : 0;	    }	    int found = 0;	    int index = lastIndex ? str.length() : INDEX_NOT_FOUND;	    do {	        if (lastIndex) {	            index = CharSequenceUtils.lastIndexOf(str, searchStr, index - 1);	        } else {	            index = CharSequenceUtils.indexOf(str, searchStr, index + 1);	        }	        if (index < 0) {	            return index;	        }	        found++;	    } while (found < ordinal);	    return index;	}
public static float max(final float a, final float b, final float c) {	    return Math.max(Math.max(a, b), c);	}
protected String getContentEnd() {	    return contentEnd;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public static String wrap(final String str, int wrapLength, String newLineStr, final boolean wrapLongWords) {	    if (str == null) {	        return null;	    }	    if (newLineStr == null) {	        newLineStr = SystemUtils.LINE_SEPARATOR;	    }	    if (wrapLength < 1) {	        wrapLength = 1;	    }	    final int inputLineLength = str.length();	    int offset = 0;	    final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32);	    while (inputLineLength - offset > wrapLength) {	        if (str.charAt(offset) == ' ') {	            offset++;	            continue;	        }	        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);	        if (spaceToWrapAt >= offset) {	            wrappedLine.append(str.substring(offset, spaceToWrapAt));	            wrappedLine.append(newLineStr);	            offset = spaceToWrapAt + 1;	        } else {	            if (wrapLongWords) {	                wrappedLine.append(str.substring(offset, wrapLength + offset));	                wrappedLine.append(newLineStr);	                offset += wrapLength;	            } else {	                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);	                if (spaceToWrapAt >= 0) {	                    wrappedLine.append(str.substring(offset, spaceToWrapAt));	                    wrappedLine.append(newLineStr);	                    offset = spaceToWrapAt + 1;	                } else {	                    wrappedLine.append(str.substring(offset));	                    offset = inputLineLength;	                }	            }	        }	    }	    wrappedLine.append(str.substring(offset));	    return wrappedLine.toString();	}
public static boolean isEmpty(final CharSequence cs) {	    return cs == null || cs.length() == 0;	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
public String getNewLineText() {	    return newLine;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static char intToHexDigit(final int nibble) {	    final char c = Character.forDigit(nibble, 16);	    if (c == Character.MIN_VALUE) {	        throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble);	    }	    return c;	}
public boolean isAppendTransients() {	    return this.appendTransients;	}
public static String stripEnd(final String str, final String stripChars) {	    int end;	    if (str == null || (end = str.length()) == 0) {	        return str;	    }	    if (stripChars == null) {	        while (end != 0 && Character.isWhitespace(str.charAt(end - 1))) {	            end--;	        }	    } else if (stripChars.isEmpty()) {	        return str;	    } else {	        while (end != 0 && stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND) {	            end--;	        }	    }	    return str.substring(0, end);	}
private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase) {	    if (str == null || prefix == null) {	        return str == null && prefix == null;	    }	    if (prefix.length() > str.length()) {	        return false;	    }	    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static String capitalize(final String str) {	    int strLen;	    if (str == null || (strLen = str.length()) == 0) {	        return str;	    }	    char firstChar = str.charAt(0);	    if (Character.isTitleCase(firstChar)) {	        return str;	    }	    return new StringBuilder(strLen).append(Character.toTitleCase(firstChar)).append(str.substring(1)).toString();	}
public static String getMessage(final Throwable th) {	    if (th == null) {	        return "";	    }	    final String clsName = ClassUtils.getShortClassName(th, null);	    final String msg = th.getMessage();	    return clsName + ": " + StringUtils.defaultString(msg);	}
public static String rightPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return rightPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return str.concat(padStr);	    } else if (pads < padLen) {	        return str.concat(padStr.substring(0, pads));	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return str.concat(new String(padding));	    }	}
public final synchronized void setExternalExecutor(final ExecutorService externalExecutor) {	    if (isStarted()) {	        throw new IllegalStateException("Cannot set ExecutorService after start()!");	    }	    this.externalExecutor = externalExecutor;	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
public static String capitalize(final String str, final char... delimiters) {	    final int delimLen = delimiters == null ? -1 : delimiters.length;	    if (StringUtils.isEmpty(str) || delimLen == 0) {	        return str;	    }	    final char[] buffer = str.toCharArray();	    boolean capitalizeNext = true;	    for (int i = 0; i < buffer.length; i++) {	        final char ch = buffer[i];	        if (isDelimiter(ch, delimiters)) {	            capitalizeNext = true;	        } else if (capitalizeNext) {	            buffer[i] = Character.toTitleCase(ch);	            capitalizeNext = false;	        }	    }	    return new String(buffer);	}
public static final String escapeJson(final String input) {	    return ESCAPE_JSON.translate(input);	}
public static String[][] BASIC_UNESCAPE() {	    return BASIC_UNESCAPE.clone();	}
void increment() {	    count++;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public boolean isIgnoreEmptyTokens() {	    return ignoreEmptyTokens;	}
@Override	public Integer build() {	    return Integer.valueOf(toHashCode());	}
public static char toChar(final String str, final char defaultValue) {	    if (StringUtils.isEmpty(str)) {	        return defaultValue;	    }	    return str.charAt(0);	}
public static boolean isAlphanumeric(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetterOrDigit(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static String stripStart(final String str, final String stripChars) {	    int strLen;	    if (str == null || (strLen = str.length()) == 0) {	        return str;	    }	    int start = 0;	    if (stripChars == null) {	        while (start != strLen && Character.isWhitespace(str.charAt(start))) {	            start++;	        }	    } else if (stripChars.isEmpty()) {	        return str;	    } else {	        while (start != strLen && stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND) {	            start++;	        }	    }	    return str.substring(start);	}
public static double toDouble(final String str, final double defaultValue) {	    if (str == null) {	        return defaultValue;	    }	    try {	        return Double.parseDouble(str);	    } catch (final NumberFormatException nfe) {	        return defaultValue;	    }	}
public int capacity() {	    return buffer.length;	}
public int indexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex < 0 ? 0 : startIndex);	    if (matcher == null || startIndex >= size) {	        return -1;	    }	    final int len = size;	    final char[] buf = buffer;	    for (int i = startIndex; i < len; i++) {	        if (matcher.isMatch(buf, i, startIndex, len) > 0) {	            return i;	        }	    }	    return -1;	}
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) {	    final StringBuilder buffer = new StringBuilder();	    boolean lastOutputSeconds = false;	    final int sz = tokens.length;	    for (int i = 0; i < sz; i++) {	        final Token token = tokens[i];	        final Object value = token.getValue();	        final int count = token.getCount();	        if (value instanceof StringBuilder) {	            buffer.append(value.toString());	        } else {	            if (value == y) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years));	                lastOutputSeconds = false;	            } else if (value == M) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months));	                lastOutputSeconds = false;	            } else if (value == d) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days));	                lastOutputSeconds = false;	            } else if (value == H) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours));	                lastOutputSeconds = false;	            } else if (value == m) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes));	                lastOutputSeconds = false;	            } else if (value == s) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds));	                lastOutputSeconds = true;	            } else if (value == S) {	                if (lastOutputSeconds) {	                    milliseconds += 1000;	                    final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds);	                    buffer.append(str.substring(1));	                } else {	                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds));	                }	                lastOutputSeconds = false;	            }	        }	    }	    return buffer.toString();	}
public char getStart() {	    return this.start;	}
public StrSubstitutor setVariableSuffix(final String suffix) {	    if (suffix == null) {	        throw new IllegalArgumentException("Variable suffix must not be null!");	    }	    return setVariableSuffixMatcher(StrMatcher.stringMatcher(suffix));	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
public int capacity() {	    return buffer.length;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public boolean containsRange(final Range<T> otherRange) {	    if (otherRange == null) {	        return false;	    }	    return contains(otherRange.minimum) && contains(otherRange.maximum);	}
public static boolean isAlpha(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) {	    if (str == null) {	        if (trueString == null) {	            return Boolean.TRUE;	        }	        if (falseString == null) {	            return Boolean.FALSE;	        }	        if (nullString == null) {	            return null;	        }	    } else if (str.equals(trueString)) {	        return Boolean.TRUE;	    } else if (str.equals(falseString)) {	        return Boolean.FALSE;	    } else if (str.equals(nullString)) {	        return null;	    }	    throw new IllegalArgumentException("The String did not match any specified value");	}
public static boolean isAllLowerCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLowerCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
protected boolean isUseClassName() {	    return useClassName;	}
@Override	public int previousIndex() {	    return tokenPos - 1;	}
public static String capitalize(final String str, final char... delimiters) {	    final int delimLen = delimiters == null ? -1 : delimiters.length;	    if (StringUtils.isEmpty(str) || delimLen == 0) {	        return str;	    }	    final char[] buffer = str.toCharArray();	    boolean capitalizeNext = true;	    for (int i = 0; i < buffer.length; i++) {	        final char ch = buffer[i];	        if (isDelimiter(ch, delimiters)) {	            capitalizeNext = true;	        } else if (capitalizeNext) {	            buffer[i] = Character.toTitleCase(ch);	            capitalizeNext = false;	        }	    }	    return new String(buffer);	}
public String getNullText() {	    return nullText;	}
protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size) {	    buffer.append(sizeStartText);	    buffer.append(size);	    buffer.append(sizeEndText);	}
@Override	public double doubleValue() {	    return (double) numerator / (double) denominator;	}
public static boolean isNumeric(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isDigit(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
@Override	public StringBuffer format(final Calendar calendar, final StringBuffer buf) {	    return applyRules(calendar, buf);	}
public static String upperCase(final String str, final Locale locale) {	    if (str == null) {	        return null;	    }	    return str.toUpperCase(locale);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public StrBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar) {	    return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);	}
public static String repeat(final char ch, final int repeat) {	    final char[] buf = new char[repeat];	    for (int i = repeat - 1; i >= 0; i--) {	        buf[i] = ch;	    }	    return new String(buf);	}
@Override	public String next() {	    if (hasNext()) {	        return tokens[tokenPos++];	    }	    throw new NoSuchElementException();	}
@Override	public int hashCode() {	    return toHashCode();	}
public static String repeat(final char ch, final int repeat) {	    final char[] buf = new char[repeat];	    for (int i = repeat - 1; i >= 0; i--) {	        buf[i] = ch;	    }	    return new String(buf);	}
public static String abbreviateMiddle(final String str, final String middle, final int length) {	    if (isEmpty(str) || isEmpty(middle)) {	        return str;	    }	    if (length >= str.length() || length < middle.length() + 2) {	        return str;	    }	    final int targetSting = length - middle.length();	    final int startOffset = targetSting / 2 + targetSting % 2;	    final int endOffset = str.length() - targetSting / 2;	    final StringBuilder builder = new StringBuilder(length);	    builder.append(str.substring(0, startOffset));	    builder.append(middle);	    builder.append(str.substring(endOffset));	    return builder.toString();	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static final String escapeEcmaScript(final String input) {	    return ESCAPE_ECMASCRIPT.translate(input);	}
public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {	    if (str == null || searchStr == null) {	        return INDEX_NOT_FOUND;	    }	    if (startPos > str.length() - searchStr.length()) {	        startPos = str.length() - searchStr.length();	    }	    if (startPos < 0) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return startPos;	    }	    for (int i = startPos; i >= 0; i--) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) {	    if (it != null) {	        separator = ObjectUtils.toString(separator);	        while (it.hasNext()) {	            append(it.next());	            if (it.hasNext()) {	                append(separator);	            }	        }	    }	    return this;	}
static Set<Pair<IDKey, IDKey>> getRegistry() {	    return REGISTRY.get();	}
public Fraction divideBy(final Fraction fraction) {	    if (fraction == null) {	        throw new IllegalArgumentException("The fraction must not be null");	    }	    if (fraction.numerator == 0) {	        throw new ArithmeticException("The fraction to divide by must not be zero");	    }	    return multiplyBy(fraction.invert());	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public static boolean isPrimitiveOrWrapper(final Class<?> type) {	    if (type == null) {	        return false;	    }	    return type.isPrimitive() || isPrimitiveWrapper(type);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
static Set<Pair<IDKey, IDKey>> getRegistry() {	    return REGISTRY.get();	}
public static Float createFloat(final String str) {	    if (str == null) {	        return null;	    }	    return Float.valueOf(str);	}
@Override	public void setValue(final Number value) {	    this.value = value.byteValue();	}
public static String removeEnd(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.endsWith(remove)) {	        return str.substring(0, str.length() - remove.length());	    }	    return str;	}
protected String getContentEnd() {	    return contentEnd;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
@Override	public void setSizeEndText(final String sizeEndText) {	    super.setSizeEndText(sizeEndText);	}
public static <T extends CharSequence> T validIndex(final T chars, final int index) {	    return validIndex(chars, index, DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE, Integer.valueOf(index));	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public boolean isAppendTransients() {	    return this.appendTransients;	}
@Override	public BasicThreadFactory build() {	    final BasicThreadFactory factory = new BasicThreadFactory(this);	    reset();	    return factory;	}
public static <T extends Serializable> T clone(final T object) {	    if (object == null) {	        return null;	    }	    final byte[] objectData = serialize(object);	    final ByteArrayInputStream bais = new ByteArrayInputStream(objectData);	    ClassLoaderAwareObjectInputStream in = null;	    try {	        in = new ClassLoaderAwareObjectInputStream(bais, object.getClass().getClassLoader());	        @SuppressWarnings("unchecked")	        final T readObject = (T) in.readObject();	        return readObject;	    } catch (final ClassNotFoundException ex) {	        throw new SerializationException("ClassNotFoundException while reading cloned object data", ex);	    } catch (final IOException ex) {	        throw new SerializationException("IOException while reading cloned object data", ex);	    } finally {	        try {	            if (in != null) {	                in.close();	            }	        } catch (final IOException ex) {	            throw new SerializationException("IOException on closing cloned object data InputStream.", ex);	        }	    }	}
protected String getArrayEnd() {	    return arrayEnd;	}
protected boolean isUseFieldNames() {	    return useFieldNames;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static String leftPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return leftPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return padStr.concat(str);	    } else if (pads < padLen) {	        return padStr.substring(0, pads).concat(str);	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return new String(padding).concat(str);	    }	}
public int size() {	    return size;	}
public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) {	    if (array == null) {	        return null;	    }	    if (startIndexInclusive < 0) {	        startIndexInclusive = 0;	    }	    if (endIndexExclusive > array.length) {	        endIndexExclusive = array.length;	    }	    final int newSize = endIndexExclusive - startIndexInclusive;	    if (newSize <= 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] subarray = new boolean[newSize];	    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);	    return subarray;	}
public static <T extends CharSequence> T notBlank(final T chars) {	    return notBlank(chars, DEFAULT_NOT_BLANK_EX_MESSAGE);	}
public static String formatUTC(final Date date, final String pattern, final Locale locale) {	    return format(date, pattern, UTC_TIME_ZONE, locale);	}
protected String getNullText() {	    return nullText;	}
public int size() {	    return size;	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
protected boolean isDefaultFullDetail() {	    return defaultFullDetail;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
@Override	public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) {	    return formatter.format(obj, toAppendTo, pos);	}
static boolean containsTokenWithValue(final Token[] tokens, final Object value) {	    final int sz = tokens.length;	    for (int i = 0; i < sz; i++) {	        if (tokens[i].getValue() == value) {	            return true;	        }	    }	    return false;	}
protected boolean isUseShortClassName() {	    return useShortClassName;	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public static String uncapitalize(final String str, final char... delimiters) {	    final int delimLen = delimiters == null ? -1 : delimiters.length;	    if (StringUtils.isEmpty(str) || delimLen == 0) {	        return str;	    }	    final char[] buffer = str.toCharArray();	    boolean uncapitalizeNext = true;	    for (int i = 0; i < buffer.length; i++) {	        final char ch = buffer[i];	        if (isDelimiter(ch, delimiters)) {	            uncapitalizeNext = true;	        } else if (uncapitalizeNext) {	            buffer[i] = Character.toLowerCase(ch);	            uncapitalizeNext = false;	        }	    }	    return new String(buffer);	}
public static Type[] getImplicitUpperBounds(final WildcardType wildcardType) {	    final Type[] bounds = wildcardType.getUpperBounds();	    return bounds.length == 0 ? new Type[] { Object.class } : normalizeUpperBounds(bounds);	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
protected void setArrayStart(String arrayStart) {	    if (arrayStart == null) {	        arrayStart = "";	    }	    this.arrayStart = arrayStart;	}
@Override	protected List<String> tokenize(final char[] chars, final int offset, final int count) {	    if (chars == null) {	        return super.tokenize(StrBuilder.this.buffer, 0, StrBuilder.this.size());	    }	    return super.tokenize(chars, offset, count);	}
public int capacity() {	    return buffer.length;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public HashCodeBuilder append(final short[] array) {	    if (array == null) {	        iTotal = iTotal * iConstant;	    } else {	        for (final short element : array) {	            append(element);	        }	    }	    return this;	}
public T getMinimum() {	    return minimum;	}
public CompareToBuilder appendSuper(final int superCompareTo) {	    if (comparison != 0) {	        return this;	    }	    comparison = superCompareTo;	    return this;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
@Override	public void mark(final int readAheadLimit) {	    mark = pos;	}
protected String getArraySeparator() {	    return arraySeparator;	}
public short setShortValue(final short holder, final short value) {	    return (short) setValue(holder, value);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public Byte toByte() {	    return Byte.valueOf(byteValue());	}
public static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes) {	    if ((src.length == 0 && srcPos == 0) || 0 == nBytes) {	        return dstInit;	    }	    if ((nBytes - 1) * 8 + dstPos >= 64) {	        throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 64");	    }	    long out = dstInit;	    int shift = 0;	    for (int i = 0; i < nBytes; i++) {	        shift = i * 8 + dstPos;	        final long bits = (0xffL & src[i + srcPos]) << shift;	        final long mask = 0xffL << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
private static long getFragment(final Calendar calendar, final int fragment, final int unit) {	    if (calendar == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final long millisPerUnit = getMillisPerUnit(unit);	    long result = 0;	    switch(fragment) {	        case Calendar.YEAR:	            result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit;	            break;	        case Calendar.MONTH:	            result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit;	            break;	    }	    switch(fragment) {	        case Calendar.YEAR:	        case Calendar.MONTH:	        case Calendar.DAY_OF_YEAR:	        case Calendar.DATE:	            result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit;	        case Calendar.HOUR_OF_DAY:	            result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit;	        case Calendar.MINUTE:	            result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit;	        case Calendar.SECOND:	            result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit;	            break;	        case Calendar.MILLISECOND:	            break;	        default:	            throw new IllegalArgumentException("The fragment " + fragment + " is not supported");	    }	    return result;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static String stripEnd(final String str, final String stripChars) {	    int end;	    if (str == null || (end = str.length()) == 0) {	        return str;	    }	    if (stripChars == null) {	        while (end != 0 && Character.isWhitespace(str.charAt(end - 1))) {	            end--;	        }	    } else if (stripChars.isEmpty()) {	        return str;	    } else {	        while (end != 0 && stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND) {	            end--;	        }	    }	    return str.substring(0, end);	}
public boolean isEmpty() {	    return size == 0;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static boolean isAscii(final char ch) {	    return ch < 128;	}
public boolean isIgnoreEmptyTokens() {	    return ignoreEmptyTokens;	}
public static Field[] getAllFields(Class<?> cls) {	    final List<Field> allFieldsList = getAllFieldsList(cls);	    return allFieldsList.toArray(new Field[allFieldsList.size()]);	}
@Override	public void add(final String obj) {	    throw new UnsupportedOperationException("add() is unsupported");	}
public StrBuilder deleteAll(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, -1);	}
public static <T extends CharSequence> T validIndex(final T chars, final int index) {	    return validIndex(chars, index, DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE, Integer.valueOf(index));	}
public static <T> T median(final Comparator<T> comparator, final T... items) {	    Validate.notEmpty(items, "null/empty items");	    Validate.noNullElements(items);	    Validate.notNull(comparator, "null comparator");	    final TreeSet<T> sort = new TreeSet<T>(comparator);	    Collections.addAll(sort, items);	    @SuppressWarnings("unchecked")	    final T result = (T) sort.toArray()[(sort.size() - 1) / 2];	    return result;	}
public boolean contains(final CharRange range) {	    if (range == null) {	        throw new IllegalArgumentException("The Range must not be null");	    }	    if (negated) {	        if (range.negated) {	            return start >= range.start && end <= range.end;	        }	        return range.end < start || range.start > end;	    }	    if (range.negated) {	        return start == 0 && end == Character.MAX_VALUE;	    }	    return start <= range.start && end >= range.end;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static String formatDurationHMS(final long durationMillis) {	    return formatDuration(durationMillis, "H:mm:ss.SSS");	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
protected boolean isFieldSeparatorAtStart() {	    return fieldSeparatorAtStart;	}
public final Boolean getDaemonFlag() {	    return daemonFlag;	}
public static String formatDuration(long durationMillis, final String format, final boolean padWithZeros) {	    final Token[] tokens = lexx(format);	    int days = 0;	    int hours = 0;	    int minutes = 0;	    int seconds = 0;	    int milliseconds = 0;	    if (Token.containsTokenWithValue(tokens, d)) {	        days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY);	        durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY);	    }	    if (Token.containsTokenWithValue(tokens, H)) {	        hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR);	        durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR);	    }	    if (Token.containsTokenWithValue(tokens, m)) {	        minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE);	        durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE);	    }	    if (Token.containsTokenWithValue(tokens, s)) {	        seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND);	        durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND);	    }	    if (Token.containsTokenWithValue(tokens, S)) {	        milliseconds = (int) durationMillis;	    }	    return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
public static Locale toLocale(final String str) {	    if (str == null) {	        return null;	    }	    if (str.contains("#")) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final int len = str.length();	    if (len < 2) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final char ch0 = str.charAt(0);	    if (ch0 == '_') {	        if (len < 3) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        final char ch1 = str.charAt(1);	        final char ch2 = str.charAt(2);	        if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        if (len == 3) {	            return new Locale("", str.substring(1, 3));	        }	        if (len < 5) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        if (str.charAt(3) != '_') {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        return new Locale("", str.substring(1, 3), str.substring(4));	    }	    final char ch1 = str.charAt(1);	    if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (len == 2) {	        return new Locale(str);	    }	    if (len < 5) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (str.charAt(2) != '_') {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final char ch3 = str.charAt(3);	    if (ch3 == '_') {	        return new Locale(str.substring(0, 2), "", str.substring(4));	    }	    final char ch4 = str.charAt(4);	    if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (len == 5) {	        return new Locale(str.substring(0, 2), str.substring(3, 5));	    }	    if (len < 7) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (str.charAt(5) != '_') {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));	}
public boolean isEmpty() {	    return size == 0;	}
public static boolean containsOnly(final CharSequence cs, final String validChars) {	    if (cs == null || validChars == null) {	        return false;	    }	    return containsOnly(cs, validChars.toCharArray());	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
@Override	public Integer build() {	    return Integer.valueOf(toHashCode());	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException {	    return charsetName == null ? new String(bytes) : new String(bytes, charsetName);	}
public static String removeStart(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.startsWith(remove)) {	        return str.substring(remove.length());	    }	    return str;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public static String replaceChars(final String str, final String searchChars, String replaceChars) {	    if (isEmpty(str) || isEmpty(searchChars)) {	        return str;	    }	    if (replaceChars == null) {	        replaceChars = EMPTY;	    }	    boolean modified = false;	    final int replaceCharsLength = replaceChars.length();	    final int strLength = str.length();	    final StringBuilder buf = new StringBuilder(strLength);	    for (int i = 0; i < strLength; i++) {	        final char ch = str.charAt(i);	        final int index = searchChars.indexOf(ch);	        if (index >= 0) {	            modified = true;	            if (index < replaceCharsLength) {	                buf.append(replaceChars.charAt(index));	            }	        } else {	            buf.append(ch);	        }	    }	    if (modified) {	        return buf.toString();	    }	    return str;	}
public static String random(final int count, final char... chars) {	    if (chars == null) {	        return random(count, 0, 0, false, false, null, RANDOM);	    }	    return random(count, 0, chars.length, false, false, chars, RANDOM);	}
protected ScheduledFuture<?> startTimer() {	    return getExecutorService().scheduleAtFixedRate(new Runnable() {		        @Override	        public void run() {	            endOfPeriod();	        }	    }, getPeriod(), getPeriod(), getUnit());	}
public static String stripToNull(String str) {	    if (str == null) {	        return null;	    }	    str = strip(str, null);	    return str.isEmpty() ? null : str;	}
public static boolean contains(final boolean[] array, final boolean valueToFind) {	    return indexOf(array, valueToFind) != INDEX_NOT_FOUND;	}
public static String randomAlphabetic(final int count) {	    return random(count, true, false);	}
public boolean isNegated() {	    return negated;	}
public static int lastIndexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = INDEX_NOT_FOUND;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.lastIndexOf(str, search, str.length());	        if (tmp > ret) {	            ret = tmp;	        }	    }	    return ret;	}
public static boolean isBlank(final CharSequence cs) {	    int strLen;	    if (cs == null || (strLen = cs.length()) == 0) {	        return true;	    }	    for (int i = 0; i < strLen; i++) {	        if (Character.isWhitespace(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public String getNullText() {	    return nullText;	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public Fraction pow(final int power) {	    if (power == 1) {	        return this;	    } else if (power == 0) {	        return ONE;	    } else if (power < 0) {	        if (power == Integer.MIN_VALUE) {	            return this.invert().pow(2).pow(-(power / 2));	        }	        return this.invert().pow(-power);	    } else {	        final Fraction f = this.multiplyBy(this);	        if (power % 2 == 0) {	            return f.pow(power / 2);	        } else {	            return f.pow(power / 2).multiplyBy(this);	        }	    }	}
@Override	public int length() {	    return size;	}
public boolean isEmpty() {	    return size == 0;	}
public boolean isAppendStatics() {	    return this.appendStatics;	}
public static Date truncate(final Object date, final int field) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (date instanceof Date) {	        return truncate((Date) date, field);	    } else if (date instanceof Calendar) {	        return truncate((Calendar) date, field).getTime();	    } else {	        throw new ClassCastException("Could not truncate " + date);	    }	}
private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase) {	    if (str == null || prefix == null) {	        return str == null && prefix == null;	    }	    if (prefix.length() > str.length()) {	        return false;	    }	    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static <T> T notNull(final T object, final String message, final Object... values) {	    if (object == null) {	        throw new NullPointerException(String.format(message, values));	    }	    return object;	}
public boolean isEmptyTokenAsNull() {	    return this.emptyAsNull;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) {	    String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'");	    if (suppressLeadingZeroElements) {	        duration = " " + duration;	        String tmp = StringUtils.replaceOnce(duration, " 0 days", "");	        if (tmp.length() != duration.length()) {	            duration = tmp;	            tmp = StringUtils.replaceOnce(duration, " 0 hours", "");	            if (tmp.length() != duration.length()) {	                duration = tmp;	                tmp = StringUtils.replaceOnce(duration, " 0 minutes", "");	                duration = tmp;	                if (tmp.length() != duration.length()) {	                    duration = StringUtils.replaceOnce(tmp, " 0 seconds", "");	                }	            }	        }	        if (duration.length() != 0) {	            duration = duration.substring(1);	        }	    }	    if (suppressTrailingZeroElements) {	        String tmp = StringUtils.replaceOnce(duration, " 0 seconds", "");	        if (tmp.length() != duration.length()) {	            duration = tmp;	            tmp = StringUtils.replaceOnce(duration, " 0 minutes", "");	            if (tmp.length() != duration.length()) {	                duration = tmp;	                tmp = StringUtils.replaceOnce(duration, " 0 hours", "");	                if (tmp.length() != duration.length()) {	                    duration = StringUtils.replaceOnce(tmp, " 0 days", "");	                }	            }	        }	    }	    duration = " " + duration;	    duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second");	    duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute");	    duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour");	    duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day");	    return duration.trim();	}
@Override	public int read(final char[] b, final int off, int len) {	    if (off < 0 || len < 0 || off > b.length || (off + len) > b.length || (off + len) < 0) {	        throw new IndexOutOfBoundsException();	    }	    if (len == 0) {	        return 0;	    }	    if (pos >= StrBuilder.this.size()) {	        return -1;	    }	    if (pos + len > size()) {	        len = StrBuilder.this.size() - pos;	    }	    StrBuilder.this.getChars(pos, pos + len, b, off);	    pos += len;	    return len;	}
@Override	public StringBuffer format(final Calendar calendar, final StringBuffer buf) {	    return applyRules(calendar, buf);	}
public int capacity() {	    return buffer.length;	}
@Override	public int length() {	    return size;	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public int capacity() {	    return buffer.length;	}
public int size() {	    return size;	}
public static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex) {	    if (0 == nHex) {	        return dstInit;	    }	    if ((nHex - 1) * 4 + dstPos >= 8) {	        throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 8");	    }	    byte out = dstInit;	    int shift = 0;	    for (int i = 0; i < nHex; i++) {	        shift = i * 4 + dstPos;	        final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift;	        final int mask = 0xf << shift;	        out = (byte) ((out & ~mask) | bits);	    }	    return out;	}
public static boolean[] removeElements(final boolean[] array, final boolean... values) {	    if (isEmpty(array) || isEmpty(values)) {	        return clone(array);	    }	    final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2);	    for (final boolean v : values) {	        final Boolean boxed = Boolean.valueOf(v);	        final MutableInt count = occurrences.get(boxed);	        if (count == null) {	            occurrences.put(boxed, new MutableInt(1));	        } else {	            count.increment();	        }	    }	    final BitSet toRemove = new BitSet();	    for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) {	        final Boolean v = e.getKey();	        int found = 0;	        for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {	            found = indexOf(array, v.booleanValue(), found);	            if (found < 0) {	                break;	            }	            toRemove.set(found++);	        }	    }	    return (boolean[]) removeAll(array, toRemove);	}
public StrTokenizer setTrimmerMatcher(final StrMatcher trimmer) {	    if (trimmer != null) {	        this.trimmerMatcher = trimmer;	    }	    return this;	}
public int size() {	    return size;	}
protected void setArrayStart(String arrayStart) {	    if (arrayStart == null) {	        arrayStart = "";	    }	    this.arrayStart = arrayStart;	}
public int capacity() {	    return buffer.length;	}
public static String substringBetween(final String str, final String open, final String close) {	    if (str == null || open == null || close == null) {	        return null;	    }	    final int start = str.indexOf(open);	    if (start != INDEX_NOT_FOUND) {	        final int end = str.indexOf(close, start + open.length());	        if (end != INDEX_NOT_FOUND) {	            return str.substring(start + open.length(), end);	        }	    }	    return null;	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static String leftPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return leftPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return padStr.concat(str);	    } else if (pads < padLen) {	        return padStr.substring(0, pads).concat(str);	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return new String(padding).concat(str);	    }	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) {	    if (it != null) {	        separator = ObjectUtils.toString(separator);	        while (it.hasNext()) {	            append(it.next());	            if (it.hasNext()) {	                append(separator);	            }	        }	    }	    return this;	}
@Override	public int length() {	    return size;	}
protected boolean isDefaultFullDetail() {	    return defaultFullDetail;	}
public static String prependIfMissing(final String str, final CharSequence prefix, final CharSequence... prefixes) {	    return prependIfMissing(str, prefix, false, prefixes);	}
public String getNewLineText() {	    return newLine;	}
public String getNullText() {	    return nullText;	}
public int indexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex < 0 ? 0 : startIndex);	    if (matcher == null || startIndex >= size) {	        return -1;	    }	    final int len = size;	    final char[] buf = buffer;	    for (int i = startIndex; i < len; i++) {	        if (matcher.isMatch(buf, i, startIndex, len) > 0) {	            return i;	        }	    }	    return -1;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static char binaryToHexDigit(final boolean[] src, final int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    if (src.length > srcPos + 3 && src[srcPos + 3]) {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src[srcPos]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
private static Date add(final Date date, final int calendarField, final int amount) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final Calendar c = Calendar.getInstance();	    c.setTime(date);	    c.add(calendarField, amount);	    return c.getTime();	}
public static <T> String reflectionToString(final T object, final ToStringStyle style, final boolean outputTransients, final Class<? super T> reflectUpToClass) {	    return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass);	}
public static <T extends CharSequence> T defaultIfEmpty(final T str, final T defaultStr) {	    return StringUtils.isEmpty(str) ? defaultStr : str;	}
public HashCodeBuilder append(final short[] array) {	    if (array == null) {	        iTotal = iTotal * iConstant;	    } else {	        for (final short element : array) {	            append(element);	        }	    }	    return this;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public static CharRange isNotIn(final char start, final char end) {	    return new CharRange(start, end, true);	}
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) {	    if (str == null) {	        if (trueString == null) {	            return Boolean.TRUE;	        }	        if (falseString == null) {	            return Boolean.FALSE;	        }	        if (nullString == null) {	            return null;	        }	    } else if (str.equals(trueString)) {	        return Boolean.TRUE;	    } else if (str.equals(falseString)) {	        return Boolean.FALSE;	    } else if (str.equals(nullString)) {	        return null;	    }	    throw new IllegalArgumentException("The String did not match any specified value");	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static double[] addAll(final double[] array1, final double... array2) {	    if (array1 == null) {	        return clone(array2);	    } else if (array2 == null) {	        return clone(array1);	    }	    final double[] joinedArray = new double[array1.length + array2.length];	    System.arraycopy(array1, 0, joinedArray, 0, array1.length);	    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);	    return joinedArray;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public final void translate(final CharSequence input, final Writer out) throws IOException {	    if (out == null) {	        throw new IllegalArgumentException("The Writer must not be null");	    }	    if (input == null) {	        return;	    }	    int pos = 0;	    final int len = input.length();	    while (pos < len) {	        final int consumed = translate(input, pos, out);	        if (consumed == 0) {	            final char[] c = Character.toChars(Character.codePointAt(input, pos));	            out.write(c);	            pos += c.length;	            continue;	        }	        for (int pt = 0; pt < consumed; pt++) {	            pos += Character.charCount(Character.codePointAt(input, pt));	        }	    }	}
public static boolean isSameLength(final boolean[] array1, final boolean[] array2) {	    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {	        return false;	    }	    return true;	}
private static boolean endsWith(final CharSequence str, final CharSequence suffix, final boolean ignoreCase) {	    if (str == null || suffix == null) {	        return str == null && suffix == null;	    }	    if (suffix.length() > str.length()) {	        return false;	    }	    final int strOffset = str.length() - suffix.length();	    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, suffix, 0, suffix.length());	}
public StringBuilder toStringBuilder() {	    return new StringBuilder(size).append(buffer, 0, size);	}
public static String substringAfterLast(final String str, final String separator) {	    if (isEmpty(str)) {	        return str;	    }	    if (isEmpty(separator)) {	        return EMPTY;	    }	    final int pos = str.lastIndexOf(separator);	    if (pos == INDEX_NOT_FOUND || pos == str.length() - separator.length()) {	        return EMPTY;	    }	    return str.substring(pos + separator.length());	}
public static String uncapitalize(final String str) {	    int strLen;	    if (str == null || (strLen = str.length()) == 0) {	        return str;	    }	    char firstChar = str.charAt(0);	    if (Character.isLowerCase(firstChar)) {	        return str;	    }	    return new StringBuilder(strLen).append(Character.toLowerCase(firstChar)).append(str.substring(1)).toString();	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public static void handleCause(final ExecutionException ex) throws ConcurrentException {	    final ConcurrentException cex = extractCause(ex);	    if (cex != null) {	        throw cex;	    }	}
static boolean isRegistered(final Object lhs, final Object rhs) {	    final Set<Pair<IDKey, IDKey>> registry = getRegistry();	    final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);	    final Pair<IDKey, IDKey> swappedPair = Pair.of(pair.getLeft(), pair.getRight());	    return registry != null && (registry.contains(pair) || registry.contains(swappedPair));	}
public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale) {	    return cache.getDateInstance(style, timeZone, locale);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
static boolean regionMatches(final CharSequence cs, final boolean ignoreCase, final int thisStart, final CharSequence substring, final int start, final int length) {	    if (cs instanceof String && substring instanceof String) {	        return ((String) cs).regionMatches(ignoreCase, thisStart, (String) substring, start, length);	    } else {	        int index1 = thisStart;	        int index2 = start;	        int tmpLen = length;	        while (tmpLen-- > 0) {	            char c1 = cs.charAt(index1++);	            char c2 = substring.charAt(index2++);	            if (c1 == c2) {	                continue;	            }	            if (!ignoreCase) {	                return false;	            }	            if (Character.toUpperCase(c1) != Character.toUpperCase(c2) && Character.toLowerCase(c1) != Character.toLowerCase(c2)) {	                return false;	            }	        }	        return true;	    }	}
public int capacity() {	    return buffer.length;	}
@Override	public boolean ready() {	    return pos < StrBuilder.this.size();	}
protected boolean isArrayContentDetail() {	    return arrayContentDetail;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    buffer.append(arrayStart);	    for (int i = 0; i < array.length; i++) {	        if (i > 0) {	            buffer.append(arraySeparator);	        }	        appendDetail(buffer, fieldName, array[i]);	    }	    buffer.append(arrayEnd);	}
public boolean isEmpty() {	    return size == 0;	}
public boolean isAppendTransients() {	    return this.appendTransients;	}
public boolean contains(final CharRange range) {	    if (range == null) {	        throw new IllegalArgumentException("The Range must not be null");	    }	    if (negated) {	        if (range.negated) {	            return start >= range.start && end <= range.end;	        }	        return range.end < start || range.start > end;	    }	    if (range.negated) {	        return start == 0 && end == Character.MAX_VALUE;	    }	    return start <= range.start && end >= range.end;	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
protected String getSummaryObjectEndText() {	    return summaryObjectEndText;	}
public int capacity() {	    return buffer.length;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
@Override	public String build() {	    return toString();	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static String deleteWhitespace(final String str) {	    if (isEmpty(str)) {	        return str;	    }	    final int sz = str.length();	    final char[] chs = new char[sz];	    int count = 0;	    for (int i = 0; i < sz; i++) {	        if (!Character.isWhitespace(str.charAt(i))) {	            chs[count++] = str.charAt(i);	        }	    }	    if (count == sz) {	        return str;	    }	    return new String(chs, 0, count);	}
@Override	public int hashCode() {	    return toHashCode();	}
public static String overlay(final String str, String overlay, int start, int end) {	    if (str == null) {	        return null;	    }	    if (overlay == null) {	        overlay = EMPTY;	    }	    final int len = str.length();	    if (start < 0) {	        start = 0;	    }	    if (start > len) {	        start = len;	    }	    if (end < 0) {	        end = 0;	    }	    if (end > len) {	        end = len;	    }	    if (start > end) {	        final int temp = start;	        start = end;	        end = temp;	    }	    return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString();	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
protected String getContentEnd() {	    return contentEnd;	}
@Override	public int length() {	    return size;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
@Override	public String toPattern() {	    return toPattern;	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
public void stop() {	    if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {	        throw new IllegalStateException("Stopwatch is not running. ");	    }	    if (this.runningState == STATE_RUNNING) {	        this.stopTime = System.nanoTime();	    }	    this.runningState = STATE_STOPPED;	}
public boolean isEmpty() {	    return size == 0;	}
public int set(final int holder) {	    return holder | _mask;	}
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) {	    style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));	    return this;	}
@Override	public boolean equals(final Object obj) {	    if (obj == this) {	        return true;	    }	    if (obj == null) {	        return false;	    }	    if (!super.equals(obj)) {	        return false;	    }	    if (ObjectUtils.notEqual(getClass(), obj.getClass())) {	        return false;	    }	    final ExtendedMessageFormat rhs = (ExtendedMessageFormat) obj;	    if (ObjectUtils.notEqual(toPattern, rhs.toPattern)) {	        return false;	    }	    if (ObjectUtils.notEqual(registry, rhs.registry)) {	        return false;	    }	    return true;	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public static String initials(final String str, final char... delimiters) {	    if (StringUtils.isEmpty(str)) {	        return str;	    }	    if (delimiters != null && delimiters.length == 0) {	        return "";	    }	    final int strLen = str.length();	    final char[] buf = new char[strLen / 2 + 1];	    int count = 0;	    boolean lastWasGap = true;	    for (int i = 0; i < strLen; i++) {	        final char ch = str.charAt(i);	        if (isDelimiter(ch, delimiters)) {	            lastWasGap = true;	        } else if (lastWasGap) {	            buf[count++] = ch;	            lastWasGap = false;	        } else {	            continue;	        }	    }	    return new String(buf, 0, count);	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {	    if (array == null) {	        if (index != 0) {	            throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0");	        }	        final Object joinedArray = Array.newInstance(clss, 1);	        Array.set(joinedArray, 0, element);	        return joinedArray;	    }	    final int length = Array.getLength(array);	    if (index > length || index < 0) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(clss, length + 1);	    System.arraycopy(array, 0, result, 0, index);	    Array.set(result, index, element);	    if (index < length) {	        System.arraycopy(array, index, result, index + 1, length - index);	    }	    return result;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
private static Date set(final Date date, final int calendarField, final int amount) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final Calendar c = Calendar.getInstance();	    c.setLenient(false);	    c.setTime(date);	    c.set(calendarField, amount);	    return c.getTime();	}
public static String getCommonPrefix(final String... strs) {	    if (strs == null || strs.length == 0) {	        return EMPTY;	    }	    final int smallestIndexOfDiff = indexOfDifference(strs);	    if (smallestIndexOfDiff == INDEX_NOT_FOUND) {	        if (strs[0] == null) {	            return EMPTY;	        }	        return strs[0];	    } else if (smallestIndexOfDiff == 0) {	        return EMPTY;	    } else {	        return strs[0].substring(0, smallestIndexOfDiff);	    }	}
public Fraction negate() {	    if (numerator == Integer.MIN_VALUE) {	        throw new ArithmeticException("overflow: too large to negate");	    }	    return new Fraction(-numerator, denominator);	}
protected void removeLastFieldSeparator(final StringBuffer buffer) {	    final int len = buffer.length();	    final int sepLen = fieldSeparator.length();	    if (len > 0 && sepLen > 0 && len >= sepLen) {	        boolean match = true;	        for (int i = 0; i < sepLen; i++) {	            if (buffer.charAt(len - 1 - i) != fieldSeparator.charAt(sepLen - 1 - i)) {	                match = false;	                break;	            }	        }	        if (match) {	            buffer.setLength(len - sepLen);	        }	    }	}
protected boolean isUseIdentityHashCode() {	    return useIdentityHashCode;	}
public Writer asWriter() {	    return new StrBuilderWriter();	}
public String getNullText() {	    return nullText;	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex) {	    return indexOf(throwable, type, fromIndex, true);	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public String previousToken() {	    if (hasPrevious()) {	        return tokens[--tokenPos];	    }	    return null;	}
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return true;	    }	    if (lhs == null || rhs == null) {	        return false;	    }	    final Class<?> lhsClass = lhs.getClass();	    final Class<?> rhsClass = rhs.getClass();	    Class<?> testClass;	    if (lhsClass.isInstance(rhs)) {	        testClass = lhsClass;	        if (!rhsClass.isInstance(lhs)) {	            testClass = rhsClass;	        }	    } else if (rhsClass.isInstance(lhs)) {	        testClass = rhsClass;	        if (!lhsClass.isInstance(rhs)) {	            testClass = lhsClass;	        }	    } else {	        return false;	    }	    final EqualsBuilder equalsBuilder = new EqualsBuilder();	    try {	        reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {	            testClass = testClass.getSuperclass();	            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        }	    } catch (final IllegalArgumentException e) {	        return false;	    }	    return equalsBuilder.isEquals();	}
public StringBuffer toStringBuffer() {	    return new StringBuffer(size).append(buffer, 0, size);	}
@Override	public float floatValue() {	    return (float) numerator / (float) denominator;	}
@Override	public Object clone() {	    try {	        return cloneReset();	    } catch (final CloneNotSupportedException ex) {	        return null;	    }	}
public String getNewLineText() {	    return newLine;	}
public int capacity() {	    return buffer.length;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
@Override	public R setValue(final R value) {	    final R result = getRight();	    setRight(value);	    return result;	}
public static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts) {	    if (0 == nShorts) {	        return dst;	    }	    if ((nShorts - 1) * 16 + srcPos >= 64) {	        throw new IllegalArgumentException("(nShorts-1)*16+srcPos is greather or equal to than 64");	    }	    int shift = 0;	    for (int i = 0; i < nShorts; i++) {	        shift = i * 16 + srcPos;	        dst[dstPos + i] = (short) (0xffff & (src >> shift));	    }	    return dst;	}
protected String getContentStart() {	    return contentStart;	}
public static String chop(final String str) {	    if (str == null) {	        return null;	    }	    final int strLen = str.length();	    if (strLen < 2) {	        return EMPTY;	    }	    final int lastIdx = strLen - 1;	    final String ret = str.substring(0, lastIdx);	    final char last = str.charAt(lastIdx);	    if (last == CharUtils.LF && ret.charAt(lastIdx - 1) == CharUtils.CR) {	        return ret.substring(0, lastIdx - 1);	    }	    return ret;	}
public static boolean isAllUpperCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isUpperCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes) {	    if (0 == nBytes) {	        return dst;	    }	    if ((nBytes - 1) * 8 + srcPos >= 16) {	        throw new IllegalArgumentException("(nBytes-1)*8+srcPos is greather or equal to than 16");	    }	    int shift = 0;	    for (int i = 0; i < nBytes; i++) {	        shift = i * 8 + srcPos;	        dst[dstPos + i] = (byte) (0xff & (src >> shift));	    }	    return dst;	}
public static short CONST_SHORT(final int v) throws IllegalArgumentException {	    if (v < Short.MIN_VALUE || v > Short.MAX_VALUE) {	        throw new IllegalArgumentException("Supplied value must be a valid byte literal between -32768 and 32767: [" + v + "]");	    }	    return (short) v;	}
public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) {	    if (it != null) {	        separator = ObjectUtils.toString(separator);	        while (it.hasNext()) {	            append(it.next());	            if (it.hasNext()) {	                append(separator);	            }	        }	    }	    return this;	}
@Override	public int length() {	    return size;	}
protected boolean isFieldSeparatorAtEnd() {	    return fieldSeparatorAtEnd;	}
private static long getFragment(final Calendar calendar, final int fragment, final int unit) {	    if (calendar == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final long millisPerUnit = getMillisPerUnit(unit);	    long result = 0;	    switch(fragment) {	        case Calendar.YEAR:	            result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit;	            break;	        case Calendar.MONTH:	            result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit;	            break;	    }	    switch(fragment) {	        case Calendar.YEAR:	        case Calendar.MONTH:	        case Calendar.DAY_OF_YEAR:	        case Calendar.DATE:	            result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit;	        case Calendar.HOUR_OF_DAY:	            result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit;	        case Calendar.MINUTE:	            result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit;	        case Calendar.SECOND:	            result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit;	            break;	        case Calendar.MILLISECOND:	            break;	        default:	            throw new IllegalArgumentException("The fragment " + fragment + " is not supported");	    }	    return result;	}
public static String replaceChars(final String str, final String searchChars, String replaceChars) {	    if (isEmpty(str) || isEmpty(searchChars)) {	        return str;	    }	    if (replaceChars == null) {	        replaceChars = EMPTY;	    }	    boolean modified = false;	    final int replaceCharsLength = replaceChars.length();	    final int strLength = str.length();	    final StringBuilder buf = new StringBuilder(strLength);	    for (int i = 0; i < strLength; i++) {	        final char ch = str.charAt(i);	        final int index = searchChars.indexOf(ch);	        if (index >= 0) {	            modified = true;	            if (index < replaceCharsLength) {	                buf.append(replaceChars.charAt(index));	            }	        } else {	            buf.append(ch);	        }	    }	    if (modified) {	        return buf.toString();	    }	    return str;	}
@Override	public char charAt(final int index) {	    if (index < 0 || index >= length()) {	        throw new StringIndexOutOfBoundsException(index);	    }	    return buffer[index];	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public static String right(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(str.length() - len);	}
@Override	public int compareTo(final MutableBoolean other) {	    final boolean anotherVal = other.value;	    return value == anotherVal ? 0 : (value ? 1 : -1);	}
public static <T> T clone(final T obj) {	    if (obj instanceof Cloneable) {	        final Object result;	        if (obj.getClass().isArray()) {	            final Class<?> componentType = obj.getClass().getComponentType();	            if (!componentType.isPrimitive()) {	                result = ((Object[]) obj).clone();	            } else {	                int length = Array.getLength(obj);	                result = Array.newInstance(componentType, length);	                while (length-- > 0) {	                    Array.set(result, length, Array.get(obj, length));	                }	            }	        } else {	            try {	                final Method clone = obj.getClass().getMethod("clone");	                result = clone.invoke(obj);	            } catch (final NoSuchMethodException e) {	                throw new CloneFailedException("Cloneable type " + obj.getClass().getName() + " has no clone method", e);	            } catch (final IllegalAccessException e) {	                throw new CloneFailedException("Cannot clone Cloneable type " + obj.getClass().getName(), e);	            } catch (final InvocationTargetException e) {	                throw new CloneFailedException("Exception cloning Cloneable type " + obj.getClass().getName(), e.getCause());	            }	        }	        @SuppressWarnings("unchecked")	        final T checked = (T) result;	        return checked;	    }	    return null;	}
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return 0;	    }	    if (lhs == null || rhs == null) {	        throw new NullPointerException();	    }	    Class<?> lhsClazz = lhs.getClass();	    if (!lhsClazz.isInstance(rhs)) {	        throw new ClassCastException();	    }	    final CompareToBuilder compareToBuilder = new CompareToBuilder();	    reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);	    while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) {	        lhsClazz = lhsClazz.getSuperclass();	        reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);	    }	    return compareToBuilder.toComparison();	}
public ToStringBuilder appendAsObjectToString(final Object object) {	    ObjectUtils.identityToString(this.getStringBuffer(), object);	    return this;	}
public int getNumerator() {	    return numerator;	}
@Override	public int hashCode() {	    return (int) (value ^ (value >>> 32));	}
public static String formatPeriodISO(final long startMillis, final long endMillis) {	    return formatPeriod(startMillis, endMillis, ISO_EXTENDED_FORMAT_PATTERN, false, TimeZone.getDefault());	}
public String getNullText() {	    return nullText;	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
public String getNewLineText() {	    return newLine;	}
public static boolean isAsciiPrintable(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
public static String capitalize(final String str, final char... delimiters) {	    final int delimLen = delimiters == null ? -1 : delimiters.length;	    if (StringUtils.isEmpty(str) || delimLen == 0) {	        return str;	    }	    final char[] buffer = str.toCharArray();	    boolean capitalizeNext = true;	    for (int i = 0; i < buffer.length; i++) {	        final char ch = buffer[i];	        if (isDelimiter(ch, delimiters)) {	            capitalizeNext = true;	        } else if (capitalizeNext) {	            buffer[i] = Character.toTitleCase(ch);	            capitalizeNext = false;	        }	    }	    return new String(buffer);	}
public String getNullText() {	    return nullText;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
static Token[] lexx(final String format) {	    final char[] array = format.toCharArray();	    final ArrayList<Token> list = new ArrayList<Token>(array.length);	    boolean inLiteral = false;	    StringBuilder buffer = null;	    Token previous = null;	    final int sz = array.length;	    for (int i = 0; i < sz; i++) {	        final char ch = array[i];	        if (inLiteral && ch != '\'') {	            buffer.append(ch);	            continue;	        }	        Object value = null;	        switch(ch) {	            case '\'':	                if (inLiteral) {	                    buffer = null;	                    inLiteral = false;	                } else {	                    buffer = new StringBuilder();	                    list.add(new Token(buffer));	                    inLiteral = true;	                }	                break;	            case 'y':	                value = y;	                break;	            case 'M':	                value = M;	                break;	            case 'd':	                value = d;	                break;	            case 'H':	                value = H;	                break;	            case 'm':	                value = m;	                break;	            case 's':	                value = s;	                break;	            case 'S':	                value = S;	                break;	            default:	                if (buffer == null) {	                    buffer = new StringBuilder();	                    list.add(new Token(buffer));	                }	                buffer.append(ch);	        }	        if (value != null) {	            if (previous != null && previous.getValue() == value) {	                previous.increment();	            } else {	                final Token token = new Token(value);	                list.add(token);	                previous = token;	            }	            buffer = null;	        }	    }	    return list.toArray(new Token[list.size()]);	}
public static boolean isNotEmpty(final CharSequence cs) {	    return !StringUtils.isEmpty(cs);	}
public int capacity() {	    return buffer.length;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public String getNewLineText() {	    return newLine;	}
public static ConcurrentRuntimeException extractCauseUnchecked(final ExecutionException ex) {	    if (ex == null || ex.getCause() == null) {	        return null;	    }	    throwCause(ex);	    return new ConcurrentRuntimeException(ex.getMessage(), ex.getCause());	}
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = Integer.MAX_VALUE;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.indexOf(str, search, 0);	        if (tmp == INDEX_NOT_FOUND) {	            continue;	        }	        if (tmp < ret) {	            ret = tmp;	        }	    }	    return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public void appendEnd(final StringBuffer buffer, final Object object) {	    if (this.fieldSeparatorAtEnd == false) {	        removeLastFieldSeparator(buffer);	    }	    appendContentEnd(buffer);	    unregister(object);	}
public static <T> void inclusiveBetween(final T start, final T end, final Comparable<T> value, final String message, final Object... values) {	    if (value.compareTo(start) < 0 || value.compareTo(end) > 0) {	        throw new IllegalArgumentException(String.format(message, values));	    }	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
public static Class<?> getClass(final String className, final boolean initialize) throws ClassNotFoundException {	    final ClassLoader contextCL = Thread.currentThread().getContextClassLoader();	    final ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL;	    return getClass(loader, className, initialize);	}
protected boolean isUseClassName() {	    return useClassName;	}
public static byte toByte(final String str, final byte defaultValue) {	    if (str == null) {	        return defaultValue;	    }	    try {	        return Byte.parseByte(str);	    } catch (final NumberFormatException nfe) {	        return defaultValue;	    }	}
public boolean isEmpty() {	    return size == 0;	}
public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException {	    return parseDateWithLeniency(str, locale, parsePatterns, true);	}
public StrMatcher getDelimiterMatcher() {	    return this.delimMatcher;	}
public void start() {	    if (this.runningState == STATE_STOPPED) {	        throw new IllegalStateException("Stopwatch must be reset before being restarted. ");	    }	    if (this.runningState != STATE_UNSTARTED) {	        throw new IllegalStateException("Stopwatch already started. ");	    }	    this.startTime = System.nanoTime();	    this.startTimeMillis = System.currentTimeMillis();	    this.runningState = STATE_RUNNING;	}
protected String getArrayEnd() {	    return arrayEnd;	}
public Writer asWriter() {	    return new StrBuilderWriter();	}
public static Double createDouble(final String str) {	    if (str == null) {	        return null;	    }	    return Double.valueOf(str);	}
public static String[] splitByWholeSeparatorPreserveAllTokens(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, true);	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static String abbreviate(final String str, int offset, final int maxWidth) {	    if (str == null) {	        return null;	    }	    if (maxWidth < 4) {	        throw new IllegalArgumentException("Minimum abbreviation width is 4");	    }	    if (str.length() <= maxWidth) {	        return str;	    }	    if (offset > str.length()) {	        offset = str.length();	    }	    if (str.length() - offset < maxWidth - 3) {	        offset = str.length() - (maxWidth - 3);	    }	    final String abrevMarker = "...";	    if (offset <= 4) {	        return str.substring(0, maxWidth - 3) + abrevMarker;	    }	    if (maxWidth < 7) {	        throw new IllegalArgumentException("Minimum abbreviation width with offset is 7");	    }	    if (offset + maxWidth - 3 < str.length()) {	        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);	    }	    return abrevMarker + str.substring(str.length() - (maxWidth - 3));	}
@Override	public void mark(final int readAheadLimit) {	    mark = pos;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
@Override	public boolean equals(final Object obj) {	    return obj instanceof MutableFloat && Float.floatToIntBits(((MutableFloat) obj).value) == Float.floatToIntBits(value);	}
public static boolean isBlank(final CharSequence cs) {	    int strLen;	    if (cs == null || (strLen = cs.length()) == 0) {	        return true;	    }	    for (int i = 0; i < strLen; i++) {	        if (Character.isWhitespace(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static boolean[] clone(final boolean[] array) {	    if (array == null) {	        return null;	    }	    return array.clone();	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public static Iterator<?> iterator(final Object focus, final int rangeStyle) {	    if (focus == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (focus instanceof Date) {	        return iterator((Date) focus, rangeStyle);	    } else if (focus instanceof Calendar) {	        return iterator((Calendar) focus, rangeStyle);	    } else {	        throw new ClassCastException("Could not iterate based on " + focus);	    }	}
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = Integer.MAX_VALUE;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.indexOf(str, search, 0);	        if (tmp == INDEX_NOT_FOUND) {	            continue;	        }	        if (tmp < ret) {	            ret = tmp;	        }	    }	    return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static String toStringOnOff(final boolean bool) {	    return toString(bool, "on", "off");	}
public int getNumerator() {	    return numerator;	}
public static String prependIfMissing(final String str, final CharSequence prefix, final CharSequence... prefixes) {	    return prependIfMissing(str, prefix, false, prefixes);	}
public static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts) {	    if ((src.length == 0 && srcPos == 0) || 0 == nShorts) {	        return dstInit;	    }	    if ((nShorts - 1) * 16 + dstPos >= 64) {	        throw new IllegalArgumentException("(nShorts-1)*16+dstPos is greather or equal to than 64");	    }	    long out = dstInit;	    int shift = 0;	    for (int i = 0; i < nShorts; i++) {	        shift = i * 16 + dstPos;	        final long bits = (0xffffL & src[i + srcPos]) << shift;	        final long mask = 0xffffL << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
public String getNewLineText() {	    return newLine;	}
public static String deleteWhitespace(final String str) {	    if (isEmpty(str)) {	        return str;	    }	    final int sz = str.length();	    final char[] chs = new char[sz];	    int count = 0;	    for (int i = 0; i < sz; i++) {	        if (!Character.isWhitespace(str.charAt(i))) {	            chs[count++] = str.charAt(i);	        }	    }	    if (count == sz) {	        return str;	    }	    return new String(chs, 0, count);	}
@Override	public boolean hasNext() {	    checkTokenized();	    return tokenPos < tokens.length;	}
public static <T extends CharSequence> T notEmpty(final T chars) {	    return notEmpty(chars, DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE);	}
public String getNullText() {	    return nullText;	}
public static Date ceiling(final Object date, final int field) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (date instanceof Date) {	        return ceiling((Date) date, field);	    } else if (date instanceof Calendar) {	        return ceiling((Calendar) date, field).getTime();	    } else {	        throw new ClassCastException("Could not find ceiling of for type: " + date.getClass());	    }	}
protected String getArraySeparator() {	    return arraySeparator;	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
public static String abbreviate(final String str, int offset, final int maxWidth) {	    if (str == null) {	        return null;	    }	    if (maxWidth < 4) {	        throw new IllegalArgumentException("Minimum abbreviation width is 4");	    }	    if (str.length() <= maxWidth) {	        return str;	    }	    if (offset > str.length()) {	        offset = str.length();	    }	    if (str.length() - offset < maxWidth - 3) {	        offset = str.length() - (maxWidth - 3);	    }	    final String abrevMarker = "...";	    if (offset <= 4) {	        return str.substring(0, maxWidth - 3) + abrevMarker;	    }	    if (maxWidth < 7) {	        throw new IllegalArgumentException("Minimum abbreviation width with offset is 7");	    }	    if (offset + maxWidth - 3 < str.length()) {	        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);	    }	    return abrevMarker + str.substring(str.length() - (maxWidth - 3));	}
public String getNewLineText() {	    return newLine;	}
static Object removeAll(final Object array, final BitSet indices) {	    final int srcLength = ArrayUtils.getLength(array);	    final int removals = indices.cardinality();	    final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals);	    int srcIndex = 0;	    int destIndex = 0;	    int count;	    int set;	    while ((set = indices.nextSetBit(srcIndex)) != -1) {	        count = set - srcIndex;	        if (count > 0) {	            System.arraycopy(array, srcIndex, result, destIndex, count);	            destIndex += count;	        }	        srcIndex = indices.nextClearBit(set);	    }	    count = srcLength - srcIndex;	    if (count > 0) {	        System.arraycopy(array, srcIndex, result, destIndex, count);	    }	    return result;	}
public static void isAssignableFrom(final Class<?> superType, final Class<?> type, final String message, final Object... values) {	    if (superType.isAssignableFrom(type) == false) {	        throw new IllegalArgumentException(String.format(message, values));	    }	}
public Fraction negate() {	    if (numerator == Integer.MIN_VALUE) {	        throw new ArithmeticException("overflow: too large to negate");	    }	    return new Fraction(-numerator, denominator);	}
public static String capitalize(final String str, final char... delimiters) {	    final int delimLen = delimiters == null ? -1 : delimiters.length;	    if (StringUtils.isEmpty(str) || delimLen == 0) {	        return str;	    }	    final char[] buffer = str.toCharArray();	    boolean capitalizeNext = true;	    for (int i = 0; i < buffer.length; i++) {	        final char ch = buffer[i];	        if (isDelimiter(ch, delimiters)) {	            capitalizeNext = true;	        } else if (capitalizeNext) {	            buffer[i] = Character.toTitleCase(ch);	            capitalizeNext = false;	        }	    }	    return new String(buffer);	}
public static float min(final float a, final float b, final float c) {	    return Math.min(Math.min(a, b), c);	}
public static String trim(final String str) {	    return str == null ? null : str.trim();	}
public static char toChar(final String str, final char defaultValue) {	    if (StringUtils.isEmpty(str)) {	        return defaultValue;	    }	    return str.charAt(0);	}
public static boolean equalsIgnoreCase(final CharSequence str1, final CharSequence str2) {	    if (str1 == null || str2 == null) {	        return str1 == str2;	    } else if (str1 == str2) {	        return true;	    } else if (str1.length() != str2.length()) {	        return false;	    } else {	        return CharSequenceUtils.regionMatches(str1, true, 0, str2, 0, str1.length());	    }	}
public StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, 1);	}
@Override	public boolean ready() {	    return pos < StrBuilder.this.size();	}
public Integer toInteger() {	    return Integer.valueOf(intValue());	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public String getNullText() {	    return nullText;	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
@Override	public int read(final char[] b, final int off, int len) {	    if (off < 0 || len < 0 || off > b.length || (off + len) > b.length || (off + len) < 0) {	        throw new IndexOutOfBoundsException();	    }	    if (len == 0) {	        return 0;	    }	    if (pos >= StrBuilder.this.size()) {	        return -1;	    }	    if (pos + len > size()) {	        len = StrBuilder.this.size() - pos;	    }	    StrBuilder.this.getChars(pos, pos + len, b, off);	    pos += len;	    return len;	}
public static boolean isNotEmpty(final CharSequence cs) {	    return !StringUtils.isEmpty(cs);	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public boolean isEmpty() {	    return size == 0;	}
public boolean isStartedBy(final T element) {	    if (element == null) {	        return false;	    }	    return comparator.compare(element, minimum) == 0;	}
public static String getShortClassName(String className) {	    if (StringUtils.isEmpty(className)) {	        return StringUtils.EMPTY;	    }	    final StringBuilder arrayPrefix = new StringBuilder();	    if (className.startsWith("[")) {	        while (className.charAt(0) == '[') {	            className = className.substring(1);	            arrayPrefix.append("[]");	        }	        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {	            className = className.substring(1, className.length() - 1);	        }	        if (reverseAbbreviationMap.containsKey(className)) {	            className = reverseAbbreviationMap.get(className);	        }	    }	    final int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);	    final int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);	    String out = className.substring(lastDotIdx + 1);	    if (innerIdx != -1) {	        out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);	    }	    return out + arrayPrefix;	}
public static <T> T CONST(final T v) {	    return v;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static boolean contains(final boolean[] array, final boolean valueToFind) {	    return indexOf(array, valueToFind) != INDEX_NOT_FOUND;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public static <T> T clone(final T obj) {	    if (obj instanceof Cloneable) {	        final Object result;	        if (obj.getClass().isArray()) {	            final Class<?> componentType = obj.getClass().getComponentType();	            if (!componentType.isPrimitive()) {	                result = ((Object[]) obj).clone();	            } else {	                int length = Array.getLength(obj);	                result = Array.newInstance(componentType, length);	                while (length-- > 0) {	                    Array.set(result, length, Array.get(obj, length));	                }	            }	        } else {	            try {	                final Method clone = obj.getClass().getMethod("clone");	                result = clone.invoke(obj);	            } catch (final NoSuchMethodException e) {	                throw new CloneFailedException("Cloneable type " + obj.getClass().getName() + " has no clone method", e);	            } catch (final IllegalAccessException e) {	                throw new CloneFailedException("Cannot clone Cloneable type " + obj.getClass().getName(), e);	            } catch (final InvocationTargetException e) {	                throw new CloneFailedException("Exception cloning Cloneable type " + obj.getClass().getName(), e.getCause());	            }	        }	        @SuppressWarnings("unchecked")	        final T checked = (T) result;	        return checked;	    }	    return null;	}
public int clear(final int holder) {	    return holder & ~_mask;	}
@Override	public void mark(final int readAheadLimit) {	    mark = pos;	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
@Override	public int length() {	    return size;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public synchronized boolean isShutdown() {	    return shutdown;	}
protected int validateRange(final int startIndex, int endIndex) {	    if (startIndex < 0) {	        throw new StringIndexOutOfBoundsException(startIndex);	    }	    if (endIndex > size) {	        endIndex = size;	    }	    if (startIndex > endIndex) {	        throw new StringIndexOutOfBoundsException("end < start");	    }	    return endIndex;	}
public static String overlay(final String str, String overlay, int start, int end) {	    if (str == null) {	        return null;	    }	    if (overlay == null) {	        overlay = EMPTY;	    }	    final int len = str.length();	    if (start < 0) {	        start = 0;	    }	    if (start > len) {	        start = len;	    }	    if (end < 0) {	        end = 0;	    }	    if (end > len) {	        end = len;	    }	    if (start > end) {	        final int temp = start;	        start = end;	        end = temp;	    }	    return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString();	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public static Throwable getRootCause(final Throwable throwable) {	    final List<Throwable> list = getThrowableList(throwable);	    return list.size() < 2 ? null : (Throwable) list.get(list.size() - 1);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public String getNullText() {	    return nullText;	}
@Override	public void write(final String str, final int off, final int len) {	    StrBuilder.this.append(str, off, len);	}
public static String center(String str, final int size, String padStr) {	    if (str == null || size <= 0) {	        return str;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    str = leftPad(str, strLen + pads / 2, padStr);	    str = rightPad(str, size, padStr);	    return str;	}
@Override	public String previous() {	    if (hasPrevious()) {	        return tokens[--tokenPos];	    }	    throw new NoSuchElementException();	}
public String getNullText() {	    return nullText;	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
public static <T> String reflectionToString(final T object, final ToStringStyle style, final boolean outputTransients, final Class<? super T> reflectUpToClass) {	    return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass);	}
public String getNullText() {	    return nullText;	}
public int size() {	    return size;	}
public static <T extends CharSequence> T validIndex(final T chars, final int index) {	    return validIndex(chars, index, DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE, Integer.valueOf(index));	}
public void add(final Number operand) {	    this.value += operand.longValue();	}
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) {	    style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));	    return this;	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
public char getEscapeChar() {	    return this.escapeChar;	}
@Override	public String previous() {	    if (hasPrevious()) {	        return tokens[--tokenPos];	    }	    throw new NoSuchElementException();	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {	    if (array == null) {	        if (index != 0) {	            throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0");	        }	        final Object joinedArray = Array.newInstance(clss, 1);	        Array.set(joinedArray, 0, element);	        return joinedArray;	    }	    final int length = Array.getLength(array);	    if (index > length || index < 0) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(clss, length + 1);	    System.arraycopy(array, 0, result, 0, index);	    Array.set(result, index, element);	    if (index < length) {	        System.arraycopy(array, index, result, index + 1, length - index);	    }	    return result;	}
public short setShort(final short holder) {	    return (short) set(holder);	}
public int capacity() {	    return buffer.length;	}
public static String defaultString(final String str, final String defaultStr) {	    return str == null ? defaultStr : str;	}
public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width, final int precision, final char padChar, final CharSequence ellipsis) {	    Validate.isTrue(ellipsis == null || precision < 0 || ellipsis.length() <= precision, "Specified ellipsis '%1$s' exceeds precision of %2$s", ellipsis, Integer.valueOf(precision));	    final StringBuilder buf = new StringBuilder(seq);	    if (precision >= 0 && precision < seq.length()) {	        final CharSequence _ellipsis = ObjectUtils.defaultIfNull(ellipsis, StringUtils.EMPTY);	        buf.replace(precision - _ellipsis.length(), seq.length(), _ellipsis.toString());	    }	    final boolean leftJustify = (flags & LEFT_JUSTIFY) == LEFT_JUSTIFY;	    for (int i = buf.length(); i < width; i++) {	        buf.insert(leftJustify ? i : 0, padChar);	    }	    formatter.format(buf.toString());	    return formatter;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
protected String getSizeStartText() {	    return sizeStartText;	}
public static int indexOfDifference(final CharSequence... css) {	    if (css == null || css.length <= 1) {	        return INDEX_NOT_FOUND;	    }	    boolean anyStringNull = false;	    boolean allStringsNull = true;	    final int arrayLen = css.length;	    int shortestStrLen = Integer.MAX_VALUE;	    int longestStrLen = 0;	    for (int i = 0; i < arrayLen; i++) {	        if (css[i] == null) {	            anyStringNull = true;	            shortestStrLen = 0;	        } else {	            allStringsNull = false;	            shortestStrLen = Math.min(css[i].length(), shortestStrLen);	            longestStrLen = Math.max(css[i].length(), longestStrLen);	        }	    }	    if (allStringsNull || longestStrLen == 0 && !anyStringNull) {	        return INDEX_NOT_FOUND;	    }	    if (shortestStrLen == 0) {	        return 0;	    }	    int firstDiff = -1;	    for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {	        final char comparisonChar = css[0].charAt(stringPos);	        for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {	            if (css[arrayPos].charAt(stringPos) != comparisonChar) {	                firstDiff = stringPos;	                break;	            }	        }	        if (firstDiff != -1) {	            break;	        }	    }	    if (firstDiff == -1 && shortestStrLen != longestStrLen) {	        return shortestStrLen;	    }	    return firstDiff;	}
public static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    final int beSrcPos = src.length - 1 - srcPos;	    final int srcLen = Math.min(4, beSrcPos + 1);	    final boolean[] paddedSrc = new boolean[4];	    System.arraycopy(src, beSrcPos + 1 - srcLen, paddedSrc, 4 - srcLen, srcLen);	    src = paddedSrc;	    srcPos = 0;	    if (src[srcPos]) {	        if (src.length > srcPos + 1 && src[srcPos + 1]) {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 1 && src[srcPos + 1]) {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
public static boolean containsNone(final CharSequence cs, final String invalidChars) {	    if (cs == null || invalidChars == null) {	        return true;	    }	    return containsNone(cs, invalidChars.toCharArray());	}
public int capacity() {	    return buffer.length;	}
public String getNewLineText() {	    return newLine;	}
public static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {	    if (str == null || searchStr == null) {	        return INDEX_NOT_FOUND;	    }	    if (startPos < 0) {	        startPos = 0;	    }	    final int endLimit = str.length() - searchStr.length() + 1;	    if (startPos > endLimit) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return startPos;	    }	    for (int i = startPos; i < endLimit; i++) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static String leftPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return leftPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return padStr.concat(str);	    } else if (pads < padLen) {	        return padStr.substring(0, pads).concat(str);	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return new String(padding).concat(str);	    }	}
public static String center(String str, final int size, String padStr) {	    if (str == null || size <= 0) {	        return str;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    str = leftPad(str, strLen + pads / 2, padStr);	    str = rightPad(str, size, padStr);	    return str;	}
public boolean isAppendTransients() {	    return this.appendTransients;	}
public String leftString(final int length) {	    if (length <= 0) {	        return "";	    } else if (length >= size) {	        return new String(buffer, 0, size);	    } else {	        return new String(buffer, 0, length);	    }	}
public static ConcurrentException extractCause(final ExecutionException ex) {	    if (ex == null || ex.getCause() == null) {	        return null;	    }	    throwCause(ex);	    return new ConcurrentException(ex.getMessage(), ex.getCause());	}
protected boolean isUseFieldNames() {	    return useFieldNames;	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public static Fraction getReducedFraction(int numerator, int denominator) {	    if (denominator == 0) {	        throw new ArithmeticException("The denominator must not be zero");	    }	    if (numerator == 0) {	        return ZERO;	    }	    if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) {	        numerator /= 2;	        denominator /= 2;	    }	    if (denominator < 0) {	        if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {	            throw new ArithmeticException("overflow: can't negate");	        }	        numerator = -numerator;	        denominator = -denominator;	    }	    final int gcd = greatestCommonDivisor(numerator, denominator);	    numerator /= gcd;	    denominator /= gcd;	    return new Fraction(numerator, denominator);	}
public static boolean[] clone(final boolean[] array) {	    if (array == null) {	        return null;	    }	    return array.clone();	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public static boolean isNotEmpty(final boolean[] array) {	    return (array != null && array.length != 0);	}
public static String toString(final Object array, final String stringIfNull) {	    if (array == null) {	        return stringIfNull;	    }	    return new ToStringBuilder(array, ToStringStyle.SIMPLE_STYLE).append(array).toString();	}
@Override	public void mark(final int readAheadLimit) {	    mark = pos;	}
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {	    if (array == null) {	        if (index != 0) {	            throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0");	        }	        final Object joinedArray = Array.newInstance(clss, 1);	        Array.set(joinedArray, 0, element);	        return joinedArray;	    }	    final int length = Array.getLength(array);	    if (index > length || index < 0) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(clss, length + 1);	    System.arraycopy(array, 0, result, 0, index);	    Array.set(result, index, element);	    if (index < length) {	        System.arraycopy(array, index, result, index + 1, length - index);	    }	    return result;	}
public static void reverse(final boolean[] array) {	    if (array == null) {	        return;	    }	    int i = 0;	    int j = array.length - 1;	    boolean tmp;	    while (j > i) {	        tmp = array[j];	        array[j] = array[i];	        array[i] = tmp;	        j--;	        i++;	    }	}
public static int hexDigitMsb0ToInt(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return 0x0;	        case '1':	            return 0x8;	        case '2':	            return 0x4;	        case '3':	            return 0xC;	        case '4':	            return 0x2;	        case '5':	            return 0xA;	        case '6':	            return 0x6;	        case '7':	            return 0xE;	        case '8':	            return 0x1;	        case '9':	            return 0x9;	        case 'a':	        case 'A':	            return 0x5;	        case 'b':	        case 'B':	            return 0xD;	        case 'c':	        case 'C':	            return 0x3;	        case 'd':	        case 'D':	            return 0xB;	        case 'e':	        case 'E':	            return 0x7;	        case 'f':	        case 'F':	            return 0xF;	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
@Override	public boolean markSupported() {	    return true;	}
public String substring(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    return new String(buffer, startIndex, endIndex - startIndex);	}
public final String getNamingPattern() {	    return namingPattern;	}
@Deprecated	public static String chomp(final String str, final String separator) {	    return removeEnd(str, separator);	}
public static String stripStart(final String str, final String stripChars) {	    int strLen;	    if (str == null || (strLen = str.length()) == 0) {	        return str;	    }	    int start = 0;	    if (stripChars == null) {	        while (start != strLen && Character.isWhitespace(str.charAt(start))) {	            start++;	        }	    } else if (stripChars.isEmpty()) {	        return str;	    } else {	        while (start != strLen && stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND) {	            start++;	        }	    }	    return str.substring(start);	}
public static StrMatcher stringMatcher(final String str) {	    if (StringUtils.isEmpty(str)) {	        return NONE_MATCHER;	    }	    return new StringMatcher(str);	}
public static UnicodeEscaper above(final int codepoint) {	    return outsideOf(0, codepoint);	}
public static final String unescapeJava(final String input) {	    return UNESCAPE_JAVA.translate(input);	}
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) {	    final StringBuilder buffer = new StringBuilder();	    boolean lastOutputSeconds = false;	    final int sz = tokens.length;	    for (int i = 0; i < sz; i++) {	        final Token token = tokens[i];	        final Object value = token.getValue();	        final int count = token.getCount();	        if (value instanceof StringBuilder) {	            buffer.append(value.toString());	        } else {	            if (value == y) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years));	                lastOutputSeconds = false;	            } else if (value == M) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months));	                lastOutputSeconds = false;	            } else if (value == d) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days));	                lastOutputSeconds = false;	            } else if (value == H) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours));	                lastOutputSeconds = false;	            } else if (value == m) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes));	                lastOutputSeconds = false;	            } else if (value == s) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds));	                lastOutputSeconds = true;	            } else if (value == S) {	                if (lastOutputSeconds) {	                    milliseconds += 1000;	                    final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds);	                    buffer.append(str.substring(1));	                } else {	                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds));	                }	                lastOutputSeconds = false;	            }	        }	    }	    return buffer.toString();	}
public static Integer toIntegerObject(final Boolean bool, final Integer trueValue, final Integer falseValue, final Integer nullValue) {	    if (bool == null) {	        return nullValue;	    }	    return bool.booleanValue() ? trueValue : falseValue;	}
protected boolean isUseShortClassName() {	    return useShortClassName;	}
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) {	    if (str == null) {	        if (trueString == null) {	            return Boolean.TRUE;	        }	        if (falseString == null) {	            return Boolean.FALSE;	        }	        if (nullString == null) {	            return null;	        }	    } else if (str.equals(trueString)) {	        return Boolean.TRUE;	    } else if (str.equals(falseString)) {	        return Boolean.FALSE;	    } else if (str.equals(nullString)) {	        return null;	    }	    throw new IllegalArgumentException("The String did not match any specified value");	}
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) {	    if (str == null) {	        if (trueString == null) {	            return Boolean.TRUE;	        }	        if (falseString == null) {	            return Boolean.FALSE;	        }	        if (nullString == null) {	            return null;	        }	    } else if (str.equals(trueString)) {	        return Boolean.TRUE;	    } else if (str.equals(falseString)) {	        return Boolean.FALSE;	    } else if (str.equals(nullString)) {	        return null;	    }	    throw new IllegalArgumentException("The String did not match any specified value");	}
public StrTokenizer setDelimiterMatcher(final StrMatcher delim) {	    if (delim == null) {	        this.delimMatcher = StrMatcher.noneMatcher();	    } else {	        this.delimMatcher = delim;	    }	    return this;	}
@Override	public Date parse(final String source, final ParsePosition pos) {	    final int offset = pos.getIndex();	    final Matcher matcher = parsePattern.matcher(source.substring(offset));	    if (!matcher.lookingAt()) {	        return null;	    }	    final Calendar cal = Calendar.getInstance(timeZone, locale);	    cal.clear();	    for (int i = 0; i < strategies.length; ) {	        final Strategy strategy = strategies[i++];	        strategy.setCalendar(this, cal, matcher.group(i));	    }	    pos.setIndex(offset + matcher.end());	    return cal.getTime();	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    if (index != 0) {	        throw new IllegalStateException("CsvUnescaper should never reach the [1] index");	    }	    if (input.charAt(0) != CSV_QUOTE || input.charAt(input.length() - 1) != CSV_QUOTE) {	        out.write(input.toString());	        return input.length();	    }	    final String quoteless = input.subSequence(1, input.length() - 1).toString();	    if (StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS)) {	        out.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR));	    } else {	        out.write(input.toString());	    }	    return input.length();	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
private static boolean endsWith(final CharSequence str, final CharSequence suffix, final boolean ignoreCase) {	    if (str == null || suffix == null) {	        return str == null && suffix == null;	    }	    if (suffix.length() > str.length()) {	        return false;	    }	    final int strOffset = str.length() - suffix.length();	    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, suffix, 0, suffix.length());	}
@Override	public int length() {	    return size;	}
public boolean isEmpty() {	    return size == 0;	}
public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables) {	    this.enableSubstitutionInVariables = enableSubstitutionInVariables;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static <T> Range<T> is(final T element, final Comparator<T> comparator) {	    return between(element, element, comparator);	}
public static ToStringStyle getDefaultStyle() {	    return defaultStyle;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {	    if (str == null || searchStr == null) {	        return INDEX_NOT_FOUND;	    }	    if (startPos < 0) {	        startPos = 0;	    }	    final int endLimit = str.length() - searchStr.length() + 1;	    if (startPos > endLimit) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return startPos;	    }	    for (int i = startPos; i < endLimit; i++) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, true);	}
public static String right(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(str.length() - len);	}
public static Character toCharacterObject(final String str) {	    if (StringUtils.isEmpty(str)) {	        return null;	    }	    return Character.valueOf(str.charAt(0));	}
@Override	public boolean ready() {	    return pos < StrBuilder.this.size();	}
public StrBuilder deleteAll(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, -1);	}
public boolean isEmpty() {	    return size == 0;	}
public boolean isEmpty() {	    return size == 0;	}
public static String swapCase(final String str) {	    if (StringUtils.isEmpty(str)) {	        return str;	    }	    final char[] buffer = str.toCharArray();	    for (int i = 0; i < buffer.length; i++) {	        final char ch = buffer[i];	        if (Character.isUpperCase(ch)) {	            buffer[i] = Character.toLowerCase(ch);	        } else if (Character.isTitleCase(ch)) {	            buffer[i] = Character.toLowerCase(ch);	        } else if (Character.isLowerCase(ch)) {	            buffer[i] = Character.toUpperCase(ch);	        }	    }	    return new String(buffer);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return 0;	    }	    if (lhs == null || rhs == null) {	        throw new NullPointerException();	    }	    Class<?> lhsClazz = lhs.getClass();	    if (!lhsClazz.isInstance(rhs)) {	        throw new ClassCastException();	    }	    final CompareToBuilder compareToBuilder = new CompareToBuilder();	    reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);	    while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) {	        lhsClazz = lhsClazz.getSuperclass();	        reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);	    }	    return compareToBuilder.toComparison();	}
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) {	    return new Range<T>(fromInclusive, toInclusive, comparator);	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static boolean isAllLowerCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLowerCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
@Override	public int read(final char[] b, final int off, int len) {	    if (off < 0 || len < 0 || off > b.length || (off + len) > b.length || (off + len) < 0) {	        throw new IndexOutOfBoundsException();	    }	    if (len == 0) {	        return 0;	    }	    if (pos >= StrBuilder.this.size()) {	        return -1;	    }	    if (pos + len > size()) {	        len = StrBuilder.this.size() - pos;	    }	    StrBuilder.this.getChars(pos, pos + len, b, off);	    pos += len;	    return len;	}
protected boolean isArrayContentDetail() {	    return arrayContentDetail;	}
@Override	public void setValue(final Number value) {	    this.value = value.floatValue();	}
protected String getSummaryObjectStartText() {	    return summaryObjectStartText;	}
protected boolean isFieldSeparatorAtStart() {	    return fieldSeparatorAtStart;	}
public static final String escapeJson(final String input) {	    return ESCAPE_JSON.translate(input);	}
public boolean isEquals() {	    return this.isEquals;	}
public static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes) {	    if (0 == nBytes) {	        return dst;	    }	    if ((nBytes - 1) * 8 + srcPos >= 32) {	        throw new IllegalArgumentException("(nBytes-1)*8+srcPos is greather or equal to than 32");	    }	    int shift = 0;	    for (int i = 0; i < nBytes; i++) {	        shift = i * 8 + srcPos;	        dst[dstPos + i] = (byte) (0xff & (src >> shift));	    }	    return dst;	}
public int capacity() {	    return buffer.length;	}
public byte setByteBoolean(final byte holder, final boolean flag) {	    return flag ? setByte(holder) : clearByte(holder);	}
public static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex) {	    if (0 == nHex) {	        return dstInit;	    }	    if ((nHex - 1) * 4 + dstPos >= 16) {	        throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 16");	    }	    short out = dstInit;	    int shift = 0;	    for (int i = 0; i < nHex; i++) {	        shift = i * 4 + dstPos;	        final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift;	        final int mask = 0xf << shift;	        out = (short) ((out & ~mask) | bits);	    }	    return out;	}
public static String random(final int count, final char... chars) {	    if (chars == null) {	        return random(count, 0, 0, false, false, null, RANDOM);	    }	    return random(count, 0, chars.length, false, false, chars, RANDOM);	}
public static boolean isAlpha(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public int capacity() {	    return buffer.length;	}
public static String lowerCase(final String str, final Locale locale) {	    if (str == null) {	        return null;	    }	    return str.toLowerCase(locale);	}
public String getNewLineText() {	    return newLine;	}
protected boolean isUseIdentityHashCode() {	    return useIdentityHashCode;	}
public static float max(final float a, final float b, final float c) {	    return Math.max(Math.max(a, b), c);	}
public boolean isAllSet(final int holder) {	    return (holder & _mask) == _mask;	}
public static void handleCause(final ExecutionException ex) throws ConcurrentException {	    final ConcurrentException cex = extractCause(ex);	    if (cex != null) {	        throw cex;	    }	}
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return new boolean[] { false, false, false, false };	        case '1':	            return new boolean[] { false, false, false, true };	        case '2':	            return new boolean[] { false, false, true, false };	        case '3':	            return new boolean[] { false, false, true, true };	        case '4':	            return new boolean[] { false, true, false, false };	        case '5':	            return new boolean[] { false, true, false, true };	        case '6':	            return new boolean[] { false, true, true, false };	        case '7':	            return new boolean[] { false, true, true, true };	        case '8':	            return new boolean[] { true, false, false, false };	        case '9':	            return new boolean[] { true, false, false, true };	        case 'a':	        case 'A':	            return new boolean[] { true, false, true, false };	        case 'b':	        case 'B':	            return new boolean[] { true, false, true, true };	        case 'c':	        case 'C':	            return new boolean[] { true, true, false, false };	        case 'd':	        case 'D':	            return new boolean[] { true, true, false, true };	        case 'e':	        case 'E':	            return new boolean[] { true, true, true, false };	        case 'f':	        case 'F':	            return new boolean[] { true, true, true, true };	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public static <T extends CharSequence> T notEmpty(final T chars) {	    return notEmpty(chars, DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE);	}
public static int getThrowableCount(final Throwable throwable) {	    return getThrowableList(throwable).size();	}
public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames) {	    if (causeFrames == null || wrapperFrames == null) {	        throw new IllegalArgumentException("The List must not be null");	    }	    int causeFrameIndex = causeFrames.size() - 1;	    int wrapperFrameIndex = wrapperFrames.size() - 1;	    while (causeFrameIndex >= 0 && wrapperFrameIndex >= 0) {	        final String causeFrame = causeFrames.get(causeFrameIndex);	        final String wrapperFrame = wrapperFrames.get(wrapperFrameIndex);	        if (causeFrame.equals(wrapperFrame)) {	            causeFrames.remove(causeFrameIndex);	        }	        causeFrameIndex--;	        wrapperFrameIndex--;	    }	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public void subtract(final Number operand) {	    this.value -= operand.floatValue();	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public int capacity() {	    return buffer.length;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
public static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex) {	    if (0 == nHex) {	        return dstInit;	    }	    if ((nHex - 1) * 4 + dstPos >= 8) {	        throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 8");	    }	    byte out = dstInit;	    int shift = 0;	    for (int i = 0; i < nHex; i++) {	        shift = i * 4 + dstPos;	        final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift;	        final int mask = 0xf << shift;	        out = (byte) ((out & ~mask) | bits);	    }	    return out;	}
public static int count(final String str, final String... set) {	    if (StringUtils.isEmpty(str) || deepEmpty(set)) {	        return 0;	    }	    final CharSet chars = CharSet.getInstance(set);	    int count = 0;	    for (final char c : str.toCharArray()) {	        if (chars.contains(c)) {	            count++;	        }	    }	    return count;	}
public StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, 1);	}
public static String substringBefore(final String str, final String separator) {	    if (isEmpty(str) || separator == null) {	        return str;	    }	    if (separator.isEmpty()) {	        return EMPTY;	    }	    final int pos = str.indexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return str;	    }	    return str.substring(0, pos);	}
public static <L, M, R> Triple<L, M, R> of(final L left, final M middle, final R right) {	    return new ImmutableTriple<L, M, R>(left, middle, right);	}
public boolean isNegated() {	    return negated;	}
@Override	public void setValue(final Number value) {	    this.value = value.floatValue();	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public StrBuilder appendSeparator(final char separator, final int loopIndex) {	    if (loopIndex > 0) {	        append(separator);	    }	    return this;	}
public static <T> Range<T> is(final T element, final Comparator<T> comparator) {	    return between(element, element, comparator);	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
private static Date add(final Date date, final int calendarField, final int amount) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final Calendar c = Calendar.getInstance();	    c.setTime(date);	    c.add(calendarField, amount);	    return c.getTime();	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
protected boolean isUseFieldNames() {	    return useFieldNames;	}
public static String replaceChars(final String str, final String searchChars, String replaceChars) {	    if (isEmpty(str) || isEmpty(searchChars)) {	        return str;	    }	    if (replaceChars == null) {	        replaceChars = EMPTY;	    }	    boolean modified = false;	    final int replaceCharsLength = replaceChars.length();	    final int strLength = str.length();	    final StringBuilder buf = new StringBuilder(strLength);	    for (int i = 0; i < strLength; i++) {	        final char ch = str.charAt(i);	        final int index = searchChars.indexOf(ch);	        if (index >= 0) {	            modified = true;	            if (index < replaceCharsLength) {	                buf.append(replaceChars.charAt(index));	            }	        } else {	            buf.append(ch);	        }	    }	    if (modified) {	        return buf.toString();	    }	    return str;	}
@Override	public Date parse(final String source, final ParsePosition pos) {	    return parser.parse(source, pos);	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static long getFragmentInMinutes(final Calendar calendar, final int fragment) {	    return getFragment(calendar, fragment, Calendar.MINUTE);	}
public int size() {	    return size;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static String getPackageCanonicalName(final String canonicalName) {	    return ClassUtils.getPackageName(getCanonicalName(canonicalName));	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) {	    if (str == null) {	        if (trueString == null) {	            return Boolean.TRUE;	        }	        if (falseString == null) {	            return Boolean.FALSE;	        }	        if (nullString == null) {	            return null;	        }	    } else if (str.equals(trueString)) {	        return Boolean.TRUE;	    } else if (str.equals(falseString)) {	        return Boolean.FALSE;	    } else if (str.equals(nullString)) {	        return null;	    }	    throw new IllegalArgumentException("The String did not match any specified value");	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
@Override	public int length() {	    return size;	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) {	    style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));	    return this;	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public static Number createNumber(final String str) throws NumberFormatException {	    if (str == null) {	        return null;	    }	    if (StringUtils.isBlank(str)) {	        throw new NumberFormatException("A blank string is not a valid number");	    }	    final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" };	    int pfxLen = 0;	    for (final String pfx : hex_prefixes) {	        if (str.startsWith(pfx)) {	            pfxLen += pfx.length();	            break;	        }	    }	    if (pfxLen > 0) {	        final int hexDigits = str.length() - pfxLen;	        if (hexDigits > 16) {	            return createBigInteger(str);	        }	        if (hexDigits > 8) {	            return createLong(str);	        }	        return createInteger(str);	    }	    final char lastChar = str.charAt(str.length() - 1);	    String mant;	    String dec;	    String exp;	    final int decPos = str.indexOf('.');	    final int expPos = str.indexOf('e') + str.indexOf('E') + 1;	    int numDecimals = 0;	    if (decPos > -1) {	        if (expPos > -1) {	            if (expPos < decPos || expPos > str.length()) {	                throw new NumberFormatException(str + " is not a valid number.");	            }	            dec = str.substring(decPos + 1, expPos);	        } else {	            dec = str.substring(decPos + 1);	        }	        mant = str.substring(0, decPos);	        numDecimals = dec.length();	    } else {	        if (expPos > -1) {	            if (expPos > str.length()) {	                throw new NumberFormatException(str + " is not a valid number.");	            }	            mant = str.substring(0, expPos);	        } else {	            mant = str;	        }	        dec = null;	    }	    if (!Character.isDigit(lastChar) && lastChar != '.') {	        if (expPos > -1 && expPos < str.length() - 1) {	            exp = str.substring(expPos + 1, str.length() - 1);	        } else {	            exp = null;	        }	        final String numeric = str.substring(0, str.length() - 1);	        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);	        switch(lastChar) {	            case 'l':	            case 'L':	                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {	                    try {	                        return createLong(numeric);	                    } catch (final NumberFormatException nfe) {	                    }	                    return createBigInteger(numeric);	                }	                throw new NumberFormatException(str + " is not a valid number.");	            case 'f':	            case 'F':	                try {	                    final Float f = NumberUtils.createFloat(numeric);	                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {	                        return f;	                    }	                } catch (final NumberFormatException nfe) {	                }	            case 'd':	            case 'D':	                try {	                    final Double d = NumberUtils.createDouble(numeric);	                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {	                        return d;	                    }	                } catch (final NumberFormatException nfe) {	                }	                try {	                    return createBigDecimal(numeric);	                } catch (final NumberFormatException e) {	                }	            default:	                throw new NumberFormatException(str + " is not a valid number.");	        }	    }	    if (expPos > -1 && expPos < str.length() - 1) {	        exp = str.substring(expPos + 1, str.length());	    } else {	        exp = null;	    }	    if (dec == null && exp == null) {	        try {	            return createInteger(str);	        } catch (final NumberFormatException nfe) {	        }	        try {	            return createLong(str);	        } catch (final NumberFormatException nfe) {	        }	        return createBigInteger(str);	    }	    final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);	    try {	        if (numDecimals <= 7) {	            final Float f = createFloat(str);	            if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {	                return f;	            }	        }	    } catch (final NumberFormatException nfe) {	    }	    try {	        if (numDecimals <= 16) {	            final Double d = createDouble(str);	            if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {	                return d;	            }	        }	    } catch (final NumberFormatException nfe) {	    }	    return createBigDecimal(str);	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    if (input.charAt(index) == '\\' && index + 1 < input.length() && input.charAt(index + 1) == 'u') {	        int i = 2;	        while (index + i < input.length() && input.charAt(index + i) == 'u') {	            i++;	        }	        if (index + i < input.length() && input.charAt(index + i) == '+') {	            i++;	        }	        if (index + i + 4 <= input.length()) {	            final CharSequence unicode = input.subSequence(index + i, index + i + 4);	            try {	                final int value = Integer.parseInt(unicode.toString(), 16);	                out.write((char) value);	            } catch (final NumberFormatException nfe) {	                throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe);	            }	            return i + 4;	        } else {	            throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + input.subSequence(index, input.length()) + "' due to end of CharSequence");	        }	    }	    return 0;	}
public StrSubstitutor setVariableSuffix(final String suffix) {	    if (suffix == null) {	        throw new IllegalArgumentException("Variable suffix must not be null!");	    }	    return setVariableSuffixMatcher(StrMatcher.stringMatcher(suffix));	}
public static int hexDigitMsb0ToInt(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return 0x0;	        case '1':	            return 0x8;	        case '2':	            return 0x4;	        case '3':	            return 0xC;	        case '4':	            return 0x2;	        case '5':	            return 0xA;	        case '6':	            return 0x6;	        case '7':	            return 0xE;	        case '8':	            return 0x1;	        case '9':	            return 0x9;	        case 'a':	        case 'A':	            return 0x5;	        case 'b':	        case 'B':	            return 0xD;	        case 'c':	        case 'C':	            return 0x3;	        case 'd':	        case 'D':	            return 0xB;	        case 'e':	        case 'E':	            return 0x7;	        case 'f':	        case 'F':	            return 0xF;	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
@Override	public T get(final long timeout, final TimeUnit unit) {	    return value;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
@Override	public int length() {	    return size;	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
@Override	public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) {	    return buffer[pos] <= 32 ? 1 : 0;	}
public int toHashCode() {	    return iTotal;	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public StrTokenizer setDelimiterChar(final char delim) {	    return setDelimiterMatcher(StrMatcher.charMatcher(delim));	}
public StrBuilder replaceAll(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, -1);	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public static boolean isAlphanumericSpace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetterOrDigit(cs.charAt(i)) == false && cs.charAt(i) != ' ') {	            return false;	        }	    }	    return true;	}
public char getEnd() {	    return this.end;	}
public static String getCommonPrefix(final String... strs) {	    if (strs == null || strs.length == 0) {	        return EMPTY;	    }	    final int smallestIndexOfDiff = indexOfDifference(strs);	    if (smallestIndexOfDiff == INDEX_NOT_FOUND) {	        if (strs[0] == null) {	            return EMPTY;	        }	        return strs[0];	    } else if (smallestIndexOfDiff == 0) {	        return EMPTY;	    } else {	        return strs[0].substring(0, smallestIndexOfDiff);	    }	}
@Override	public int hashCode() {	    return toHashCode();	}
public static <L> void addEventListener(final Object eventSource, final Class<L> listenerType, final L listener) {	    try {	        MethodUtils.invokeMethod(eventSource, "add" + listenerType.getSimpleName(), listener);	    } catch (final NoSuchMethodException e) {	        throw new IllegalArgumentException("Class " + eventSource.getClass().getName() + " does not have a public add" + listenerType.getSimpleName() + " method which takes a parameter of type " + listenerType.getName() + ".");	    } catch (final IllegalAccessException e) {	        throw new IllegalArgumentException("Class " + eventSource.getClass().getName() + " does not have an accessible add" + listenerType.getSimpleName() + " method which takes a parameter of type " + listenerType.getName() + ".");	    } catch (final InvocationTargetException e) {	        throw new RuntimeException("Unable to add listener.", e.getCause());	    }	}
public static int countMatches(final CharSequence str, final CharSequence sub) {	    if (isEmpty(str) || isEmpty(sub)) {	        return 0;	    }	    int count = 0;	    int idx = 0;	    while ((idx = CharSequenceUtils.indexOf(str, sub, idx)) != INDEX_NOT_FOUND) {	        count++;	        idx += sub.length();	    }	    return count;	}
@Override	public Thread newThread(final Runnable r) {	    final Thread t = getWrappedFactory().newThread(r);	    initializeThread(t);	    return t;	}
public boolean isEquals() {	    return this.isEquals;	}
@Override	public Date parse(final String source, final ParsePosition pos) {	    final int offset = pos.getIndex();	    final Matcher matcher = parsePattern.matcher(source.substring(offset));	    if (!matcher.lookingAt()) {	        return null;	    }	    final Calendar cal = Calendar.getInstance(timeZone, locale);	    cal.clear();	    for (int i = 0; i < strategies.length; ) {	        final Strategy strategy = strategies[i++];	        strategy.setCalendar(this, cal, matcher.group(i));	    }	    pos.setIndex(offset + matcher.end());	    return cal.getTime();	}
public static CharRange is(final char ch) {	    return new CharRange(ch, ch, false);	}
@Override	public int length() {	    return size;	}
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) {	    return new Range<T>(fromInclusive, toInclusive, comparator);	}
public static String right(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(str.length() - len);	}
public char getStart() {	    return this.start;	}
public int capacity() {	    return buffer.length;	}
@Override	public CharSequence subSequence(final int startIndex, final int endIndex) {	    if (startIndex < 0) {	        throw new StringIndexOutOfBoundsException(startIndex);	    }	    if (endIndex > size) {	        throw new StringIndexOutOfBoundsException(endIndex);	    }	    if (startIndex > endIndex) {	        throw new StringIndexOutOfBoundsException(endIndex - startIndex);	    }	    return substring(startIndex, endIndex);	}
public static Date addYears(final Date date, final int amount) {	    return add(date, Calendar.YEAR, amount);	}
public int size() {	    return size;	}
public HashCodeBuilder append(final short[] array) {	    if (array == null) {	        iTotal = iTotal * iConstant;	    } else {	        for (final short element : array) {	            append(element);	        }	    }	    return this;	}
public static CharRange is(final char ch) {	    return new CharRange(ch, ch, false);	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
static int indexOf(final CharSequence cs, final CharSequence searchChar, final int start) {	    return cs.toString().indexOf(searchChar.toString(), start);	}
public static String chop(final String str) {	    if (str == null) {	        return null;	    }	    final int strLen = str.length();	    if (strLen < 2) {	        return EMPTY;	    }	    final int lastIdx = strLen - 1;	    final String ret = str.substring(0, lastIdx);	    final char last = str.charAt(lastIdx);	    if (last == CharUtils.LF && ret.charAt(lastIdx - 1) == CharUtils.CR) {	        return ret.substring(0, lastIdx - 1);	    }	    return ret;	}
public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {	    if (str == null || searchStr == null) {	        return INDEX_NOT_FOUND;	    }	    if (startPos > str.length() - searchStr.length()) {	        startPos = str.length() - searchStr.length();	    }	    if (startPos < 0) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return startPos;	    }	    for (int i = startPos; i >= 0; i--) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static <T> void inclusiveBetween(final T start, final T end, final Comparable<T> value, final String message, final Object... values) {	    if (value.compareTo(start) < 0 || value.compareTo(end) > 0) {	        throw new IllegalArgumentException(String.format(message, values));	    }	}
public static String formatDuration(long durationMillis, final String format, final boolean padWithZeros) {	    final Token[] tokens = lexx(format);	    int days = 0;	    int hours = 0;	    int minutes = 0;	    int seconds = 0;	    int milliseconds = 0;	    if (Token.containsTokenWithValue(tokens, d)) {	        days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY);	        durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY);	    }	    if (Token.containsTokenWithValue(tokens, H)) {	        hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR);	        durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR);	    }	    if (Token.containsTokenWithValue(tokens, m)) {	        minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE);	        durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE);	    }	    if (Token.containsTokenWithValue(tokens, s)) {	        seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND);	        durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND);	    }	    if (Token.containsTokenWithValue(tokens, S)) {	        milliseconds = (int) durationMillis;	    }	    return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
public static Boolean[] toObject(final boolean[] array) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    final Boolean[] result = new Boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        result[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE);	    }	    return result;	}
public static boolean isAllUpperCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isUpperCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
@Override	public String getFormattedExceptionMessage(final String baseMessage) {	    return exceptionContext.getFormattedExceptionMessage(baseMessage);	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
public String toSplitString() {	    return DurationFormatUtils.formatDurationHMS(getSplitTime());	}
public String getNewLineText() {	    return newLine;	}
private static boolean endsWith(final CharSequence str, final CharSequence suffix, final boolean ignoreCase) {	    if (str == null || suffix == null) {	        return str == null && suffix == null;	    }	    if (suffix.length() > str.length()) {	        return false;	    }	    final int strOffset = str.length() - suffix.length();	    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, suffix, 0, suffix.length());	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public static void isAssignableFrom(final Class<?> superType, final Class<?> type, final String message, final Object... values) {	    if (superType.isAssignableFrom(type) == false) {	        throw new IllegalArgumentException(String.format(message, values));	    }	}
public String getNewLineText() {	    return newLine;	}
public boolean contains(final StrMatcher matcher) {	    return indexOf(matcher, 0) >= 0;	}
public static String[] stripAll(final String[] strs, final String stripChars) {	    int strsLen;	    if (strs == null || (strsLen = strs.length) == 0) {	        return strs;	    }	    final String[] newArr = new String[strsLen];	    for (int i = 0; i < strsLen; i++) {	        newArr[i] = strip(strs[i], stripChars);	    }	    return newArr;	}
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, true);	}
public static void isTrue(final boolean expression) {	    if (expression == false) {	        throw new IllegalArgumentException(DEFAULT_IS_TRUE_EX_MESSAGE);	    }	}
public StrBuilder setNullText(String nullText) {	    if (nullText != null && nullText.isEmpty()) {	        nullText = null;	    }	    this.nullText = nullText;	    return this;	}
public boolean isAppendTransients() {	    return this.appendTransients;	}
public static String removeStart(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.startsWith(remove)) {	        return str.substring(remove.length());	    }	    return str;	}
private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) {	    if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {	        return text;	    }	    if (timeToLive < 0) {	        throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another");	    }	    final int searchLength = searchList.length;	    final int replacementLength = replacementList.length;	    if (searchLength != replacementLength) {	        throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength);	    }	    final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];	    int textIndex = -1;	    int replaceIndex = -1;	    int tempIndex = -1;	    for (int i = 0; i < searchLength; i++) {	        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {	            continue;	        }	        tempIndex = text.indexOf(searchList[i]);	        if (tempIndex == -1) {	            noMoreMatchesForReplIndex[i] = true;	        } else {	            if (textIndex == -1 || tempIndex < textIndex) {	                textIndex = tempIndex;	                replaceIndex = i;	            }	        }	    }	    if (textIndex == -1) {	        return text;	    }	    int start = 0;	    int increase = 0;	    for (int i = 0; i < searchList.length; i++) {	        if (searchList[i] == null || replacementList[i] == null) {	            continue;	        }	        final int greater = replacementList[i].length() - searchList[i].length();	        if (greater > 0) {	            increase += 3 * greater;	        }	    }	    increase = Math.min(increase, text.length() / 5);	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (textIndex != -1) {	        for (int i = start; i < textIndex; i++) {	            buf.append(text.charAt(i));	        }	        buf.append(replacementList[replaceIndex]);	        start = textIndex + searchList[replaceIndex].length();	        textIndex = -1;	        replaceIndex = -1;	        tempIndex = -1;	        for (int i = 0; i < searchLength; i++) {	            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {	                continue;	            }	            tempIndex = text.indexOf(searchList[i], start);	            if (tempIndex == -1) {	                noMoreMatchesForReplIndex[i] = true;	            } else {	                if (textIndex == -1 || tempIndex < textIndex) {	                    textIndex = tempIndex;	                    replaceIndex = i;	                }	            }	        }	    }	    final int textLength = text.length();	    for (int i = start; i < textLength; i++) {	        buf.append(text.charAt(i));	    }	    final String result = buf.toString();	    if (!repeat) {	        return result;	    }	    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
@Override	public int length() {	    return size;	}
public static String initials(final String str, final char... delimiters) {	    if (StringUtils.isEmpty(str)) {	        return str;	    }	    if (delimiters != null && delimiters.length == 0) {	        return "";	    }	    final int strLen = str.length();	    final char[] buf = new char[strLen / 2 + 1];	    int count = 0;	    boolean lastWasGap = true;	    for (int i = 0; i < strLen; i++) {	        final char ch = str.charAt(i);	        if (isDelimiter(ch, delimiters)) {	            lastWasGap = true;	        } else if (lastWasGap) {	            buf[count++] = ch;	            lastWasGap = false;	        } else {	            continue;	        }	    }	    return new String(buf, 0, count);	}
public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) {	    if (s == null || t == null) {	        throw new IllegalArgumentException("Strings must not be null");	    }	    if (threshold < 0) {	        throw new IllegalArgumentException("Threshold must not be negative");	    }	    int n = s.length();	    int m = t.length();	    if (n == 0) {	        return m <= threshold ? m : -1;	    } else if (m == 0) {	        return n <= threshold ? n : -1;	    }	    if (n > m) {	        final CharSequence tmp = s;	        s = t;	        t = tmp;	        n = m;	        m = t.length();	    }	    int[] p = new int[n + 1];	    int[] d = new int[n + 1];	    int[] _d;	    final int boundary = Math.min(n, threshold) + 1;	    for (int i = 0; i < boundary; i++) {	        p[i] = i;	    }	    Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);	    Arrays.fill(d, Integer.MAX_VALUE);	    for (int j = 1; j <= m; j++) {	        final char t_j = t.charAt(j - 1);	        d[0] = j;	        final int min = Math.max(1, j - threshold);	        final int max = Math.min(n, j + threshold);	        if (min > max) {	            return -1;	        }	        if (min > 1) {	            d[min - 1] = Integer.MAX_VALUE;	        }	        for (int i = min; i <= max; i++) {	            if (s.charAt(i - 1) == t_j) {	                d[i] = p[i - 1];	            } else {	                d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);	            }	        }	        _d = p;	        p = d;	        d = _d;	    }	    if (p[n] <= threshold) {	        return p[n];	    }	    return -1;	}
public String getNullText() {	    return nullText;	}
public static boolean containsOnly(final CharSequence cs, final String validChars) {	    if (cs == null || validChars == null) {	        return false;	    }	    return containsOnly(cs, validChars.toCharArray());	}
public static boolean isEmpty(final CharSequence cs) {	    return cs == null || cs.length() == 0;	}
public boolean isEmptyTokenAsNull() {	    return this.emptyAsNull;	}
protected String getArrayStart() {	    return arrayStart;	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public String getNullText() {	    return nullText;	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex) {	    return indexOf(throwable, clazz, fromIndex, false);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex) {	    return indexOf(throwable, clazz, fromIndex, false);	}
public boolean isEquals() {	    return this.isEquals;	}
public static String appendIfMissing(final String str, final CharSequence suffix, final CharSequence... suffixes) {	    return appendIfMissing(str, suffix, false, suffixes);	}
public static String capitalize(final String str) {	    int strLen;	    if (str == null || (strLen = str.length()) == 0) {	        return str;	    }	    char firstChar = str.charAt(0);	    if (Character.isTitleCase(firstChar)) {	        return str;	    }	    return new StringBuilder(strLen).append(Character.toTitleCase(firstChar)).append(str.substring(1)).toString();	}
public static String abbreviateMiddle(final String str, final String middle, final int length) {	    if (isEmpty(str) || isEmpty(middle)) {	        return str;	    }	    if (length >= str.length() || length < middle.length() + 2) {	        return str;	    }	    final int targetSting = length - middle.length();	    final int startOffset = targetSting / 2 + targetSting % 2;	    final int endOffset = str.length() - targetSting / 2;	    final StringBuilder builder = new StringBuilder(length);	    builder.append(str.substring(0, startOffset));	    builder.append(middle);	    builder.append(str.substring(endOffset));	    return builder.toString();	}
public StrBuilder deleteAll(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, -1);	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static char intToHexDigitMsb0(final int nibble) {	    switch(nibble) {	        case 0x0:	            return '0';	        case 0x1:	            return '8';	        case 0x2:	            return '4';	        case 0x3:	            return 'c';	        case 0x4:	            return '2';	        case 0x5:	            return 'a';	        case 0x6:	            return '6';	        case 0x7:	            return 'e';	        case 0x8:	            return '1';	        case 0x9:	            return '9';	        case 0xA:	            return '5';	        case 0xB:	            return 'd';	        case 0xC:	            return '3';	        case 0xD:	            return 'b';	        case 0xE:	            return '7';	        case 0xF:	            return 'f';	        default:	            throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble);	    }	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static String randomNumeric(final int count) {	    return random(count, false, true);	}
public char getStart() {	    return this.start;	}
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) {	    if (str == null) {	        if (trueString == null) {	            return Boolean.TRUE;	        }	        if (falseString == null) {	            return Boolean.FALSE;	        }	        if (nullString == null) {	            return null;	        }	    } else if (str.equals(trueString)) {	        return Boolean.TRUE;	    } else if (str.equals(falseString)) {	        return Boolean.FALSE;	    } else if (str.equals(nullString)) {	        return null;	    }	    throw new IllegalArgumentException("The String did not match any specified value");	}
public static Class<?>[] wrappersToPrimitives(final Class<?>... classes) {	    if (classes == null) {	        return null;	    }	    if (classes.length == 0) {	        return classes;	    }	    final Class<?>[] convertedClasses = new Class[classes.length];	    for (int i = 0; i < classes.length; i++) {	        convertedClasses[i] = wrapperToPrimitive(classes[i]);	    }	    return convertedClasses;	}
public long getStartTime() {	    if (this.runningState == STATE_UNSTARTED) {	        throw new IllegalStateException("Stopwatch has not been started");	    }	    return this.startTimeMillis;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public StrBuilder appendSeparator(final char separator, final int loopIndex) {	    if (loopIndex > 0) {	        append(separator);	    }	    return this;	}
static Object removeAll(final Object array, final BitSet indices) {	    final int srcLength = ArrayUtils.getLength(array);	    final int removals = indices.cardinality();	    final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals);	    int srcIndex = 0;	    int destIndex = 0;	    int count;	    int set;	    while ((set = indices.nextSetBit(srcIndex)) != -1) {	        count = set - srcIndex;	        if (count > 0) {	            System.arraycopy(array, srcIndex, result, destIndex, count);	            destIndex += count;	        }	        srcIndex = indices.nextClearBit(set);	    }	    count = srcLength - srcIndex;	    if (count > 0) {	        System.arraycopy(array, srcIndex, result, destIndex, count);	    }	    return result;	}
public static float min(final float a, final float b, final float c) {	    return Math.min(Math.min(a, b), c);	}
public static String chop(final String str) {	    if (str == null) {	        return null;	    }	    final int strLen = str.length();	    if (strLen < 2) {	        return EMPTY;	    }	    final int lastIdx = strLen - 1;	    final String ret = str.substring(0, lastIdx);	    final char last = str.charAt(lastIdx);	    if (last == CharUtils.LF && ret.charAt(lastIdx - 1) == CharUtils.CR) {	        return ret.substring(0, lastIdx - 1);	    }	    return ret;	}
public static String prependIfMissingIgnoreCase(final String str, final CharSequence prefix, final CharSequence... prefixes) {	    return prependIfMissing(str, prefix, true, prefixes);	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
@Override	public int compareTo(final Fraction other) {	    if (this == other) {	        return 0;	    }	    if (numerator == other.numerator && denominator == other.denominator) {	        return 0;	    }	    final long first = (long) numerator * (long) other.denominator;	    final long second = (long) other.numerator * (long) denominator;	    if (first == second) {	        return 0;	    } else if (first < second) {	        return -1;	    } else {	        return 1;	    }	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    if (input.charAt(index) == '\\' && index + 1 < input.length() && input.charAt(index + 1) == 'u') {	        int i = 2;	        while (index + i < input.length() && input.charAt(index + i) == 'u') {	            i++;	        }	        if (index + i < input.length() && input.charAt(index + i) == '+') {	            i++;	        }	        if (index + i + 4 <= input.length()) {	            final CharSequence unicode = input.subSequence(index + i, index + i + 4);	            try {	                final int value = Integer.parseInt(unicode.toString(), 16);	                out.write((char) value);	            } catch (final NumberFormatException nfe) {	                throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe);	            }	            return i + 4;	        } else {	            throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + input.subSequence(index, input.length()) + "' due to end of CharSequence");	        }	    }	    return 0;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static final String escapeJson(final String input) {	    return ESCAPE_JSON.translate(input);	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
public String getNullText() {	    return nullText;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public static char binaryToHexDigit(final boolean[] src, final int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    if (src.length > srcPos + 3 && src[srcPos + 3]) {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src[srcPos]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
protected boolean isUseClassName() {	    return useClassName;	}
public static Date truncate(final Object date, final int field) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (date instanceof Date) {	        return truncate((Date) date, field);	    } else if (date instanceof Calendar) {	        return truncate((Calendar) date, field).getTime();	    } else {	        throw new ClassCastException("Could not truncate " + date);	    }	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public final Boolean getDaemonFlag() {	    return daemonFlag;	}
public static boolean isAsciiAlphanumeric(final char ch) {	    return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9');	}
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) {	    if (bool == null) {	        return nullValue;	    }	    return bool.booleanValue() ? trueValue : falseValue;	}
public static String trim(final String str) {	    return str == null ? null : str.trim();	}
public void getChars(final int startIndex, final int endIndex, final char[] destination, final int destinationIndex) {	    if (startIndex < 0) {	        throw new StringIndexOutOfBoundsException(startIndex);	    }	    if (endIndex < 0 || endIndex > length()) {	        throw new StringIndexOutOfBoundsException(endIndex);	    }	    if (startIndex > endIndex) {	        throw new StringIndexOutOfBoundsException("end < start");	    }	    System.arraycopy(buffer, startIndex, destination, destinationIndex, endIndex - startIndex);	}
public static float max(final float a, final float b, final float c) {	    return Math.max(Math.max(a, b), c);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
private static String[] splitByCharacterType(final String str, final boolean camelCase) {	    if (str == null) {	        return null;	    }	    if (str.isEmpty()) {	        return ArrayUtils.EMPTY_STRING_ARRAY;	    }	    final char[] c = str.toCharArray();	    final List<String> list = new ArrayList<String>();	    int tokenStart = 0;	    int currentType = Character.getType(c[tokenStart]);	    for (int pos = tokenStart + 1; pos < c.length; pos++) {	        final int type = Character.getType(c[pos]);	        if (type == currentType) {	            continue;	        }	        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {	            final int newTokenStart = pos - 1;	            if (newTokenStart != tokenStart) {	                list.add(new String(c, tokenStart, newTokenStart - tokenStart));	                tokenStart = newTokenStart;	            }	        } else {	            list.add(new String(c, tokenStart, pos - tokenStart));	            tokenStart = pos;	        }	        currentType = type;	    }	    list.add(new String(c, tokenStart, c.length - tokenStart));	    return list.toArray(new String[list.size()]);	}
public static String getShortCanonicalName(final String canonicalName) {	    return ClassUtils.getShortClassName(getCanonicalName(canonicalName));	}
public static StrLookup<String> systemPropertiesLookup() {	    return SYSTEM_PROPERTIES_LOOKUP;	}
public static void isTrue(final boolean expression) {	    if (expression == false) {	        throw new IllegalArgumentException(DEFAULT_IS_TRUE_EX_MESSAGE);	    }	}
public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) {	    if (src.length > 8) {	        throw new IllegalArgumentException("src.length>8: src.length=" + src.length);	    }	    if (src.length - srcPos < 4) {	        throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos);	    }	    if (src[srcPos + 3]) {	        if (src[srcPos + 2]) {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return '7';	                }	            } else {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return '3';	                }	            }	        } else {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return '5';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '1';	                }	            }	        }	    } else {	        if (src[srcPos + 2]) {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'e';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return 'a';	                } else {	                    return '2';	                }	            }	        } else {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'c';	                } else {	                    return '4';	                }	            } else {	                if (src[srcPos]) {	                    return '8';	                } else {	                    return '0';	                }	            }	        }	    }	}
@Override	public int length() {	    return size;	}
public boolean contains(final StrMatcher matcher) {	    return indexOf(matcher, 0) >= 0;	}
protected boolean isArrayContentDetail() {	    return arrayContentDetail;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public static String getPackageName(String className) {	    if (StringUtils.isEmpty(className)) {	        return StringUtils.EMPTY;	    }	    while (className.charAt(0) == '[') {	        className = className.substring(1);	    }	    if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {	        className = className.substring(1);	    }	    final int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);	    if (i == -1) {	        return StringUtils.EMPTY;	    }	    return className.substring(0, i);	}
public boolean isEmpty() {	    return size == 0;	}
public static final String escapeHtml4(final String input) {	    return ESCAPE_HTML4.translate(input);	}
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, true);	}
public static int indexOfAnyBut(final CharSequence seq, final CharSequence searchChars) {	    if (isEmpty(seq) || isEmpty(searchChars)) {	        return INDEX_NOT_FOUND;	    }	    final int strLen = seq.length();	    for (int i = 0; i < strLen; i++) {	        final char ch = seq.charAt(i);	        final boolean chFound = CharSequenceUtils.indexOf(searchChars, ch, 0) >= 0;	        if (i + 1 < strLen && Character.isHighSurrogate(ch)) {	            final char ch2 = seq.charAt(i + 1);	            if (chFound && CharSequenceUtils.indexOf(searchChars, ch2, 0) < 0) {	                return i;	            }	        } else {	            if (!chFound) {	                return i;	            }	        }	    }	    return INDEX_NOT_FOUND;	}
protected String getFieldNameValueSeparator() {	    return fieldNameValueSeparator;	}
public final void translate(final CharSequence input, final Writer out) throws IOException {	    if (out == null) {	        throw new IllegalArgumentException("The Writer must not be null");	    }	    if (input == null) {	        return;	    }	    int pos = 0;	    final int len = input.length();	    while (pos < len) {	        final int consumed = translate(input, pos, out);	        if (consumed == 0) {	            final char[] c = Character.toChars(Character.codePointAt(input, pos));	            out.write(c);	            pos += c.length;	            continue;	        }	        for (int pt = 0; pt < consumed; pt++) {	            pos += Character.charCount(Character.codePointAt(input, pt));	        }	    }	}
public static double[] addAll(final double[] array1, final double... array2) {	    if (array1 == null) {	        return clone(array2);	    } else if (array2 == null) {	        return clone(array1);	    }	    final double[] joinedArray = new double[array1.length + array2.length];	    System.arraycopy(array1, 0, joinedArray, 0, array1.length);	    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);	    return joinedArray;	}
public void increment() {	    value++;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts) {	    if (0 == nInts) {	        return dst;	    }	    if ((nInts - 1) * 32 + srcPos >= 64) {	        throw new IllegalArgumentException("(nInts-1)*32+srcPos is greather or equal to than 64");	    }	    int shift = 0;	    for (int i = 0; i < nInts; i++) {	        shift = i * 32 + srcPos;	        dst[dstPos + i] = (int) (0xffffffff & (src >> shift));	    }	    return dst;	}
static Object removeAll(final Object array, final BitSet indices) {	    final int srcLength = ArrayUtils.getLength(array);	    final int removals = indices.cardinality();	    final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals);	    int srcIndex = 0;	    int destIndex = 0;	    int count;	    int set;	    while ((set = indices.nextSetBit(srcIndex)) != -1) {	        count = set - srcIndex;	        if (count > 0) {	            System.arraycopy(array, srcIndex, result, destIndex, count);	            destIndex += count;	        }	        srcIndex = indices.nextClearBit(set);	    }	    count = srcLength - srcIndex;	    if (count > 0) {	        System.arraycopy(array, srcIndex, result, destIndex, count);	    }	    return result;	}
public static <T extends CharSequence> T notEmpty(final T chars) {	    return notEmpty(chars, DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE);	}
protected boolean isFieldSeparatorAtStart() {	    return fieldSeparatorAtStart;	}
public int capacity() {	    return buffer.length;	}
public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2) {	    if (cal1 == null || cal2 == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.getClass() == cal2.getClass());	}
@Override	public Set<String> getContextLabels() {	    return exceptionContext.getContextLabels();	}
public static char binaryToHexDigit(final boolean[] src, final int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    if (src.length > srcPos + 3 && src[srcPos + 3]) {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src[srcPos]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass) {	    if (throwable == null || type == null) {	        return -1;	    }	    if (fromIndex < 0) {	        fromIndex = 0;	    }	    final Throwable[] throwables = ExceptionUtils.getThrowables(throwable);	    if (fromIndex >= throwables.length) {	        return -1;	    }	    if (subclass) {	        for (int i = fromIndex; i < throwables.length; i++) {	            if (type.isAssignableFrom(throwables[i].getClass())) {	                return i;	            }	        }	    } else {	        for (int i = fromIndex; i < throwables.length; i++) {	            if (type.equals(throwables[i].getClass())) {	                return i;	            }	        }	    }	    return -1;	}
public static Date setSeconds(final Date date, final int amount) {	    return set(date, Calendar.SECOND, amount);	}
@Override	public StringBuffer format(final Calendar calendar, final StringBuffer buf) {	    return applyRules(calendar, buf);	}
@Override	public Object getFirstContextValue(final String label) {	    return this.exceptionContext.getFirstContextValue(label);	}
public int capacity() {	    return buffer.length;	}
public static boolean isAscii(final char ch) {	    return ch < 128;	}
@Override	public double doubleValue() {	    return value;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static String replaceEachRepeatedly(final String text, final String[] searchList, final String[] replacementList) {	    final int timeToLive = searchList == null ? 0 : searchList.length;	    return replaceEach(text, searchList, replacementList, true, timeToLive);	}
public static String[][] JAVA_CTRL_CHARS_UNESCAPE() {	    return JAVA_CTRL_CHARS_UNESCAPE.clone();	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static String removePattern(final String source, final String regex) {	    return replacePattern(source, regex, StringUtils.EMPTY);	}
public static void matchesPattern(final CharSequence input, final String pattern, final String message, final Object... values) {	    if (Pattern.matches(pattern, input) == false) {	        throw new IllegalArgumentException(String.format(message, values));	    }	}
public void increment() {	    value++;	}
public static boolean containsOnly(final CharSequence cs, final String validChars) {	    if (cs == null || validChars == null) {	        return false;	    }	    return containsOnly(cs, validChars.toCharArray());	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public String getNullText() {	    return nullText;	}
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) {	    final StringBuilder buffer = new StringBuilder();	    boolean lastOutputSeconds = false;	    final int sz = tokens.length;	    for (int i = 0; i < sz; i++) {	        final Token token = tokens[i];	        final Object value = token.getValue();	        final int count = token.getCount();	        if (value instanceof StringBuilder) {	            buffer.append(value.toString());	        } else {	            if (value == y) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years));	                lastOutputSeconds = false;	            } else if (value == M) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months));	                lastOutputSeconds = false;	            } else if (value == d) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days));	                lastOutputSeconds = false;	            } else if (value == H) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours));	                lastOutputSeconds = false;	            } else if (value == m) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes));	                lastOutputSeconds = false;	            } else if (value == s) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds));	                lastOutputSeconds = true;	            } else if (value == S) {	                if (lastOutputSeconds) {	                    milliseconds += 1000;	                    final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds);	                    buffer.append(str.substring(1));	                } else {	                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds));	                }	                lastOutputSeconds = false;	            }	        }	    }	    return buffer.toString();	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static String overlay(final String str, String overlay, int start, int end) {	    if (str == null) {	        return null;	    }	    if (overlay == null) {	        overlay = EMPTY;	    }	    final int len = str.length();	    if (start < 0) {	        start = 0;	    }	    if (start > len) {	        start = len;	    }	    if (end < 0) {	        end = 0;	    }	    if (end > len) {	        end = len;	    }	    if (start > end) {	        final int temp = start;	        start = end;	        end = temp;	    }	    return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString();	}
public char getEscapeChar() {	    return this.escapeChar;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static String repeat(final char ch, final int repeat) {	    final char[] buf = new char[repeat];	    for (int i = repeat - 1; i >= 0; i--) {	        buf[i] = ch;	    }	    return new String(buf);	}
@Override	public StringBuffer format(final Calendar calendar, final StringBuffer buf) {	    return applyRules(calendar, buf);	}
protected int validateRange(final int startIndex, int endIndex) {	    if (startIndex < 0) {	        throw new StringIndexOutOfBoundsException(startIndex);	    }	    if (endIndex > size) {	        endIndex = size;	    }	    if (startIndex > endIndex) {	        throw new StringIndexOutOfBoundsException("end < start");	    }	    return endIndex;	}
public StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, 1);	}
public static int hexDigitMsb0ToInt(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return 0x0;	        case '1':	            return 0x8;	        case '2':	            return 0x4;	        case '3':	            return 0xC;	        case '4':	            return 0x2;	        case '5':	            return 0xA;	        case '6':	            return 0x6;	        case '7':	            return 0xE;	        case '8':	            return 0x1;	        case '9':	            return 0x9;	        case 'a':	        case 'A':	            return 0x5;	        case 'b':	        case 'B':	            return 0xD;	        case 'c':	        case 'C':	            return 0x3;	        case 'd':	        case 'D':	            return 0xB;	        case 'e':	        case 'E':	            return 0x7;	        case 'f':	        case 'F':	            return 0xF;	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public int size() {	    return size;	}
public static String[] stripAll(final String[] strs, final String stripChars) {	    int strsLen;	    if (strs == null || (strsLen = strs.length) == 0) {	        return strs;	    }	    final String[] newArr = new String[strsLen];	    for (int i = 0; i < strsLen; i++) {	        newArr[i] = strip(strs[i], stripChars);	    }	    return newArr;	}
public String getNewLineText() {	    return newLine;	}
public static String repeat(final char ch, final int repeat) {	    final char[] buf = new char[repeat];	    for (int i = repeat - 1; i >= 0; i--) {	        buf[i] = ch;	    }	    return new String(buf);	}
@Override	public String getContentStart() {	    return super.getContentStart();	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
@Override	public DefaultExceptionContext addContextValue(final String label, final Object value) {	    contextValues.add(new ImmutablePair<String, Object>(label, value));	    return this;	}
public static int hashCode(final Object obj) {	    return obj == null ? 0 : obj.hashCode();	}
@Override	public int length() {	    return size;	}
public static <T> T invokeExactConstructor(final Class<T> cls, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {	    if (args == null) {	        args = ArrayUtils.EMPTY_OBJECT_ARRAY;	    }	    if (parameterTypes == null) {	        parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;	    }	    final Constructor<T> ctor = getAccessibleConstructor(cls, parameterTypes);	    if (ctor == null) {	        throw new NoSuchMethodException("No such accessible constructor on object: " + cls.getName());	    }	    return ctor.newInstance(args);	}
public static int lastIndexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = INDEX_NOT_FOUND;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.lastIndexOf(str, search, str.length());	        if (tmp > ret) {	            ret = tmp;	        }	    }	    return ret;	}
public String getNullText() {	    return nullText;	}
public static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts) {	    if ((src.length == 0 && srcPos == 0) || 0 == nInts) {	        return dstInit;	    }	    if ((nInts - 1) * 32 + dstPos >= 64) {	        throw new IllegalArgumentException("(nInts-1)*32+dstPos is greather or equal to than 64");	    }	    long out = dstInit;	    int shift = 0;	    for (int i = 0; i < nInts; i++) {	        shift = i * 32 + dstPos;	        final long bits = ((0xffffffffL & src[i + srcPos]) << shift);	        final long mask = 0xffffffffL << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
@Override	public Integer build() {	    return Integer.valueOf(toHashCode());	}
public int capacity() {	    return buffer.length;	}
public static String rightPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return rightPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return str.concat(padStr);	    } else if (pads < padLen) {	        return str.concat(padStr.substring(0, pads));	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return str.concat(new String(padding));	    }	}
public StrBuilder appendSeparator(final char separator, final int loopIndex) {	    if (loopIndex > 0) {	        append(separator);	    }	    return this;	}
@Override	public void setValue(final Number value) {	    this.value = value.longValue();	}
@Deprecated	public static String chomp(final String str, final String separator) {	    return removeEnd(str, separator);	}
@Override	public int length() {	    return size;	}
public static String prependIfMissingIgnoreCase(final String str, final CharSequence prefix, final CharSequence... prefixes) {	    return prependIfMissing(str, prefix, true, prefixes);	}
protected String getSummaryObjectEndText() {	    return summaryObjectEndText;	}
public static String prependIfMissingIgnoreCase(final String str, final CharSequence prefix, final CharSequence... prefixes) {	    return prependIfMissing(str, prefix, true, prefixes);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static String abbreviate(final String str, int offset, final int maxWidth) {	    if (str == null) {	        return null;	    }	    if (maxWidth < 4) {	        throw new IllegalArgumentException("Minimum abbreviation width is 4");	    }	    if (str.length() <= maxWidth) {	        return str;	    }	    if (offset > str.length()) {	        offset = str.length();	    }	    if (str.length() - offset < maxWidth - 3) {	        offset = str.length() - (maxWidth - 3);	    }	    final String abrevMarker = "...";	    if (offset <= 4) {	        return str.substring(0, maxWidth - 3) + abrevMarker;	    }	    if (maxWidth < 7) {	        throw new IllegalArgumentException("Minimum abbreviation width with offset is 7");	    }	    if (offset + maxWidth - 3 < str.length()) {	        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);	    }	    return abrevMarker + str.substring(str.length() - (maxWidth - 3));	}
public static boolean isEmpty(final CharSequence cs) {	    return cs == null || cs.length() == 0;	}
public static String right(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(str.length() - len);	}
public char getEnd() {	    return this.end;	}
@Override	public int length() {	    return size;	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
@Override	public String toString() {	    if (this.getObject() == null) {	        return this.getStyle().getNullText();	    }	    Class<?> clazz = this.getObject().getClass();	    this.appendFieldsIn(clazz);	    while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {	        clazz = clazz.getSuperclass();	        this.appendFieldsIn(clazz);	    }	    return super.toString();	}
@Override	public void setNullText(final String nullText) {	    super.setNullText(nullText);	}
public int size() {	    return size;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
@Override	public void setArrayEnd(final String arrayEnd) {	    super.setArrayEnd(arrayEnd);	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
@Override	public boolean equals(final Object obj) {	    if (this == obj) {	        return true;	    }	    if (obj instanceof TimeZoneDisplayKey) {	        final TimeZoneDisplayKey other = (TimeZoneDisplayKey) obj;	        return mTimeZone.equals(other.mTimeZone) && mStyle == other.mStyle && mLocale.equals(other.mLocale);	    }	    return false;	}
@Override	public String next() {	    if (hasNext()) {	        return tokens[tokenPos++];	    }	    throw new NoSuchElementException();	}
public static Date ceiling(final Object date, final int field) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (date instanceof Date) {	        return ceiling((Date) date, field);	    } else if (date instanceof Calendar) {	        return ceiling((Calendar) date, field).getTime();	    } else {	        throw new ClassCastException("Could not find ceiling of for type: " + date.getClass());	    }	}
@Override	public void setValue(final T value) {	    this.value = value;	}
public static void identityToString(final StringBuilder builder, final Object object) {	    if (object == null) {	        throw new NullPointerException("Cannot get the toString of a null identity");	    }	    builder.append(object.getClass().getName()).append('@').append(Integer.toHexString(System.identityHashCode(object)));	}
public int getNumerator() {	    return numerator;	}
@Override	public T get() throws ConcurrentException {	    try {	        return getFuture().get();	    } catch (final ExecutionException execex) {	        ConcurrentUtils.handleCause(execex);	        return null;	    } catch (final InterruptedException iex) {	        Thread.currentThread().interrupt();	        throw new ConcurrentException(iex);	    }	}
public static String deleteWhitespace(final String str) {	    if (isEmpty(str)) {	        return str;	    }	    final int sz = str.length();	    final char[] chs = new char[sz];	    int count = 0;	    for (int i = 0; i < sz; i++) {	        if (!Character.isWhitespace(str.charAt(i))) {	            chs[count++] = str.charAt(i);	        }	    }	    if (count == sz) {	        return str;	    }	    return new String(chs, 0, count);	}
public static StrTokenizer getTSVInstance(final char[] input) {	    final StrTokenizer tok = getTSVClone();	    tok.reset(input);	    return tok;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public static void identityToString(final StringBuilder builder, final Object object) {	    if (object == null) {	        throw new NullPointerException("Cannot get the toString of a null identity");	    }	    builder.append(object.getClass().getName()).append('@').append(Integer.toHexString(System.identityHashCode(object)));	}
public static String chop(final String str) {	    if (str == null) {	        return null;	    }	    final int strLen = str.length();	    if (strLen < 2) {	        return EMPTY;	    }	    final int lastIdx = strLen - 1;	    final String ret = str.substring(0, lastIdx);	    final char last = str.charAt(lastIdx);	    if (last == CharUtils.LF && ret.charAt(lastIdx - 1) == CharUtils.CR) {	        return ret.substring(0, lastIdx - 1);	    }	    return ret;	}
public Double toDouble() {	    return Double.valueOf(doubleValue());	}
public StrTokenizer setQuoteChar(final char quote) {	    return setQuoteMatcher(StrMatcher.charMatcher(quote));	}
public StrBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar) {	    return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);	}
@Override	public int previousIndex() {	    return tokenPos - 1;	}
public static <T extends Comparable<? super T>> T max(final T... values) {	    T result = null;	    if (values != null) {	        for (final T value : values) {	            if (compare(value, result, false) > 0) {	                result = value;	            }	        }	    }	    return result;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public CompareToBuilder appendSuper(final int superCompareTo) {	    if (comparison != 0) {	        return this;	    }	    comparison = superCompareTo;	    return this;	}
public boolean isEquals() {	    return this.isEquals;	}
public boolean contains(final StrMatcher matcher) {	    return indexOf(matcher, 0) >= 0;	}
public static void writeDeclaredStaticField(final Class<?> cls, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException {	    final Field field = getDeclaredField(cls, fieldName, forceAccess);	    if (field == null) {	        throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName);	    }	    writeField(field, (Object) null, value);	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public static boolean isAllLowerCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLowerCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
@Override	public int compareTo(final MutableFloat other) {	    final float anotherVal = other.value;	    return Float.compare(value, anotherVal);	}
public static String toString(final boolean bool, final String trueString, final String falseString) {	    return bool ? trueString : falseString;	}
@Override	public int length() {	    return size;	}
public int size() {	    return size;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
static boolean containsTokenWithValue(final Token[] tokens, final Object value) {	    final int sz = tokens.length;	    for (int i = 0; i < sz; i++) {	        if (tokens[i].getValue() == value) {	            return true;	        }	    }	    return false;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
@Override	public T get(final long timeout, final TimeUnit unit) {	    return value;	}
public static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {	    if (str == null || searchStr == null) {	        return INDEX_NOT_FOUND;	    }	    if (startPos < 0) {	        startPos = 0;	    }	    final int endLimit = str.length() - searchStr.length() + 1;	    if (startPos > endLimit) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return startPos;	    }	    for (int i = startPos; i < endLimit; i++) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return 0;	    }	    if (lhs == null || rhs == null) {	        throw new NullPointerException();	    }	    Class<?> lhsClazz = lhs.getClass();	    if (!lhsClazz.isInstance(rhs)) {	        throw new ClassCastException();	    }	    final CompareToBuilder compareToBuilder = new CompareToBuilder();	    reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);	    while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) {	        lhsClazz = lhsClazz.getSuperclass();	        reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);	    }	    return compareToBuilder.toComparison();	}
public char getEscapeChar() {	    return this.escapeChar;	}
@Override	public TimeZone getTimeZone() {	    return timeZone;	}
public static char toChar(final String str, final char defaultValue) {	    if (StringUtils.isEmpty(str)) {	        return defaultValue;	    }	    return str.charAt(0);	}
public String getNewLineText() {	    return newLine;	}
public int size() {	    return size;	}
public int size() {	    return size;	}
public static boolean isAlpha(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public final CharSequenceTranslator with(final CharSequenceTranslator... translators) {	    final CharSequenceTranslator[] newArray = new CharSequenceTranslator[translators.length + 1];	    newArray[0] = this;	    System.arraycopy(translators, 0, newArray, 1, translators.length);	    return new AggregateTranslator(newArray);	}
public static String formatUTC(final Date date, final String pattern, final Locale locale) {	    return format(date, pattern, UTC_TIME_ZONE, locale);	}
public final synchronized void setExternalExecutor(final ExecutorService externalExecutor) {	    if (isStarted()) {	        throw new IllegalStateException("Cannot set ExecutorService after start()!");	    }	    this.externalExecutor = externalExecutor;	}
@Override	public Object parseObject(final String source, final ParsePosition pos) {	    return parser.parseObject(source, pos);	}
public String getNewLineText() {	    return newLine;	}
public Class<?> getUpToClass() {	    return this.upToClass;	}
protected String getFieldNameValueSeparator() {	    return fieldNameValueSeparator;	}
public static String substringBetween(final String str, final String open, final String close) {	    if (str == null || open == null || close == null) {	        return null;	    }	    final int start = str.indexOf(open);	    if (start != INDEX_NOT_FOUND) {	        final int end = str.indexOf(close, start + open.length());	        if (end != INDEX_NOT_FOUND) {	            return str.substring(start + open.length(), end);	        }	    }	    return null;	}
public String getNewLineText() {	    return newLine;	}
@Override	public String getNullText() {	    return super.getNullText();	}
@Override	public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) {	    return buffer[pos] <= 32 ? 1 : 0;	}
public StrBuilder deleteFirst(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, 1);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
@Override	public String toPattern() {	    return toPattern;	}
public String getNewLineText() {	    return newLine;	}
public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final E... values) {	    asEnum(enumClass);	    Validate.noNullElements(values);	    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);	    Collections.addAll(condensed, values);	    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];	    for (final E value : condensed) {	        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);	    }	    ArrayUtils.reverse(result);	    return result;	}
public static String reverseDelimited(final String str, final char separatorChar) {	    if (str == null) {	        return null;	    }	    final String[] strs = split(str, separatorChar);	    ArrayUtils.reverse(strs);	    return join(strs, separatorChar);	}
public static boolean isAsciiAlpha(final char ch) {	    return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');	}
public boolean isEquals() {	    return this.isEquals;	}
public static boolean isNotEmpty(final boolean[] array) {	    return (array != null && array.length != 0);	}
@Override	public int intValue() {	    return value;	}
public static boolean isNotEmpty(final CharSequence cs) {	    return !StringUtils.isEmpty(cs);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public static String stripToNull(String str) {	    if (str == null) {	        return null;	    }	    str = strip(str, null);	    return str.isEmpty() ? null : str;	}
private static String[] splitByCharacterType(final String str, final boolean camelCase) {	    if (str == null) {	        return null;	    }	    if (str.isEmpty()) {	        return ArrayUtils.EMPTY_STRING_ARRAY;	    }	    final char[] c = str.toCharArray();	    final List<String> list = new ArrayList<String>();	    int tokenStart = 0;	    int currentType = Character.getType(c[tokenStart]);	    for (int pos = tokenStart + 1; pos < c.length; pos++) {	        final int type = Character.getType(c[pos]);	        if (type == currentType) {	            continue;	        }	        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {	            final int newTokenStart = pos - 1;	            if (newTokenStart != tokenStart) {	                list.add(new String(c, tokenStart, newTokenStart - tokenStart));	                tokenStart = newTokenStart;	            }	        } else {	            list.add(new String(c, tokenStart, pos - tokenStart));	            tokenStart = pos;	        }	        currentType = type;	    }	    list.add(new String(c, tokenStart, c.length - tokenStart));	    return list.toArray(new String[list.size()]);	}
@Override	public L getLeft() {	    return left;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof FastDateFormat == false) {	        return false;	    }	    final FastDateFormat other = (FastDateFormat) obj;	    return printer.equals(other.printer);	}
@Override	public boolean isCancelled() {	    return false;	}
public StrTokenizer setIgnoredChar(final char ignored) {	    return setIgnoredMatcher(StrMatcher.charMatcher(ignored));	}
public static boolean[] removeElements(final boolean[] array, final boolean... values) {	    if (isEmpty(array) || isEmpty(values)) {	        return clone(array);	    }	    final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2);	    for (final boolean v : values) {	        final Boolean boxed = Boolean.valueOf(v);	        final MutableInt count = occurrences.get(boxed);	        if (count == null) {	            occurrences.put(boxed, new MutableInt(1));	        } else {	            count.increment();	        }	    }	    final BitSet toRemove = new BitSet();	    for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) {	        final Boolean v = e.getKey();	        int found = 0;	        for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {	            found = indexOf(array, v.booleanValue(), found);	            if (found < 0) {	                break;	            }	            toRemove.set(found++);	        }	    }	    return (boolean[]) removeAll(array, toRemove);	}
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) {	    return new Range<T>(fromInclusive, toInclusive, comparator);	}
public static StrTokenizer getTSVInstance(final char[] input) {	    final StrTokenizer tok = getTSVClone();	    tok.reset(input);	    return tok;	}
public static String replacePattern(final String source, final String regex, final String replacement) {	    return Pattern.compile(regex, Pattern.DOTALL).matcher(source).replaceAll(replacement);	}
@Override	public int hashCode() {	    return toHashCode();	}
public String getNullText() {	    return nullText;	}
@Override	public String toString() {	    return StringUtils.repeat(this.value.toString(), this.count);	}
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, true);	}
public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values) {	    final EnumSet<E> results = EnumSet.noneOf(asEnum(enumClass));	    values = ArrayUtils.clone(Validate.notNull(values));	    ArrayUtils.reverse(values);	    for (final E constant : enumClass.getEnumConstants()) {	        final int block = constant.ordinal() / Long.SIZE;	        if (block < values.length && (values[block] & 1 << (constant.ordinal() % Long.SIZE)) != 0) {	            results.add(constant);	        }	    }	    return results;	}
public static List<Field> getAllFieldsList(Class<?> cls) {	    if (cls == null) {	        throw new IllegalArgumentException("The class must not be null");	    }	    List<Field> allFields = new ArrayList<Field>();	    Class<?> currentClass = cls;	    while (currentClass != null) {	        final Field[] declaredFields = currentClass.getDeclaredFields();	        for (Field field : declaredFields) {	            allFields.add(field);	        }	        currentClass = currentClass.getSuperclass();	    }	    return allFields;	}
@Override	public void close() {	}
public static boolean isAllUpperCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isUpperCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
@Override	public StringBuffer format(final Calendar calendar, final StringBuffer buf) {	    return printer.format(calendar, buf);	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
protected abstract T initialize() throws Exception;
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static int toIntValue(final Character ch, final int defaultValue) {	    if (ch == null) {	        return defaultValue;	    }	    return toIntValue(ch.charValue(), defaultValue);	}
public static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) {	    if (0 == nBools) {	        return dst;	    }	    if (nBools - 1 + srcPos >= 64) {	        throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 64");	    }	    int shift = 0;	    for (int i = 0; i < nBools; i++) {	        shift = i * 1 + srcPos;	        dst[dstPos + i] = ((0x1 & (src >> shift)) != 0);	    }	    return dst;	}
public static String prependIfMissingIgnoreCase(final String str, final CharSequence prefix, final CharSequence... prefixes) {	    return prependIfMissing(str, prefix, true, prefixes);	}
@Override	public BasicThreadFactory build() {	    final BasicThreadFactory factory = new BasicThreadFactory(this);	    reset();	    return factory;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
protected String getFieldSeparator() {	    return fieldSeparator;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    appendSummarySize(buffer, fieldName, array.length);	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public void increment() {	    value++;	}
public boolean isEmpty() {	    return size == 0;	}
protected String getArrayStart() {	    return arrayStart;	}
public boolean contains(final T element) {	    if (element == null) {	        return false;	    }	    return comparator.compare(element, minimum) > -1 && comparator.compare(element, maximum) < 1;	}
public static String overlay(final String str, String overlay, int start, int end) {	    if (str == null) {	        return null;	    }	    if (overlay == null) {	        overlay = EMPTY;	    }	    final int len = str.length();	    if (start < 0) {	        start = 0;	    }	    if (start > len) {	        start = len;	    }	    if (end < 0) {	        end = 0;	    }	    if (end > len) {	        end = len;	    }	    if (start > end) {	        final int temp = start;	        start = end;	        end = temp;	    }	    return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString();	}
public static String getPackageName(String className) {	    if (StringUtils.isEmpty(className)) {	        return StringUtils.EMPTY;	    }	    while (className.charAt(0) == '[') {	        className = className.substring(1);	    }	    if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {	        className = className.substring(1);	    }	    final int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);	    if (i == -1) {	        return StringUtils.EMPTY;	    }	    return className.substring(0, i);	}
public boolean isEmpty() {	    return size == 0;	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width, final int precision, final char padChar, final CharSequence ellipsis) {	    Validate.isTrue(ellipsis == null || precision < 0 || ellipsis.length() <= precision, "Specified ellipsis '%1$s' exceeds precision of %2$s", ellipsis, Integer.valueOf(precision));	    final StringBuilder buf = new StringBuilder(seq);	    if (precision >= 0 && precision < seq.length()) {	        final CharSequence _ellipsis = ObjectUtils.defaultIfNull(ellipsis, StringUtils.EMPTY);	        buf.replace(precision - _ellipsis.length(), seq.length(), _ellipsis.toString());	    }	    final boolean leftJustify = (flags & LEFT_JUSTIFY) == LEFT_JUSTIFY;	    for (int i = buf.length(); i < width; i++) {	        buf.insert(leftJustify ? i : 0, padChar);	    }	    formatter.format(buf.toString());	    return formatter;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale) {	    return cache.getTimeInstance(style, timeZone, locale);	}
public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale) {	    return cache.getDateTimeInstance(dateStyle, timeStyle, timeZone, locale);	}
public static String stripToEmpty(final String str) {	    return str == null ? EMPTY : strip(str, null);	}
public static String[] splitByWholeSeparatorPreserveAllTokens(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, true);	}
public static <T> Range<T> is(final T element, final Comparator<T> comparator) {	    return between(element, element, comparator);	}
public boolean isEquals() {	    return this.isEquals;	}
public int capacity() {	    return buffer.length;	}
public void appendStart(final StringBuffer buffer, final Object object) {	    if (object != null) {	        appendClassName(buffer, object);	        appendIdentityHashCode(buffer, object);	        appendContentStart(buffer);	        if (fieldSeparatorAtStart) {	            appendFieldSeparator(buffer);	        }	    }	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public String getNullText() {	    return nullText;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static String difference(final String str1, final String str2) {	    if (str1 == null) {	        return str2;	    }	    if (str2 == null) {	        return str1;	    }	    final int at = indexOfDifference(str1, str2);	    if (at == INDEX_NOT_FOUND) {	        return EMPTY;	    }	    return str2.substring(at);	}
@Override	protected T initialize() throws Exception {	    return callable.call();	}
public int getDenominator() {	    return denominator;	}
@Override	public int length() {	    return size;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public int indexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex < 0 ? 0 : startIndex);	    if (matcher == null || startIndex >= size) {	        return -1;	    }	    final int len = size;	    final char[] buf = buffer;	    for (int i = startIndex; i < len; i++) {	        if (matcher.isMatch(buf, i, startIndex, len) > 0) {	            return i;	        }	    }	    return -1;	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) {	    return new Range<T>(fromInclusive, toInclusive, comparator);	}
public static boolean isAllUpperCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isUpperCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
protected String getSizeStartText() {	    return sizeStartText;	}
public static String appendIfMissing(final String str, final CharSequence suffix, final CharSequence... suffixes) {	    return appendIfMissing(str, suffix, false, suffixes);	}
@Override	public String toPattern() {	    return toPattern;	}
static boolean isAccessible(final Member m) {	    return m != null && Modifier.isPublic(m.getModifiers()) && !m.isSynthetic();	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
public int toComparison() {	    return comparison;	}
public static boolean isNumeric(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isDigit(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
@Override	public String lookup(final String key) {	    if (map == null) {	        return null;	    }	    final Object obj = map.get(key);	    if (obj == null) {	        return null;	    }	    return obj.toString();	}
public boolean replaceIn(final StrBuilder source, final int offset, final int length) {	    if (source == null) {	        return false;	    }	    return substitute(source, offset, length);	}
protected String getArrayStart() {	    return arrayStart;	}
@Override	public int length() {	    return size;	}
@Override	public CharSequence subSequence(final int startIndex, final int endIndex) {	    if (startIndex < 0) {	        throw new StringIndexOutOfBoundsException(startIndex);	    }	    if (endIndex > size) {	        throw new StringIndexOutOfBoundsException(endIndex);	    }	    if (startIndex > endIndex) {	        throw new StringIndexOutOfBoundsException(endIndex - startIndex);	    }	    return substring(startIndex, endIndex);	}
protected String getArrayStart() {	    return arrayStart;	}
public String getNewLineText() {	    return newLine;	}
@Override	public TimeZone getTimeZone() {	    return timeZone;	}
@Override	public Integer build() {	    return Integer.valueOf(toHashCode());	}
@Override	public int length() {	    return size;	}
public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) {	    final Token[] tokens = lexx(format);	    final Calendar start = Calendar.getInstance(timezone);	    start.setTime(new Date(startMillis));	    final Calendar end = Calendar.getInstance(timezone);	    end.setTime(new Date(endMillis));	    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);	    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);	    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);	    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);	    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);	    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);	    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);	    while (milliseconds < 0) {	        milliseconds += 1000;	        seconds -= 1;	    }	    while (seconds < 0) {	        seconds += 60;	        minutes -= 1;	    }	    while (minutes < 0) {	        minutes += 60;	        hours -= 1;	    }	    while (hours < 0) {	        hours += 24;	        days -= 1;	    }	    if (Token.containsTokenWithValue(tokens, M)) {	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	        while (months < 0) {	            months += 12;	            years -= 1;	        }	        if (!Token.containsTokenWithValue(tokens, y) && years != 0) {	            while (years != 0) {	                months += 12 * years;	                years = 0;	            }	        }	    } else {	        if (!Token.containsTokenWithValue(tokens, y)) {	            int target = end.get(Calendar.YEAR);	            if (months < 0) {	                target -= 1;	            }	            while (start.get(Calendar.YEAR) != target) {	                days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);	                if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) {	                    days += 1;	                }	                start.add(Calendar.YEAR, 1);	                days += start.get(Calendar.DAY_OF_YEAR);	            }	            years = 0;	        }	        while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            start.add(Calendar.MONTH, 1);	        }	        months = 0;	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	    }	    if (!Token.containsTokenWithValue(tokens, d)) {	        hours += 24 * days;	        days = 0;	    }	    if (!Token.containsTokenWithValue(tokens, H)) {	        minutes += 60 * hours;	        hours = 0;	    }	    if (!Token.containsTokenWithValue(tokens, m)) {	        seconds += 60 * minutes;	        minutes = 0;	    }	    if (!Token.containsTokenWithValue(tokens, s)) {	        milliseconds += 1000 * seconds;	        seconds = 0;	    }	    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
public static Number createNumber(final String str) throws NumberFormatException {	    if (str == null) {	        return null;	    }	    if (StringUtils.isBlank(str)) {	        throw new NumberFormatException("A blank string is not a valid number");	    }	    final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" };	    int pfxLen = 0;	    for (final String pfx : hex_prefixes) {	        if (str.startsWith(pfx)) {	            pfxLen += pfx.length();	            break;	        }	    }	    if (pfxLen > 0) {	        final int hexDigits = str.length() - pfxLen;	        if (hexDigits > 16) {	            return createBigInteger(str);	        }	        if (hexDigits > 8) {	            return createLong(str);	        }	        return createInteger(str);	    }	    final char lastChar = str.charAt(str.length() - 1);	    String mant;	    String dec;	    String exp;	    final int decPos = str.indexOf('.');	    final int expPos = str.indexOf('e') + str.indexOf('E') + 1;	    int numDecimals = 0;	    if (decPos > -1) {	        if (expPos > -1) {	            if (expPos < decPos || expPos > str.length()) {	                throw new NumberFormatException(str + " is not a valid number.");	            }	            dec = str.substring(decPos + 1, expPos);	        } else {	            dec = str.substring(decPos + 1);	        }	        mant = str.substring(0, decPos);	        numDecimals = dec.length();	    } else {	        if (expPos > -1) {	            if (expPos > str.length()) {	                throw new NumberFormatException(str + " is not a valid number.");	            }	            mant = str.substring(0, expPos);	        } else {	            mant = str;	        }	        dec = null;	    }	    if (!Character.isDigit(lastChar) && lastChar != '.') {	        if (expPos > -1 && expPos < str.length() - 1) {	            exp = str.substring(expPos + 1, str.length() - 1);	        } else {	            exp = null;	        }	        final String numeric = str.substring(0, str.length() - 1);	        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);	        switch(lastChar) {	            case 'l':	            case 'L':	                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {	                    try {	                        return createLong(numeric);	                    } catch (final NumberFormatException nfe) {	                    }	                    return createBigInteger(numeric);	                }	                throw new NumberFormatException(str + " is not a valid number.");	            case 'f':	            case 'F':	                try {	                    final Float f = NumberUtils.createFloat(numeric);	                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {	                        return f;	                    }	                } catch (final NumberFormatException nfe) {	                }	            case 'd':	            case 'D':	                try {	                    final Double d = NumberUtils.createDouble(numeric);	                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {	                        return d;	                    }	                } catch (final NumberFormatException nfe) {	                }	                try {	                    return createBigDecimal(numeric);	                } catch (final NumberFormatException e) {	                }	            default:	                throw new NumberFormatException(str + " is not a valid number.");	        }	    }	    if (expPos > -1 && expPos < str.length() - 1) {	        exp = str.substring(expPos + 1, str.length());	    } else {	        exp = null;	    }	    if (dec == null && exp == null) {	        try {	            return createInteger(str);	        } catch (final NumberFormatException nfe) {	        }	        try {	            return createLong(str);	        } catch (final NumberFormatException nfe) {	        }	        return createBigInteger(str);	    }	    final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);	    try {	        if (numDecimals <= 7) {	            final Float f = createFloat(str);	            if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {	                return f;	            }	        }	    } catch (final NumberFormatException nfe) {	    }	    try {	        if (numDecimals <= 16) {	            final Double d = createDouble(str);	            if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {	                return d;	            }	        }	    } catch (final NumberFormatException nfe) {	    }	    return createBigDecimal(str);	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public StrBuilder deleteAll(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, -1);	}
public static boolean isAsciiPrintable(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) {	    final Token[] tokens = lexx(format);	    final Calendar start = Calendar.getInstance(timezone);	    start.setTime(new Date(startMillis));	    final Calendar end = Calendar.getInstance(timezone);	    end.setTime(new Date(endMillis));	    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);	    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);	    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);	    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);	    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);	    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);	    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);	    while (milliseconds < 0) {	        milliseconds += 1000;	        seconds -= 1;	    }	    while (seconds < 0) {	        seconds += 60;	        minutes -= 1;	    }	    while (minutes < 0) {	        minutes += 60;	        hours -= 1;	    }	    while (hours < 0) {	        hours += 24;	        days -= 1;	    }	    if (Token.containsTokenWithValue(tokens, M)) {	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	        while (months < 0) {	            months += 12;	            years -= 1;	        }	        if (!Token.containsTokenWithValue(tokens, y) && years != 0) {	            while (years != 0) {	                months += 12 * years;	                years = 0;	            }	        }	    } else {	        if (!Token.containsTokenWithValue(tokens, y)) {	            int target = end.get(Calendar.YEAR);	            if (months < 0) {	                target -= 1;	            }	            while (start.get(Calendar.YEAR) != target) {	                days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);	                if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) {	                    days += 1;	                }	                start.add(Calendar.YEAR, 1);	                days += start.get(Calendar.DAY_OF_YEAR);	            }	            years = 0;	        }	        while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            start.add(Calendar.MONTH, 1);	        }	        months = 0;	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	    }	    if (!Token.containsTokenWithValue(tokens, d)) {	        hours += 24 * days;	        days = 0;	    }	    if (!Token.containsTokenWithValue(tokens, H)) {	        minutes += 60 * hours;	        hours = 0;	    }	    if (!Token.containsTokenWithValue(tokens, m)) {	        seconds += 60 * minutes;	        minutes = 0;	    }	    if (!Token.containsTokenWithValue(tokens, s)) {	        milliseconds += 1000 * seconds;	        seconds = 0;	    }	    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public boolean isEmpty() {	    return size == 0;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
@Override	public int hashCode() {	    return toHashCode();	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public char getStart() {	    return this.start;	}
public int size() {	    return size;	}
@Override	public int length() {	    return size;	}
public static double[] addAll(final double[] array1, final double... array2) {	    if (array1 == null) {	        return clone(array2);	    } else if (array2 == null) {	        return clone(array1);	    }	    final double[] joinedArray = new double[array1.length + array2.length];	    System.arraycopy(array1, 0, joinedArray, 0, array1.length);	    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);	    return joinedArray;	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public static boolean isAscii(final char ch) {	    return ch < 128;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
public static String formatDuration(long durationMillis, final String format, final boolean padWithZeros) {	    final Token[] tokens = lexx(format);	    int days = 0;	    int hours = 0;	    int minutes = 0;	    int seconds = 0;	    int milliseconds = 0;	    if (Token.containsTokenWithValue(tokens, d)) {	        days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY);	        durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY);	    }	    if (Token.containsTokenWithValue(tokens, H)) {	        hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR);	        durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR);	    }	    if (Token.containsTokenWithValue(tokens, m)) {	        minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE);	        durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE);	    }	    if (Token.containsTokenWithValue(tokens, s)) {	        seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND);	        durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND);	    }	    if (Token.containsTokenWithValue(tokens, S)) {	        milliseconds = (int) durationMillis;	    }	    return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
public HashCodeBuilder append(final short[] array) {	    if (array == null) {	        iTotal = iTotal * iConstant;	    } else {	        for (final short element : array) {	            append(element);	        }	    }	    return this;	}
protected boolean isUseShortClassName() {	    return useShortClassName;	}
static int compareParameterTypes(final Class<?>[] left, final Class<?>[] right, final Class<?>[] actual) {	    final float leftCost = getTotalTransformationCost(actual, left);	    final float rightCost = getTotalTransformationCost(actual, right);	    return leftCost < rightCost ? -1 : rightCost < leftCost ? 1 : 0;	}
public static int reflectionHashCode(final Object object, final String... excludeFields) {	    return reflectionHashCode(17, 37, object, false, null, excludeFields);	}
synchronized void endOfPeriod() {	    lastCallsPerPeriod = acquireCount;	    totalAcquireCount += acquireCount;	    periodCount++;	    acquireCount = 0;	    notifyAll();	}
@Override	public int length() {	    return size;	}
protected String getFieldSeparator() {	    return fieldSeparator;	}
public static String stripEnd(final String str, final String stripChars) {	    int end;	    if (str == null || (end = str.length()) == 0) {	        return str;	    }	    if (stripChars == null) {	        while (end != 0 && Character.isWhitespace(str.charAt(end - 1))) {	            end--;	        }	    } else if (stripChars.isEmpty()) {	        return str;	    } else {	        while (end != 0 && stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND) {	            end--;	        }	    }	    return str.substring(0, end);	}
public int toComparison() {	    return comparison;	}
public static boolean isNotEmpty(final CharSequence cs) {	    return !StringUtils.isEmpty(cs);	}
protected boolean isUseShortClassName() {	    return useShortClassName;	}
public String substring(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    return new String(buffer, startIndex, endIndex - startIndex);	}
protected boolean isUseFieldNames() {	    return useFieldNames;	}
public static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools) {	    if ((src.length == 0 && srcPos == 0) || 0 == nBools) {	        return dstInit;	    }	    if (nBools - 1 + dstPos >= 32) {	        throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 32");	    }	    int out = dstInit;	    int shift = 0;	    for (int i = 0; i < nBools; i++) {	        shift = i * 1 + dstPos;	        final int bits = (src[i + srcPos] ? 1 : 0) << shift;	        final int mask = 0x1 << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
@Deprecated	public static String chomp(final String str, final String separator) {	    return removeEnd(str, separator);	}
public static <T> Range<T> is(final T element, final Comparator<T> comparator) {	    return between(element, element, comparator);	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
@Override	public T get(final long timeout, final TimeUnit unit) {	    return value;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public int size() {	    return size;	}
public String getNullText() {	    return nullText;	}
public static boolean containsNone(final CharSequence cs, final String invalidChars) {	    if (cs == null || invalidChars == null) {	        return true;	    }	    return containsNone(cs, invalidChars.toCharArray());	}
public static String stripStart(final String str, final String stripChars) {	    int strLen;	    if (str == null || (strLen = str.length()) == 0) {	        return str;	    }	    int start = 0;	    if (stripChars == null) {	        while (start != strLen && Character.isWhitespace(str.charAt(start))) {	            start++;	        }	    } else if (stripChars.isEmpty()) {	        return str;	    } else {	        while (start != strLen && stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND) {	            start++;	        }	    }	    return str.substring(start);	}
public StrBuilder minimizeCapacity() {	    if (buffer.length > length()) {	        final char[] old = buffer;	        buffer = new char[length()];	        System.arraycopy(old, 0, buffer, 0, size);	    }	    return this;	}
public static String wrap(final String str, int wrapLength, String newLineStr, final boolean wrapLongWords) {	    if (str == null) {	        return null;	    }	    if (newLineStr == null) {	        newLineStr = SystemUtils.LINE_SEPARATOR;	    }	    if (wrapLength < 1) {	        wrapLength = 1;	    }	    final int inputLineLength = str.length();	    int offset = 0;	    final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32);	    while (inputLineLength - offset > wrapLength) {	        if (str.charAt(offset) == ' ') {	            offset++;	            continue;	        }	        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);	        if (spaceToWrapAt >= offset) {	            wrappedLine.append(str.substring(offset, spaceToWrapAt));	            wrappedLine.append(newLineStr);	            offset = spaceToWrapAt + 1;	        } else {	            if (wrapLongWords) {	                wrappedLine.append(str.substring(offset, wrapLength + offset));	                wrappedLine.append(newLineStr);	                offset += wrapLength;	            } else {	                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);	                if (spaceToWrapAt >= 0) {	                    wrappedLine.append(str.substring(offset, spaceToWrapAt));	                    wrappedLine.append(newLineStr);	                    offset = spaceToWrapAt + 1;	                } else {	                    wrappedLine.append(str.substring(offset));	                    offset = inputLineLength;	                }	            }	        }	    }	    wrappedLine.append(str.substring(offset));	    return wrappedLine.toString();	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public Builder priority(final int prio) {	    priority = Integer.valueOf(prio);	    return this;	}
public static byte CONST_BYTE(final int v) throws IllegalArgumentException {	    if (v < Byte.MIN_VALUE || v > Byte.MAX_VALUE) {	        throw new IllegalArgumentException("Supplied value must be a valid byte literal between -128 and 127: [" + v + "]");	    }	    return (byte) v;	}
public StrTokenizer setEmptyTokenAsNull(final boolean emptyAsNull) {	    this.emptyAsNull = emptyAsNull;	    return this;	}
public static List<Field> getAllFieldsList(Class<?> cls) {	    if (cls == null) {	        throw new IllegalArgumentException("The class must not be null");	    }	    List<Field> allFields = new ArrayList<Field>();	    Class<?> currentClass = cls;	    while (currentClass != null) {	        final Field[] declaredFields = currentClass.getDeclaredFields();	        for (Field field : declaredFields) {	            allFields.add(field);	        }	        currentClass = currentClass.getSuperclass();	    }	    return allFields;	}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    buffer.append(arrayStart);	    for (int i = 0; i < array.length; i++) {	        if (i > 0) {	            buffer.append(arraySeparator);	        }	        appendDetail(buffer, fieldName, array[i]);	    }	    buffer.append(arrayEnd);	}
public boolean isEmpty() {	    return size == 0;	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public static <T extends CharSequence> T defaultIfBlank(final T str, final T defaultStr) {	    return StringUtils.isBlank(str) ? defaultStr : str;	}
public static float max(final float a, final float b, final float c) {	    return Math.max(Math.max(a, b), c);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
static void setAccessibleWorkaround(final AccessibleObject o) {	    if (o == null || o.isAccessible()) {	        return;	    }	    final Member m = (Member) o;	    if (Modifier.isPublic(m.getModifiers()) && isPackageAccess(m.getDeclaringClass().getModifiers())) {	        try {	            o.setAccessible(true);	        } catch (final SecurityException e) {	        }	    }	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
@Override	public double doubleValue() {	    return value;	}
@Override	public int hashCode() {	    return 83 + start + 7 * end + (negated ? 1 : 0);	}
protected boolean isUseShortClassName() {	    return useShortClassName;	}
static int lastIndexOf(final CharSequence cs, final CharSequence searchChar, final int start) {	    return cs.toString().lastIndexOf(searchChar.toString(), start);	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public static StrTokenizer getCSVInstance(final char[] input) {	    final StrTokenizer tok = getCSVClone();	    tok.reset(input);	    return tok;	}
public static void handleCause(final ExecutionException ex) throws ConcurrentException {	    final ConcurrentException cex = extractCause(ex);	    if (cex != null) {	        throw cex;	    }	}
public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) {	    final Token[] tokens = lexx(format);	    final Calendar start = Calendar.getInstance(timezone);	    start.setTime(new Date(startMillis));	    final Calendar end = Calendar.getInstance(timezone);	    end.setTime(new Date(endMillis));	    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);	    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);	    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);	    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);	    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);	    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);	    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);	    while (milliseconds < 0) {	        milliseconds += 1000;	        seconds -= 1;	    }	    while (seconds < 0) {	        seconds += 60;	        minutes -= 1;	    }	    while (minutes < 0) {	        minutes += 60;	        hours -= 1;	    }	    while (hours < 0) {	        hours += 24;	        days -= 1;	    }	    if (Token.containsTokenWithValue(tokens, M)) {	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	        while (months < 0) {	            months += 12;	            years -= 1;	        }	        if (!Token.containsTokenWithValue(tokens, y) && years != 0) {	            while (years != 0) {	                months += 12 * years;	                years = 0;	            }	        }	    } else {	        if (!Token.containsTokenWithValue(tokens, y)) {	            int target = end.get(Calendar.YEAR);	            if (months < 0) {	                target -= 1;	            }	            while (start.get(Calendar.YEAR) != target) {	                days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);	                if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) {	                    days += 1;	                }	                start.add(Calendar.YEAR, 1);	                days += start.get(Calendar.DAY_OF_YEAR);	            }	            years = 0;	        }	        while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            start.add(Calendar.MONTH, 1);	        }	        months = 0;	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	    }	    if (!Token.containsTokenWithValue(tokens, d)) {	        hours += 24 * days;	        days = 0;	    }	    if (!Token.containsTokenWithValue(tokens, H)) {	        minutes += 60 * hours;	        hours = 0;	    }	    if (!Token.containsTokenWithValue(tokens, m)) {	        seconds += 60 * minutes;	        minutes = 0;	    }	    if (!Token.containsTokenWithValue(tokens, s)) {	        milliseconds += 1000 * seconds;	        seconds = 0;	    }	    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
public boolean isEmpty() {	    return size == 0;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
@Override	public TimeZone getTimeZone() {	    return printer.getTimeZone();	}
public static <T> T invokeConstructor(final Class<T> cls, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {	    if (parameterTypes == null) {	        parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;	    }	    if (args == null) {	        args = ArrayUtils.EMPTY_OBJECT_ARRAY;	    }	    final Constructor<T> ctor = getMatchingAccessibleConstructor(cls, parameterTypes);	    if (ctor == null) {	        throw new NoSuchMethodException("No such accessible constructor on object: " + cls.getName());	    }	    return ctor.newInstance(args);	}
public String leftString(final int length) {	    if (length <= 0) {	        return "";	    } else if (length >= size) {	        return new String(buffer, 0, size);	    } else {	        return new String(buffer, 0, length);	    }	}
public int size() {	    return size;	}
@Override	public int length() {	    return size;	}
protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    appendSummarySize(buffer, fieldName, array.length);	}
public StrBuilder setLength(final int length) {	    if (length < 0) {	        throw new StringIndexOutOfBoundsException(length);	    }	    if (length < size) {	        size = length;	    } else if (length > size) {	        ensureCapacity(length);	        final int oldEnd = size;	        final int newEnd = length;	        size = length;	        for (int i = oldEnd; i < newEnd; i++) {	            buffer[i] = '\0';	        }	    }	    return this;	}
@Override	public int hashCode() {	    return value == null ? 0 : value.hashCode();	}
protected boolean isUseClassName() {	    return useClassName;	}
public void appendEnd(final StringBuffer buffer, final Object object) {	    if (this.fieldSeparatorAtEnd == false) {	        removeLastFieldSeparator(buffer);	    }	    appendContentEnd(buffer);	    unregister(object);	}
public static Date setMonths(final Date date, final int amount) {	    return set(date, Calendar.MONTH, amount);	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public static boolean isAscii(final char ch) {	    return ch < 128;	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public static String trim(final String str) {	    return str == null ? null : str.trim();	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof MutableByte) {	        return value == ((MutableByte) obj).byteValue();	    }	    return false;	}
@Override	public int hashCode() {	    return toHashCode();	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
public int capacity() {	    return buffer.length;	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
@Override	public String next() {	    if (hasNext()) {	        return tokens[tokenPos++];	    }	    throw new NoSuchElementException();	}
public int lastIndexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex >= size ? size - 1 : startIndex);	    if (matcher == null || startIndex < 0) {	        return -1;	    }	    final char[] buf = buffer;	    final int endIndex = startIndex + 1;	    for (int i = startIndex; i >= 0; i--) {	        if (matcher.isMatch(buf, i, 0, endIndex) > 0) {	            return i;	        }	    }	    return -1;	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
public static String formatDuration(long durationMillis, final String format, final boolean padWithZeros) {	    final Token[] tokens = lexx(format);	    int days = 0;	    int hours = 0;	    int minutes = 0;	    int seconds = 0;	    int milliseconds = 0;	    if (Token.containsTokenWithValue(tokens, d)) {	        days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY);	        durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY);	    }	    if (Token.containsTokenWithValue(tokens, H)) {	        hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR);	        durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR);	    }	    if (Token.containsTokenWithValue(tokens, m)) {	        minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE);	        durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE);	    }	    if (Token.containsTokenWithValue(tokens, s)) {	        seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND);	        durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND);	    }	    if (Token.containsTokenWithValue(tokens, S)) {	        milliseconds = (int) durationMillis;	    }	    return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
public static Class<?> getClass(final String className, final boolean initialize) throws ClassNotFoundException {	    final ClassLoader contextCL = Thread.currentThread().getContextClassLoader();	    final ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL;	    return getClass(loader, className, initialize);	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public synchronized boolean start() {	    if (!isStarted()) {	        ExecutorService tempExec;	        executor = getExternalExecutor();	        if (executor == null) {	            executor = tempExec = createExecutor();	        } else {	            tempExec = null;	        }	        future = executor.submit(createTask(tempExec));	        return true;	    }	    return false;	}
private static String[] splitByCharacterType(final String str, final boolean camelCase) {	    if (str == null) {	        return null;	    }	    if (str.isEmpty()) {	        return ArrayUtils.EMPTY_STRING_ARRAY;	    }	    final char[] c = str.toCharArray();	    final List<String> list = new ArrayList<String>();	    int tokenStart = 0;	    int currentType = Character.getType(c[tokenStart]);	    for (int pos = tokenStart + 1; pos < c.length; pos++) {	        final int type = Character.getType(c[pos]);	        if (type == currentType) {	            continue;	        }	        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {	            final int newTokenStart = pos - 1;	            if (newTokenStart != tokenStart) {	                list.add(new String(c, tokenStart, newTokenStart - tokenStart));	                tokenStart = newTokenStart;	            }	        } else {	            list.add(new String(c, tokenStart, pos - tokenStart));	            tokenStart = pos;	        }	        currentType = type;	    }	    list.add(new String(c, tokenStart, c.length - tokenStart));	    return list.toArray(new String[list.size()]);	}
public static Boolean[] nullToEmpty(final Boolean[] array) {	    if (array == null || array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    return array;	}
public static String overlay(final String str, String overlay, int start, int end) {	    if (str == null) {	        return null;	    }	    if (overlay == null) {	        overlay = EMPTY;	    }	    final int len = str.length();	    if (start < 0) {	        start = 0;	    }	    if (start > len) {	        start = len;	    }	    if (end < 0) {	        end = 0;	    }	    if (end > len) {	        end = len;	    }	    if (start > end) {	        final int temp = start;	        start = end;	        end = temp;	    }	    return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString();	}
public char getStart() {	    return this.start;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static String center(String str, final int size, String padStr) {	    if (str == null || size <= 0) {	        return str;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    str = leftPad(str, strLen + pads / 2, padStr);	    str = rightPad(str, size, padStr);	    return str;	}
public void suspend() {	    if (this.runningState != STATE_RUNNING) {	        throw new IllegalStateException("Stopwatch must be running to suspend. ");	    }	    this.stopTime = System.nanoTime();	    this.runningState = STATE_SUSPENDED;	}
public static boolean startsWithAny(final CharSequence string, final CharSequence... searchStrings) {	    if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {	        return false;	    }	    for (final CharSequence searchString : searchStrings) {	        if (StringUtils.startsWith(string, searchString)) {	            return true;	        }	    }	    return false;	}
public static String chop(final String str) {	    if (str == null) {	        return null;	    }	    final int strLen = str.length();	    if (strLen < 2) {	        return EMPTY;	    }	    final int lastIdx = strLen - 1;	    final String ret = str.substring(0, lastIdx);	    final char last = str.charAt(lastIdx);	    if (last == CharUtils.LF && ret.charAt(lastIdx - 1) == CharUtils.CR) {	        return ret.substring(0, lastIdx - 1);	    }	    return ret;	}
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, true);	}
public static <T extends CharSequence> T defaultIfEmpty(final T str, final T defaultStr) {	    return StringUtils.isEmpty(str) ? defaultStr : str;	}
@Override	public void write(final String str, final int off, final int len) {	    StrBuilder.this.append(str, off, len);	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public StrBuilder appendNewLine() {	    if (newLine == null) {	        append(SystemUtils.LINE_SEPARATOR);	        return this;	    }	    return append(newLine);	}
private static String[] splitByCharacterType(final String str, final boolean camelCase) {	    if (str == null) {	        return null;	    }	    if (str.isEmpty()) {	        return ArrayUtils.EMPTY_STRING_ARRAY;	    }	    final char[] c = str.toCharArray();	    final List<String> list = new ArrayList<String>();	    int tokenStart = 0;	    int currentType = Character.getType(c[tokenStart]);	    for (int pos = tokenStart + 1; pos < c.length; pos++) {	        final int type = Character.getType(c[pos]);	        if (type == currentType) {	            continue;	        }	        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {	            final int newTokenStart = pos - 1;	            if (newTokenStart != tokenStart) {	                list.add(new String(c, tokenStart, newTokenStart - tokenStart));	                tokenStart = newTokenStart;	            }	        } else {	            list.add(new String(c, tokenStart, pos - tokenStart));	            tokenStart = pos;	        }	        currentType = type;	    }	    list.add(new String(c, tokenStart, c.length - tokenStart));	    return list.toArray(new String[list.size()]);	}
public static String getShortClassName(String className) {	    if (StringUtils.isEmpty(className)) {	        return StringUtils.EMPTY;	    }	    final StringBuilder arrayPrefix = new StringBuilder();	    if (className.startsWith("[")) {	        while (className.charAt(0) == '[') {	            className = className.substring(1);	            arrayPrefix.append("[]");	        }	        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {	            className = className.substring(1, className.length() - 1);	        }	        if (reverseAbbreviationMap.containsKey(className)) {	            className = reverseAbbreviationMap.get(className);	        }	    }	    final int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);	    final int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);	    String out = className.substring(lastDotIdx + 1);	    if (innerIdx != -1) {	        out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);	    }	    return out + arrayPrefix;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static boolean equalsIgnoreCase(final CharSequence str1, final CharSequence str2) {	    if (str1 == null || str2 == null) {	        return str1 == str2;	    } else if (str1 == str2) {	        return true;	    } else if (str1.length() != str2.length()) {	        return false;	    } else {	        return CharSequenceUtils.regionMatches(str1, true, 0, str2, 0, str1.length());	    }	}
public static String formatDurationHMS(final long durationMillis) {	    return formatDuration(durationMillis, "H:mm:ss.SSS");	}
@Override	public String toString() {	    if (this.getObject() == null) {	        return this.getStyle().getNullText();	    }	    Class<?> clazz = this.getObject().getClass();	    this.appendFieldsIn(clazz);	    while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {	        clazz = clazz.getSuperclass();	        this.appendFieldsIn(clazz);	    }	    return super.toString();	}
public int toComparison() {	    return comparison;	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    final int seqEnd = input.length();	    if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') {	        int start = index + 2;	        boolean isHex = false;	        final char firstChar = input.charAt(start);	        if (firstChar == 'x' || firstChar == 'X') {	            start++;	            isHex = true;	            if (start == seqEnd) {	                return 0;	            }	        }	        int end = start;	        while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) {	            end++;	        }	        final boolean semiNext = end != seqEnd && input.charAt(end) == ';';	        if (!semiNext) {	            if (isSet(OPTION.semiColonRequired)) {	                return 0;	            } else if (isSet(OPTION.errorIfNoSemiColon)) {	                throw new IllegalArgumentException("Semi-colon required at end of numeric entity");	            }	        }	        int entityValue;	        try {	            if (isHex) {	                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);	            } else {	                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);	            }	        } catch (final NumberFormatException nfe) {	            return 0;	        }	        if (entityValue > 0xFFFF) {	            final char[] chrs = Character.toChars(entityValue);	            out.write(chrs[0]);	            out.write(chrs[1]);	        } else {	            out.write(entityValue);	        }	        return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0);	    }	    return 0;	}
protected String getArrayEnd() {	    return arrayEnd;	}
public static String abbreviate(final String str, int offset, final int maxWidth) {	    if (str == null) {	        return null;	    }	    if (maxWidth < 4) {	        throw new IllegalArgumentException("Minimum abbreviation width is 4");	    }	    if (str.length() <= maxWidth) {	        return str;	    }	    if (offset > str.length()) {	        offset = str.length();	    }	    if (str.length() - offset < maxWidth - 3) {	        offset = str.length() - (maxWidth - 3);	    }	    final String abrevMarker = "...";	    if (offset <= 4) {	        return str.substring(0, maxWidth - 3) + abrevMarker;	    }	    if (maxWidth < 7) {	        throw new IllegalArgumentException("Minimum abbreviation width with offset is 7");	    }	    if (offset + maxWidth - 3 < str.length()) {	        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);	    }	    return abrevMarker + str.substring(str.length() - (maxWidth - 3));	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public String getNullText() {	    return nullText;	}
public static String capitalize(final String str, final char... delimiters) {	    final int delimLen = delimiters == null ? -1 : delimiters.length;	    if (StringUtils.isEmpty(str) || delimLen == 0) {	        return str;	    }	    final char[] buffer = str.toCharArray();	    boolean capitalizeNext = true;	    for (int i = 0; i < buffer.length; i++) {	        final char ch = buffer[i];	        if (isDelimiter(ch, delimiters)) {	            capitalizeNext = true;	        } else if (capitalizeNext) {	            buffer[i] = Character.toTitleCase(ch);	            capitalizeNext = false;	        }	    }	    return new String(buffer);	}
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) {	    if (bool == null) {	        return nullValue;	    }	    return bool.booleanValue() ? trueValue : falseValue;	}
public String getNullText() {	    return nullText;	}
static Throwable checkedException(final Throwable ex) {	    if (ex != null && !(ex instanceof RuntimeException) && !(ex instanceof Error)) {	        return ex;	    } else {	        throw new IllegalArgumentException("Not a checked exception: " + ex);	    }	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
protected String getSizeStartText() {	    return sizeStartText;	}
public static String prependIfMissing(final String str, final CharSequence prefix, final CharSequence... prefixes) {	    return prependIfMissing(str, prefix, false, prefixes);	}
public static <E extends Enum<E>> EnumSet<E> processBitVector(final Class<E> enumClass, final long value) {	    checkBitVectorable(enumClass).getEnumConstants();	    return processBitVectors(enumClass, value);	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public static double[] addAll(final double[] array1, final double... array2) {	    if (array1 == null) {	        return clone(array2);	    } else if (array2 == null) {	        return clone(array1);	    }	    final double[] joinedArray = new double[array1.length + array2.length];	    System.arraycopy(array1, 0, joinedArray, 0, array1.length);	    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);	    return joinedArray;	}
public abstract R getRight();
public static float max(final float a, final float b, final float c) {	    return Math.max(Math.max(a, b), c);	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
public String getNullText() {	    return nullText;	}
public static boolean isAllUpperCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isUpperCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex) {	    if (0 == nHex) {	        return dstInit;	    }	    if ((nHex - 1) * 4 + dstPos >= 8) {	        throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 8");	    }	    byte out = dstInit;	    int shift = 0;	    for (int i = 0; i < nHex; i++) {	        shift = i * 4 + dstPos;	        final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift;	        final int mask = 0xf << shift;	        out = (byte) ((out & ~mask) | bits);	    }	    return out;	}
protected boolean isUseShortClassName() {	    return useShortClassName;	}
@Override	public StringBuffer format(final Calendar calendar, final StringBuffer buf) {	    return printer.format(calendar, buf);	}
public byte setByte(final byte holder) {	    return (byte) set(holder);	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess) {	    if (cls == null) {	        throw new IllegalArgumentException("The class must not be null");	    }	    if (fieldName == null) {	        throw new IllegalArgumentException("The field name must not be null");	    }	    try {	        final Field field = cls.getDeclaredField(fieldName);	        if (!MemberUtils.isAccessible(field)) {	            if (forceAccess) {	                field.setAccessible(true);	            } else {	                return null;	            }	        }	        return field;	    } catch (final NoSuchFieldException e) {	    }	    return null;	}
public static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts) {	    if (0 == nInts) {	        return dst;	    }	    if ((nInts - 1) * 32 + srcPos >= 64) {	        throw new IllegalArgumentException("(nInts-1)*32+srcPos is greather or equal to than 64");	    }	    int shift = 0;	    for (int i = 0; i < nInts; i++) {	        shift = i * 32 + srcPos;	        dst[dstPos + i] = (int) (0xffffffff & (src >> shift));	    }	    return dst;	}
public int capacity() {	    return buffer.length;	}
public static String removeEndIgnoreCase(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (endsWithIgnoreCase(str, remove)) {	        return str.substring(0, str.length() - remove.length());	    }	    return str;	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    if (input.charAt(index) == '\\' && index + 1 < input.length() && input.charAt(index + 1) == 'u') {	        int i = 2;	        while (index + i < input.length() && input.charAt(index + i) == 'u') {	            i++;	        }	        if (index + i < input.length() && input.charAt(index + i) == '+') {	            i++;	        }	        if (index + i + 4 <= input.length()) {	            final CharSequence unicode = input.subSequence(index + i, index + i + 4);	            try {	                final int value = Integer.parseInt(unicode.toString(), 16);	                out.write((char) value);	            } catch (final NumberFormatException nfe) {	                throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe);	            }	            return i + 4;	        } else {	            throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + input.subSequence(index, input.length()) + "' due to end of CharSequence");	        }	    }	    return 0;	}
@Override	public Object parseObject(final String source, final ParsePosition pos) {	    return parser.parseObject(source, pos);	}
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) {	    if (bool == null) {	        return nullValue;	    }	    return bool.booleanValue() ? trueValue : falseValue;	}
public StrTokenizer reset(final char[] input) {	    reset();	    this.chars = ArrayUtils.clone(input);	    return this;	}
@Override	public int nextIndex() {	    return tokenPos;	}
public String getNullText() {	    return nullText;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static Boolean xor(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return xor(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public static String substringBefore(final String str, final String separator) {	    if (isEmpty(str) || separator == null) {	        return str;	    }	    if (separator.isEmpty()) {	        return EMPTY;	    }	    final int pos = str.indexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return str;	    }	    return str.substring(0, pos);	}
protected boolean isUseIdentityHashCode() {	    return useIdentityHashCode;	}
public int toComparison() {	    return comparison;	}
public static short toShort(final String str, final short defaultValue) {	    if (str == null) {	        return defaultValue;	    }	    try {	        return Short.parseShort(str);	    } catch (final NumberFormatException nfe) {	        return defaultValue;	    }	}
@Override	public T get() throws ConcurrentException {	    try {	        return getFuture().get();	    } catch (final ExecutionException execex) {	        ConcurrentUtils.handleCause(execex);	        return null;	    } catch (final InterruptedException iex) {	        Thread.currentThread().interrupt();	        throw new ConcurrentException(iex);	    }	}
public static Iterator<?> iterator(final Object focus, final int rangeStyle) {	    if (focus == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (focus instanceof Date) {	        return iterator((Date) focus, rangeStyle);	    } else if (focus instanceof Calendar) {	        return iterator((Calendar) focus, rangeStyle);	    } else {	        throw new ClassCastException("Could not iterate based on " + focus);	    }	}
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return new boolean[] { false, false, false, false };	        case '1':	            return new boolean[] { false, false, false, true };	        case '2':	            return new boolean[] { false, false, true, false };	        case '3':	            return new boolean[] { false, false, true, true };	        case '4':	            return new boolean[] { false, true, false, false };	        case '5':	            return new boolean[] { false, true, false, true };	        case '6':	            return new boolean[] { false, true, true, false };	        case '7':	            return new boolean[] { false, true, true, true };	        case '8':	            return new boolean[] { true, false, false, false };	        case '9':	            return new boolean[] { true, false, false, true };	        case 'a':	        case 'A':	            return new boolean[] { true, false, true, false };	        case 'b':	        case 'B':	            return new boolean[] { true, false, true, true };	        case 'c':	        case 'C':	            return new boolean[] { true, true, false, false };	        case 'd':	        case 'D':	            return new boolean[] { true, true, false, true };	        case 'e':	        case 'E':	            return new boolean[] { true, true, true, false };	        case 'f':	        case 'F':	            return new boolean[] { true, true, true, true };	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) {	    if (0 == nHexs) {	        return dstInit;	    }	    if ((nHexs - 1) * 4 + srcPos >= 64) {	        throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 64");	    }	    final StringBuilder sb = new StringBuilder(dstInit);	    int shift = 0;	    int append = sb.length();	    for (int i = 0; i < nHexs; i++) {	        shift = i * 4 + srcPos;	        final int bits = (int) (0xF & (src >> shift));	        if (dstPos + i == append) {	            ++append;	            sb.append(intToHexDigit(bits));	        } else {	            sb.setCharAt(dstPos + i, intToHexDigit(bits));	        }	    }	    return sb.toString();	}
public int size() {	    return size;	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
public String getNewLineText() {	    return newLine;	}
@Override	public boolean equals(final Object obj2) {	    if (obj2 instanceof Token) {	        final Token tok2 = (Token) obj2;	        if (this.value.getClass() != tok2.value.getClass()) {	            return false;	        }	        if (this.count != tok2.count) {	            return false;	        }	        if (this.value instanceof StringBuilder) {	            return this.value.toString().equals(tok2.value.toString());	        } else if (this.value instanceof Number) {	            return this.value.equals(tok2.value);	        } else {	            return this.value == tok2.value;	        }	    }	    return false;	}
CharRange[] getCharRanges() {	    return set.toArray(new CharRange[set.size()]);	}
public static CharSet getInstance(final String... setStrs) {	    if (setStrs == null) {	        return null;	    }	    if (setStrs.length == 1) {	        final CharSet common = COMMON.get(setStrs[0]);	        if (common != null) {	            return common;	        }	    }	    return new CharSet(setStrs);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static String removeEnd(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.endsWith(remove)) {	        return str.substring(0, str.length() - remove.length());	    }	    return str;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public StrBuilder deleteFirst(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, 1);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public int size() {	    return size;	}
public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) {	    if (toClass == null) {	        return false;	    }	    if (cls == null) {	        return !toClass.isPrimitive();	    }	    if (autoboxing) {	        if (cls.isPrimitive() && !toClass.isPrimitive()) {	            cls = primitiveToWrapper(cls);	            if (cls == null) {	                return false;	            }	        }	        if (toClass.isPrimitive() && !cls.isPrimitive()) {	            cls = wrapperToPrimitive(cls);	            if (cls == null) {	                return false;	            }	        }	    }	    if (cls.equals(toClass)) {	        return true;	    }	    if (cls.isPrimitive()) {	        if (toClass.isPrimitive() == false) {	            return false;	        }	        if (Integer.TYPE.equals(cls)) {	            return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Long.TYPE.equals(cls)) {	            return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Boolean.TYPE.equals(cls)) {	            return false;	        }	        if (Double.TYPE.equals(cls)) {	            return false;	        }	        if (Float.TYPE.equals(cls)) {	            return Double.TYPE.equals(toClass);	        }	        if (Character.TYPE.equals(cls)) {	            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Short.TYPE.equals(cls)) {	            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Byte.TYPE.equals(cls)) {	            return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        return false;	    }	    return toClass.isAssignableFrom(cls);	}
@Deprecated	public static String chomp(final String str, final String separator) {	    return removeEnd(str, separator);	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public static long getFragmentInHours(final Calendar calendar, final int fragment) {	    return getFragment(calendar, fragment, Calendar.HOUR_OF_DAY);	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public String leftString(final int length) {	    if (length <= 0) {	        return "";	    } else if (length >= size) {	        return new String(buffer, 0, size);	    } else {	        return new String(buffer, 0, length);	    }	}
public static String trimToEmpty(final String str) {	    return str == null ? EMPTY : str.trim();	}
public String leftString(final int length) {	    if (length <= 0) {	        return "";	    } else if (length >= size) {	        return new String(buffer, 0, size);	    } else {	        return new String(buffer, 0, length);	    }	}
@Override	public String toString() {	    if (this.getObject() == null) {	        return this.getStyle().getNullText();	    }	    Class<?> clazz = this.getObject().getClass();	    this.appendFieldsIn(clazz);	    while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {	        clazz = clazz.getSuperclass();	        this.appendFieldsIn(clazz);	    }	    return super.toString();	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
protected boolean isUseFieldNames() {	    return useFieldNames;	}
static boolean isJavaVersionMatch(final String version, final String versionPrefix) {	    if (version == null) {	        return false;	    }	    return version.startsWith(versionPrefix);	}
public static String lowerCase(final String str, final Locale locale) {	    if (str == null) {	        return null;	    }	    return str.toLowerCase(locale);	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
@Override	public TimeZone getTimeZone() {	    return mTimeZone;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
@Override	public void setValue(final Number value) {	    this.value = value.doubleValue();	}
@Override	public void reset() {	    pos = mark;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static String rightPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return rightPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return str.concat(padStr);	    } else if (pads < padLen) {	        return str.concat(padStr.substring(0, pads));	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return str.concat(new String(padding));	    }	}
public static float max(final float a, final float b, final float c) {	    return Math.max(Math.max(a, b), c);	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public String getNewLineText() {	    return newLine;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
static Object removeAll(final Object array, final BitSet indices) {	    final int srcLength = ArrayUtils.getLength(array);	    final int removals = indices.cardinality();	    final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals);	    int srcIndex = 0;	    int destIndex = 0;	    int count;	    int set;	    while ((set = indices.nextSetBit(srcIndex)) != -1) {	        count = set - srcIndex;	        if (count > 0) {	            System.arraycopy(array, srcIndex, result, destIndex, count);	            destIndex += count;	        }	        srcIndex = indices.nextClearBit(set);	    }	    count = srcLength - srcIndex;	    if (count > 0) {	        System.arraycopy(array, srcIndex, result, destIndex, count);	    }	    return result;	}
public int size() {	    return size;	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static <T> T median(final Comparator<T> comparator, final T... items) {	    Validate.notEmpty(items, "null/empty items");	    Validate.noNullElements(items);	    Validate.notNull(comparator, "null comparator");	    final TreeSet<T> sort = new TreeSet<T>(comparator);	    Collections.addAll(sort, items);	    @SuppressWarnings("unchecked")	    final T result = (T) sort.toArray()[(sort.size() - 1) / 2];	    return result;	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public static String difference(final String str1, final String str2) {	    if (str1 == null) {	        return str2;	    }	    if (str2 == null) {	        return str1;	    }	    final int at = indexOfDifference(str1, str2);	    if (at == INDEX_NOT_FOUND) {	        return EMPTY;	    }	    return str2.substring(at);	}
public static boolean isNumber(final String str) {	    if (StringUtils.isEmpty(str)) {	        return false;	    }	    final char[] chars = str.toCharArray();	    int sz = chars.length;	    boolean hasExp = false;	    boolean hasDecPoint = false;	    boolean allowSigns = false;	    boolean foundDigit = false;	    final int start = (chars[0] == '-') ? 1 : 0;	    if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') {	        int i = start + 2;	        if (i == sz) {	            return false;	        }	        for (; i < chars.length; i++) {	            if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) {	                return false;	            }	        }	        return true;	    }	    sz--;	    int i = start;	    while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {	        if (chars[i] >= '0' && chars[i] <= '9') {	            foundDigit = true;	            allowSigns = false;	        } else if (chars[i] == '.') {	            if (hasDecPoint || hasExp) {	                return false;	            }	            hasDecPoint = true;	        } else if (chars[i] == 'e' || chars[i] == 'E') {	            if (hasExp) {	                return false;	            }	            if (!foundDigit) {	                return false;	            }	            hasExp = true;	            allowSigns = true;	        } else if (chars[i] == '+' || chars[i] == '-') {	            if (!allowSigns) {	                return false;	            }	            allowSigns = false;	            foundDigit = false;	        } else {	            return false;	        }	        i++;	    }	    if (i < chars.length) {	        if (chars[i] >= '0' && chars[i] <= '9') {	            return true;	        }	        if (chars[i] == 'e' || chars[i] == 'E') {	            return false;	        }	        if (chars[i] == '.') {	            if (hasDecPoint || hasExp) {	                return false;	            }	            return foundDigit;	        }	        if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) {	            return foundDigit;	        }	        if (chars[i] == 'l' || chars[i] == 'L') {	            return foundDigit && !hasExp && !hasDecPoint;	        }	        return false;	    }	    return !allowSigns && foundDigit;	}
public boolean isEmpty() {	    return size == 0;	}
public static boolean[] hexDigitToBinary(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return new boolean[] { false, false, false, false };	        case '1':	            return new boolean[] { true, false, false, false };	        case '2':	            return new boolean[] { false, true, false, false };	        case '3':	            return new boolean[] { true, true, false, false };	        case '4':	            return new boolean[] { false, false, true, false };	        case '5':	            return new boolean[] { true, false, true, false };	        case '6':	            return new boolean[] { false, true, true, false };	        case '7':	            return new boolean[] { true, true, true, false };	        case '8':	            return new boolean[] { false, false, false, true };	        case '9':	            return new boolean[] { true, false, false, true };	        case 'a':	        case 'A':	            return new boolean[] { false, true, false, true };	        case 'b':	        case 'B':	            return new boolean[] { true, true, false, true };	        case 'c':	        case 'C':	            return new boolean[] { false, false, true, true };	        case 'd':	        case 'D':	            return new boolean[] { true, false, true, true };	        case 'e':	        case 'E':	            return new boolean[] { false, true, true, true };	        case 'f':	        case 'F':	            return new boolean[] { true, true, true, true };	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public char getStart() {	    return this.start;	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof MutableShort) {	        return value == ((MutableShort) obj).shortValue();	    }	    return false;	}
public static int indexOfDifference(final CharSequence... css) {	    if (css == null || css.length <= 1) {	        return INDEX_NOT_FOUND;	    }	    boolean anyStringNull = false;	    boolean allStringsNull = true;	    final int arrayLen = css.length;	    int shortestStrLen = Integer.MAX_VALUE;	    int longestStrLen = 0;	    for (int i = 0; i < arrayLen; i++) {	        if (css[i] == null) {	            anyStringNull = true;	            shortestStrLen = 0;	        } else {	            allStringsNull = false;	            shortestStrLen = Math.min(css[i].length(), shortestStrLen);	            longestStrLen = Math.max(css[i].length(), longestStrLen);	        }	    }	    if (allStringsNull || longestStrLen == 0 && !anyStringNull) {	        return INDEX_NOT_FOUND;	    }	    if (shortestStrLen == 0) {	        return 0;	    }	    int firstDiff = -1;	    for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {	        final char comparisonChar = css[0].charAt(stringPos);	        for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {	            if (css[arrayPos].charAt(stringPos) != comparisonChar) {	                firstDiff = stringPos;	                break;	            }	        }	        if (firstDiff != -1) {	            break;	        }	    }	    if (firstDiff == -1 && shortestStrLen != longestStrLen) {	        return shortestStrLen;	    }	    return firstDiff;	}
public int capacity() {	    return buffer.length;	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public static String getShortCanonicalName(final String canonicalName) {	    return ClassUtils.getShortClassName(getCanonicalName(canonicalName));	}
@Override	public int length() {	    return size;	}
@Override	public int hashCode() {	    return toHashCode();	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static boolean isAlphaSpace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false && cs.charAt(i) != ' ') {	            return false;	        }	    }	    return true;	}
public static String removeStart(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.startsWith(remove)) {	        return str.substring(remove.length());	    }	    return str;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static String replaceChars(final String str, final String searchChars, String replaceChars) {	    if (isEmpty(str) || isEmpty(searchChars)) {	        return str;	    }	    if (replaceChars == null) {	        replaceChars = EMPTY;	    }	    boolean modified = false;	    final int replaceCharsLength = replaceChars.length();	    final int strLength = str.length();	    final StringBuilder buf = new StringBuilder(strLength);	    for (int i = 0; i < strLength; i++) {	        final char ch = str.charAt(i);	        final int index = searchChars.indexOf(ch);	        if (index >= 0) {	            modified = true;	            if (index < replaceCharsLength) {	                buf.append(replaceChars.charAt(index));	            }	        } else {	            buf.append(ch);	        }	    }	    if (modified) {	        return buf.toString();	    }	    return str;	}
public static String substringAfter(final String str, final String separator) {	    if (isEmpty(str)) {	        return str;	    }	    if (separator == null) {	        return EMPTY;	    }	    final int pos = str.indexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return EMPTY;	    }	    return str.substring(pos + separator.length());	}
public static String right(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(str.length() - len);	}
public static void handleCauseUnchecked(final ExecutionException ex) {	    final ConcurrentRuntimeException crex = extractCauseUnchecked(ex);	    if (crex != null) {	        throw crex;	    }	}
@Override	public int read(final char[] b, final int off, int len) {	    if (off < 0 || len < 0 || off > b.length || (off + len) > b.length || (off + len) < 0) {	        throw new IndexOutOfBoundsException();	    }	    if (len == 0) {	        return 0;	    }	    if (pos >= StrBuilder.this.size()) {	        return -1;	    }	    if (pos + len > size()) {	        len = StrBuilder.this.size() - pos;	    }	    StrBuilder.this.getChars(pos, pos + len, b, off);	    pos += len;	    return len;	}
public static String formatDuration(long durationMillis, final String format, final boolean padWithZeros) {	    final Token[] tokens = lexx(format);	    int days = 0;	    int hours = 0;	    int minutes = 0;	    int seconds = 0;	    int milliseconds = 0;	    if (Token.containsTokenWithValue(tokens, d)) {	        days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY);	        durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY);	    }	    if (Token.containsTokenWithValue(tokens, H)) {	        hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR);	        durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR);	    }	    if (Token.containsTokenWithValue(tokens, m)) {	        minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE);	        durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE);	    }	    if (Token.containsTokenWithValue(tokens, s)) {	        seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND);	        durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND);	    }	    if (Token.containsTokenWithValue(tokens, S)) {	        milliseconds = (int) durationMillis;	    }	    return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
public void stop() {	    if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {	        throw new IllegalStateException("Stopwatch is not running. ");	    }	    if (this.runningState == STATE_RUNNING) {	        this.stopTime = System.nanoTime();	    }	    this.runningState = STATE_STOPPED;	}
public int capacity() {	    return buffer.length;	}
@Override	public final void applyPattern(final String pattern) {	    if (registry == null) {	        super.applyPattern(pattern);	        toPattern = super.toPattern();	        return;	    }	    final ArrayList<Format> foundFormats = new ArrayList<Format>();	    final ArrayList<String> foundDescriptions = new ArrayList<String>();	    final StringBuilder stripCustom = new StringBuilder(pattern.length());	    final ParsePosition pos = new ParsePosition(0);	    final char[] c = pattern.toCharArray();	    int fmtCount = 0;	    while (pos.getIndex() < pattern.length()) {	        switch(c[pos.getIndex()]) {	            case QUOTE:	                appendQuotedString(pattern, pos, stripCustom, true);	                break;	            case START_FE:	                fmtCount++;	                seekNonWs(pattern, pos);	                final int start = pos.getIndex();	                final int index = readArgumentIndex(pattern, next(pos));	                stripCustom.append(START_FE).append(index);	                seekNonWs(pattern, pos);	                Format format = null;	                String formatDescription = null;	                if (c[pos.getIndex()] == START_FMT) {	                    formatDescription = parseFormatDescription(pattern, next(pos));	                    format = getFormat(formatDescription);	                    if (format == null) {	                        stripCustom.append(START_FMT).append(formatDescription);	                    }	                }	                foundFormats.add(format);	                foundDescriptions.add(format == null ? null : formatDescription);	                Validate.isTrue(foundFormats.size() == fmtCount);	                Validate.isTrue(foundDescriptions.size() == fmtCount);	                if (c[pos.getIndex()] != END_FE) {	                    throw new IllegalArgumentException("Unreadable format element at position " + start);	                }	            default:	                stripCustom.append(c[pos.getIndex()]);	                next(pos);	        }	    }	    super.applyPattern(stripCustom.toString());	    toPattern = insertFormats(super.toPattern(), foundDescriptions);	    if (containsElements(foundFormats)) {	        final Format[] origFormats = getFormats();	        int i = 0;	        for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) {	            final Format f = it.next();	            if (f != null) {	                origFormats[i] = f;	            }	        }	        super.setFormats(origFormats);	    }	}
public static <T> Range<T> is(final T element, final Comparator<T> comparator) {	    return between(element, element, comparator);	}
public static String removeEnd(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.endsWith(remove)) {	        return str.substring(0, str.length() - remove.length());	    }	    return str;	}
public boolean isEmpty() {	    return size == 0;	}
public boolean isEmptyTokenAsNull() {	    return this.emptyAsNull;	}
public static CharRange is(final char ch) {	    return new CharRange(ch, ch, false);	}
public String getNullText() {	    return nullText;	}
public static String difference(final String str1, final String str2) {	    if (str1 == null) {	        return str2;	    }	    if (str2 == null) {	        return str1;	    }	    final int at = indexOfDifference(str1, str2);	    if (at == INDEX_NOT_FOUND) {	        return EMPTY;	    }	    return str2.substring(at);	}
public static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools) {	    if ((src.length == 0 && srcPos == 0) || 0 == nBools) {	        return dstInit;	    }	    if (nBools - 1 + dstPos >= 64) {	        throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 64");	    }	    long out = dstInit;	    int shift = 0;	    for (int i = 0; i < nBools; i++) {	        shift = i * 1 + dstPos;	        final long bits = (src[i + srcPos] ? 1L : 0) << shift;	        final long mask = 0x1L << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
protected String getFieldSeparator() {	    return fieldSeparator;	}
public static Number createNumber(final String str) throws NumberFormatException {	    if (str == null) {	        return null;	    }	    if (StringUtils.isBlank(str)) {	        throw new NumberFormatException("A blank string is not a valid number");	    }	    final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" };	    int pfxLen = 0;	    for (final String pfx : hex_prefixes) {	        if (str.startsWith(pfx)) {	            pfxLen += pfx.length();	            break;	        }	    }	    if (pfxLen > 0) {	        final int hexDigits = str.length() - pfxLen;	        if (hexDigits > 16) {	            return createBigInteger(str);	        }	        if (hexDigits > 8) {	            return createLong(str);	        }	        return createInteger(str);	    }	    final char lastChar = str.charAt(str.length() - 1);	    String mant;	    String dec;	    String exp;	    final int decPos = str.indexOf('.');	    final int expPos = str.indexOf('e') + str.indexOf('E') + 1;	    int numDecimals = 0;	    if (decPos > -1) {	        if (expPos > -1) {	            if (expPos < decPos || expPos > str.length()) {	                throw new NumberFormatException(str + " is not a valid number.");	            }	            dec = str.substring(decPos + 1, expPos);	        } else {	            dec = str.substring(decPos + 1);	        }	        mant = str.substring(0, decPos);	        numDecimals = dec.length();	    } else {	        if (expPos > -1) {	            if (expPos > str.length()) {	                throw new NumberFormatException(str + " is not a valid number.");	            }	            mant = str.substring(0, expPos);	        } else {	            mant = str;	        }	        dec = null;	    }	    if (!Character.isDigit(lastChar) && lastChar != '.') {	        if (expPos > -1 && expPos < str.length() - 1) {	            exp = str.substring(expPos + 1, str.length() - 1);	        } else {	            exp = null;	        }	        final String numeric = str.substring(0, str.length() - 1);	        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);	        switch(lastChar) {	            case 'l':	            case 'L':	                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {	                    try {	                        return createLong(numeric);	                    } catch (final NumberFormatException nfe) {	                    }	                    return createBigInteger(numeric);	                }	                throw new NumberFormatException(str + " is not a valid number.");	            case 'f':	            case 'F':	                try {	                    final Float f = NumberUtils.createFloat(numeric);	                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {	                        return f;	                    }	                } catch (final NumberFormatException nfe) {	                }	            case 'd':	            case 'D':	                try {	                    final Double d = NumberUtils.createDouble(numeric);	                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {	                        return d;	                    }	                } catch (final NumberFormatException nfe) {	                }	                try {	                    return createBigDecimal(numeric);	                } catch (final NumberFormatException e) {	                }	            default:	                throw new NumberFormatException(str + " is not a valid number.");	        }	    }	    if (expPos > -1 && expPos < str.length() - 1) {	        exp = str.substring(expPos + 1, str.length());	    } else {	        exp = null;	    }	    if (dec == null && exp == null) {	        try {	            return createInteger(str);	        } catch (final NumberFormatException nfe) {	        }	        try {	            return createLong(str);	        } catch (final NumberFormatException nfe) {	        }	        return createBigInteger(str);	    }	    final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);	    try {	        if (numDecimals <= 7) {	            final Float f = createFloat(str);	            if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {	                return f;	            }	        }	    } catch (final NumberFormatException nfe) {	    }	    try {	        if (numDecimals <= 16) {	            final Double d = createDouble(str);	            if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {	                return d;	            }	        }	    } catch (final NumberFormatException nfe) {	    }	    return createBigDecimal(str);	}
public StringBuilder toStringBuilder() {	    return new StringBuilder(size).append(buffer, 0, size);	}
public static String prependIfMissing(final String str, final CharSequence prefix, final CharSequence... prefixes) {	    return prependIfMissing(str, prefix, false, prefixes);	}
protected String getSummaryObjectStartText() {	    return summaryObjectStartText;	}
public static long toLong(final String str, final long defaultValue) {	    if (str == null) {	        return defaultValue;	    }	    try {	        return Long.parseLong(str);	    } catch (final NumberFormatException nfe) {	        return defaultValue;	    }	}
@Override	public double doubleValue() {	    return value;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static String defaultString(final String str, final String defaultStr) {	    return str == null ? defaultStr : str;	}
protected String getContentStart() {	    return contentStart;	}
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return 0;	    }	    if (lhs == null || rhs == null) {	        throw new NullPointerException();	    }	    Class<?> lhsClazz = lhs.getClass();	    if (!lhsClazz.isInstance(rhs)) {	        throw new ClassCastException();	    }	    final CompareToBuilder compareToBuilder = new CompareToBuilder();	    reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);	    while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) {	        lhsClazz = lhsClazz.getSuperclass();	        reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);	    }	    return compareToBuilder.toComparison();	}
public int getNumerator() {	    return numerator;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static float max(final float a, final float b) {	    if (Float.isNaN(a)) {	        return b;	    } else if (Float.isNaN(b)) {	        return a;	    } else {	        return Math.max(a, b);	    }	}
public static Locale toLocale(final String str) {	    if (str == null) {	        return null;	    }	    if (str.contains("#")) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final int len = str.length();	    if (len < 2) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final char ch0 = str.charAt(0);	    if (ch0 == '_') {	        if (len < 3) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        final char ch1 = str.charAt(1);	        final char ch2 = str.charAt(2);	        if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        if (len == 3) {	            return new Locale("", str.substring(1, 3));	        }	        if (len < 5) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        if (str.charAt(3) != '_') {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        return new Locale("", str.substring(1, 3), str.substring(4));	    }	    final char ch1 = str.charAt(1);	    if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (len == 2) {	        return new Locale(str);	    }	    if (len < 5) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (str.charAt(2) != '_') {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final char ch3 = str.charAt(3);	    if (ch3 == '_') {	        return new Locale(str.substring(0, 2), "", str.substring(4));	    }	    final char ch4 = str.charAt(4);	    if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (len == 5) {	        return new Locale(str.substring(0, 2), str.substring(3, 5));	    }	    if (len < 7) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (str.charAt(5) != '_') {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));	}
@Override	public long longValue() {	    return value;	}
public int getNumerator() {	    return numerator;	}
public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) {	    if (it != null) {	        separator = ObjectUtils.toString(separator);	        while (it.hasNext()) {	            append(it.next());	            if (it.hasNext()) {	                append(separator);	            }	        }	    }	    return this;	}
@Override	public float floatValue() {	    return value;	}
public static Object invokeMethod(final Object object, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {	    if (parameterTypes == null) {	        parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;	    }	    if (args == null) {	        args = ArrayUtils.EMPTY_OBJECT_ARRAY;	    }	    final Method method = getMatchingAccessibleMethod(object.getClass(), methodName, parameterTypes);	    if (method == null) {	        throw new NoSuchMethodException("No such accessible method: " + methodName + "() on object: " + object.getClass().getName());	    }	    return method.invoke(object, args);	}
public static <T extends CharSequence> T validIndex(final T chars, final int index) {	    return validIndex(chars, index, DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE, Integer.valueOf(index));	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
@Override	public int length() {	    return size;	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale) {	    return cache.getInstance(pattern, timeZone, locale);	}
public static Date addMinutes(final Date date, final int amount) {	    return add(date, Calendar.MINUTE, amount);	}
public void stop() {	    if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {	        throw new IllegalStateException("Stopwatch is not running. ");	    }	    if (this.runningState == STATE_RUNNING) {	        this.stopTime = System.nanoTime();	    }	    this.runningState = STATE_STOPPED;	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
public static void writeField(final Object target, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException {	    if (target == null) {	        throw new IllegalArgumentException("target object must not be null");	    }	    final Class<?> cls = target.getClass();	    final Field field = getField(cls, fieldName, forceAccess);	    if (field == null) {	        throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName);	    }	    writeField(field, target, value);	}
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) {	    style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));	    return this;	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    if (input.charAt(index) == '\\' && index < (input.length() - 1) && Character.isDigit(input.charAt(index + 1))) {	        final int start = index + 1;	        int end = index + 2;	        while (end < input.length() && Character.isDigit(input.charAt(end))) {	            end++;	            if (Integer.parseInt(input.subSequence(start, end).toString(), 10) > OCTAL_MAX) {	                end--;	                break;	            }	        }	        out.write(Integer.parseInt(input.subSequence(start, end).toString(), 8));	        return 1 + end - start;	    }	    return 0;	}
@Override	public boolean markSupported() {	    return true;	}
@Override	public long longValue() {	    return value;	}
public final synchronized int getLimit() {	    return limit;	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) {	    if (bool == null) {	        return nullValue;	    }	    return bool.booleanValue() ? trueValue : falseValue;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
private static long getFragment(final Calendar calendar, final int fragment, final int unit) {	    if (calendar == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final long millisPerUnit = getMillisPerUnit(unit);	    long result = 0;	    switch(fragment) {	        case Calendar.YEAR:	            result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit;	            break;	        case Calendar.MONTH:	            result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit;	            break;	    }	    switch(fragment) {	        case Calendar.YEAR:	        case Calendar.MONTH:	        case Calendar.DAY_OF_YEAR:	        case Calendar.DATE:	            result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit;	        case Calendar.HOUR_OF_DAY:	            result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit;	        case Calendar.MINUTE:	            result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit;	        case Calendar.SECOND:	            result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit;	            break;	        case Calendar.MILLISECOND:	            break;	        default:	            throw new IllegalArgumentException("The fragment " + fragment + " is not supported");	    }	    return result;	}
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) {	    if (str == null) {	        if (trueString == null) {	            return Boolean.TRUE;	        }	        if (falseString == null) {	            return Boolean.FALSE;	        }	        if (nullString == null) {	            return null;	        }	    } else if (str.equals(trueString)) {	        return Boolean.TRUE;	    } else if (str.equals(falseString)) {	        return Boolean.FALSE;	    } else if (str.equals(nullString)) {	        return null;	    }	    throw new IllegalArgumentException("The String did not match any specified value");	}
@Override	public T call() throws Exception {	    try {	        return initialize();	    } finally {	        if (execFinally != null) {	            execFinally.shutdown();	        }	    }	}
public static String getCommonPrefix(final String... strs) {	    if (strs == null || strs.length == 0) {	        return EMPTY;	    }	    final int smallestIndexOfDiff = indexOfDifference(strs);	    if (smallestIndexOfDiff == INDEX_NOT_FOUND) {	        if (strs[0] == null) {	            return EMPTY;	        }	        return strs[0];	    } else if (smallestIndexOfDiff == 0) {	        return EMPTY;	    } else {	        return strs[0].substring(0, smallestIndexOfDiff);	    }	}
@Override	public Integer build() {	    return Integer.valueOf(toHashCode());	}
public boolean isEmpty() {	    return size == 0;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static String prependIfMissing(final String str, final CharSequence prefix, final CharSequence... prefixes) {	    return prependIfMissing(str, prefix, false, prefixes);	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public int size() {	    return size;	}
public static byte[] serialize(final Serializable obj) {	    final ByteArrayOutputStream baos = new ByteArrayOutputStream(512);	    serialize(obj, baos);	    return baos.toByteArray();	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
@Override	public int length() {	    return size;	}
public char getEscapeChar() {	    return this.escapeChar;	}
@Override	public long longValue() {	    return (long) value;	}
public static String formatDurationHMS(final long durationMillis) {	    return formatDuration(durationMillis, "H:mm:ss.SSS");	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public static CharRange is(final char ch) {	    return new CharRange(ch, ch, false);	}
@Override	public DefaultExceptionContext setContextValue(final String label, final Object value) {	    for (final Iterator<Pair<String, Object>> iter = contextValues.iterator(); iter.hasNext(); ) {	        final Pair<String, Object> p = iter.next();	        if (StringUtils.equals(label, p.getKey())) {	            iter.remove();	        }	    }	    addContextValue(label, value);	    return this;	}
@Override	public T get(final long timeout, final TimeUnit unit) {	    return value;	}
public TimeUnit getUnit() {	    return unit;	}
public String getNewLineText() {	    return newLine;	}
public int capacity() {	    return buffer.length;	}
protected String getSummaryObjectEndText() {	    return summaryObjectEndText;	}
public static String right(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(str.length() - len);	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final E... values) {	    asEnum(enumClass);	    Validate.noNullElements(values);	    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);	    Collections.addAll(condensed, values);	    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];	    for (final E value : condensed) {	        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);	    }	    ArrayUtils.reverse(result);	    return result;	}
public boolean isAllSet(final int holder) {	    return (holder & _mask) == _mask;	}
public static String repeat(final char ch, final int repeat) {	    final char[] buf = new char[repeat];	    for (int i = repeat - 1; i >= 0; i--) {	        buf[i] = ch;	    }	    return new String(buf);	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public static <T extends CharSequence> T validIndex(final T chars, final int index) {	    return validIndex(chars, index, DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE, Integer.valueOf(index));	}
public int toComparison() {	    return comparison;	}
public String getNewLineText() {	    return newLine;	}
public static boolean isNotBlank(final CharSequence cs) {	    return !StringUtils.isBlank(cs);	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static <L, M, R> MutableTriple<L, M, R> of(final L left, final M middle, final R right) {	    return new MutableTriple<L, M, R>(left, middle, right);	}
static boolean isOSMatch(final String osName, final String osVersion, final String osNamePrefix, final String osVersionPrefix) {	    if (osName == null || osVersion == null) {	        return false;	    }	    return osName.startsWith(osNamePrefix) && osVersion.startsWith(osVersionPrefix);	}
@Override	public int compareTo(final MutableBoolean other) {	    final boolean anotherVal = other.value;	    return value == anotherVal ? 0 : (value ? 1 : -1);	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
public synchronized boolean isStarted() {	    return future != null;	}
public static String mid(final String str, int pos, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0 || pos > str.length()) {	        return EMPTY;	    }	    if (pos < 0) {	        pos = 0;	    }	    if (str.length() <= pos + len) {	        return str.substring(pos);	    }	    return str.substring(pos, pos + len);	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
public StrTokenizer setEmptyTokenAsNull(final boolean emptyAsNull) {	    this.emptyAsNull = emptyAsNull;	    return this;	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
protected boolean isDefaultFullDetail() {	    return defaultFullDetail;	}
protected String getContentEnd() {	    return contentEnd;	}
public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) {	    if (it != null) {	        separator = ObjectUtils.toString(separator);	        while (it.hasNext()) {	            append(it.next());	            if (it.hasNext()) {	                append(separator);	            }	        }	    }	    return this;	}
@Override	public String previous() {	    if (hasPrevious()) {	        return tokens[--tokenPos];	    }	    throw new NoSuchElementException();	}
public static String formatDuration(long durationMillis, final String format, final boolean padWithZeros) {	    final Token[] tokens = lexx(format);	    int days = 0;	    int hours = 0;	    int minutes = 0;	    int seconds = 0;	    int milliseconds = 0;	    if (Token.containsTokenWithValue(tokens, d)) {	        days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY);	        durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY);	    }	    if (Token.containsTokenWithValue(tokens, H)) {	        hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR);	        durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR);	    }	    if (Token.containsTokenWithValue(tokens, m)) {	        minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE);	        durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE);	    }	    if (Token.containsTokenWithValue(tokens, s)) {	        seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND);	        durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND);	    }	    if (Token.containsTokenWithValue(tokens, S)) {	        milliseconds = (int) durationMillis;	    }	    return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static Class<?> getClass(final String className, final boolean initialize) throws ClassNotFoundException {	    final ClassLoader contextCL = Thread.currentThread().getContextClassLoader();	    final ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL;	    return getClass(loader, className, initialize);	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, true);	}
public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width, final int precision, final char padChar, final CharSequence ellipsis) {	    Validate.isTrue(ellipsis == null || precision < 0 || ellipsis.length() <= precision, "Specified ellipsis '%1$s' exceeds precision of %2$s", ellipsis, Integer.valueOf(precision));	    final StringBuilder buf = new StringBuilder(seq);	    if (precision >= 0 && precision < seq.length()) {	        final CharSequence _ellipsis = ObjectUtils.defaultIfNull(ellipsis, StringUtils.EMPTY);	        buf.replace(precision - _ellipsis.length(), seq.length(), _ellipsis.toString());	    }	    final boolean leftJustify = (flags & LEFT_JUSTIFY) == LEFT_JUSTIFY;	    for (int i = buf.length(); i < width; i++) {	        buf.insert(leftJustify ? i : 0, padChar);	    }	    formatter.format(buf.toString());	    return formatter;	}
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return 0;	    }	    if (lhs == null || rhs == null) {	        throw new NullPointerException();	    }	    Class<?> lhsClazz = lhs.getClass();	    if (!lhsClazz.isInstance(rhs)) {	        throw new ClassCastException();	    }	    final CompareToBuilder compareToBuilder = new CompareToBuilder();	    reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);	    while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) {	        lhsClazz = lhsClazz.getSuperclass();	        reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);	    }	    return compareToBuilder.toComparison();	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
static boolean regionMatches(final CharSequence cs, final boolean ignoreCase, final int thisStart, final CharSequence substring, final int start, final int length) {	    if (cs instanceof String && substring instanceof String) {	        return ((String) cs).regionMatches(ignoreCase, thisStart, (String) substring, start, length);	    } else {	        int index1 = thisStart;	        int index2 = start;	        int tmpLen = length;	        while (tmpLen-- > 0) {	            char c1 = cs.charAt(index1++);	            char c2 = substring.charAt(index2++);	            if (c1 == c2) {	                continue;	            }	            if (!ignoreCase) {	                return false;	            }	            if (Character.toUpperCase(c1) != Character.toUpperCase(c2) && Character.toLowerCase(c1) != Character.toLowerCase(c2)) {	                return false;	            }	        }	        return true;	    }	}
public static boolean equalsIgnoreCase(final CharSequence str1, final CharSequence str2) {	    if (str1 == null || str2 == null) {	        return str1 == str2;	    } else if (str1 == str2) {	        return true;	    } else if (str1.length() != str2.length()) {	        return false;	    } else {	        return CharSequenceUtils.regionMatches(str1, true, 0, str2, 0, str1.length());	    }	}
public static boolean isAsciiAlpha(final char ch) {	    return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');	}
public int size() {	    return size;	}
public int capacity() {	    return buffer.length;	}
public String getContent() {	    if (chars == null) {	        return null;	    }	    return new String(chars);	}
public char getEscapeChar() {	    return this.escapeChar;	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
public int size() {	    return size;	}
public synchronized void shutdown() {	    if (!shutdown) {	        if (ownExecutor) {	            getExecutorService().shutdownNow();	        }	        if (task != null) {	            task.cancel(false);	        }	        shutdown = true;	    }	}
@Override	public StringBuffer format(final Calendar calendar, final StringBuffer buf) {	    return applyRules(calendar, buf);	}
protected abstract T initialize() throws Exception;
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static boolean isNotEmpty(final boolean[] array) {	    return (array != null && array.length != 0);	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public char getEnd() {	    return this.end;	}
public static Locale toLocale(final String str) {	    if (str == null) {	        return null;	    }	    if (str.contains("#")) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final int len = str.length();	    if (len < 2) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final char ch0 = str.charAt(0);	    if (ch0 == '_') {	        if (len < 3) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        final char ch1 = str.charAt(1);	        final char ch2 = str.charAt(2);	        if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        if (len == 3) {	            return new Locale("", str.substring(1, 3));	        }	        if (len < 5) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        if (str.charAt(3) != '_') {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        return new Locale("", str.substring(1, 3), str.substring(4));	    }	    final char ch1 = str.charAt(1);	    if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (len == 2) {	        return new Locale(str);	    }	    if (len < 5) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (str.charAt(2) != '_') {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final char ch3 = str.charAt(3);	    if (ch3 == '_') {	        return new Locale(str.substring(0, 2), "", str.substring(4));	    }	    final char ch4 = str.charAt(4);	    if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (len == 5) {	        return new Locale(str.substring(0, 2), str.substring(3, 5));	    }	    if (len < 7) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (str.charAt(5) != '_') {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));	}
public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) {	    if (src.length > 8) {	        throw new IllegalArgumentException("src.length>8: src.length=" + src.length);	    }	    if (src.length - srcPos < 4) {	        throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos);	    }	    if (src[srcPos + 3]) {	        if (src[srcPos + 2]) {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return '7';	                }	            } else {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return '3';	                }	            }	        } else {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return '5';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '1';	                }	            }	        }	    } else {	        if (src[srcPos + 2]) {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'e';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return 'a';	                } else {	                    return '2';	                }	            }	        } else {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'c';	                } else {	                    return '4';	                }	            } else {	                if (src[srcPos]) {	                    return '8';	                } else {	                    return '0';	                }	            }	        }	    }	}
public static String toString(final Object obj, final String nullStr) {	    return obj == null ? nullStr : obj.toString();	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    final int seqEnd = input.length();	    if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') {	        int start = index + 2;	        boolean isHex = false;	        final char firstChar = input.charAt(start);	        if (firstChar == 'x' || firstChar == 'X') {	            start++;	            isHex = true;	            if (start == seqEnd) {	                return 0;	            }	        }	        int end = start;	        while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) {	            end++;	        }	        final boolean semiNext = end != seqEnd && input.charAt(end) == ';';	        if (!semiNext) {	            if (isSet(OPTION.semiColonRequired)) {	                return 0;	            } else if (isSet(OPTION.errorIfNoSemiColon)) {	                throw new IllegalArgumentException("Semi-colon required at end of numeric entity");	            }	        }	        int entityValue;	        try {	            if (isHex) {	                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);	            } else {	                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);	            }	        } catch (final NumberFormatException nfe) {	            return 0;	        }	        if (entityValue > 0xFFFF) {	            final char[] chrs = Character.toChars(entityValue);	            out.write(chrs[0]);	            out.write(chrs[1]);	        } else {	            out.write(entityValue);	        }	        return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0);	    }	    return 0;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {	    if (str == null || searchStr == null) {	        return INDEX_NOT_FOUND;	    }	    if (startPos < 0) {	        startPos = 0;	    }	    final int endLimit = str.length() - searchStr.length() + 1;	    if (startPos > endLimit) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return startPos;	    }	    for (int i = startPos; i < endLimit; i++) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale) {	    return cache.getDateTimeInstance(dateStyle, timeStyle, timeZone, locale);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static boolean truncatedEquals(final Date date1, final Date date2, final int field) {	    return truncatedCompareTo(date1, date2, field) == 0;	}
public static char toChar(final String str, final char defaultValue) {	    if (StringUtils.isEmpty(str)) {	        return defaultValue;	    }	    return str.charAt(0);	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
protected boolean isDefaultFullDetail() {	    return defaultFullDetail;	}
@Override	public Long getValue() {	    return Long.valueOf(this.value);	}
@Override	public T get(final long timeout, final TimeUnit unit) {	    return value;	}
@Override	public boolean markSupported() {	    return true;	}
@Override	public String toPattern() {	    return toPattern;	}
@Override	public int compare(final Object obj1, final Object obj2) {	    return ((Comparable) obj1).compareTo(obj2);	}
@Override	public TimeZone getTimeZone() {	    return timeZone;	}
public static <K, V> V createIfAbsent(final ConcurrentMap<K, V> map, final K key, final ConcurrentInitializer<V> init) throws ConcurrentException {	    if (map == null || init == null) {	        return null;	    }	    final V value = map.get(key);	    if (value == null) {	        return putIfAbsent(map, key, init.get());	    }	    return value;	}
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException {	    return charsetName == null ? new String(bytes) : new String(bytes, charsetName);	}
public static <T> Range<T> is(final T element, final Comparator<T> comparator) {	    return between(element, element, comparator);	}
public String getNullText() {	    return nullText;	}
public static short toShort(final String str, final short defaultValue) {	    if (str == null) {	        return defaultValue;	    }	    try {	        return Short.parseShort(str);	    } catch (final NumberFormatException nfe) {	        return defaultValue;	    }	}
public static void isAssignableFrom(final Class<?> superType, final Class<?> type, final String message, final Object... values) {	    if (superType.isAssignableFrom(type) == false) {	        throw new IllegalArgumentException(String.format(message, values));	    }	}
public static char intToHexDigit(final int nibble) {	    final char c = Character.forDigit(nibble, 16);	    if (c == Character.MIN_VALUE) {	        throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble);	    }	    return c;	}
public String getNewLineText() {	    return newLine;	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
@Override	public void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart) {	    super.setFieldSeparatorAtStart(fieldSeparatorAtStart);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static StrMatcher spaceMatcher() {	    return SPACE_MATCHER;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static boolean isAlphanumeric(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetterOrDigit(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static String trim(final String str) {	    return str == null ? null : str.trim();	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public static boolean isInstance(final Object value, final Type type) {	    if (type == null) {	        return false;	    }	    return value == null ? !(type instanceof Class<?>) || !((Class<?>) type).isPrimitive() : isAssignable(value.getClass(), type, null);	}
public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale) {	    return cache.getTimeInstance(style, timeZone, locale);	}
public static boolean[] hexDigitToBinary(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return new boolean[] { false, false, false, false };	        case '1':	            return new boolean[] { true, false, false, false };	        case '2':	            return new boolean[] { false, true, false, false };	        case '3':	            return new boolean[] { true, true, false, false };	        case '4':	            return new boolean[] { false, false, true, false };	        case '5':	            return new boolean[] { true, false, true, false };	        case '6':	            return new boolean[] { false, true, true, false };	        case '7':	            return new boolean[] { true, true, true, false };	        case '8':	            return new boolean[] { false, false, false, true };	        case '9':	            return new boolean[] { true, false, false, true };	        case 'a':	        case 'A':	            return new boolean[] { false, true, false, true };	        case 'b':	        case 'B':	            return new boolean[] { true, true, false, true };	        case 'c':	        case 'C':	            return new boolean[] { false, false, true, true };	        case 'd':	        case 'D':	            return new boolean[] { true, false, true, true };	        case 'e':	        case 'E':	            return new boolean[] { false, true, true, true };	        case 'f':	        case 'F':	            return new boolean[] { true, true, true, true };	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public boolean isEquals() {	    return this.isEquals;	}
@Override	public L getLeft() {	    return left;	}
protected boolean isUseClassName() {	    return useClassName;	}
@Override	public String previous() {	    if (hasPrevious()) {	        return tokens[--tokenPos];	    }	    throw new NoSuchElementException();	}
public String rightString(final int length) {	    if (length <= 0) {	        return "";	    } else if (length >= size) {	        return new String(buffer, 0, size);	    } else {	        return new String(buffer, size - length, length);	    }	}
public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames) {	    if (causeFrames == null || wrapperFrames == null) {	        throw new IllegalArgumentException("The List must not be null");	    }	    int causeFrameIndex = causeFrames.size() - 1;	    int wrapperFrameIndex = wrapperFrames.size() - 1;	    while (causeFrameIndex >= 0 && wrapperFrameIndex >= 0) {	        final String causeFrame = causeFrames.get(causeFrameIndex);	        final String wrapperFrame = wrapperFrames.get(wrapperFrameIndex);	        if (causeFrame.equals(wrapperFrame)) {	            causeFrames.remove(causeFrameIndex);	        }	        causeFrameIndex--;	        wrapperFrameIndex--;	    }	}
public Boolean toBoolean() {	    return Boolean.valueOf(booleanValue());	}
public StrBuilder appendSeparator(final char separator, final int loopIndex) {	    if (loopIndex > 0) {	        append(separator);	    }	    return this;	}
public static Number createNumber(final String str) throws NumberFormatException {	    if (str == null) {	        return null;	    }	    if (StringUtils.isBlank(str)) {	        throw new NumberFormatException("A blank string is not a valid number");	    }	    final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" };	    int pfxLen = 0;	    for (final String pfx : hex_prefixes) {	        if (str.startsWith(pfx)) {	            pfxLen += pfx.length();	            break;	        }	    }	    if (pfxLen > 0) {	        final int hexDigits = str.length() - pfxLen;	        if (hexDigits > 16) {	            return createBigInteger(str);	        }	        if (hexDigits > 8) {	            return createLong(str);	        }	        return createInteger(str);	    }	    final char lastChar = str.charAt(str.length() - 1);	    String mant;	    String dec;	    String exp;	    final int decPos = str.indexOf('.');	    final int expPos = str.indexOf('e') + str.indexOf('E') + 1;	    int numDecimals = 0;	    if (decPos > -1) {	        if (expPos > -1) {	            if (expPos < decPos || expPos > str.length()) {	                throw new NumberFormatException(str + " is not a valid number.");	            }	            dec = str.substring(decPos + 1, expPos);	        } else {	            dec = str.substring(decPos + 1);	        }	        mant = str.substring(0, decPos);	        numDecimals = dec.length();	    } else {	        if (expPos > -1) {	            if (expPos > str.length()) {	                throw new NumberFormatException(str + " is not a valid number.");	            }	            mant = str.substring(0, expPos);	        } else {	            mant = str;	        }	        dec = null;	    }	    if (!Character.isDigit(lastChar) && lastChar != '.') {	        if (expPos > -1 && expPos < str.length() - 1) {	            exp = str.substring(expPos + 1, str.length() - 1);	        } else {	            exp = null;	        }	        final String numeric = str.substring(0, str.length() - 1);	        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);	        switch(lastChar) {	            case 'l':	            case 'L':	                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {	                    try {	                        return createLong(numeric);	                    } catch (final NumberFormatException nfe) {	                    }	                    return createBigInteger(numeric);	                }	                throw new NumberFormatException(str + " is not a valid number.");	            case 'f':	            case 'F':	                try {	                    final Float f = NumberUtils.createFloat(numeric);	                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {	                        return f;	                    }	                } catch (final NumberFormatException nfe) {	                }	            case 'd':	            case 'D':	                try {	                    final Double d = NumberUtils.createDouble(numeric);	                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {	                        return d;	                    }	                } catch (final NumberFormatException nfe) {	                }	                try {	                    return createBigDecimal(numeric);	                } catch (final NumberFormatException e) {	                }	            default:	                throw new NumberFormatException(str + " is not a valid number.");	        }	    }	    if (expPos > -1 && expPos < str.length() - 1) {	        exp = str.substring(expPos + 1, str.length());	    } else {	        exp = null;	    }	    if (dec == null && exp == null) {	        try {	            return createInteger(str);	        } catch (final NumberFormatException nfe) {	        }	        try {	            return createLong(str);	        } catch (final NumberFormatException nfe) {	        }	        return createBigInteger(str);	    }	    final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);	    try {	        if (numDecimals <= 7) {	            final Float f = createFloat(str);	            if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {	                return f;	            }	        }	    } catch (final NumberFormatException nfe) {	    }	    try {	        if (numDecimals <= 16) {	            final Double d = createDouble(str);	            if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {	                return d;	            }	        }	    } catch (final NumberFormatException nfe) {	    }	    return createBigDecimal(str);	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
public static boolean containsWhitespace(final CharSequence seq) {	    if (isEmpty(seq)) {	        return false;	    }	    final int strLen = seq.length();	    for (int i = 0; i < strLen; i++) {	        if (Character.isWhitespace(seq.charAt(i))) {	            return true;	        }	    }	    return false;	}
public boolean isEmpty() {	    return size == 0;	}
public static String capitalize(final String str) {	    int strLen;	    if (str == null || (strLen = str.length()) == 0) {	        return str;	    }	    char firstChar = str.charAt(0);	    if (Character.isTitleCase(firstChar)) {	        return str;	    }	    return new StringBuilder(strLen).append(Character.toTitleCase(firstChar)).append(str.substring(1)).toString();	}
public int size() {	    return size;	}
public static void reverse(final boolean[] array) {	    if (array == null) {	        return;	    }	    int i = 0;	    int j = array.length - 1;	    boolean tmp;	    while (j > i) {	        tmp = array[j];	        array[j] = array[i];	        array[i] = tmp;	        j--;	        i++;	    }	}
public static boolean isEmpty(final boolean[] array) {	    return array == null || array.length == 0;	}
protected String getContentStart() {	    return contentStart;	}
public static Locale toLocale(final String str) {	    if (str == null) {	        return null;	    }	    if (str.contains("#")) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final int len = str.length();	    if (len < 2) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final char ch0 = str.charAt(0);	    if (ch0 == '_') {	        if (len < 3) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        final char ch1 = str.charAt(1);	        final char ch2 = str.charAt(2);	        if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        if (len == 3) {	            return new Locale("", str.substring(1, 3));	        }	        if (len < 5) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        if (str.charAt(3) != '_') {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        return new Locale("", str.substring(1, 3), str.substring(4));	    }	    final char ch1 = str.charAt(1);	    if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (len == 2) {	        return new Locale(str);	    }	    if (len < 5) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (str.charAt(2) != '_') {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final char ch3 = str.charAt(3);	    if (ch3 == '_') {	        return new Locale(str.substring(0, 2), "", str.substring(4));	    }	    final char ch4 = str.charAt(4);	    if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (len == 5) {	        return new Locale(str.substring(0, 2), str.substring(3, 5));	    }	    if (len < 7) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (str.charAt(5) != '_') {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));	}
@Override	public TimeZone getTimeZone() {	    return mTimeZone;	}
public static <K, V> V createIfAbsent(final ConcurrentMap<K, V> map, final K key, final ConcurrentInitializer<V> init) throws ConcurrentException {	    if (map == null || init == null) {	        return null;	    }	    final V value = map.get(key);	    if (value == null) {	        return putIfAbsent(map, key, init.get());	    }	    return value;	}
public void add(final Number operand) {	    this.value += operand.floatValue();	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public char getEnd() {	    return this.end;	}
public String getNewLineText() {	    return newLine;	}
public static boolean isAllLowerCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLowerCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static boolean isNotEmpty(final CharSequence cs) {	    return !StringUtils.isEmpty(cs);	}
public static UUID byteArrayToUuid(final byte[] src, final int srcPos) {	    if (src.length - srcPos < 16) {	        throw new IllegalArgumentException("Need at least 16 bytes for UUID");	    }	    return new UUID(byteArrayToLong(src, srcPos, 0, 0, 8), byteArrayToLong(src, srcPos + 8, 0, 0, 8));	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static boolean isAscii(final char ch) {	    return ch < 128;	}
public static String rightPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return rightPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return str.concat(padStr);	    } else if (pads < padLen) {	        return str.concat(padStr.substring(0, pads));	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return str.concat(new String(padding));	    }	}
@Deprecated	public static String chomp(final String str, final String separator) {	    return removeEnd(str, separator);	}
protected String getSummaryObjectStartText() {	    return summaryObjectStartText;	}
public static String[] stripAll(final String[] strs, final String stripChars) {	    int strsLen;	    if (strs == null || (strsLen = strs.length) == 0) {	        return strs;	    }	    final String[] newArr = new String[strsLen];	    for (int i = 0; i < strsLen; i++) {	        newArr[i] = strip(strs[i], stripChars);	    }	    return newArr;	}
@Override	public boolean ready() {	    return pos < StrBuilder.this.size();	}
public void subtract(final Number operand) {	    this.value -= operand.floatValue();	}
public static boolean endsWithIgnoreCase(final CharSequence str, final CharSequence suffix) {	    return endsWith(str, suffix, true);	}
public StrBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar) {	    return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);	}
public static final String escapeHtml3(final String input) {	    return ESCAPE_HTML3.translate(input);	}
public static String repeat(final char ch, final int repeat) {	    final char[] buf = new char[repeat];	    for (int i = repeat - 1; i >= 0; i--) {	        buf[i] = ch;	    }	    return new String(buf);	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
public static String stripEnd(final String str, final String stripChars) {	    int end;	    if (str == null || (end = str.length()) == 0) {	        return str;	    }	    if (stripChars == null) {	        while (end != 0 && Character.isWhitespace(str.charAt(end - 1))) {	            end--;	        }	    } else if (stripChars.isEmpty()) {	        return str;	    } else {	        while (end != 0 && stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND) {	            end--;	        }	    }	    return str.substring(0, end);	}
private static long getFragment(final Calendar calendar, final int fragment, final int unit) {	    if (calendar == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final long millisPerUnit = getMillisPerUnit(unit);	    long result = 0;	    switch(fragment) {	        case Calendar.YEAR:	            result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit;	            break;	        case Calendar.MONTH:	            result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit;	            break;	    }	    switch(fragment) {	        case Calendar.YEAR:	        case Calendar.MONTH:	        case Calendar.DAY_OF_YEAR:	        case Calendar.DATE:	            result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit;	        case Calendar.HOUR_OF_DAY:	            result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit;	        case Calendar.MINUTE:	            result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit;	        case Calendar.SECOND:	            result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit;	            break;	        case Calendar.MILLISECOND:	            break;	        default:	            throw new IllegalArgumentException("The fragment " + fragment + " is not supported");	    }	    return result;	}
public String getNullText() {	    return nullText;	}
public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final E... values) {	    Validate.noNullElements(values);	    return generateBitVector(enumClass, Arrays.<E>asList(values));	}
@Override	public int intValue() {	    return value;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
@Override	public Date parse(final String source, final ParsePosition pos) {	    final int offset = pos.getIndex();	    final Matcher matcher = parsePattern.matcher(source.substring(offset));	    if (!matcher.lookingAt()) {	        return null;	    }	    final Calendar cal = Calendar.getInstance(timeZone, locale);	    cal.clear();	    for (int i = 0; i < strategies.length; ) {	        final Strategy strategy = strategies[i++];	        strategy.setCalendar(this, cal, matcher.group(i));	    }	    pos.setIndex(offset + matcher.end());	    return cal.getTime();	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
public static String formatUTC(final Date date, final String pattern, final Locale locale) {	    return format(date, pattern, UTC_TIME_ZONE, locale);	}
public int capacity() {	    return buffer.length;	}
public String getNullText() {	    return nullText;	}
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException {	    return charsetName == null ? new String(bytes) : new String(bytes, charsetName);	}
public static Type[] getImplicitUpperBounds(final WildcardType wildcardType) {	    final Type[] bounds = wildcardType.getUpperBounds();	    return bounds.length == 0 ? new Type[] { Object.class } : normalizeUpperBounds(bounds);	}
public String getNewLineText() {	    return newLine;	}
public static boolean isNotFalse(final Boolean bool) {	    return !isFalse(bool);	}
protected String getArrayStart() {	    return arrayStart;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale) {	    return cache.getDateInstance(style, timeZone, locale);	}
public static String random(final int count, final char... chars) {	    if (chars == null) {	        return random(count, 0, 0, false, false, null, RANDOM);	    }	    return random(count, 0, chars.length, false, false, chars, RANDOM);	}
public static void isAssignableFrom(final Class<?> superType, final Class<?> type, final String message, final Object... values) {	    if (superType.isAssignableFrom(type) == false) {	        throw new IllegalArgumentException(String.format(message, values));	    }	}
@Override	public void close() {	}
public StrBuilder deleteAll(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, -1);	}
public static String randomAlphabetic(final int count) {	    return random(count, true, false);	}
public String getNullText() {	    return nullText;	}
@Override	public boolean translate(final int codepoint, final Writer out) throws IOException {	    if (between) {	        if (codepoint < below || codepoint > above) {	            return false;	        }	    } else {	        if (codepoint >= below && codepoint <= above) {	            return false;	        }	    }	    out.write("&#");	    out.write(Integer.toString(codepoint, 10));	    out.write(';');	    return true;	}
public static String abbreviate(final String str, int offset, final int maxWidth) {	    if (str == null) {	        return null;	    }	    if (maxWidth < 4) {	        throw new IllegalArgumentException("Minimum abbreviation width is 4");	    }	    if (str.length() <= maxWidth) {	        return str;	    }	    if (offset > str.length()) {	        offset = str.length();	    }	    if (str.length() - offset < maxWidth - 3) {	        offset = str.length() - (maxWidth - 3);	    }	    final String abrevMarker = "...";	    if (offset <= 4) {	        return str.substring(0, maxWidth - 3) + abrevMarker;	    }	    if (maxWidth < 7) {	        throw new IllegalArgumentException("Minimum abbreviation width with offset is 7");	    }	    if (offset + maxWidth - 3 < str.length()) {	        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);	    }	    return abrevMarker + str.substring(str.length() - (maxWidth - 3));	}
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) {	    style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));	    return this;	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static Boolean or(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public static Boolean[] nullToEmpty(final Boolean[] array) {	    if (array == null || array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    return array;	}
protected String getSummaryObjectEndText() {	    return summaryObjectEndText;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
private static String[] splitByCharacterType(final String str, final boolean camelCase) {	    if (str == null) {	        return null;	    }	    if (str.isEmpty()) {	        return ArrayUtils.EMPTY_STRING_ARRAY;	    }	    final char[] c = str.toCharArray();	    final List<String> list = new ArrayList<String>();	    int tokenStart = 0;	    int currentType = Character.getType(c[tokenStart]);	    for (int pos = tokenStart + 1; pos < c.length; pos++) {	        final int type = Character.getType(c[pos]);	        if (type == currentType) {	            continue;	        }	        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {	            final int newTokenStart = pos - 1;	            if (newTokenStart != tokenStart) {	                list.add(new String(c, tokenStart, newTokenStart - tokenStart));	                tokenStart = newTokenStart;	            }	        } else {	            list.add(new String(c, tokenStart, pos - tokenStart));	            tokenStart = pos;	        }	        currentType = type;	    }	    list.add(new String(c, tokenStart, c.length - tokenStart));	    return list.toArray(new String[list.size()]);	}
@Override	public int length() {	    return size;	}
@Override	public long skip(long n) {	    if (pos + n > StrBuilder.this.size()) {	        n = StrBuilder.this.size() - pos;	    }	    if (n < 0) {	        return 0;	    }	    pos += n;	    return n;	}
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return new boolean[] { false, false, false, false };	        case '1':	            return new boolean[] { false, false, false, true };	        case '2':	            return new boolean[] { false, false, true, false };	        case '3':	            return new boolean[] { false, false, true, true };	        case '4':	            return new boolean[] { false, true, false, false };	        case '5':	            return new boolean[] { false, true, false, true };	        case '6':	            return new boolean[] { false, true, true, false };	        case '7':	            return new boolean[] { false, true, true, true };	        case '8':	            return new boolean[] { true, false, false, false };	        case '9':	            return new boolean[] { true, false, false, true };	        case 'a':	        case 'A':	            return new boolean[] { true, false, true, false };	        case 'b':	        case 'B':	            return new boolean[] { true, false, true, true };	        case 'c':	        case 'C':	            return new boolean[] { true, true, false, false };	        case 'd':	        case 'D':	            return new boolean[] { true, true, false, true };	        case 'e':	        case 'E':	            return new boolean[] { true, true, true, false };	        case 'f':	        case 'F':	            return new boolean[] { true, true, true, true };	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) {	    return new Range<T>(fromInclusive, toInclusive, comparator);	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) {	    final StringBuilder buffer = new StringBuilder();	    boolean lastOutputSeconds = false;	    final int sz = tokens.length;	    for (int i = 0; i < sz; i++) {	        final Token token = tokens[i];	        final Object value = token.getValue();	        final int count = token.getCount();	        if (value instanceof StringBuilder) {	            buffer.append(value.toString());	        } else {	            if (value == y) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years));	                lastOutputSeconds = false;	            } else if (value == M) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months));	                lastOutputSeconds = false;	            } else if (value == d) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days));	                lastOutputSeconds = false;	            } else if (value == H) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours));	                lastOutputSeconds = false;	            } else if (value == m) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes));	                lastOutputSeconds = false;	            } else if (value == s) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds));	                lastOutputSeconds = true;	            } else if (value == S) {	                if (lastOutputSeconds) {	                    milliseconds += 1000;	                    final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds);	                    buffer.append(str.substring(1));	                } else {	                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds));	                }	                lastOutputSeconds = false;	            }	        }	    }	    return buffer.toString();	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static int lastIndexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = INDEX_NOT_FOUND;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.lastIndexOf(str, search, str.length());	        if (tmp > ret) {	            ret = tmp;	        }	    }	    return ret;	}
public int toComparison() {	    return comparison;	}
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return new boolean[] { false, false, false, false };	        case '1':	            return new boolean[] { false, false, false, true };	        case '2':	            return new boolean[] { false, false, true, false };	        case '3':	            return new boolean[] { false, false, true, true };	        case '4':	            return new boolean[] { false, true, false, false };	        case '5':	            return new boolean[] { false, true, false, true };	        case '6':	            return new boolean[] { false, true, true, false };	        case '7':	            return new boolean[] { false, true, true, true };	        case '8':	            return new boolean[] { true, false, false, false };	        case '9':	            return new boolean[] { true, false, false, true };	        case 'a':	        case 'A':	            return new boolean[] { true, false, true, false };	        case 'b':	        case 'B':	            return new boolean[] { true, false, true, true };	        case 'c':	        case 'C':	            return new boolean[] { true, true, false, false };	        case 'd':	        case 'D':	            return new boolean[] { true, true, false, true };	        case 'e':	        case 'E':	            return new boolean[] { true, true, true, false };	        case 'f':	        case 'F':	            return new boolean[] { true, true, true, true };	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
@Override	public int compare(final Object obj1, final Object obj2) {	    return ((Comparable) obj1).compareTo(obj2);	}
public static <L, R> Pair<L, R> of(final L left, final R right) {	    return new ImmutablePair<L, R>(left, right);	}
public static <T extends CharSequence> T defaultIfBlank(final T str, final T defaultStr) {	    return StringUtils.isBlank(str) ? defaultStr : str;	}
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] result = new boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        final Boolean b = array[i];	        result[i] = (b == null ? valueForNull : b.booleanValue());	    }	    return result;	}
@Override	public long longValue() {	    return (long) numerator / denominator;	}
@Override	public String previous() {	    if (hasPrevious()) {	        return tokens[--tokenPos];	    }	    throw new NoSuchElementException();	}
public StrBuilder appendFixedWidthPadRight(final int value, final int width, final char padChar) {	    return appendFixedWidthPadRight(String.valueOf(value), width, padChar);	}
@Override	public int length() {	    return size;	}
public void start() {	    if (this.runningState == STATE_STOPPED) {	        throw new IllegalStateException("Stopwatch must be reset before being restarted. ");	    }	    if (this.runningState != STATE_UNSTARTED) {	        throw new IllegalStateException("Stopwatch already started. ");	    }	    this.startTime = System.nanoTime();	    this.startTimeMillis = System.currentTimeMillis();	    this.runningState = STATE_RUNNING;	}
public static boolean containsOnly(final CharSequence cs, final String validChars) {	    if (cs == null || validChars == null) {	        return false;	    }	    return containsOnly(cs, validChars.toCharArray());	}
public static <E extends Enum<E>> E getEnum(final Class<E> enumClass, final String enumName) {	    if (enumName == null) {	        return null;	    }	    try {	        return Enum.valueOf(enumClass, enumName);	    } catch (final IllegalArgumentException ex) {	        return null;	    }	}
public static <E extends Enum<E>> Map<String, E> getEnumMap(final Class<E> enumClass) {	    final Map<String, E> map = new LinkedHashMap<String, E>();	    for (final E e : enumClass.getEnumConstants()) {	        map.put(e.name(), e);	    }	    return map;	}
public static Type getArrayComponentType(final Type type) {	    if (type instanceof Class<?>) {	        final Class<?> clazz = (Class<?>) type;	        return clazz.isArray() ? clazz.getComponentType() : null;	    }	    if (type instanceof GenericArrayType) {	        return ((GenericArrayType) type).getGenericComponentType();	    }	    return null;	}
public static String substringBeforeLast(final String str, final String separator) {	    if (isEmpty(str) || isEmpty(separator)) {	        return str;	    }	    final int pos = str.lastIndexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return str;	    }	    return str.substring(0, pos);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static boolean isSameLength(final boolean[] array1, final boolean[] array2) {	    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {	        return false;	    }	    return true;	}
public static boolean containsAny(final CharSequence cs, final CharSequence searchChars) {	    if (searchChars == null) {	        return false;	    }	    return containsAny(cs, CharSequenceUtils.toCharArray(searchChars));	}
public String toString(final String format) {	    return String.format(format, minimum, maximum, comparator);	}
public StrBuilder appendNull() {	    if (nullText == null) {	        return this;	    }	    return append(nullText);	}
public StrSubstitutor setVariablePrefix(final String prefix) {	    if (prefix == null) {	        throw new IllegalArgumentException("Variable prefix must not be null!");	    }	    return setVariablePrefixMatcher(StrMatcher.stringMatcher(prefix));	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
static int compareParameterTypes(final Class<?>[] left, final Class<?>[] right, final Class<?>[] actual) {	    final float leftCost = getTotalTransformationCost(actual, left);	    final float rightCost = getTotalTransformationCost(actual, right);	    return leftCost < rightCost ? -1 : rightCost < leftCost ? 1 : 0;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public long getThreadCount() {	    return threadCounter.get();	}
public int capacity() {	    return buffer.length;	}
public void add(final Number operand) {	    this.value += operand.intValue();	}
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) {	    style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));	    return this;	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public boolean replaceIn(final StrBuilder source, final int offset, final int length) {	    if (source == null) {	        return false;	    }	    return substitute(source, offset, length);	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static boolean isAllUpperCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isUpperCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public boolean isEmpty() {	    return size == 0;	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
protected boolean isUseClassName() {	    return useClassName;	}
public int size() {	    return size;	}
protected boolean isFieldSeparatorAtEnd() {	    return fieldSeparatorAtEnd;	}
public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {	    if (str == null || searchStr == null) {	        return INDEX_NOT_FOUND;	    }	    if (startPos > str.length() - searchStr.length()) {	        startPos = str.length() - searchStr.length();	    }	    if (startPos < 0) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return startPos;	    }	    for (int i = startPos; i >= 0; i--) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public StrTokenizer reset(final char[] input) {	    reset();	    this.chars = ArrayUtils.clone(input);	    return this;	}
@Override	public String getArrayEnd() {	    return super.getArrayEnd();	}
public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) {	    if (s == null || t == null) {	        throw new IllegalArgumentException("Strings must not be null");	    }	    if (threshold < 0) {	        throw new IllegalArgumentException("Threshold must not be negative");	    }	    int n = s.length();	    int m = t.length();	    if (n == 0) {	        return m <= threshold ? m : -1;	    } else if (m == 0) {	        return n <= threshold ? n : -1;	    }	    if (n > m) {	        final CharSequence tmp = s;	        s = t;	        t = tmp;	        n = m;	        m = t.length();	    }	    int[] p = new int[n + 1];	    int[] d = new int[n + 1];	    int[] _d;	    final int boundary = Math.min(n, threshold) + 1;	    for (int i = 0; i < boundary; i++) {	        p[i] = i;	    }	    Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);	    Arrays.fill(d, Integer.MAX_VALUE);	    for (int j = 1; j <= m; j++) {	        final char t_j = t.charAt(j - 1);	        d[0] = j;	        final int min = Math.max(1, j - threshold);	        final int max = Math.min(n, j + threshold);	        if (min > max) {	            return -1;	        }	        if (min > 1) {	            d[min - 1] = Integer.MAX_VALUE;	        }	        for (int i = min; i <= max; i++) {	            if (s.charAt(i - 1) == t_j) {	                d[i] = p[i - 1];	            } else {	                d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);	            }	        }	        _d = p;	        p = d;	        d = _d;	    }	    if (p[n] <= threshold) {	        return p[n];	    }	    return -1;	}
@Override	public boolean equals(final Object obj) {	    if (obj == this) {	        return true;	    }	    if (obj == null) {	        return false;	    }	    if (!super.equals(obj)) {	        return false;	    }	    if (ObjectUtils.notEqual(getClass(), obj.getClass())) {	        return false;	    }	    final ExtendedMessageFormat rhs = (ExtendedMessageFormat) obj;	    if (ObjectUtils.notEqual(toPattern, rhs.toPattern)) {	        return false;	    }	    if (ObjectUtils.notEqual(registry, rhs.registry)) {	        return false;	    }	    return true;	}
public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) {	    if (array == null) {	        return null;	    }	    if (startIndexInclusive < 0) {	        startIndexInclusive = 0;	    }	    if (endIndexExclusive > array.length) {	        endIndexExclusive = array.length;	    }	    final int newSize = endIndexExclusive - startIndexInclusive;	    if (newSize <= 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] subarray = new boolean[newSize];	    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);	    return subarray;	}
public char getEnd() {	    return this.end;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes) {	    if ((src.length == 0 && srcPos == 0) || 0 == nBytes) {	        return dstInit;	    }	    if ((nBytes - 1) * 8 + dstPos >= 16) {	        throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 16");	    }	    short out = dstInit;	    int shift = 0;	    for (int i = 0; i < nBytes; i++) {	        shift = i * 8 + dstPos;	        final int bits = (0xff & src[i + srcPos]) << shift;	        final int mask = 0xff << shift;	        out = (short) ((out & ~mask) | bits);	    }	    return out;	}
public int toComparison() {	    return comparison;	}
public static Date addMinutes(final Date date, final int amount) {	    return add(date, Calendar.MINUTE, amount);	}
public int toComparison() {	    return comparison;	}
public Float toFloat() {	    return Float.valueOf(floatValue());	}
protected String getArrayStart() {	    return arrayStart;	}
protected void add(final String str) {	    if (str == null) {	        return;	    }	    final int len = str.length();	    int pos = 0;	    while (pos < len) {	        final int remainder = len - pos;	        if (remainder >= 4 && str.charAt(pos) == '^' && str.charAt(pos + 2) == '-') {	            set.add(CharRange.isNotIn(str.charAt(pos + 1), str.charAt(pos + 3)));	            pos += 4;	        } else if (remainder >= 3 && str.charAt(pos + 1) == '-') {	            set.add(CharRange.isIn(str.charAt(pos), str.charAt(pos + 2)));	            pos += 3;	        } else if (remainder >= 2 && str.charAt(pos) == '^') {	            set.add(CharRange.isNot(str.charAt(pos + 1)));	            pos += 2;	        } else {	            set.add(CharRange.is(str.charAt(pos)));	            pos += 1;	        }	    }	}
public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) {	    if (array == null) {	        return null;	    }	    if (startIndexInclusive < 0) {	        startIndexInclusive = 0;	    }	    if (endIndexExclusive > array.length) {	        endIndexExclusive = array.length;	    }	    final int newSize = endIndexExclusive - startIndexInclusive;	    if (newSize <= 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] subarray = new boolean[newSize];	    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);	    return subarray;	}
public Builder namingPattern(final String pattern) {	    if (pattern == null) {	        throw new NullPointerException("Naming pattern must not be null!");	    }	    namingPattern = pattern;	    return this;	}
protected void appendFieldStart(final StringBuffer buffer, final String fieldName) {	    if (useFieldNames && fieldName != null) {	        buffer.append(fieldName);	        buffer.append(fieldNameValueSeparator);	    }	}
@Override	public int compareTo(final MutableInt other) {	    final int anotherVal = other.value;	    return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1);	}
public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale) {	    return cache.getInstance(pattern, timeZone, locale);	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static Method getAccessibleMethod(Method method) {	    if (!MemberUtils.isAccessible(method)) {	        return null;	    }	    final Class<?> cls = method.getDeclaringClass();	    if (Modifier.isPublic(cls.getModifiers())) {	        return method;	    }	    final String methodName = method.getName();	    final Class<?>[] parameterTypes = method.getParameterTypes();	    method = getAccessibleMethodFromInterfaceNest(cls, methodName, parameterTypes);	    if (method == null) {	        method = getAccessibleMethodFromSuperclass(cls, methodName, parameterTypes);	    }	    return method;	}
protected String getContentStart() {	    return contentStart;	}
static int lastIndexOf(final CharSequence cs, final CharSequence searchChar, final int start) {	    return cs.toString().lastIndexOf(searchChar.toString(), start);	}
public boolean isEmpty() {	    return size == 0;	}
public String getNullText() {	    return nullText;	}
public static Object invokeExactMethod(final Object object, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {	    if (args == null) {	        args = ArrayUtils.EMPTY_OBJECT_ARRAY;	    }	    if (parameterTypes == null) {	        parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;	    }	    final Method method = getAccessibleMethod(object.getClass(), methodName, parameterTypes);	    if (method == null) {	        throw new NoSuchMethodException("No such accessible method: " + methodName + "() on object: " + object.getClass().getName());	    }	    return method.invoke(object, args);	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
@Override	public long longValue() {	    return value;	}
public static Boolean negate(final Boolean bool) {	    if (bool == null) {	        return null;	    }	    return bool.booleanValue() ? Boolean.FALSE : Boolean.TRUE;	}
public static boolean isAsciiNumeric(final char ch) {	    return ch >= '0' && ch <= '9';	}
@Override	public boolean isArrayContentDetail() {	    return super.isArrayContentDetail();	}
public static String randomAscii(final int count) {	    return random(count, 32, 127, false, false);	}
public int clear(final int holder) {	    return holder & ~_mask;	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public Fraction negate() {	    if (numerator == Integer.MIN_VALUE) {	        throw new ArithmeticException("overflow: too large to negate");	    }	    return new Fraction(-numerator, denominator);	}
public static String abbreviateMiddle(final String str, final String middle, final int length) {	    if (isEmpty(str) || isEmpty(middle)) {	        return str;	    }	    if (length >= str.length() || length < middle.length() + 2) {	        return str;	    }	    final int targetSting = length - middle.length();	    final int startOffset = targetSting / 2 + targetSting % 2;	    final int endOffset = str.length() - targetSting / 2;	    final StringBuilder builder = new StringBuilder(length);	    builder.append(str.substring(0, startOffset));	    builder.append(middle);	    builder.append(str.substring(endOffset));	    return builder.toString();	}
public static Class<?>[] wrappersToPrimitives(final Class<?>... classes) {	    if (classes == null) {	        return null;	    }	    if (classes.length == 0) {	        return classes;	    }	    final Class<?>[] convertedClasses = new Class[classes.length];	    for (int i = 0; i < classes.length; i++) {	        convertedClasses[i] = wrapperToPrimitive(classes[i]);	    }	    return convertedClasses;	}
public static Boolean or(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
protected String getContentEnd() {	    return contentEnd;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public String[] getTokenArray() {	    checkTokenized();	    return tokens.clone();	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
public int size() {	    return size;	}
public static String stripEnd(final String str, final String stripChars) {	    int end;	    if (str == null || (end = str.length()) == 0) {	        return str;	    }	    if (stripChars == null) {	        while (end != 0 && Character.isWhitespace(str.charAt(end - 1))) {	            end--;	        }	    } else if (stripChars.isEmpty()) {	        return str;	    } else {	        while (end != 0 && stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND) {	            end--;	        }	    }	    return str.substring(0, end);	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public boolean startsWith(final String str) {	    if (str == null) {	        return false;	    }	    final int len = str.length();	    if (len == 0) {	        return true;	    }	    if (len > size) {	        return false;	    }	    for (int i = 0; i < len; i++) {	        if (buffer[i] != str.charAt(i)) {	            return false;	        }	    }	    return true;	}
public static String[] splitByWholeSeparatorPreserveAllTokens(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, true);	}
public static String difference(final String str1, final String str2) {	    if (str1 == null) {	        return str2;	    }	    if (str2 == null) {	        return str1;	    }	    final int at = indexOfDifference(str1, str2);	    if (at == INDEX_NOT_FOUND) {	        return EMPTY;	    }	    return str2.substring(at);	}
protected boolean isFieldSeparatorAtEnd() {	    return fieldSeparatorAtEnd;	}
public static int toIntValue(final Character ch, final int defaultValue) {	    if (ch == null) {	        return defaultValue;	    }	    return toIntValue(ch.charValue(), defaultValue);	}
public int toComparison() {	    return comparison;	}
public static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex) {	    if (0 == nHex) {	        return dstInit;	    }	    if ((nHex - 1) * 4 + dstPos >= 16) {	        throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 16");	    }	    short out = dstInit;	    int shift = 0;	    for (int i = 0; i < nHex; i++) {	        shift = i * 4 + dstPos;	        final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift;	        final int mask = 0xf << shift;	        out = (short) ((out & ~mask) | bits);	    }	    return out;	}
@Override	public T get() throws ConcurrentException {	    try {	        return getFuture().get();	    } catch (final ExecutionException execex) {	        ConcurrentUtils.handleCause(execex);	        return null;	    } catch (final InterruptedException iex) {	        Thread.currentThread().interrupt();	        throw new ConcurrentException(iex);	    }	}
@Override	public long longValue() {	    return value;	}
@Override	public String toString() {	    return String.valueOf(value);	}
protected boolean isArrayContentDetail() {	    return arrayContentDetail;	}
public static float min(final float a, final float b, final float c) {	    return Math.min(Math.min(a, b), c);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public boolean isEmpty() {	    return size == 0;	}
public static String removeStart(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.startsWith(remove)) {	        return str.substring(remove.length());	    }	    return str;	}
public String getNewLineText() {	    return newLine;	}
public static boolean isAsciiPrintable(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
@Override	public TimeZone getTimeZone() {	    return printer.getTimeZone();	}
public EqualsBuilder appendSuper(final boolean superEquals) {	    if (isEquals == false) {	        return this;	    }	    isEquals = superEquals;	    return this;	}
public static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) {	    if (0 == nHexs) {	        return dstInit;	    }	    if ((nHexs - 1) * 4 + srcPos >= 32) {	        throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 32");	    }	    final StringBuilder sb = new StringBuilder(dstInit);	    int shift = 0;	    int append = sb.length();	    for (int i = 0; i < nHexs; i++) {	        shift = i * 4 + srcPos;	        final int bits = 0xF & (src >> shift);	        if (dstPos + i == append) {	            ++append;	            sb.append(intToHexDigit(bits));	        } else {	            sb.setCharAt(dstPos + i, intToHexDigit(bits));	        }	    }	    return sb.toString();	}
public static String getSimpleName(final Object object, final String valueIfNull) {	    if (object == null) {	        return valueIfNull;	    }	    return getSimpleName(object.getClass());	}
@Override	public String getSizeStartText() {	    return super.getSizeStartText();	}
public static String substringBefore(final String str, final String separator) {	    if (isEmpty(str) || separator == null) {	        return str;	    }	    if (separator.isEmpty()) {	        return EMPTY;	    }	    final int pos = str.indexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return str;	    }	    return str.substring(0, pos);	}
public static CharRange isNot(final char ch) {	    return new CharRange(ch, ch, true);	}
public static String formatDuration(long durationMillis, final String format, final boolean padWithZeros) {	    final Token[] tokens = lexx(format);	    int days = 0;	    int hours = 0;	    int minutes = 0;	    int seconds = 0;	    int milliseconds = 0;	    if (Token.containsTokenWithValue(tokens, d)) {	        days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY);	        durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY);	    }	    if (Token.containsTokenWithValue(tokens, H)) {	        hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR);	        durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR);	    }	    if (Token.containsTokenWithValue(tokens, m)) {	        minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE);	        durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE);	    }	    if (Token.containsTokenWithValue(tokens, s)) {	        seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND);	        durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND);	    }	    if (Token.containsTokenWithValue(tokens, S)) {	        milliseconds = (int) durationMillis;	    }	    return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public static <T> String reflectionToString(final T object, final ToStringStyle style, final boolean outputTransients, final Class<? super T> reflectUpToClass) {	    return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass);	}
public static String random(final int count, final char... chars) {	    if (chars == null) {	        return random(count, 0, 0, false, false, null, RANDOM);	    }	    return random(count, 0, chars.length, false, false, chars, RANDOM);	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables) {	    this.enableSubstitutionInVariables = enableSubstitutionInVariables;	}
public String getNewLineText() {	    return newLine;	}
@Override	public int compareTo(final Pair<L, R> other) {	    return new CompareToBuilder().append(getLeft(), other.getLeft()).append(getRight(), other.getRight()).toComparison();	}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    buffer.append(arrayStart);	    for (int i = 0; i < array.length; i++) {	        if (i > 0) {	            buffer.append(arraySeparator);	        }	        appendDetail(buffer, fieldName, array[i]);	    }	    buffer.append(arrayEnd);	}
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) {	    style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));	    return this;	}
public static ConcurrentException extractCause(final ExecutionException ex) {	    if (ex == null || ex.getCause() == null) {	        return null;	    }	    throwCause(ex);	    return new ConcurrentException(ex.getMessage(), ex.getCause());	}
public Integer toInteger() {	    return Integer.valueOf(intValue());	}
public boolean isEmptyTokenAsNull() {	    return this.emptyAsNull;	}
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) {	    final StringBuilder buffer = new StringBuilder();	    boolean lastOutputSeconds = false;	    final int sz = tokens.length;	    for (int i = 0; i < sz; i++) {	        final Token token = tokens[i];	        final Object value = token.getValue();	        final int count = token.getCount();	        if (value instanceof StringBuilder) {	            buffer.append(value.toString());	        } else {	            if (value == y) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years));	                lastOutputSeconds = false;	            } else if (value == M) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months));	                lastOutputSeconds = false;	            } else if (value == d) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days));	                lastOutputSeconds = false;	            } else if (value == H) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours));	                lastOutputSeconds = false;	            } else if (value == m) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes));	                lastOutputSeconds = false;	            } else if (value == s) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds));	                lastOutputSeconds = true;	            } else if (value == S) {	                if (lastOutputSeconds) {	                    milliseconds += 1000;	                    final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds);	                    buffer.append(str.substring(1));	                } else {	                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds));	                }	                lastOutputSeconds = false;	            }	        }	    }	    return buffer.toString();	}
@Override	public void write(final String str, final int off, final int len) {	    StrBuilder.this.append(str, off, len);	}
@Override	public String toString() {	    if (this.getObject() == null) {	        return this.getStyle().getNullText();	    }	    Class<?> clazz = this.getObject().getClass();	    this.appendFieldsIn(clazz);	    while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {	        clazz = clazz.getSuperclass();	        this.appendFieldsIn(clazz);	    }	    return super.toString();	}
public int capacity() {	    return buffer.length;	}
public static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts) {	    if ((src.length == 0 && srcPos == 0) || 0 == nShorts) {	        return dstInit;	    }	    if ((nShorts - 1) * 16 + dstPos >= 32) {	        throw new IllegalArgumentException("(nShorts-1)*16+dstPos is greather or equal to than 32");	    }	    int out = dstInit;	    int shift = 0;	    for (int i = 0; i < nShorts; i++) {	        shift = i * 16 + dstPos;	        final int bits = (0xffff & src[i + srcPos]) << shift;	        final int mask = 0xffff << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
public String toString(final String format) {	    return String.format(format, minimum, maximum, comparator);	}
public static String toString(final Object obj, final String nullStr) {	    return obj == null ? nullStr : obj.toString();	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public static boolean equalsIgnoreCase(final CharSequence str1, final CharSequence str2) {	    if (str1 == null || str2 == null) {	        return str1 == str2;	    } else if (str1 == str2) {	        return true;	    } else if (str1.length() != str2.length()) {	        return false;	    } else {	        return CharSequenceUtils.regionMatches(str1, true, 0, str2, 0, str1.length());	    }	}
public String getNewLineText() {	    return newLine;	}
public HashCodeBuilder append(final short[] array) {	    if (array == null) {	        iTotal = iTotal * iConstant;	    } else {	        for (final short element : array) {	            append(element);	        }	    }	    return this;	}
public static String random(final int count, final char... chars) {	    if (chars == null) {	        return random(count, 0, 0, false, false, null, RANDOM);	    }	    return random(count, 0, chars.length, false, false, chars, RANDOM);	}
public static String right(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(str.length() - len);	}
public static Boolean[] nullToEmpty(final Boolean[] array) {	    if (array == null || array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    return array;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes) {	    if (0 == nBytes) {	        return dst;	    }	    if ((nBytes - 1) * 8 + srcPos >= 16) {	        throw new IllegalArgumentException("(nBytes-1)*8+srcPos is greather or equal to than 16");	    }	    int shift = 0;	    for (int i = 0; i < nBytes; i++) {	        shift = i * 8 + srcPos;	        dst[dstPos + i] = (byte) (0xff & (src >> shift));	    }	    return dst;	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public String getNewLineText() {	    return newLine;	}
public boolean isEmpty() {	    return size == 0;	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public static short[] removeElement(final short[] array, final short element) {	    final int index = indexOf(array, element);	    if (index == INDEX_NOT_FOUND) {	        return clone(array);	    }	    return remove(array, index);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public int getDenominator() {	    return denominator;	}
protected String getSizeStartText() {	    return sizeStartText;	}
public static String removeEndIgnoreCase(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (endsWithIgnoreCase(str, remove)) {	        return str.substring(0, str.length() - remove.length());	    }	    return str;	}
static boolean isRegistered(final Object lhs, final Object rhs) {	    final Set<Pair<IDKey, IDKey>> registry = getRegistry();	    final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);	    final Pair<IDKey, IDKey> swappedPair = Pair.of(pair.getLeft(), pair.getRight());	    return registry != null && (registry.contains(pair) || registry.contains(swappedPair));	}
@Override	public void setFieldNameValueSeparator(final String fieldNameValueSeparator) {	    super.setFieldNameValueSeparator(fieldNameValueSeparator);	}
public static Object invokeMethod(final Object object, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {	    if (parameterTypes == null) {	        parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;	    }	    if (args == null) {	        args = ArrayUtils.EMPTY_OBJECT_ARRAY;	    }	    final Method method = getMatchingAccessibleMethod(object.getClass(), methodName, parameterTypes);	    if (method == null) {	        throw new NoSuchMethodException("No such accessible method: " + methodName + "() on object: " + object.getClass().getName());	    }	    return method.invoke(object, args);	}
public static String stripEnd(final String str, final String stripChars) {	    int end;	    if (str == null || (end = str.length()) == 0) {	        return str;	    }	    if (stripChars == null) {	        while (end != 0 && Character.isWhitespace(str.charAt(end - 1))) {	            end--;	        }	    } else if (stripChars.isEmpty()) {	        return str;	    } else {	        while (end != 0 && stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND) {	            end--;	        }	    }	    return str.substring(0, end);	}
static String[] toNoNullStringArray(final Object[] array) {	    final List<String> list = new ArrayList<String>(array.length);	    for (final Object e : array) {	        if (e != null) {	            list.add(e.toString());	        }	    }	    return list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);	}
@Override	public boolean markSupported() {	    return true;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {	    if (str == null || searchStr == null) {	        return INDEX_NOT_FOUND;	    }	    if (startPos > str.length() - searchStr.length()) {	        startPos = str.length() - searchStr.length();	    }	    if (startPos < 0) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return startPos;	    }	    for (int i = startPos; i >= 0; i--) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    final int seqEnd = input.length();	    if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') {	        int start = index + 2;	        boolean isHex = false;	        final char firstChar = input.charAt(start);	        if (firstChar == 'x' || firstChar == 'X') {	            start++;	            isHex = true;	            if (start == seqEnd) {	                return 0;	            }	        }	        int end = start;	        while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) {	            end++;	        }	        final boolean semiNext = end != seqEnd && input.charAt(end) == ';';	        if (!semiNext) {	            if (isSet(OPTION.semiColonRequired)) {	                return 0;	            } else if (isSet(OPTION.errorIfNoSemiColon)) {	                throw new IllegalArgumentException("Semi-colon required at end of numeric entity");	            }	        }	        int entityValue;	        try {	            if (isHex) {	                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);	            } else {	                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);	            }	        } catch (final NumberFormatException nfe) {	            return 0;	        }	        if (entityValue > 0xFFFF) {	            final char[] chrs = Character.toChars(entityValue);	            out.write(chrs[0]);	            out.write(chrs[1]);	        } else {	            out.write(entityValue);	        }	        return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0);	    }	    return 0;	}
public static String reverseDelimited(final String str, final char separatorChar) {	    if (str == null) {	        return null;	    }	    final String[] strs = split(str, separatorChar);	    ArrayUtils.reverse(strs);	    return join(strs, separatorChar);	}
public StrMatcher getIgnoredMatcher() {	    return ignoredMatcher;	}
public static boolean isEmpty(final CharSequence cs) {	    return cs == null || cs.length() == 0;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public void decrement() {	    value--;	}
protected boolean isFieldSeparatorAtEnd() {	    return fieldSeparatorAtEnd;	}
@Override	public String toString() {	    if (this.getObject() == null) {	        return this.getStyle().getNullText();	    }	    Class<?> clazz = this.getObject().getClass();	    this.appendFieldsIn(clazz);	    while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {	        clazz = clazz.getSuperclass();	        this.appendFieldsIn(clazz);	    }	    return super.toString();	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public String getNullText() {	    return nullText;	}
public static StrTokenizer getTSVInstance(final char[] input) {	    final StrTokenizer tok = getTSVClone();	    tok.reset(input);	    return tok;	}
public String getNullText() {	    return nullText;	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
@Override	public String next() {	    if (hasNext()) {	        return tokens[tokenPos++];	    }	    throw new NoSuchElementException();	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public StrBuilder appendPadding(final int length, final char padChar) {	    if (length >= 0) {	        ensureCapacity(size + length);	        for (int i = 0; i < length; i++) {	            buffer[size++] = padChar;	        }	    }	    return this;	}
public static final String escapeEcmaScript(final String input) {	    return ESCAPE_ECMASCRIPT.translate(input);	}
public static String appendIfMissingIgnoreCase(final String str, final CharSequence suffix, final CharSequence... suffixes) {	    return appendIfMissing(str, suffix, true, suffixes);	}
public void subtract(final Number operand) {	    this.value -= operand.shortValue();	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public static long getFragmentInMinutes(final Calendar calendar, final int fragment) {	    return getFragment(calendar, fragment, Calendar.MINUTE);	}
@Deprecated	public static String chomp(final String str, final String separator) {	    return removeEnd(str, separator);	}
public static <T extends CharSequence> T defaultIfEmpty(final T str, final T defaultStr) {	    return StringUtils.isEmpty(str) ? defaultStr : str;	}
public static <T extends Iterable<?>> T noNullElements(final T iterable) {	    return noNullElements(iterable, DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE);	}
public boolean isEquals() {	    return this.isEquals;	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
public int capacity() {	    return buffer.length;	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
protected String getFieldSeparator() {	    return fieldSeparator;	}
public static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools) {	    if ((src.length == 0 && srcPos == 0) || 0 == nBools) {	        return dstInit;	    }	    if (nBools - 1 + dstPos >= 16) {	        throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 16");	    }	    short out = dstInit;	    int shift = 0;	    for (int i = 0; i < nBools; i++) {	        shift = i * 1 + dstPos;	        final int bits = (src[i + srcPos] ? 1 : 0) << shift;	        final int mask = 0x1 << shift;	        out = (short) ((out & ~mask) | bits);	    }	    return out;	}
public static Date addDays(final Date date, final int amount) {	    return add(date, Calendar.DAY_OF_MONTH, amount);	}
public String getNullText() {	    return nullText;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static int truncatedCompareTo(final Date date1, final Date date2, final int field) {	    final Date truncatedDate1 = truncate(date1, field);	    final Date truncatedDate2 = truncate(date2, field);	    return truncatedDate1.compareTo(truncatedDate2);	}
public static int hexDigitMsb0ToInt(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return 0x0;	        case '1':	            return 0x8;	        case '2':	            return 0x4;	        case '3':	            return 0xC;	        case '4':	            return 0x2;	        case '5':	            return 0xA;	        case '6':	            return 0x6;	        case '7':	            return 0xE;	        case '8':	            return 0x1;	        case '9':	            return 0x9;	        case 'a':	        case 'A':	            return 0x5;	        case 'b':	        case 'B':	            return 0xD;	        case 'c':	        case 'C':	            return 0x3;	        case 'd':	        case 'D':	            return 0xB;	        case 'e':	        case 'E':	            return 0x7;	        case 'f':	        case 'F':	            return 0xF;	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
protected String getArrayEnd() {	    return arrayEnd;	}
protected String getSizeEndText() {	    return sizeEndText;	}
public static String capitalize(final String str) {	    int strLen;	    if (str == null || (strLen = str.length()) == 0) {	        return str;	    }	    char firstChar = str.charAt(0);	    if (Character.isTitleCase(firstChar)) {	        return str;	    }	    return new StringBuilder(strLen).append(Character.toTitleCase(firstChar)).append(str.substring(1)).toString();	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static String prependIfMissing(final String str, final CharSequence prefix, final CharSequence... prefixes) {	    return prependIfMissing(str, prefix, false, prefixes);	}
public static boolean isAscii(final char ch) {	    return ch < 128;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
@Override	public boolean isArrayContentDetail() {	    return super.isArrayContentDetail();	}
public static final String escapeHtml3(final String input) {	    return ESCAPE_HTML3.translate(input);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
protected boolean isArrayContentDetail() {	    return arrayContentDetail;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public int getNumerator() {	    return numerator;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
static boolean containsTokenWithValue(final Token[] tokens, final Object value) {	    final int sz = tokens.length;	    for (int i = 0; i < sz; i++) {	        if (tokens[i].getValue() == value) {	            return true;	        }	    }	    return false;	}
public static Boolean xor(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return xor(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
public static boolean isAllUpperCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isUpperCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public String getNullText() {	    return nullText;	}
public int capacity() {	    return buffer.length;	}
@Override	public Thread newThread(final Runnable r) {	    final Thread t = getWrappedFactory().newThread(r);	    initializeThread(t);	    return t;	}
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return true;	    }	    if (lhs == null || rhs == null) {	        return false;	    }	    final Class<?> lhsClass = lhs.getClass();	    final Class<?> rhsClass = rhs.getClass();	    Class<?> testClass;	    if (lhsClass.isInstance(rhs)) {	        testClass = lhsClass;	        if (!rhsClass.isInstance(lhs)) {	            testClass = rhsClass;	        }	    } else if (rhsClass.isInstance(lhs)) {	        testClass = rhsClass;	        if (!lhsClass.isInstance(rhs)) {	            testClass = lhsClass;	        }	    } else {	        return false;	    }	    final EqualsBuilder equalsBuilder = new EqualsBuilder();	    try {	        reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {	            testClass = testClass.getSuperclass();	            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        }	    } catch (final IllegalArgumentException e) {	        return false;	    }	    return equalsBuilder.isEquals();	}
public static <K, V> V putIfAbsent(final ConcurrentMap<K, V> map, final K key, final V value) {	    if (map == null) {	        return null;	    }	    final V result = map.putIfAbsent(key, value);	    return result != null ? result : value;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public String getNullText() {	    return nullText;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static Object readField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException {	    if (target == null) {	        throw new IllegalArgumentException("target object must not be null");	    }	    final Class<?> cls = target.getClass();	    final Field field = getField(cls, fieldName, forceAccess);	    if (field == null) {	        throw new IllegalArgumentException("Cannot locate field " + fieldName + " on " + cls);	    }	    return readField(field, target);	}
public String getNullText() {	    return nullText;	}
public static String capitalizeFully(String str, final char... delimiters) {	    final int delimLen = delimiters == null ? -1 : delimiters.length;	    if (StringUtils.isEmpty(str) || delimLen == 0) {	        return str;	    }	    str = str.toLowerCase();	    return capitalize(str, delimiters);	}
public static String[] substringsBetween(final String str, final String open, final String close) {	    if (str == null || isEmpty(open) || isEmpty(close)) {	        return null;	    }	    final int strLen = str.length();	    if (strLen == 0) {	        return ArrayUtils.EMPTY_STRING_ARRAY;	    }	    final int closeLen = close.length();	    final int openLen = open.length();	    final List<String> list = new ArrayList<String>();	    int pos = 0;	    while (pos < strLen - closeLen) {	        int start = str.indexOf(open, pos);	        if (start < 0) {	            break;	        }	        start += openLen;	        final int end = str.indexOf(close, start);	        if (end < 0) {	            break;	        }	        list.add(str.substring(start, end));	        pos = end + closeLen;	    }	    if (list.isEmpty()) {	        return null;	    }	    return list.toArray(new String[list.size()]);	}
public static boolean isPrimitiveOrWrapper(final Class<?> type) {	    if (type == null) {	        return false;	    }	    return type.isPrimitive() || isPrimitiveWrapper(type);	}
public synchronized boolean start() {	    if (!isStarted()) {	        ExecutorService tempExec;	        executor = getExternalExecutor();	        if (executor == null) {	            executor = tempExec = createExecutor();	        } else {	            tempExec = null;	        }	        future = executor.submit(createTask(tempExec));	        return true;	    }	    return false;	}
public static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {	    if (str == null || searchStr == null) {	        return INDEX_NOT_FOUND;	    }	    if (startPos < 0) {	        startPos = 0;	    }	    final int endLimit = str.length() - searchStr.length() + 1;	    if (startPos > endLimit) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return startPos;	    }	    for (int i = startPos; i < endLimit; i++) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
@Override	public Integer build() {	    return Integer.valueOf(toHashCode());	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) {	    return new Range<T>(fromInclusive, toInclusive, comparator);	}
public static boolean isAscii(final char ch) {	    return ch < 128;	}
@Override	public boolean equals(final Object obj) {	    if (obj == this) {	        return true;	    }	    if (obj instanceof CharSet == false) {	        return false;	    }	    final CharSet other = (CharSet) obj;	    return set.equals(other.set);	}
public static <T> T CONST(final T v) {	    return v;	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] result = new boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        final Boolean b = array[i];	        result[i] = (b == null ? valueForNull : b.booleanValue());	    }	    return result;	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public static Boolean and(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return and(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
public static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts) {	    if ((src.length == 0 && srcPos == 0) || 0 == nShorts) {	        return dstInit;	    }	    if ((nShorts - 1) * 16 + dstPos >= 64) {	        throw new IllegalArgumentException("(nShorts-1)*16+dstPos is greather or equal to than 64");	    }	    long out = dstInit;	    int shift = 0;	    for (int i = 0; i < nShorts; i++) {	        shift = i * 16 + dstPos;	        final long bits = (0xffffL & src[i + srcPos]) << shift;	        final long mask = 0xffffL << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
public static boolean equalsIgnoreCase(final CharSequence str1, final CharSequence str2) {	    if (str1 == null || str2 == null) {	        return str1 == str2;	    } else if (str1 == str2) {	        return true;	    } else if (str1.length() != str2.length()) {	        return false;	    } else {	        return CharSequenceUtils.regionMatches(str1, true, 0, str2, 0, str1.length());	    }	}
protected boolean isFieldSeparatorAtEnd() {	    return fieldSeparatorAtEnd;	}
public String getNewLineText() {	    return newLine;	}
public static void reverse(final boolean[] array) {	    if (array == null) {	        return;	    }	    int i = 0;	    int j = array.length - 1;	    boolean tmp;	    while (j > i) {	        tmp = array[j];	        array[j] = array[i];	        array[i] = tmp;	        j--;	        i++;	    }	}
private static Date set(final Date date, final int calendarField, final int amount) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final Calendar c = Calendar.getInstance();	    c.setLenient(false);	    c.setTime(date);	    c.set(calendarField, amount);	    return c.getTime();	}
public int capacity() {	    return buffer.length;	}
public int size() {	    return size;	}
protected boolean isUseIdentityHashCode() {	    return useIdentityHashCode;	}
public static String lowerCase(final String str, final Locale locale) {	    if (str == null) {	        return null;	    }	    return str.toLowerCase(locale);	}
public char getEscapeChar() {	    return this.escapeChar;	}
public static Object invokeExactStaticMethod(final Class<?> cls, final String methodName, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {	    if (args == null) {	        args = ArrayUtils.EMPTY_OBJECT_ARRAY;	    }	    final Class<?>[] parameterTypes = ClassUtils.toClass(args);	    return invokeExactStaticMethod(cls, methodName, args, parameterTypes);	}
public int indexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex < 0 ? 0 : startIndex);	    if (matcher == null || startIndex >= size) {	        return -1;	    }	    final int len = size;	    final char[] buf = buffer;	    for (int i = startIndex; i < len; i++) {	        if (matcher.isMatch(buf, i, startIndex, len) > 0) {	            return i;	        }	    }	    return -1;	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public static String randomAlphabetic(final int count) {	    return random(count, true, false);	}
@Override	public T get() throws ConcurrentException {	    try {	        return getFuture().get();	    } catch (final ExecutionException execex) {	        ConcurrentUtils.handleCause(execex);	        return null;	    } catch (final InterruptedException iex) {	        Thread.currentThread().interrupt();	        throw new ConcurrentException(iex);	    }	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
public String getNullText() {	    return nullText;	}
public static short[] removeElement(final short[] array, final short element) {	    final int index = indexOf(array, element);	    if (index == INDEX_NOT_FOUND) {	        return clone(array);	    }	    return remove(array, index);	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public String getNullText() {	    return nullText;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
protected String getArrayStart() {	    return arrayStart;	}
public static Number createNumber(final String str) throws NumberFormatException {	    if (str == null) {	        return null;	    }	    if (StringUtils.isBlank(str)) {	        throw new NumberFormatException("A blank string is not a valid number");	    }	    final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" };	    int pfxLen = 0;	    for (final String pfx : hex_prefixes) {	        if (str.startsWith(pfx)) {	            pfxLen += pfx.length();	            break;	        }	    }	    if (pfxLen > 0) {	        final int hexDigits = str.length() - pfxLen;	        if (hexDigits > 16) {	            return createBigInteger(str);	        }	        if (hexDigits > 8) {	            return createLong(str);	        }	        return createInteger(str);	    }	    final char lastChar = str.charAt(str.length() - 1);	    String mant;	    String dec;	    String exp;	    final int decPos = str.indexOf('.');	    final int expPos = str.indexOf('e') + str.indexOf('E') + 1;	    int numDecimals = 0;	    if (decPos > -1) {	        if (expPos > -1) {	            if (expPos < decPos || expPos > str.length()) {	                throw new NumberFormatException(str + " is not a valid number.");	            }	            dec = str.substring(decPos + 1, expPos);	        } else {	            dec = str.substring(decPos + 1);	        }	        mant = str.substring(0, decPos);	        numDecimals = dec.length();	    } else {	        if (expPos > -1) {	            if (expPos > str.length()) {	                throw new NumberFormatException(str + " is not a valid number.");	            }	            mant = str.substring(0, expPos);	        } else {	            mant = str;	        }	        dec = null;	    }	    if (!Character.isDigit(lastChar) && lastChar != '.') {	        if (expPos > -1 && expPos < str.length() - 1) {	            exp = str.substring(expPos + 1, str.length() - 1);	        } else {	            exp = null;	        }	        final String numeric = str.substring(0, str.length() - 1);	        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);	        switch(lastChar) {	            case 'l':	            case 'L':	                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {	                    try {	                        return createLong(numeric);	                    } catch (final NumberFormatException nfe) {	                    }	                    return createBigInteger(numeric);	                }	                throw new NumberFormatException(str + " is not a valid number.");	            case 'f':	            case 'F':	                try {	                    final Float f = NumberUtils.createFloat(numeric);	                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {	                        return f;	                    }	                } catch (final NumberFormatException nfe) {	                }	            case 'd':	            case 'D':	                try {	                    final Double d = NumberUtils.createDouble(numeric);	                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {	                        return d;	                    }	                } catch (final NumberFormatException nfe) {	                }	                try {	                    return createBigDecimal(numeric);	                } catch (final NumberFormatException e) {	                }	            default:	                throw new NumberFormatException(str + " is not a valid number.");	        }	    }	    if (expPos > -1 && expPos < str.length() - 1) {	        exp = str.substring(expPos + 1, str.length());	    } else {	        exp = null;	    }	    if (dec == null && exp == null) {	        try {	            return createInteger(str);	        } catch (final NumberFormatException nfe) {	        }	        try {	            return createLong(str);	        } catch (final NumberFormatException nfe) {	        }	        return createBigInteger(str);	    }	    final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);	    try {	        if (numDecimals <= 7) {	            final Float f = createFloat(str);	            if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {	                return f;	            }	        }	    } catch (final NumberFormatException nfe) {	    }	    try {	        if (numDecimals <= 16) {	            final Double d = createDouble(str);	            if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {	                return d;	            }	        }	    } catch (final NumberFormatException nfe) {	    }	    return createBigDecimal(str);	}
public int capacity() {	    return buffer.length;	}
public String getNullText() {	    return nullText;	}
public static String[][] invert(final String[][] array) {	    final String[][] newarray = new String[array.length][2];	    for (int i = 0; i < array.length; i++) {	        newarray[i][0] = array[i][1];	        newarray[i][1] = array[i][0];	    }	    return newarray;	}
public boolean isEmpty() {	    return size == 0;	}
public static final String unescapeCsv(final String input) {	    return UNESCAPE_CSV.translate(input);	}
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {	    if (array == null) {	        if (index != 0) {	            throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0");	        }	        final Object joinedArray = Array.newInstance(clss, 1);	        Array.set(joinedArray, 0, element);	        return joinedArray;	    }	    final int length = Array.getLength(array);	    if (index > length || index < 0) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(clss, length + 1);	    System.arraycopy(array, 0, result, 0, index);	    Array.set(result, index, element);	    if (index < length) {	        System.arraycopy(array, index, result, index + 1, length - index);	    }	    return result;	}
public static String toStringTrueFalse(final boolean bool) {	    return toString(bool, "true", "false");	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
protected String getSummaryObjectEndText() {	    return summaryObjectEndText;	}
public static boolean isAlpha(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
@Override	public int length() {	    return size;	}
private static long getFragment(final Calendar calendar, final int fragment, final int unit) {	    if (calendar == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final long millisPerUnit = getMillisPerUnit(unit);	    long result = 0;	    switch(fragment) {	        case Calendar.YEAR:	            result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit;	            break;	        case Calendar.MONTH:	            result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit;	            break;	    }	    switch(fragment) {	        case Calendar.YEAR:	        case Calendar.MONTH:	        case Calendar.DAY_OF_YEAR:	        case Calendar.DATE:	            result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit;	        case Calendar.HOUR_OF_DAY:	            result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit;	        case Calendar.MINUTE:	            result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit;	        case Calendar.SECOND:	            result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit;	            break;	        case Calendar.MILLISECOND:	            break;	        default:	            throw new IllegalArgumentException("The fragment " + fragment + " is not supported");	    }	    return result;	}
public int size() {	    return size;	}
public static boolean isValidAnnotationMemberType(Class<?> type) {	    if (type == null) {	        return false;	    }	    if (type.isArray()) {	        type = type.getComponentType();	    }	    return type.isPrimitive() || type.isEnum() || type.isAnnotation() || String.class.equals(type) || Class.class.equals(type);	}
public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) {	    final Token[] tokens = lexx(format);	    final Calendar start = Calendar.getInstance(timezone);	    start.setTime(new Date(startMillis));	    final Calendar end = Calendar.getInstance(timezone);	    end.setTime(new Date(endMillis));	    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);	    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);	    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);	    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);	    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);	    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);	    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);	    while (milliseconds < 0) {	        milliseconds += 1000;	        seconds -= 1;	    }	    while (seconds < 0) {	        seconds += 60;	        minutes -= 1;	    }	    while (minutes < 0) {	        minutes += 60;	        hours -= 1;	    }	    while (hours < 0) {	        hours += 24;	        days -= 1;	    }	    if (Token.containsTokenWithValue(tokens, M)) {	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	        while (months < 0) {	            months += 12;	            years -= 1;	        }	        if (!Token.containsTokenWithValue(tokens, y) && years != 0) {	            while (years != 0) {	                months += 12 * years;	                years = 0;	            }	        }	    } else {	        if (!Token.containsTokenWithValue(tokens, y)) {	            int target = end.get(Calendar.YEAR);	            if (months < 0) {	                target -= 1;	            }	            while (start.get(Calendar.YEAR) != target) {	                days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);	                if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) {	                    days += 1;	                }	                start.add(Calendar.YEAR, 1);	                days += start.get(Calendar.DAY_OF_YEAR);	            }	            years = 0;	        }	        while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            start.add(Calendar.MONTH, 1);	        }	        months = 0;	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	    }	    if (!Token.containsTokenWithValue(tokens, d)) {	        hours += 24 * days;	        days = 0;	    }	    if (!Token.containsTokenWithValue(tokens, H)) {	        minutes += 60 * hours;	        hours = 0;	    }	    if (!Token.containsTokenWithValue(tokens, m)) {	        seconds += 60 * minutes;	        minutes = 0;	    }	    if (!Token.containsTokenWithValue(tokens, s)) {	        milliseconds += 1000 * seconds;	        seconds = 0;	    }	    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
protected boolean isFieldSeparatorAtEnd() {	    return fieldSeparatorAtEnd;	}
public static String removeEnd(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.endsWith(remove)) {	        return str.substring(0, str.length() - remove.length());	    }	    return str;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
protected String getContentStart() {	    return contentStart;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public EqualsBuilder appendSuper(final boolean superEquals) {	    if (isEquals == false) {	        return this;	    }	    isEquals = superEquals;	    return this;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
@Override	public Integer build() {	    return Integer.valueOf(toHashCode());	}
public int indexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex < 0 ? 0 : startIndex);	    if (matcher == null || startIndex >= size) {	        return -1;	    }	    final int len = size;	    final char[] buf = buffer;	    for (int i = startIndex; i < len; i++) {	        if (matcher.isMatch(buf, i, startIndex, len) > 0) {	            return i;	        }	    }	    return -1;	}
protected boolean isArrayContentDetail() {	    return arrayContentDetail;	}
static int indexOf(final CharSequence cs, final CharSequence searchChar, final int start) {	    return cs.toString().indexOf(searchChar.toString(), start);	}
public StrBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar) {	    return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);	}
public HashCodeBuilder appendSuper(final int superHashCode) {	    iTotal = iTotal * iConstant + superHashCode;	    return this;	}
@Override	public void setValue(final Number value) {	    this.value = value.floatValue();	}
public boolean isEquals() {	    return this.isEquals;	}
public int size() {	    checkTokenized();	    return tokens.length;	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
public String getNewLineText() {	    return newLine;	}
public Integer toInteger() {	    return Integer.valueOf(intValue());	}
protected String getSizeEndText() {	    return sizeEndText;	}
public void getChars(final int startIndex, final int endIndex, final char[] destination, final int destinationIndex) {	    if (startIndex < 0) {	        throw new StringIndexOutOfBoundsException(startIndex);	    }	    if (endIndex < 0 || endIndex > length()) {	        throw new StringIndexOutOfBoundsException(endIndex);	    }	    if (startIndex > endIndex) {	        throw new StringIndexOutOfBoundsException("end < start");	    }	    System.arraycopy(buffer, startIndex, destination, destinationIndex, endIndex - startIndex);	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
protected String getNullText() {	    return nullText;	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
protected String parseToken(final String pattern, final int[] indexRef) {	    final StringBuilder buf = new StringBuilder();	    int i = indexRef[0];	    final int length = pattern.length();	    char c = pattern.charAt(i);	    if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {	        buf.append(c);	        while (i + 1 < length) {	            final char peek = pattern.charAt(i + 1);	            if (peek == c) {	                buf.append(c);	                i++;	            } else {	                break;	            }	        }	    } else {	        buf.append('\'');	        boolean inLiteral = false;	        for (; i < length; i++) {	            c = pattern.charAt(i);	            if (c == '\'') {	                if (i + 1 < length && pattern.charAt(i + 1) == '\'') {	                    i++;	                    buf.append(c);	                } else {	                    inLiteral = !inLiteral;	                }	            } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {	                i--;	                break;	            } else {	                buf.append(c);	            }	        }	    }	    indexRef[0] = i;	    return buf.toString();	}
public static Number createNumber(final String str) throws NumberFormatException {	    if (str == null) {	        return null;	    }	    if (StringUtils.isBlank(str)) {	        throw new NumberFormatException("A blank string is not a valid number");	    }	    final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" };	    int pfxLen = 0;	    for (final String pfx : hex_prefixes) {	        if (str.startsWith(pfx)) {	            pfxLen += pfx.length();	            break;	        }	    }	    if (pfxLen > 0) {	        final int hexDigits = str.length() - pfxLen;	        if (hexDigits > 16) {	            return createBigInteger(str);	        }	        if (hexDigits > 8) {	            return createLong(str);	        }	        return createInteger(str);	    }	    final char lastChar = str.charAt(str.length() - 1);	    String mant;	    String dec;	    String exp;	    final int decPos = str.indexOf('.');	    final int expPos = str.indexOf('e') + str.indexOf('E') + 1;	    int numDecimals = 0;	    if (decPos > -1) {	        if (expPos > -1) {	            if (expPos < decPos || expPos > str.length()) {	                throw new NumberFormatException(str + " is not a valid number.");	            }	            dec = str.substring(decPos + 1, expPos);	        } else {	            dec = str.substring(decPos + 1);	        }	        mant = str.substring(0, decPos);	        numDecimals = dec.length();	    } else {	        if (expPos > -1) {	            if (expPos > str.length()) {	                throw new NumberFormatException(str + " is not a valid number.");	            }	            mant = str.substring(0, expPos);	        } else {	            mant = str;	        }	        dec = null;	    }	    if (!Character.isDigit(lastChar) && lastChar != '.') {	        if (expPos > -1 && expPos < str.length() - 1) {	            exp = str.substring(expPos + 1, str.length() - 1);	        } else {	            exp = null;	        }	        final String numeric = str.substring(0, str.length() - 1);	        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);	        switch(lastChar) {	            case 'l':	            case 'L':	                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {	                    try {	                        return createLong(numeric);	                    } catch (final NumberFormatException nfe) {	                    }	                    return createBigInteger(numeric);	                }	                throw new NumberFormatException(str + " is not a valid number.");	            case 'f':	            case 'F':	                try {	                    final Float f = NumberUtils.createFloat(numeric);	                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {	                        return f;	                    }	                } catch (final NumberFormatException nfe) {	                }	            case 'd':	            case 'D':	                try {	                    final Double d = NumberUtils.createDouble(numeric);	                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {	                        return d;	                    }	                } catch (final NumberFormatException nfe) {	                }	                try {	                    return createBigDecimal(numeric);	                } catch (final NumberFormatException e) {	                }	            default:	                throw new NumberFormatException(str + " is not a valid number.");	        }	    }	    if (expPos > -1 && expPos < str.length() - 1) {	        exp = str.substring(expPos + 1, str.length());	    } else {	        exp = null;	    }	    if (dec == null && exp == null) {	        try {	            return createInteger(str);	        } catch (final NumberFormatException nfe) {	        }	        try {	            return createLong(str);	        } catch (final NumberFormatException nfe) {	        }	        return createBigInteger(str);	    }	    final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);	    try {	        if (numDecimals <= 7) {	            final Float f = createFloat(str);	            if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {	                return f;	            }	        }	    } catch (final NumberFormatException nfe) {	    }	    try {	        if (numDecimals <= 16) {	            final Double d = createDouble(str);	            if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {	                return d;	            }	        }	    } catch (final NumberFormatException nfe) {	    }	    return createBigDecimal(str);	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof MutableInt) {	        return value == ((MutableInt) obj).intValue();	    }	    return false;	}
public int toComparison() {	    return comparison;	}
public void subtract(final Number operand) {	    this.value -= operand.shortValue();	}
@Override	public String getMessage() {	    return getFormattedExceptionMessage(super.getMessage());	}
public static String initials(final String str, final char... delimiters) {	    if (StringUtils.isEmpty(str)) {	        return str;	    }	    if (delimiters != null && delimiters.length == 0) {	        return "";	    }	    final int strLen = str.length();	    final char[] buf = new char[strLen / 2 + 1];	    int count = 0;	    boolean lastWasGap = true;	    for (int i = 0; i < strLen; i++) {	        final char ch = str.charAt(i);	        if (isDelimiter(ch, delimiters)) {	            lastWasGap = true;	        } else if (lastWasGap) {	            buf[count++] = ch;	            lastWasGap = false;	        } else {	            continue;	        }	    }	    return new String(buf, 0, count);	}
public String getNullText() {	    return nullText;	}
public static String substringAfter(final String str, final String separator) {	    if (isEmpty(str)) {	        return str;	    }	    if (separator == null) {	        return EMPTY;	    }	    final int pos = str.indexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return EMPTY;	    }	    return str.substring(pos + separator.length());	}
public StrBuilder deleteCharAt(final int index) {	    if (index < 0 || index >= size) {	        throw new StringIndexOutOfBoundsException(index);	    }	    deleteImpl(index, index + 1, 1);	    return this;	}
public boolean contains(final StrMatcher matcher) {	    return indexOf(matcher, 0) >= 0;	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public boolean isEmpty() {	    return size == 0;	}
protected boolean isDefaultFullDetail() {	    return defaultFullDetail;	}
public static <K, V> V putIfAbsent(final ConcurrentMap<K, V> map, final K key, final V value) {	    if (map == null) {	        return null;	    }	    final V result = map.putIfAbsent(key, value);	    return result != null ? result : value;	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException {	    return charsetName == null ? new String(bytes) : new String(bytes, charsetName);	}
public static boolean[] hexDigitToBinary(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return new boolean[] { false, false, false, false };	        case '1':	            return new boolean[] { true, false, false, false };	        case '2':	            return new boolean[] { false, true, false, false };	        case '3':	            return new boolean[] { true, true, false, false };	        case '4':	            return new boolean[] { false, false, true, false };	        case '5':	            return new boolean[] { true, false, true, false };	        case '6':	            return new boolean[] { false, true, true, false };	        case '7':	            return new boolean[] { true, true, true, false };	        case '8':	            return new boolean[] { false, false, false, true };	        case '9':	            return new boolean[] { true, false, false, true };	        case 'a':	        case 'A':	            return new boolean[] { false, true, false, true };	        case 'b':	        case 'B':	            return new boolean[] { true, true, false, true };	        case 'c':	        case 'C':	            return new boolean[] { false, false, true, true };	        case 'd':	        case 'D':	            return new boolean[] { true, false, true, true };	        case 'e':	        case 'E':	            return new boolean[] { false, true, true, true };	        case 'f':	        case 'F':	            return new boolean[] { true, true, true, true };	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
@Override	public Integer build() {	    return Integer.valueOf(toHashCode());	}
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return true;	    }	    if (lhs == null || rhs == null) {	        return false;	    }	    final Class<?> lhsClass = lhs.getClass();	    final Class<?> rhsClass = rhs.getClass();	    Class<?> testClass;	    if (lhsClass.isInstance(rhs)) {	        testClass = lhsClass;	        if (!rhsClass.isInstance(lhs)) {	            testClass = rhsClass;	        }	    } else if (rhsClass.isInstance(lhs)) {	        testClass = rhsClass;	        if (!lhsClass.isInstance(rhs)) {	            testClass = lhsClass;	        }	    } else {	        return false;	    }	    final EqualsBuilder equalsBuilder = new EqualsBuilder();	    try {	        reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {	            testClass = testClass.getSuperclass();	            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        }	    } catch (final IllegalArgumentException e) {	        return false;	    }	    return equalsBuilder.isEquals();	}
private static Date set(final Date date, final int calendarField, final int amount) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final Calendar c = Calendar.getInstance();	    c.setLenient(false);	    c.setTime(date);	    c.set(calendarField, amount);	    return c.getTime();	}
@Override	public float floatValue() {	    return (float) numerator / (float) denominator;	}
public static short[] removeElement(final short[] array, final short element) {	    final int index = indexOf(array, element);	    if (index == INDEX_NOT_FOUND) {	        return clone(array);	    }	    return remove(array, index);	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public StrBuilder deleteCharAt(final int index) {	    if (index < 0 || index >= size) {	        throw new StringIndexOutOfBoundsException(index);	    }	    deleteImpl(index, index + 1, 1);	    return this;	}
public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment) {	    return getFragment(calendar, fragment, Calendar.MILLISECOND);	}
protected String getSummaryObjectEndText() {	    return summaryObjectEndText;	}
@Override	public boolean translate(final int codepoint, final Writer out) throws IOException {	    if (between) {	        if (codepoint < below || codepoint > above) {	            return false;	        }	    } else {	        if (codepoint >= below && codepoint <= above) {	            return false;	        }	    }	    out.write("&#");	    out.write(Integer.toString(codepoint, 10));	    out.write(';');	    return true;	}
public static int indexOfDifference(final CharSequence... css) {	    if (css == null || css.length <= 1) {	        return INDEX_NOT_FOUND;	    }	    boolean anyStringNull = false;	    boolean allStringsNull = true;	    final int arrayLen = css.length;	    int shortestStrLen = Integer.MAX_VALUE;	    int longestStrLen = 0;	    for (int i = 0; i < arrayLen; i++) {	        if (css[i] == null) {	            anyStringNull = true;	            shortestStrLen = 0;	        } else {	            allStringsNull = false;	            shortestStrLen = Math.min(css[i].length(), shortestStrLen);	            longestStrLen = Math.max(css[i].length(), longestStrLen);	        }	    }	    if (allStringsNull || longestStrLen == 0 && !anyStringNull) {	        return INDEX_NOT_FOUND;	    }	    if (shortestStrLen == 0) {	        return 0;	    }	    int firstDiff = -1;	    for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {	        final char comparisonChar = css[0].charAt(stringPos);	        for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {	            if (css[arrayPos].charAt(stringPos) != comparisonChar) {	                firstDiff = stringPos;	                break;	            }	        }	        if (firstDiff != -1) {	            break;	        }	    }	    if (firstDiff == -1 && shortestStrLen != longestStrLen) {	        return shortestStrLen;	    }	    return firstDiff;	}
public static String stripToNull(String str) {	    if (str == null) {	        return null;	    }	    str = strip(str, null);	    return str.isEmpty() ? null : str;	}
public void setEscapeChar(final char escapeCharacter) {	    this.escapeChar = escapeCharacter;	}
public StrBuilder deleteAll(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, -1);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
private static boolean endsWith(final CharSequence str, final CharSequence suffix, final boolean ignoreCase) {	    if (str == null || suffix == null) {	        return str == null && suffix == null;	    }	    if (suffix.length() > str.length()) {	        return false;	    }	    final int strOffset = str.length() - suffix.length();	    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, suffix, 0, suffix.length());	}
public static void isInstanceOf(final Class<?> type, final Object obj, final String message, final Object... values) {	    if (type.isInstance(obj) == false) {	        throw new IllegalArgumentException(String.format(message, values));	    }	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public static Object readField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException {	    if (target == null) {	        throw new IllegalArgumentException("target object must not be null");	    }	    final Class<?> cls = target.getClass();	    final Field field = getField(cls, fieldName, forceAccess);	    if (field == null) {	        throw new IllegalArgumentException("Cannot locate field " + fieldName + " on " + cls);	    }	    return readField(field, target);	}
static boolean isOSMatch(final String osName, final String osVersion, final String osNamePrefix, final String osVersionPrefix) {	    if (osName == null || osVersion == null) {	        return false;	    }	    return osName.startsWith(osNamePrefix) && osVersion.startsWith(osVersionPrefix);	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public Writer asWriter() {	    return new StrBuilderWriter();	}
public static String formatDuration(long durationMillis, final String format, final boolean padWithZeros) {	    final Token[] tokens = lexx(format);	    int days = 0;	    int hours = 0;	    int minutes = 0;	    int seconds = 0;	    int milliseconds = 0;	    if (Token.containsTokenWithValue(tokens, d)) {	        days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY);	        durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY);	    }	    if (Token.containsTokenWithValue(tokens, H)) {	        hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR);	        durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR);	    }	    if (Token.containsTokenWithValue(tokens, m)) {	        minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE);	        durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE);	    }	    if (Token.containsTokenWithValue(tokens, s)) {	        seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND);	        durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND);	    }	    if (Token.containsTokenWithValue(tokens, S)) {	        milliseconds = (int) durationMillis;	    }	    return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
public char getEnd() {	    return this.end;	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
public static String prependIfMissingIgnoreCase(final String str, final CharSequence prefix, final CharSequence... prefixes) {	    return prependIfMissing(str, prefix, true, prefixes);	}
public static String wrap(final String str, int wrapLength, String newLineStr, final boolean wrapLongWords) {	    if (str == null) {	        return null;	    }	    if (newLineStr == null) {	        newLineStr = SystemUtils.LINE_SEPARATOR;	    }	    if (wrapLength < 1) {	        wrapLength = 1;	    }	    final int inputLineLength = str.length();	    int offset = 0;	    final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32);	    while (inputLineLength - offset > wrapLength) {	        if (str.charAt(offset) == ' ') {	            offset++;	            continue;	        }	        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);	        if (spaceToWrapAt >= offset) {	            wrappedLine.append(str.substring(offset, spaceToWrapAt));	            wrappedLine.append(newLineStr);	            offset = spaceToWrapAt + 1;	        } else {	            if (wrapLongWords) {	                wrappedLine.append(str.substring(offset, wrapLength + offset));	                wrappedLine.append(newLineStr);	                offset += wrapLength;	            } else {	                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);	                if (spaceToWrapAt >= 0) {	                    wrappedLine.append(str.substring(offset, spaceToWrapAt));	                    wrappedLine.append(newLineStr);	                    offset = spaceToWrapAt + 1;	                } else {	                    wrappedLine.append(str.substring(offset));	                    offset = inputLineLength;	                }	            }	        }	    }	    wrappedLine.append(str.substring(offset));	    return wrappedLine.toString();	}
public static boolean isAscii(final char ch) {	    return ch < 128;	}
public int capacity() {	    return buffer.length;	}
public String getRawMessage() {	    return super.getMessage();	}
public static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts) {	    if (0 == nShorts) {	        return dst;	    }	    if ((nShorts - 1) * 16 + srcPos >= 32) {	        throw new IllegalArgumentException("(nShorts-1)*16+srcPos is greather or equal to than 32");	    }	    int shift = 0;	    for (int i = 0; i < nShorts; i++) {	        shift = i * 16 + srcPos;	        dst[dstPos + i] = (short) (0xffff & (src >> shift));	    }	    return dst;	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    if (input.charAt(index) == '\\' && index + 1 < input.length() && input.charAt(index + 1) == 'u') {	        int i = 2;	        while (index + i < input.length() && input.charAt(index + i) == 'u') {	            i++;	        }	        if (index + i < input.length() && input.charAt(index + i) == '+') {	            i++;	        }	        if (index + i + 4 <= input.length()) {	            final CharSequence unicode = input.subSequence(index + i, index + i + 4);	            try {	                final int value = Integer.parseInt(unicode.toString(), 16);	                out.write((char) value);	            } catch (final NumberFormatException nfe) {	                throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe);	            }	            return i + 4;	        } else {	            throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + input.subSequence(index, input.length()) + "' due to end of CharSequence");	        }	    }	    return 0;	}
protected String getArraySeparator() {	    return arraySeparator;	}
public static String[] splitByWholeSeparatorPreserveAllTokens(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, true);	}
public void addInitializer(final String name, final BackgroundInitializer<?> init) {	    if (name == null) {	        throw new IllegalArgumentException("Name of child initializer must not be null!");	    }	    if (init == null) {	        throw new IllegalArgumentException("Child initializer must not be null!");	    }	    synchronized (this) {	        if (isStarted()) {	            throw new IllegalStateException("addInitializer() must not be called after start()!");	        }	        childInitializers.put(name, init);	    }	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static boolean isAlphaSpace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false && cs.charAt(i) != ' ') {	            return false;	        }	    }	    return true;	}
public int capacity() {	    return buffer.length;	}
public static StrTokenizer getCSVInstance(final char[] input) {	    final StrTokenizer tok = getCSVClone();	    tok.reset(input);	    return tok;	}
public static Boolean[] nullToEmpty(final Boolean[] array) {	    if (array == null || array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    return array;	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
public int capacity() {	    return buffer.length;	}
public static CharRange is(final char ch) {	    return new CharRange(ch, ch, false);	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
@Override	public String getMessage() {	    return getFormattedExceptionMessage(super.getMessage());	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
private static boolean isAssignable(final Type type, final TypeVariable<?> toTypeVariable, final Map<TypeVariable<?>, Type> typeVarAssigns) {	    if (type == null) {	        return true;	    }	    if (toTypeVariable == null) {	        return false;	    }	    if (toTypeVariable.equals(type)) {	        return true;	    }	    if (type instanceof TypeVariable<?>) {	        final Type[] bounds = getImplicitBounds((TypeVariable<?>) type);	        for (final Type bound : bounds) {	            if (isAssignable(bound, toTypeVariable, typeVarAssigns)) {	                return true;	            }	        }	    }	    if (type instanceof Class<?> || type instanceof ParameterizedType || type instanceof GenericArrayType || type instanceof WildcardType) {	        return false;	    }	    throw new IllegalStateException("found an unhandled type: " + type);	}
@Override	public int length() {	    return size;	}
public String getNullText() {	    return nullText;	}
public StrBuilder ensureCapacity(final int capacity) {	    if (capacity > buffer.length) {	        final char[] old = buffer;	        buffer = new char[capacity * 2];	        System.arraycopy(old, 0, buffer, 0, size);	    }	    return this;	}
public int indexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex < 0 ? 0 : startIndex);	    if (matcher == null || startIndex >= size) {	        return -1;	    }	    final int len = size;	    final char[] buf = buffer;	    for (int i = startIndex; i < len; i++) {	        if (matcher.isMatch(buf, i, startIndex, len) > 0) {	            return i;	        }	    }	    return -1;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase) {	    if (str == null || prefix == null) {	        return str == null && prefix == null;	    }	    if (prefix.length() > str.length()) {	        return false;	    }	    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());	}
@Override	public int hashCode() {	    return toHashCode();	}
public char getEnd() {	    return this.end;	}
protected String getFieldNameValueSeparator() {	    return fieldNameValueSeparator;	}
public static boolean[] hexDigitToBinary(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return new boolean[] { false, false, false, false };	        case '1':	            return new boolean[] { true, false, false, false };	        case '2':	            return new boolean[] { false, true, false, false };	        case '3':	            return new boolean[] { true, true, false, false };	        case '4':	            return new boolean[] { false, false, true, false };	        case '5':	            return new boolean[] { true, false, true, false };	        case '6':	            return new boolean[] { false, true, true, false };	        case '7':	            return new boolean[] { true, true, true, false };	        case '8':	            return new boolean[] { false, false, false, true };	        case '9':	            return new boolean[] { true, false, false, true };	        case 'a':	        case 'A':	            return new boolean[] { false, true, false, true };	        case 'b':	        case 'B':	            return new boolean[] { true, true, false, true };	        case 'c':	        case 'C':	            return new boolean[] { false, false, true, true };	        case 'd':	        case 'D':	            return new boolean[] { true, false, true, true };	        case 'e':	        case 'E':	            return new boolean[] { false, true, true, true };	        case 'f':	        case 'F':	            return new boolean[] { true, true, true, true };	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public String getNullText() {	    return nullText;	}
public static void validState(final boolean expression, final String message, final Object... values) {	    if (expression == false) {	        throw new IllegalStateException(String.format(message, values));	    }	}
@Override	public int length() {	    return size;	}
protected String getFieldSeparator() {	    return fieldSeparator;	}
public static String removePattern(final String source, final String regex) {	    return replacePattern(source, regex, StringUtils.EMPTY);	}
public static boolean isAsciiAlphanumeric(final char ch) {	    return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9');	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public String getNewLineText() {	    return newLine;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public String getNewLineText() {	    return newLine;	}
public String getNullText() {	    return nullText;	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) {	    if (0 == nHexs) {	        return dstInit;	    }	    if ((nHexs - 1) * 4 + srcPos >= 64) {	        throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 64");	    }	    final StringBuilder sb = new StringBuilder(dstInit);	    int shift = 0;	    int append = sb.length();	    for (int i = 0; i < nHexs; i++) {	        shift = i * 4 + srcPos;	        final int bits = (int) (0xF & (src >> shift));	        if (dstPos + i == append) {	            ++append;	            sb.append(intToHexDigit(bits));	        } else {	            sb.setCharAt(dstPos + i, intToHexDigit(bits));	        }	    }	    return sb.toString();	}
public Fraction reduce() {	    if (numerator == 0) {	        return equals(ZERO) ? this : ZERO;	    }	    final int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);	    if (gcd == 1) {	        return this;	    }	    return Fraction.getFraction(numerator / gcd, denominator / gcd);	}
protected boolean isFieldSeparatorAtStart() {	    return fieldSeparatorAtStart;	}
@Override	public boolean equals(final Object obj) {	    if (obj == this) {	        return true;	    }	    if (obj instanceof CharRange == false) {	        return false;	    }	    final CharRange other = (CharRange) obj;	    return start == other.start && end == other.end && negated == other.negated;	}
public static Date truncate(final Object date, final int field) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (date instanceof Date) {	        return truncate((Date) date, field);	    } else if (date instanceof Calendar) {	        return truncate((Calendar) date, field).getTime();	    } else {	        throw new ClassCastException("Could not truncate " + date);	    }	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
public boolean isEndedBy(final T element) {	    if (element == null) {	        return false;	    }	    return comparator.compare(element, maximum) == 0;	}
public static boolean isNumber(final String str) {	    if (StringUtils.isEmpty(str)) {	        return false;	    }	    final char[] chars = str.toCharArray();	    int sz = chars.length;	    boolean hasExp = false;	    boolean hasDecPoint = false;	    boolean allowSigns = false;	    boolean foundDigit = false;	    final int start = (chars[0] == '-') ? 1 : 0;	    if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') {	        int i = start + 2;	        if (i == sz) {	            return false;	        }	        for (; i < chars.length; i++) {	            if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) {	                return false;	            }	        }	        return true;	    }	    sz--;	    int i = start;	    while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {	        if (chars[i] >= '0' && chars[i] <= '9') {	            foundDigit = true;	            allowSigns = false;	        } else if (chars[i] == '.') {	            if (hasDecPoint || hasExp) {	                return false;	            }	            hasDecPoint = true;	        } else if (chars[i] == 'e' || chars[i] == 'E') {	            if (hasExp) {	                return false;	            }	            if (!foundDigit) {	                return false;	            }	            hasExp = true;	            allowSigns = true;	        } else if (chars[i] == '+' || chars[i] == '-') {	            if (!allowSigns) {	                return false;	            }	            allowSigns = false;	            foundDigit = false;	        } else {	            return false;	        }	        i++;	    }	    if (i < chars.length) {	        if (chars[i] >= '0' && chars[i] <= '9') {	            return true;	        }	        if (chars[i] == 'e' || chars[i] == 'E') {	            return false;	        }	        if (chars[i] == '.') {	            if (hasDecPoint || hasExp) {	                return false;	            }	            return foundDigit;	        }	        if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) {	            return foundDigit;	        }	        if (chars[i] == 'l' || chars[i] == 'L') {	            return foundDigit && !hasExp && !hasDecPoint;	        }	        return false;	    }	    return !allowSigns && foundDigit;	}
protected String getFieldSeparator() {	    return fieldSeparator;	}
@Override	public String toString() {	    return String.valueOf(value);	}
public boolean isNegated() {	    return negated;	}
public static String formatUTC(final Date date, final String pattern, final Locale locale) {	    return format(date, pattern, UTC_TIME_ZONE, locale);	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
public static char binaryToHexDigit(final boolean[] src, final int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    if (src.length > srcPos + 3 && src[srcPos + 3]) {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src[srcPos]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
public StrBuilder appendNull() {	    if (nullText == null) {	        return this;	    }	    return append(nullText);	}
public String getNewLineText() {	    return newLine;	}
public StringBuilder toStringBuilder() {	    return new StringBuilder(size).append(buffer, 0, size);	}
public boolean isEmpty() {	    return size == 0;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = Integer.MAX_VALUE;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.indexOf(str, search, 0);	        if (tmp == INDEX_NOT_FOUND) {	            continue;	        }	        if (tmp < ret) {	            ret = tmp;	        }	    }	    return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;	}
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = Integer.MAX_VALUE;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.indexOf(str, search, 0);	        if (tmp == INDEX_NOT_FOUND) {	            continue;	        }	        if (tmp < ret) {	            ret = tmp;	        }	    }	    return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;	}
public static Date setSeconds(final Date date, final int amount) {	    return set(date, Calendar.SECOND, amount);	}
public boolean isEmpty() {	    return size == 0;	}
public StringBuilder toStringBuilder() {	    return new StringBuilder(size).append(buffer, 0, size);	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public StrBuilder replaceAll(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, -1);	}
public int size() {	    return size;	}
private static Date set(final Date date, final int calendarField, final int amount) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final Calendar c = Calendar.getInstance();	    c.setLenient(false);	    c.setTime(date);	    c.set(calendarField, amount);	    return c.getTime();	}
public String getNullText() {	    return nullText;	}
public static int indexOfAnyBut(final CharSequence seq, final CharSequence searchChars) {	    if (isEmpty(seq) || isEmpty(searchChars)) {	        return INDEX_NOT_FOUND;	    }	    final int strLen = seq.length();	    for (int i = 0; i < strLen; i++) {	        final char ch = seq.charAt(i);	        final boolean chFound = CharSequenceUtils.indexOf(searchChars, ch, 0) >= 0;	        if (i + 1 < strLen && Character.isHighSurrogate(ch)) {	            final char ch2 = seq.charAt(i + 1);	            if (chFound && CharSequenceUtils.indexOf(searchChars, ch2, 0) < 0) {	                return i;	            }	        } else {	            if (!chFound) {	                return i;	            }	        }	    }	    return INDEX_NOT_FOUND;	}
public ToStringBuilder appendSuper(final String superToString) {	    if (superToString != null) {	        style.appendSuper(buffer, superToString);	    }	    return this;	}
public void increment() {	    value++;	}
public boolean isEquals() {	    return this.isEquals;	}
public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables) {	    this.enableSubstitutionInVariables = enableSubstitutionInVariables;	}
public String getNullText() {	    return nullText;	}
public static <T> T cloneIfPossible(final T obj) {	    final T clone = clone(obj);	    return clone == null ? obj : clone;	}
public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables) {	    this.enableSubstitutionInVariables = enableSubstitutionInVariables;	}
public void subtract(final Number operand) {	    this.value -= operand.doubleValue();	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException {	    return parseDateWithLeniency(str, locale, parsePatterns, true);	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public int size() {	    return size;	}
public static String getCommonPrefix(final String... strs) {	    if (strs == null || strs.length == 0) {	        return EMPTY;	    }	    final int smallestIndexOfDiff = indexOfDifference(strs);	    if (smallestIndexOfDiff == INDEX_NOT_FOUND) {	        if (strs[0] == null) {	            return EMPTY;	        }	        return strs[0];	    } else if (smallestIndexOfDiff == 0) {	        return EMPTY;	    } else {	        return strs[0].substring(0, smallestIndexOfDiff);	    }	}
public int indexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex < 0 ? 0 : startIndex);	    if (matcher == null || startIndex >= size) {	        return -1;	    }	    final int len = size;	    final char[] buf = buffer;	    for (int i = startIndex; i < len; i++) {	        if (matcher.isMatch(buf, i, startIndex, len) > 0) {	            return i;	        }	    }	    return -1;	}
public String getNullText() {	    return nullText;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
@Override	public String toString() {	    if (this.getObject() == null) {	        return this.getStyle().getNullText();	    }	    Class<?> clazz = this.getObject().getClass();	    this.appendFieldsIn(clazz);	    while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {	        clazz = clazz.getSuperclass();	        this.appendFieldsIn(clazz);	    }	    return super.toString();	}
public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale) {	    return cache.getInstance(pattern, timeZone, locale);	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public String getNullText() {	    return nullText;	}
public StrBuilder appendSeparator(final char separator, final int loopIndex) {	    if (loopIndex > 0) {	        append(separator);	    }	    return this;	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
protected String getFieldSeparator() {	    return fieldSeparator;	}
public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) {	    if (array == null) {	        return null;	    }	    if (startIndexInclusive < 0) {	        startIndexInclusive = 0;	    }	    if (endIndexExclusive > array.length) {	        endIndexExclusive = array.length;	    }	    final int newSize = endIndexExclusive - startIndexInclusive;	    if (newSize <= 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] subarray = new boolean[newSize];	    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);	    return subarray;	}
@Override	public short shortValue() {	    return value;	}
public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex) {	    return indexOf(throwable, type, fromIndex, true);	}
public static String leftPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return leftPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return padStr.concat(str);	    } else if (pads < padLen) {	        return padStr.substring(0, pads).concat(str);	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return new String(padding).concat(str);	    }	}
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {	    if (array == null) {	        if (index != 0) {	            throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0");	        }	        final Object joinedArray = Array.newInstance(clss, 1);	        Array.set(joinedArray, 0, element);	        return joinedArray;	    }	    final int length = Array.getLength(array);	    if (index > length || index < 0) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(clss, length + 1);	    System.arraycopy(array, 0, result, 0, index);	    Array.set(result, index, element);	    if (index < length) {	        System.arraycopy(array, index, result, index + 1, length - index);	    }	    return result;	}
public static String replacePattern(final String source, final String regex, final String replacement) {	    return Pattern.compile(regex, Pattern.DOTALL).matcher(source).replaceAll(replacement);	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
@Override	public boolean markSupported() {	    return true;	}
@Override	public int hashCode() {	    return toHashCode();	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
public static float max(final float a, final float b, final float c) {	    return Math.max(Math.max(a, b), c);	}
public static UnicodeEscaper above(final int codepoint) {	    return outsideOf(0, codepoint);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static boolean isAlphanumeric(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetterOrDigit(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) {	    if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {	        return text;	    }	    if (timeToLive < 0) {	        throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another");	    }	    final int searchLength = searchList.length;	    final int replacementLength = replacementList.length;	    if (searchLength != replacementLength) {	        throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength);	    }	    final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];	    int textIndex = -1;	    int replaceIndex = -1;	    int tempIndex = -1;	    for (int i = 0; i < searchLength; i++) {	        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {	            continue;	        }	        tempIndex = text.indexOf(searchList[i]);	        if (tempIndex == -1) {	            noMoreMatchesForReplIndex[i] = true;	        } else {	            if (textIndex == -1 || tempIndex < textIndex) {	                textIndex = tempIndex;	                replaceIndex = i;	            }	        }	    }	    if (textIndex == -1) {	        return text;	    }	    int start = 0;	    int increase = 0;	    for (int i = 0; i < searchList.length; i++) {	        if (searchList[i] == null || replacementList[i] == null) {	            continue;	        }	        final int greater = replacementList[i].length() - searchList[i].length();	        if (greater > 0) {	            increase += 3 * greater;	        }	    }	    increase = Math.min(increase, text.length() / 5);	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (textIndex != -1) {	        for (int i = start; i < textIndex; i++) {	            buf.append(text.charAt(i));	        }	        buf.append(replacementList[replaceIndex]);	        start = textIndex + searchList[replaceIndex].length();	        textIndex = -1;	        replaceIndex = -1;	        tempIndex = -1;	        for (int i = 0; i < searchLength; i++) {	            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {	                continue;	            }	            tempIndex = text.indexOf(searchList[i], start);	            if (tempIndex == -1) {	                noMoreMatchesForReplIndex[i] = true;	            } else {	                if (textIndex == -1 || tempIndex < textIndex) {	                    textIndex = tempIndex;	                    replaceIndex = i;	                }	            }	        }	    }	    final int textLength = text.length();	    for (int i = start; i < textLength; i++) {	        buf.append(text.charAt(i));	    }	    final String result = buf.toString();	    if (!repeat) {	        return result;	    }	    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public boolean contains(final CharRange range) {	    if (range == null) {	        throw new IllegalArgumentException("The Range must not be null");	    }	    if (negated) {	        if (range.negated) {	            return start >= range.start && end <= range.end;	        }	        return range.end < start || range.start > end;	    }	    if (range.negated) {	        return start == 0 && end == Character.MAX_VALUE;	    }	    return start <= range.start && end >= range.end;	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
public static float max(final float a, final float b, final float c) {	    return Math.max(Math.max(a, b), c);	}
public Comparator<T> getComparator() {	    return comparator;	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public static boolean isNotEmpty(final boolean[] array) {	    return (array != null && array.length != 0);	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static Number createNumber(final String str) throws NumberFormatException {	    if (str == null) {	        return null;	    }	    if (StringUtils.isBlank(str)) {	        throw new NumberFormatException("A blank string is not a valid number");	    }	    final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" };	    int pfxLen = 0;	    for (final String pfx : hex_prefixes) {	        if (str.startsWith(pfx)) {	            pfxLen += pfx.length();	            break;	        }	    }	    if (pfxLen > 0) {	        final int hexDigits = str.length() - pfxLen;	        if (hexDigits > 16) {	            return createBigInteger(str);	        }	        if (hexDigits > 8) {	            return createLong(str);	        }	        return createInteger(str);	    }	    final char lastChar = str.charAt(str.length() - 1);	    String mant;	    String dec;	    String exp;	    final int decPos = str.indexOf('.');	    final int expPos = str.indexOf('e') + str.indexOf('E') + 1;	    int numDecimals = 0;	    if (decPos > -1) {	        if (expPos > -1) {	            if (expPos < decPos || expPos > str.length()) {	                throw new NumberFormatException(str + " is not a valid number.");	            }	            dec = str.substring(decPos + 1, expPos);	        } else {	            dec = str.substring(decPos + 1);	        }	        mant = str.substring(0, decPos);	        numDecimals = dec.length();	    } else {	        if (expPos > -1) {	            if (expPos > str.length()) {	                throw new NumberFormatException(str + " is not a valid number.");	            }	            mant = str.substring(0, expPos);	        } else {	            mant = str;	        }	        dec = null;	    }	    if (!Character.isDigit(lastChar) && lastChar != '.') {	        if (expPos > -1 && expPos < str.length() - 1) {	            exp = str.substring(expPos + 1, str.length() - 1);	        } else {	            exp = null;	        }	        final String numeric = str.substring(0, str.length() - 1);	        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);	        switch(lastChar) {	            case 'l':	            case 'L':	                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {	                    try {	                        return createLong(numeric);	                    } catch (final NumberFormatException nfe) {	                    }	                    return createBigInteger(numeric);	                }	                throw new NumberFormatException(str + " is not a valid number.");	            case 'f':	            case 'F':	                try {	                    final Float f = NumberUtils.createFloat(numeric);	                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {	                        return f;	                    }	                } catch (final NumberFormatException nfe) {	                }	            case 'd':	            case 'D':	                try {	                    final Double d = NumberUtils.createDouble(numeric);	                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {	                        return d;	                    }	                } catch (final NumberFormatException nfe) {	                }	                try {	                    return createBigDecimal(numeric);	                } catch (final NumberFormatException e) {	                }	            default:	                throw new NumberFormatException(str + " is not a valid number.");	        }	    }	    if (expPos > -1 && expPos < str.length() - 1) {	        exp = str.substring(expPos + 1, str.length());	    } else {	        exp = null;	    }	    if (dec == null && exp == null) {	        try {	            return createInteger(str);	        } catch (final NumberFormatException nfe) {	        }	        try {	            return createLong(str);	        } catch (final NumberFormatException nfe) {	        }	        return createBigInteger(str);	    }	    final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);	    try {	        if (numDecimals <= 7) {	            final Float f = createFloat(str);	            if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {	                return f;	            }	        }	    } catch (final NumberFormatException nfe) {	    }	    try {	        if (numDecimals <= 16) {	            final Double d = createDouble(str);	            if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {	                return d;	            }	        }	    } catch (final NumberFormatException nfe) {	    }	    return createBigDecimal(str);	}
public void add(final Number operand) {	    this.value += operand.doubleValue();	}
public static boolean containsNone(final CharSequence cs, final String invalidChars) {	    if (cs == null || invalidChars == null) {	        return true;	    }	    return containsNone(cs, invalidChars.toCharArray());	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public String getNullText() {	    return nullText;	}
public static Type getArrayComponentType(final Type type) {	    if (type instanceof Class<?>) {	        final Class<?> clazz = (Class<?>) type;	        return clazz.isArray() ? clazz.getComponentType() : null;	    }	    if (type instanceof GenericArrayType) {	        return ((GenericArrayType) type).getGenericComponentType();	    }	    return null;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static char binaryToHexDigit(final boolean[] src, final int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    if (src.length > srcPos + 3 && src[srcPos + 3]) {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src[srcPos]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
public static void identityToString(final StringBuilder builder, final Object object) {	    if (object == null) {	        throw new NullPointerException("Cannot get the toString of a null identity");	    }	    builder.append(object.getClass().getName()).append('@').append(Integer.toHexString(System.identityHashCode(object)));	}
public static byte CONST_BYTE(final int v) throws IllegalArgumentException {	    if (v < Byte.MIN_VALUE || v > Byte.MAX_VALUE) {	        throw new IllegalArgumentException("Supplied value must be a valid byte literal between -128 and 127: [" + v + "]");	    }	    return (byte) v;	}
public void getChars(final int startIndex, final int endIndex, final char[] destination, final int destinationIndex) {	    if (startIndex < 0) {	        throw new StringIndexOutOfBoundsException(startIndex);	    }	    if (endIndex < 0 || endIndex > length()) {	        throw new StringIndexOutOfBoundsException(endIndex);	    }	    if (startIndex > endIndex) {	        throw new StringIndexOutOfBoundsException("end < start");	    }	    System.arraycopy(buffer, startIndex, destination, destinationIndex, endIndex - startIndex);	}
public String toSplitString() {	    return DurationFormatUtils.formatDurationHMS(getSplitTime());	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public boolean isEmptyTokenAsNull() {	    return this.emptyAsNull;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
@Override	public void remove() {	    throw new UnsupportedOperationException();	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public static String getShortClassName(String className) {	    if (StringUtils.isEmpty(className)) {	        return StringUtils.EMPTY;	    }	    final StringBuilder arrayPrefix = new StringBuilder();	    if (className.startsWith("[")) {	        while (className.charAt(0) == '[') {	            className = className.substring(1);	            arrayPrefix.append("[]");	        }	        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {	            className = className.substring(1, className.length() - 1);	        }	        if (reverseAbbreviationMap.containsKey(className)) {	            className = reverseAbbreviationMap.get(className);	        }	    }	    final int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);	    final int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);	    String out = className.substring(lastDotIdx + 1);	    if (innerIdx != -1) {	        out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);	    }	    return out + arrayPrefix;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public boolean isEmpty() {	    return size == 0;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static boolean isAlphanumeric(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetterOrDigit(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess) {	    if (cls == null) {	        throw new IllegalArgumentException("The class must not be null");	    }	    if (fieldName == null) {	        throw new IllegalArgumentException("The field name must not be null");	    }	    try {	        final Field field = cls.getDeclaredField(fieldName);	        if (!MemberUtils.isAccessible(field)) {	            if (forceAccess) {	                field.setAccessible(true);	            } else {	                return null;	            }	        }	        return field;	    } catch (final NoSuchFieldException e) {	    }	    return null;	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
@Override	public String build() {	    return toString();	}
public String getNewLineText() {	    return newLine;	}
public static boolean isNotBlank(final CharSequence cs) {	    return !StringUtils.isBlank(cs);	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static String trim(final String str) {	    return str == null ? null : str.trim();	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
static int lastIndexOf(final CharSequence cs, final CharSequence searchChar, final int start) {	    return cs.toString().lastIndexOf(searchChar.toString(), start);	}
public char getEscapeChar() {	    return this.escapeChar;	}
public static CharRange is(final char ch) {	    return new CharRange(ch, ch, false);	}
public int toComparison() {	    return comparison;	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
public static boolean startsWithAny(final CharSequence string, final CharSequence... searchStrings) {	    if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {	        return false;	    }	    for (final CharSequence searchString : searchStrings) {	        if (StringUtils.startsWith(string, searchString)) {	            return true;	        }	    }	    return false;	}
public boolean isBeforeRange(final Range<T> otherRange) {	    if (otherRange == null) {	        return false;	    }	    return isBefore(otherRange.minimum);	}
@Override	public double doubleValue() {	    return (double) numerator / (double) denominator;	}
public boolean isEmpty() {	    return size == 0;	}
public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException {	    return parseDateWithLeniency(str, null, parsePatterns, false);	}
private static void getAllInterfaces(Class<?> cls, final HashSet<Class<?>> interfacesFound) {	    while (cls != null) {	        final Class<?>[] interfaces = cls.getInterfaces();	        for (final Class<?> i : interfaces) {	            if (interfacesFound.add(i)) {	                getAllInterfaces(i, interfacesFound);	            }	        }	        cls = cls.getSuperclass();	    }	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) {	    if (str == null) {	        if (trueString == null) {	            return Boolean.TRUE;	        }	        if (falseString == null) {	            return Boolean.FALSE;	        }	        if (nullString == null) {	            return null;	        }	    } else if (str.equals(trueString)) {	        return Boolean.TRUE;	    } else if (str.equals(falseString)) {	        return Boolean.FALSE;	    } else if (str.equals(nullString)) {	        return null;	    }	    throw new IllegalArgumentException("The String did not match any specified value");	}
public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex) {	    return indexOf(throwable, clazz, fromIndex, false);	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public String substring(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    return new String(buffer, startIndex, endIndex - startIndex);	}
public static String[] substringsBetween(final String str, final String open, final String close) {	    if (str == null || isEmpty(open) || isEmpty(close)) {	        return null;	    }	    final int strLen = str.length();	    if (strLen == 0) {	        return ArrayUtils.EMPTY_STRING_ARRAY;	    }	    final int closeLen = close.length();	    final int openLen = open.length();	    final List<String> list = new ArrayList<String>();	    int pos = 0;	    while (pos < strLen - closeLen) {	        int start = str.indexOf(open, pos);	        if (start < 0) {	            break;	        }	        start += openLen;	        final int end = str.indexOf(close, start);	        if (end < 0) {	            break;	        }	        list.add(str.substring(start, end));	        pos = end + closeLen;	    }	    if (list.isEmpty()) {	        return null;	    }	    return list.toArray(new String[list.size()]);	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
public static float min(final float a, final float b) {	    if (Float.isNaN(a)) {	        return b;	    } else if (Float.isNaN(b)) {	        return a;	    } else {	        return Math.min(a, b);	    }	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
@Override	public float floatValue() {	    return (float) numerator / (float) denominator;	}
@Override	public void write(final String str, final int off, final int len) {	    StrBuilder.this.append(str, off, len);	}
protected ScheduledExecutorService getExecutorService() {	    return executorService;	}
public static Boolean[] toObject(final boolean[] array) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    final Boolean[] result = new Boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        result[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE);	    }	    return result;	}
@Override	public Object parseObject(final String source, final ParsePosition pos) {	    return parser.parseObject(source, pos);	}
public static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) {	    if (0 == nBools) {	        return dst;	    }	    if (nBools - 1 + srcPos >= 16) {	        throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 16");	    }	    int shift = 0;	    assert ((nBools - 1) * 1 < 16 - srcPos);	    for (int i = 0; i < nBools; i++) {	        shift = i * 1 + srcPos;	        dst[dstPos + i] = ((0x1 & (src >> shift)) != 0);	    }	    return dst;	}
public String getNewLineText() {	    return newLine;	}
public static CharRange is(final char ch) {	    return new CharRange(ch, ch, false);	}
public static String removeEnd(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.endsWith(remove)) {	        return str.substring(0, str.length() - remove.length());	    }	    return str;	}
public StrBuilder deleteAll(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, -1);	}
@Override	public int length() {	    return size;	}
@Override	public int compare(final Object obj1, final Object obj2) {	    return ((Comparable) obj1).compareTo(obj2);	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
public static String substringAfter(final String str, final String separator) {	    if (isEmpty(str)) {	        return str;	    }	    if (separator == null) {	        return EMPTY;	    }	    final int pos = str.indexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return EMPTY;	    }	    return str.substring(pos + separator.length());	}
public String getNullText() {	    return nullText;	}
public HashCodeBuilder append(final short[] array) {	    if (array == null) {	        iTotal = iTotal * iConstant;	    } else {	        for (final short element : array) {	            append(element);	        }	    }	    return this;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes) {	    if ((src.length == 0 && srcPos == 0) || 0 == nBytes) {	        return dstInit;	    }	    if ((nBytes - 1) * 8 + dstPos >= 64) {	        throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 64");	    }	    long out = dstInit;	    int shift = 0;	    for (int i = 0; i < nBytes; i++) {	        shift = i * 8 + dstPos;	        final long bits = (0xffL & src[i + srcPos]) << shift;	        final long mask = 0xffL << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {	    if (str == null || searchStr == null) {	        return INDEX_NOT_FOUND;	    }	    if (startPos > str.length() - searchStr.length()) {	        startPos = str.length() - searchStr.length();	    }	    if (startPos < 0) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return startPos;	    }	    for (int i = startPos; i >= 0; i--) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
private static boolean endsWith(final CharSequence str, final CharSequence suffix, final boolean ignoreCase) {	    if (str == null || suffix == null) {	        return str == null && suffix == null;	    }	    if (suffix.length() > str.length()) {	        return false;	    }	    final int strOffset = str.length() - suffix.length();	    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, suffix, 0, suffix.length());	}
public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) {	    if (it != null) {	        separator = ObjectUtils.toString(separator);	        while (it.hasNext()) {	            append(it.next());	            if (it.hasNext()) {	                append(separator);	            }	        }	    }	    return this;	}
@Override	public String build() {	    return toString();	}
public int capacity() {	    return buffer.length;	}
public static StrTokenizer getCSVInstance(final char[] input) {	    final StrTokenizer tok = getCSVClone();	    tok.reset(input);	    return tok;	}
public static String appendIfMissingIgnoreCase(final String str, final CharSequence suffix, final CharSequence... suffixes) {	    return appendIfMissing(str, suffix, true, suffixes);	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
public static <T extends Iterable<?>> T noNullElements(final T iterable) {	    return noNullElements(iterable, DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE);	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) {	    if (str == null) {	        if (trueString == null) {	            return Boolean.TRUE;	        }	        if (falseString == null) {	            return Boolean.FALSE;	        }	        if (nullString == null) {	            return null;	        }	    } else if (str.equals(trueString)) {	        return Boolean.TRUE;	    } else if (str.equals(falseString)) {	        return Boolean.FALSE;	    } else if (str.equals(nullString)) {	        return null;	    }	    throw new IllegalArgumentException("The String did not match any specified value");	}
public char getEscapeChar() {	    return this.escapeChar;	}
public static boolean startsWithAny(final CharSequence string, final CharSequence... searchStrings) {	    if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {	        return false;	    }	    for (final CharSequence searchString : searchStrings) {	        if (StringUtils.startsWith(string, searchString)) {	            return true;	        }	    }	    return false;	}
static boolean isRegistered(final Object lhs, final Object rhs) {	    final Set<Pair<IDKey, IDKey>> registry = getRegistry();	    final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);	    final Pair<IDKey, IDKey> swappedPair = Pair.of(pair.getLeft(), pair.getRight());	    return registry != null && (registry.contains(pair) || registry.contains(swappedPair));	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) {	    style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));	    return this;	}
public static String substringBefore(final String str, final String separator) {	    if (isEmpty(str) || separator == null) {	        return str;	    }	    if (separator.isEmpty()) {	        return EMPTY;	    }	    final int pos = str.indexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return str;	    }	    return str.substring(0, pos);	}
public Float toFloat() {	    return Float.valueOf(floatValue());	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
public static Object invokeStaticMethod(final Class<?> cls, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {	    if (parameterTypes == null) {	        parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;	    }	    if (args == null) {	        args = ArrayUtils.EMPTY_OBJECT_ARRAY;	    }	    final Method method = getMatchingAccessibleMethod(cls, methodName, parameterTypes);	    if (method == null) {	        throw new NoSuchMethodException("No such accessible method: " + methodName + "() on class: " + cls.getName());	    }	    return method.invoke(null, args);	}
public int set(final int holder) {	    return holder | _mask;	}
public static boolean isNumber(final String str) {	    if (StringUtils.isEmpty(str)) {	        return false;	    }	    final char[] chars = str.toCharArray();	    int sz = chars.length;	    boolean hasExp = false;	    boolean hasDecPoint = false;	    boolean allowSigns = false;	    boolean foundDigit = false;	    final int start = (chars[0] == '-') ? 1 : 0;	    if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') {	        int i = start + 2;	        if (i == sz) {	            return false;	        }	        for (; i < chars.length; i++) {	            if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) {	                return false;	            }	        }	        return true;	    }	    sz--;	    int i = start;	    while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {	        if (chars[i] >= '0' && chars[i] <= '9') {	            foundDigit = true;	            allowSigns = false;	        } else if (chars[i] == '.') {	            if (hasDecPoint || hasExp) {	                return false;	            }	            hasDecPoint = true;	        } else if (chars[i] == 'e' || chars[i] == 'E') {	            if (hasExp) {	                return false;	            }	            if (!foundDigit) {	                return false;	            }	            hasExp = true;	            allowSigns = true;	        } else if (chars[i] == '+' || chars[i] == '-') {	            if (!allowSigns) {	                return false;	            }	            allowSigns = false;	            foundDigit = false;	        } else {	            return false;	        }	        i++;	    }	    if (i < chars.length) {	        if (chars[i] >= '0' && chars[i] <= '9') {	            return true;	        }	        if (chars[i] == 'e' || chars[i] == 'E') {	            return false;	        }	        if (chars[i] == '.') {	            if (hasDecPoint || hasExp) {	                return false;	            }	            return foundDigit;	        }	        if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) {	            return foundDigit;	        }	        if (chars[i] == 'l' || chars[i] == 'L') {	            return foundDigit && !hasExp && !hasDecPoint;	        }	        return false;	    }	    return !allowSigns && foundDigit;	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public final synchronized int getLimit() {	    return limit;	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static long getFragmentInMinutes(final Calendar calendar, final int fragment) {	    return getFragment(calendar, fragment, Calendar.MINUTE);	}
public static int reflectionHashCode(final Object object, final String... excludeFields) {	    return reflectionHashCode(17, 37, object, false, null, excludeFields);	}
public static String leftPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return leftPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return padStr.concat(str);	    } else if (pads < padLen) {	        return padStr.substring(0, pads).concat(str);	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return new String(padding).concat(str);	    }	}
public static boolean[] clone(final boolean[] array) {	    if (array == null) {	        return null;	    }	    return array.clone();	}
public static Class<?> getRawType(final Type type, final Type assigningType) {	    if (type instanceof Class<?>) {	        return (Class<?>) type;	    }	    if (type instanceof ParameterizedType) {	        return getRawType((ParameterizedType) type);	    }	    if (type instanceof TypeVariable<?>) {	        if (assigningType == null) {	            return null;	        }	        final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration();	        if (!(genericDeclaration instanceof Class<?>)) {	            return null;	        }	        final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType, (Class<?>) genericDeclaration);	        if (typeVarAssigns == null) {	            return null;	        }	        final Type typeArgument = typeVarAssigns.get(type);	        if (typeArgument == null) {	            return null;	        }	        return getRawType(typeArgument, assigningType);	    }	    if (type instanceof GenericArrayType) {	        final Class<?> rawComponentType = getRawType(((GenericArrayType) type).getGenericComponentType(), assigningType);	        return Array.newInstance(rawComponentType, 0).getClass();	    }	    if (type instanceof WildcardType) {	        return null;	    }	    throw new IllegalArgumentException("unknown type: " + type);	}
public void start() {	    if (this.runningState == STATE_STOPPED) {	        throw new IllegalStateException("Stopwatch must be reset before being restarted. ");	    }	    if (this.runningState != STATE_UNSTARTED) {	        throw new IllegalStateException("Stopwatch already started. ");	    }	    this.startTime = System.nanoTime();	    this.startTimeMillis = System.currentTimeMillis();	    this.runningState = STATE_RUNNING;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
@Override	public Object getFirstContextValue(final String label) {	    for (final Pair<String, Object> pair : contextValues) {	        if (StringUtils.equals(label, pair.getKey())) {	            return pair.getValue();	        }	    }	    return null;	}
public static boolean isBlank(final CharSequence cs) {	    int strLen;	    if (cs == null || (strLen = cs.length()) == 0) {	        return true;	    }	    for (int i = 0; i < strLen; i++) {	        if (Character.isWhitespace(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
protected String getArrayEnd() {	    return arrayEnd;	}
public void start() {	    if (this.runningState == STATE_STOPPED) {	        throw new IllegalStateException("Stopwatch must be reset before being restarted. ");	    }	    if (this.runningState != STATE_UNSTARTED) {	        throw new IllegalStateException("Stopwatch already started. ");	    }	    this.startTime = System.nanoTime();	    this.startTimeMillis = System.currentTimeMillis();	    this.runningState = STATE_RUNNING;	}
protected String getFieldNameValueSeparator() {	    return fieldNameValueSeparator;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public StrBuilder appendFixedWidthPadRight(final int value, final int width, final char padChar) {	    return appendFixedWidthPadRight(String.valueOf(value), width, padChar);	}
public static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) {	    if (0 == nBools) {	        return dst;	    }	    if (nBools - 1 + srcPos >= 16) {	        throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 16");	    }	    int shift = 0;	    assert ((nBools - 1) * 1 < 16 - srcPos);	    for (int i = 0; i < nBools; i++) {	        shift = i * 1 + srcPos;	        dst[dstPos + i] = ((0x1 & (src >> shift)) != 0);	    }	    return dst;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) {	    if (0 == nBools) {	        return dst;	    }	    if (nBools - 1 + srcPos >= 16) {	        throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 16");	    }	    int shift = 0;	    assert ((nBools - 1) * 1 < 16 - srcPos);	    for (int i = 0; i < nBools; i++) {	        shift = i * 1 + srcPos;	        dst[dstPos + i] = ((0x1 & (src >> shift)) != 0);	    }	    return dst;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
@Override	public TimeZone getTimeZone() {	    return mTimeZone;	}
public static <T> Range<T> is(final T element, final Comparator<T> comparator) {	    return between(element, element, comparator);	}
public static int lastOrdinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal) {	    return ordinalIndexOf(str, searchStr, ordinal, true);	}
public static boolean isAlpha(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static String rightPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return rightPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return str.concat(padStr);	    } else if (pads < padLen) {	        return str.concat(padStr.substring(0, pads));	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return str.concat(new String(padding));	    }	}
public void decrement() {	    value--;	}
public void split() {	    if (this.runningState != STATE_RUNNING) {	        throw new IllegalStateException("Stopwatch is not running. ");	    }	    this.stopTime = System.nanoTime();	    this.splitState = STATE_SPLIT;	}
public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width, final int precision, final char padChar, final CharSequence ellipsis) {	    Validate.isTrue(ellipsis == null || precision < 0 || ellipsis.length() <= precision, "Specified ellipsis '%1$s' exceeds precision of %2$s", ellipsis, Integer.valueOf(precision));	    final StringBuilder buf = new StringBuilder(seq);	    if (precision >= 0 && precision < seq.length()) {	        final CharSequence _ellipsis = ObjectUtils.defaultIfNull(ellipsis, StringUtils.EMPTY);	        buf.replace(precision - _ellipsis.length(), seq.length(), _ellipsis.toString());	    }	    final boolean leftJustify = (flags & LEFT_JUSTIFY) == LEFT_JUSTIFY;	    for (int i = buf.length(); i < width; i++) {	        buf.insert(leftJustify ? i : 0, padChar);	    }	    formatter.format(buf.toString());	    return formatter;	}
public Short toShort() {	    return Short.valueOf(shortValue());	}
protected String getFieldSeparator() {	    return fieldSeparator;	}
protected void setSummaryObjectEndText(String summaryObjectEndText) {	    if (summaryObjectEndText == null) {	        summaryObjectEndText = "";	    }	    this.summaryObjectEndText = summaryObjectEndText;	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
public static boolean containsAny(final CharSequence cs, final CharSequence searchChars) {	    if (searchChars == null) {	        return false;	    }	    return containsAny(cs, CharSequenceUtils.toCharArray(searchChars));	}
public static boolean isAscii(final char ch) {	    return ch < 128;	}
public boolean isEmpty() {	    return size == 0;	}
public int toComparison() {	    return comparison;	}
public int size() {	    return size;	}
public StrTokenizer setEmptyTokenAsNull(final boolean emptyAsNull) {	    this.emptyAsNull = emptyAsNull;	    return this;	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
protected String getSummaryObjectStartText() {	    return summaryObjectStartText;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static void reverse(final boolean[] array) {	    if (array == null) {	        return;	    }	    int i = 0;	    int j = array.length - 1;	    boolean tmp;	    while (j > i) {	        tmp = array[j];	        array[j] = array[i];	        array[i] = tmp;	        j--;	        i++;	    }	}
public Range<T> intersectionWith(final Range<T> other) {	    if (!this.isOverlappedBy(other)) {	        throw new IllegalArgumentException(String.format("Cannot calculate intersection with non-overlapping range %s", other));	    }	    if (this.equals(other)) {	        return this;	    }	    final T min = getComparator().compare(minimum, other.minimum) < 0 ? other.minimum : minimum;	    final T max = getComparator().compare(maximum, other.maximum) < 0 ? maximum : other.maximum;	    return between(min, max, getComparator());	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public StrBuilder trim() {	    if (size == 0) {	        return this;	    }	    int len = size;	    final char[] buf = buffer;	    int pos = 0;	    while (pos < len && buf[pos] <= ' ') {	        pos++;	    }	    while (pos < len && buf[len - 1] <= ' ') {	        len--;	    }	    if (len < size) {	        delete(len, size);	    }	    if (pos > 0) {	        delete(0, pos);	    }	    return this;	}
public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) {	    final Token[] tokens = lexx(format);	    final Calendar start = Calendar.getInstance(timezone);	    start.setTime(new Date(startMillis));	    final Calendar end = Calendar.getInstance(timezone);	    end.setTime(new Date(endMillis));	    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);	    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);	    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);	    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);	    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);	    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);	    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);	    while (milliseconds < 0) {	        milliseconds += 1000;	        seconds -= 1;	    }	    while (seconds < 0) {	        seconds += 60;	        minutes -= 1;	    }	    while (minutes < 0) {	        minutes += 60;	        hours -= 1;	    }	    while (hours < 0) {	        hours += 24;	        days -= 1;	    }	    if (Token.containsTokenWithValue(tokens, M)) {	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	        while (months < 0) {	            months += 12;	            years -= 1;	        }	        if (!Token.containsTokenWithValue(tokens, y) && years != 0) {	            while (years != 0) {	                months += 12 * years;	                years = 0;	            }	        }	    } else {	        if (!Token.containsTokenWithValue(tokens, y)) {	            int target = end.get(Calendar.YEAR);	            if (months < 0) {	                target -= 1;	            }	            while (start.get(Calendar.YEAR) != target) {	                days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);	                if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) {	                    days += 1;	                }	                start.add(Calendar.YEAR, 1);	                days += start.get(Calendar.DAY_OF_YEAR);	            }	            years = 0;	        }	        while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            start.add(Calendar.MONTH, 1);	        }	        months = 0;	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	    }	    if (!Token.containsTokenWithValue(tokens, d)) {	        hours += 24 * days;	        days = 0;	    }	    if (!Token.containsTokenWithValue(tokens, H)) {	        minutes += 60 * hours;	        hours = 0;	    }	    if (!Token.containsTokenWithValue(tokens, m)) {	        seconds += 60 * minutes;	        minutes = 0;	    }	    if (!Token.containsTokenWithValue(tokens, s)) {	        milliseconds += 1000 * seconds;	        seconds = 0;	    }	    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static <T> T median(final Comparator<T> comparator, final T... items) {	    Validate.notEmpty(items, "null/empty items");	    Validate.noNullElements(items);	    Validate.notNull(comparator, "null comparator");	    final TreeSet<T> sort = new TreeSet<T>(comparator);	    Collections.addAll(sort, items);	    @SuppressWarnings("unchecked")	    final T result = (T) sort.toArray()[(sort.size() - 1) / 2];	    return result;	}
public String getNewLineText() {	    return newLine;	}
public StrBuilder trim() {	    if (size == 0) {	        return this;	    }	    int len = size;	    final char[] buf = buffer;	    int pos = 0;	    while (pos < len && buf[pos] <= ' ') {	        pos++;	    }	    while (pos < len && buf[len - 1] <= ' ') {	        len--;	    }	    if (len < size) {	        delete(len, size);	    }	    if (pos > 0) {	        delete(0, pos);	    }	    return this;	}
public static CharSet getInstance(final String... setStrs) {	    if (setStrs == null) {	        return null;	    }	    if (setStrs.length == 1) {	        final CharSet common = COMMON.get(setStrs[0]);	        if (common != null) {	            return common;	        }	    }	    return new CharSet(setStrs);	}
public StrTokenizer setDelimiterMatcher(final StrMatcher delim) {	    if (delim == null) {	        this.delimMatcher = StrMatcher.noneMatcher();	    } else {	        this.delimMatcher = delim;	    }	    return this;	}
public boolean isEmptyTokenAsNull() {	    return this.emptyAsNull;	}
public static boolean isSameLength(final boolean[] array1, final boolean[] array2) {	    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {	        return false;	    }	    return true;	}
public static boolean[] removeElements(final boolean[] array, final boolean... values) {	    if (isEmpty(array) || isEmpty(values)) {	        return clone(array);	    }	    final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2);	    for (final boolean v : values) {	        final Boolean boxed = Boolean.valueOf(v);	        final MutableInt count = occurrences.get(boxed);	        if (count == null) {	            occurrences.put(boxed, new MutableInt(1));	        } else {	            count.increment();	        }	    }	    final BitSet toRemove = new BitSet();	    for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) {	        final Boolean v = e.getKey();	        int found = 0;	        for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {	            found = indexOf(array, v.booleanValue(), found);	            if (found < 0) {	                break;	            }	            toRemove.set(found++);	        }	    }	    return (boolean[]) removeAll(array, toRemove);	}
public StrBuilder appendSeparator(final char separator, final int loopIndex) {	    if (loopIndex > 0) {	        append(separator);	    }	    return this;	}
protected String getSummaryObjectEndText() {	    return summaryObjectEndText;	}
public static int hexDigitMsb0ToInt(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return 0x0;	        case '1':	            return 0x8;	        case '2':	            return 0x4;	        case '3':	            return 0xC;	        case '4':	            return 0x2;	        case '5':	            return 0xA;	        case '6':	            return 0x6;	        case '7':	            return 0xE;	        case '8':	            return 0x1;	        case '9':	            return 0x9;	        case 'a':	        case 'A':	            return 0x5;	        case 'b':	        case 'B':	            return 0xD;	        case 'c':	        case 'C':	            return 0x3;	        case 'd':	        case 'D':	            return 0xB;	        case 'e':	        case 'E':	            return 0x7;	        case 'f':	        case 'F':	            return 0xF;	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public static <T extends Iterable<?>> T noNullElements(final T iterable) {	    return noNullElements(iterable, DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public int capacity() {	    return buffer.length;	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public StrBuilder clear() {	    size = 0;	    return this;	}
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) {	    if (bool == null) {	        return nullValue;	    }	    return bool.booleanValue() ? trueValue : falseValue;	}
public static Fraction getReducedFraction(int numerator, int denominator) {	    if (denominator == 0) {	        throw new ArithmeticException("The denominator must not be zero");	    }	    if (numerator == 0) {	        return ZERO;	    }	    if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) {	        numerator /= 2;	        denominator /= 2;	    }	    if (denominator < 0) {	        if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {	            throw new ArithmeticException("overflow: can't negate");	        }	        numerator = -numerator;	        denominator = -denominator;	    }	    final int gcd = greatestCommonDivisor(numerator, denominator);	    numerator /= gcd;	    denominator /= gcd;	    return new Fraction(numerator, denominator);	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static void handleCause(final ExecutionException ex) throws ConcurrentException {	    final ConcurrentException cex = extractCause(ex);	    if (cex != null) {	        throw cex;	    }	}
public static <K, V> V createIfAbsentUnchecked(final ConcurrentMap<K, V> map, final K key, final ConcurrentInitializer<V> init) {	    try {	        return createIfAbsent(map, key, init);	    } catch (final ConcurrentException cex) {	        throw new ConcurrentRuntimeException(cex.getCause());	    }	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public synchronized void shutdown() {	    if (!shutdown) {	        if (ownExecutor) {	            getExecutorService().shutdownNow();	        }	        if (task != null) {	            task.cancel(false);	        }	        shutdown = true;	    }	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
@Override	public void mark(final int readAheadLimit) {	    mark = pos;	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public static String[] stripAll(final String[] strs, final String stripChars) {	    int strsLen;	    if (strs == null || (strsLen = strs.length) == 0) {	        return strs;	    }	    final String[] newArr = new String[strsLen];	    for (int i = 0; i < strsLen; i++) {	        newArr[i] = strip(strs[i], stripChars);	    }	    return newArr;	}
public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment) {	    return getFragment(calendar, fragment, Calendar.MILLISECOND);	}
protected boolean isFullDetail(final Boolean fullDetailRequest) {	    if (fullDetailRequest == null) {	        return defaultFullDetail;	    }	    return fullDetailRequest.booleanValue();	}
protected String getSizeEndText() {	    return sizeEndText;	}
public synchronized Future<T> getFuture() {	    if (future == null) {	        throw new IllegalStateException("start() must be called first!");	    }	    return future;	}
public static String[] stripAll(final String[] strs, final String stripChars) {	    int strsLen;	    if (strs == null || (strsLen = strs.length) == 0) {	        return strs;	    }	    final String[] newArr = new String[strsLen];	    for (int i = 0; i < strsLen; i++) {	        newArr[i] = strip(strs[i], stripChars);	    }	    return newArr;	}
public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException {	    return parseDateWithLeniency(str, locale, parsePatterns, true);	}
public int size() {	    return size;	}
public boolean isNegated() {	    return negated;	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public int set(final int holder) {	    return holder | _mask;	}
@Override	public void write(final String str, final int off, final int len) {	    StrBuilder.this.append(str, off, len);	}
protected String getSizeStartText() {	    return sizeStartText;	}
public StrBuilder trim() {	    if (size == 0) {	        return this;	    }	    int len = size;	    final char[] buf = buffer;	    int pos = 0;	    while (pos < len && buf[pos] <= ' ') {	        pos++;	    }	    while (pos < len && buf[len - 1] <= ' ') {	        len--;	    }	    if (len < size) {	        delete(len, size);	    }	    if (pos > 0) {	        delete(0, pos);	    }	    return this;	}
public static String abbreviate(final String str, int offset, final int maxWidth) {	    if (str == null) {	        return null;	    }	    if (maxWidth < 4) {	        throw new IllegalArgumentException("Minimum abbreviation width is 4");	    }	    if (str.length() <= maxWidth) {	        return str;	    }	    if (offset > str.length()) {	        offset = str.length();	    }	    if (str.length() - offset < maxWidth - 3) {	        offset = str.length() - (maxWidth - 3);	    }	    final String abrevMarker = "...";	    if (offset <= 4) {	        return str.substring(0, maxWidth - 3) + abrevMarker;	    }	    if (maxWidth < 7) {	        throw new IllegalArgumentException("Minimum abbreviation width with offset is 7");	    }	    if (offset + maxWidth - 3 < str.length()) {	        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);	    }	    return abrevMarker + str.substring(str.length() - (maxWidth - 3));	}
public String getNewLineText() {	    return newLine;	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
protected boolean isArrayContentDetail() {	    return arrayContentDetail;	}
public String toProperString() {	    if (toProperString == null) {	        if (numerator == 0) {	            toProperString = "0";	        } else if (numerator == denominator) {	            toProperString = "1";	        } else if (numerator == -1 * denominator) {	            toProperString = "-1";	        } else if ((numerator > 0 ? -numerator : numerator) < -denominator) {	            final int properNumerator = getProperNumerator();	            if (properNumerator == 0) {	                toProperString = Integer.toString(getProperWhole());	            } else {	                toProperString = new StringBuilder(32).append(getProperWhole()).append(' ').append(properNumerator).append('/').append(getDenominator()).toString();	            }	        } else {	            toProperString = new StringBuilder(32).append(getNumerator()).append('/').append(getDenominator()).toString();	        }	    }	    return toProperString;	}
public static String rightPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return rightPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return str.concat(padStr);	    } else if (pads < padLen) {	        return str.concat(padStr.substring(0, pads));	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return str.concat(new String(padding));	    }	}
public static char binaryToHexDigit(final boolean[] src, final int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    if (src.length > srcPos + 3 && src[srcPos + 3]) {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src[srcPos]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
public int lastIndexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex >= size ? size - 1 : startIndex);	    if (matcher == null || startIndex < 0) {	        return -1;	    }	    final char[] buf = buffer;	    final int endIndex = startIndex + 1;	    for (int i = startIndex; i >= 0; i--) {	        if (matcher.isMatch(buf, i, 0, endIndex) > 0) {	            return i;	        }	    }	    return -1;	}
public static String defaultString(final String str, final String defaultStr) {	    return str == null ? defaultStr : str;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public boolean isNegated() {	    return negated;	}
public int capacity() {	    return buffer.length;	}
public boolean isEnableSubstitutionInVariables() {	    return enableSubstitutionInVariables;	}
public boolean isAppendTransients() {	    return this.appendTransients;	}
public short setShort(final short holder) {	    return (short) set(holder);	}
public int size() {	    return size;	}
public void suspend() {	    if (this.runningState != STATE_RUNNING) {	        throw new IllegalStateException("Stopwatch must be running to suspend. ");	    }	    this.stopTime = System.nanoTime();	    this.runningState = STATE_SUSPENDED;	}
public static boolean isNotBlank(final CharSequence cs) {	    return !StringUtils.isBlank(cs);	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static boolean containsOnly(final CharSequence cs, final String validChars) {	    if (cs == null || validChars == null) {	        return false;	    }	    return containsOnly(cs, validChars.toCharArray());	}
public int size() {	    return size;	}
public static <E extends Enum<E>> List<E> getEnumList(final Class<E> enumClass) {	    return new ArrayList<E>(Arrays.asList(enumClass.getEnumConstants()));	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
public boolean contains(final char ch) {	    for (final CharRange range : set) {	        if (range.contains(ch)) {	            return true;	        }	    }	    return false;	}
@Override	public Object parseObject(final String source, final ParsePosition pos) {	    return parser.parseObject(source, pos);	}
public static final String escapeCsv(final String input) {	    return ESCAPE_CSV.translate(input);	}
@Override	public Byte getValue() {	    return Byte.valueOf(this.value);	}
protected boolean isFieldSeparatorAtEnd() {	    return fieldSeparatorAtEnd;	}
@Override	public float floatValue() {	    return value;	}
@Override	public int length() {	    return size;	}
public static Date truncate(final Object date, final int field) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (date instanceof Date) {	        return truncate((Date) date, field);	    } else if (date instanceof Calendar) {	        return truncate((Calendar) date, field).getTime();	    } else {	        throw new ClassCastException("Could not truncate " + date);	    }	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public String getNewLineText() {	    return newLine;	}
public StrTokenizer asTokenizer() {	    return new StrBuilderTokenizer();	}
public int capacity() {	    return buffer.length;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
protected String getSummaryObjectStartText() {	    return summaryObjectStartText;	}
public static String toStringTrueFalse(final boolean bool) {	    return toString(bool, "true", "false");	}
public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException {	    return parseDateWithLeniency(str, locale, parsePatterns, true);	}
public static boolean isAsciiAlpha(final char ch) {	    return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');	}
@Override	public int length() {	    return size;	}
public StringBuilder toStringBuilder() {	    return new StringBuilder(size).append(buffer, 0, size);	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static String removeEnd(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.endsWith(remove)) {	        return str.substring(0, str.length() - remove.length());	    }	    return str;	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public boolean isEmpty() {	    return size == 0;	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
@Override	public void write(final String str, final int off, final int len) {	    StrBuilder.this.append(str, off, len);	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public static boolean isAlphaSpace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false && cs.charAt(i) != ' ') {	            return false;	        }	    }	    return true;	}
static Object removeAll(final Object array, final BitSet indices) {	    final int srcLength = ArrayUtils.getLength(array);	    final int removals = indices.cardinality();	    final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals);	    int srcIndex = 0;	    int destIndex = 0;	    int count;	    int set;	    while ((set = indices.nextSetBit(srcIndex)) != -1) {	        count = set - srcIndex;	        if (count > 0) {	            System.arraycopy(array, srcIndex, result, destIndex, count);	            destIndex += count;	        }	        srcIndex = indices.nextClearBit(set);	    }	    count = srcLength - srcIndex;	    if (count > 0) {	        System.arraycopy(array, srcIndex, result, destIndex, count);	    }	    return result;	}
public String getNewLineText() {	    return newLine;	}
@Override	public int hashCode() {	    return printer.hashCode();	}
public static CharRange isIn(final char start, final char end) {	    return new CharRange(start, end, false);	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public boolean isEmpty() {	    return size == 0;	}
public void add(final Number operand) {	    this.value += operand.intValue();	}
public static StrTokenizer getCSVInstance(final char[] input) {	    final StrTokenizer tok = getCSVClone();	    tok.reset(input);	    return tok;	}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    buffer.append(arrayStart);	    for (int i = 0; i < array.length; i++) {	        if (i > 0) {	            buffer.append(arraySeparator);	        }	        appendDetail(buffer, fieldName, array[i]);	    }	    buffer.append(arrayEnd);	}
public static String formatPeriodISO(final long startMillis, final long endMillis) {	    return formatPeriod(startMillis, endMillis, ISO_EXTENDED_FORMAT_PATTERN, false, TimeZone.getDefault());	}
public String getNewLineText() {	    return newLine;	}
public String getNullText() {	    return nullText;	}
public static String swapCase(final String str) {	    if (StringUtils.isEmpty(str)) {	        return str;	    }	    final char[] buffer = str.toCharArray();	    for (int i = 0; i < buffer.length; i++) {	        final char ch = buffer[i];	        if (Character.isUpperCase(ch)) {	            buffer[i] = Character.toLowerCase(ch);	        } else if (Character.isTitleCase(ch)) {	            buffer[i] = Character.toLowerCase(ch);	        } else if (Character.isLowerCase(ch)) {	            buffer[i] = Character.toUpperCase(ch);	        }	    }	    return new String(buffer);	}
public static <T> String reflectionToString(final T object, final ToStringStyle style, final boolean outputTransients, final Class<? super T> reflectUpToClass) {	    return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass);	}
public static boolean isInstance(final Object value, final Type type) {	    if (type == null) {	        return false;	    }	    return value == null ? !(type instanceof Class<?>) || !((Class<?>) type).isPrimitive() : isAssignable(value.getClass(), type, null);	}
public int getProperNumerator() {	    return Math.abs(numerator % denominator);	}
protected String getFieldNameValueSeparator() {	    return fieldNameValueSeparator;	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
protected String getSizeEndText() {	    return sizeEndText;	}
public static String removeEnd(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.endsWith(remove)) {	        return str.substring(0, str.length() - remove.length());	    }	    return str;	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
static void unregister(final Object lhs, final Object rhs) {	    Set<Pair<IDKey, IDKey>> registry = getRegistry();	    if (registry != null) {	        final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);	        registry.remove(pair);	        synchronized (EqualsBuilder.class) {	            registry = getRegistry();	            if (registry != null && registry.isEmpty()) {	                REGISTRY.remove();	            }	        }	    }	}
protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    appendSummarySize(buffer, fieldName, array.length);	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public static boolean isAsciiAlphanumeric(final char ch) {	    return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9');	}
@Override	public int intValue() {	    return (int) value;	}
public static String center(String str, final int size, String padStr) {	    if (str == null || size <= 0) {	        return str;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    str = leftPad(str, strLen + pads / 2, padStr);	    str = rightPad(str, size, padStr);	    return str;	}
public int size() {	    return size;	}
@Override	public int length() {	    return size;	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public boolean isSet(final int holder) {	    return (holder & _mask) != 0;	}
@Override	public int hashCode() {	    return toHashCode();	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
@Override	public boolean isFieldSeparatorAtEnd() {	    return super.isFieldSeparatorAtEnd();	}
public static String[] getRootCauseStackTrace(final Throwable throwable) {	    if (throwable == null) {	        return ArrayUtils.EMPTY_STRING_ARRAY;	    }	    final Throwable[] throwables = getThrowables(throwable);	    final int count = throwables.length;	    final List<String> frames = new ArrayList<String>();	    List<String> nextTrace = getStackFrameList(throwables[count - 1]);	    for (int i = count; --i >= 0; ) {	        final List<String> trace = nextTrace;	        if (i != 0) {	            nextTrace = getStackFrameList(throwables[i - 1]);	            removeCommonFrames(trace, nextTrace);	        }	        if (i == count - 1) {	            frames.add(throwables[i].toString());	        } else {	            frames.add(WRAPPED_MARKER + throwables[i].toString());	        }	        for (int j = 0; j < trace.size(); j++) {	            frames.add(trace.get(j));	        }	    }	    return frames.toArray(new String[frames.size()]);	}
public static <T> T CONST(final T v) {	    return v;	}
static Object removeAll(final Object array, final BitSet indices) {	    final int srcLength = ArrayUtils.getLength(array);	    final int removals = indices.cardinality();	    final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals);	    int srcIndex = 0;	    int destIndex = 0;	    int count;	    int set;	    while ((set = indices.nextSetBit(srcIndex)) != -1) {	        count = set - srcIndex;	        if (count > 0) {	            System.arraycopy(array, srcIndex, result, destIndex, count);	            destIndex += count;	        }	        srcIndex = indices.nextClearBit(set);	    }	    count = srcLength - srcIndex;	    if (count > 0) {	        System.arraycopy(array, srcIndex, result, destIndex, count);	    }	    return result;	}
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return new boolean[] { false, false, false, false };	        case '1':	            return new boolean[] { false, false, false, true };	        case '2':	            return new boolean[] { false, false, true, false };	        case '3':	            return new boolean[] { false, false, true, true };	        case '4':	            return new boolean[] { false, true, false, false };	        case '5':	            return new boolean[] { false, true, false, true };	        case '6':	            return new boolean[] { false, true, true, false };	        case '7':	            return new boolean[] { false, true, true, true };	        case '8':	            return new boolean[] { true, false, false, false };	        case '9':	            return new boolean[] { true, false, false, true };	        case 'a':	        case 'A':	            return new boolean[] { true, false, true, false };	        case 'b':	        case 'B':	            return new boolean[] { true, false, true, true };	        case 'c':	        case 'C':	            return new boolean[] { true, true, false, false };	        case 'd':	        case 'D':	            return new boolean[] { true, true, false, true };	        case 'e':	        case 'E':	            return new boolean[] { true, true, true, false };	        case 'f':	        case 'F':	            return new boolean[] { true, true, true, true };	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
protected void setArrayEnd(String arrayEnd) {	    if (arrayEnd == null) {	        arrayEnd = "";	    }	    this.arrayEnd = arrayEnd;	}
public static String replaceChars(final String str, final String searchChars, String replaceChars) {	    if (isEmpty(str) || isEmpty(searchChars)) {	        return str;	    }	    if (replaceChars == null) {	        replaceChars = EMPTY;	    }	    boolean modified = false;	    final int replaceCharsLength = replaceChars.length();	    final int strLength = str.length();	    final StringBuilder buf = new StringBuilder(strLength);	    for (int i = 0; i < strLength; i++) {	        final char ch = str.charAt(i);	        final int index = searchChars.indexOf(ch);	        if (index >= 0) {	            modified = true;	            if (index < replaceCharsLength) {	                buf.append(replaceChars.charAt(index));	            }	        } else {	            buf.append(ch);	        }	    }	    if (modified) {	        return buf.toString();	    }	    return str;	}
public String getNewLineText() {	    return newLine;	}
public static Class<?>[] primitivesToWrappers(final Class<?>... classes) {	    if (classes == null) {	        return null;	    }	    if (classes.length == 0) {	        return classes;	    }	    final Class<?>[] convertedClasses = new Class[classes.length];	    for (int i = 0; i < classes.length; i++) {	        convertedClasses[i] = primitiveToWrapper(classes[i]);	    }	    return convertedClasses;	}
public static boolean isNotEmpty(final boolean[] array) {	    return (array != null && array.length != 0);	}
public static int toIntValue(final Character ch, final int defaultValue) {	    if (ch == null) {	        return defaultValue;	    }	    return toIntValue(ch.charValue(), defaultValue);	}
@Override	public T get() throws ConcurrentException {	    try {	        return getFuture().get();	    } catch (final ExecutionException execex) {	        ConcurrentUtils.handleCause(execex);	        return null;	    } catch (final InterruptedException iex) {	        Thread.currentThread().interrupt();	        throw new ConcurrentException(iex);	    }	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    int max = longest;	    if (index + longest > input.length()) {	        max = input.length() - index;	    }	    for (int i = max; i >= shortest; i--) {	        final CharSequence subSeq = input.subSequence(index, index + i);	        final CharSequence result = lookupMap.get(subSeq.toString());	        if (result != null) {	            out.write(result.toString());	            return i;	        }	    }	    return 0;	}
protected boolean isUseClassName() {	    return useClassName;	}
public static boolean isEmpty(final CharSequence cs) {	    return cs == null || cs.length() == 0;	}
public int size() {	    return size;	}
public static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes) {	    if (0 == nBytes) {	        return dst;	    }	    if ((nBytes - 1) * 8 + srcPos >= 32) {	        throw new IllegalArgumentException("(nBytes-1)*8+srcPos is greather or equal to than 32");	    }	    int shift = 0;	    for (int i = 0; i < nBytes; i++) {	        shift = i * 8 + srcPos;	        dst[dstPos + i] = (byte) (0xff & (src >> shift));	    }	    return dst;	}
protected boolean isUseShortClassName() {	    return useShortClassName;	}
public static boolean equalsIgnoreCase(final CharSequence str1, final CharSequence str2) {	    if (str1 == null || str2 == null) {	        return str1 == str2;	    } else if (str1 == str2) {	        return true;	    } else if (str1.length() != str2.length()) {	        return false;	    } else {	        return CharSequenceUtils.regionMatches(str1, true, 0, str2, 0, str1.length());	    }	}
public synchronized int getAvailablePermits() {	    return getLimit() - getAcquireCount();	}
public final Integer getPriority() {	    return priority;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
@Override	public int length() {	    return size;	}
protected boolean isFieldSeparatorAtStart() {	    return fieldSeparatorAtStart;	}
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) {	    final StringBuilder buffer = new StringBuilder();	    boolean lastOutputSeconds = false;	    final int sz = tokens.length;	    for (int i = 0; i < sz; i++) {	        final Token token = tokens[i];	        final Object value = token.getValue();	        final int count = token.getCount();	        if (value instanceof StringBuilder) {	            buffer.append(value.toString());	        } else {	            if (value == y) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years));	                lastOutputSeconds = false;	            } else if (value == M) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months));	                lastOutputSeconds = false;	            } else if (value == d) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days));	                lastOutputSeconds = false;	            } else if (value == H) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours));	                lastOutputSeconds = false;	            } else if (value == m) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes));	                lastOutputSeconds = false;	            } else if (value == s) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds));	                lastOutputSeconds = true;	            } else if (value == S) {	                if (lastOutputSeconds) {	                    milliseconds += 1000;	                    final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds);	                    buffer.append(str.substring(1));	                } else {	                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds));	                }	                lastOutputSeconds = false;	            }	        }	    }	    return buffer.toString();	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
public boolean isEmpty() {	    return size == 0;	}
public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) {	    if (s == null || t == null) {	        throw new IllegalArgumentException("Strings must not be null");	    }	    if (threshold < 0) {	        throw new IllegalArgumentException("Threshold must not be negative");	    }	    int n = s.length();	    int m = t.length();	    if (n == 0) {	        return m <= threshold ? m : -1;	    } else if (m == 0) {	        return n <= threshold ? n : -1;	    }	    if (n > m) {	        final CharSequence tmp = s;	        s = t;	        t = tmp;	        n = m;	        m = t.length();	    }	    int[] p = new int[n + 1];	    int[] d = new int[n + 1];	    int[] _d;	    final int boundary = Math.min(n, threshold) + 1;	    for (int i = 0; i < boundary; i++) {	        p[i] = i;	    }	    Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);	    Arrays.fill(d, Integer.MAX_VALUE);	    for (int j = 1; j <= m; j++) {	        final char t_j = t.charAt(j - 1);	        d[0] = j;	        final int min = Math.max(1, j - threshold);	        final int max = Math.min(n, j + threshold);	        if (min > max) {	            return -1;	        }	        if (min > 1) {	            d[min - 1] = Integer.MAX_VALUE;	        }	        for (int i = min; i <= max; i++) {	            if (s.charAt(i - 1) == t_j) {	                d[i] = p[i - 1];	            } else {	                d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);	            }	        }	        _d = p;	        p = d;	        d = _d;	    }	    if (p[n] <= threshold) {	        return p[n];	    }	    return -1;	}
public static boolean isAlpha(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values) {	    final EnumSet<E> results = EnumSet.noneOf(asEnum(enumClass));	    values = ArrayUtils.clone(Validate.notNull(values));	    ArrayUtils.reverse(values);	    for (final E constant : enumClass.getEnumConstants()) {	        final int block = constant.ordinal() / Long.SIZE;	        if (block < values.length && (values[block] & 1 << (constant.ordinal() % Long.SIZE)) != 0) {	            results.add(constant);	        }	    }	    return results;	}
@Override	public int previousIndex() {	    return tokenPos - 1;	}
public String getNewLineText() {	    return newLine;	}
public boolean isNegated() {	    return negated;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static Integer toIntegerObject(final Boolean bool, final Integer trueValue, final Integer falseValue, final Integer nullValue) {	    if (bool == null) {	        return nullValue;	    }	    return bool.booleanValue() ? trueValue : falseValue;	}
protected void appendContentEnd(final StringBuffer buffer) {	    buffer.append(contentEnd);	}
public static String toString(final Annotation a) {	    final ToStringBuilder builder = new ToStringBuilder(a, TO_STRING_STYLE);	    for (final Method m : a.annotationType().getDeclaredMethods()) {	        if (m.getParameterTypes().length > 0) {	            continue;	        }	        try {	            builder.append(m.getName(), m.invoke(a));	        } catch (final RuntimeException ex) {	            throw ex;	        } catch (final Exception ex) {	            throw new RuntimeException(ex);	        }	    }	    return builder.build();	}
protected boolean isUseClassName() {	    return useClassName;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
protected String getFieldNameValueSeparator() {	    return fieldNameValueSeparator;	}
protected void appendFieldsIn(final Class<?> clazz) {	    if (clazz.isArray()) {	        this.reflectionAppendArray(this.getObject());	        return;	    }	    final Field[] fields = clazz.getDeclaredFields();	    AccessibleObject.setAccessible(fields, true);	    for (final Field field : fields) {	        final String fieldName = field.getName();	        if (this.accept(field)) {	            try {	                final Object fieldValue = this.getValue(field);	                this.append(fieldName, fieldValue);	            } catch (final IllegalAccessException ex) {	                throw new InternalError("Unexpected IllegalAccessException: " + ex.getMessage());	            }	        }	    }	}
public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) {	    String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'");	    if (suppressLeadingZeroElements) {	        duration = " " + duration;	        String tmp = StringUtils.replaceOnce(duration, " 0 days", "");	        if (tmp.length() != duration.length()) {	            duration = tmp;	            tmp = StringUtils.replaceOnce(duration, " 0 hours", "");	            if (tmp.length() != duration.length()) {	                duration = tmp;	                tmp = StringUtils.replaceOnce(duration, " 0 minutes", "");	                duration = tmp;	                if (tmp.length() != duration.length()) {	                    duration = StringUtils.replaceOnce(tmp, " 0 seconds", "");	                }	            }	        }	        if (duration.length() != 0) {	            duration = duration.substring(1);	        }	    }	    if (suppressTrailingZeroElements) {	        String tmp = StringUtils.replaceOnce(duration, " 0 seconds", "");	        if (tmp.length() != duration.length()) {	            duration = tmp;	            tmp = StringUtils.replaceOnce(duration, " 0 minutes", "");	            if (tmp.length() != duration.length()) {	                duration = tmp;	                tmp = StringUtils.replaceOnce(duration, " 0 hours", "");	                if (tmp.length() != duration.length()) {	                    duration = StringUtils.replaceOnce(tmp, " 0 days", "");	                }	            }	        }	    }	    duration = " " + duration;	    duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second");	    duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute");	    duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour");	    duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day");	    return duration.trim();	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public int capacity() {	    return buffer.length;	}
public static String prependIfMissing(final String str, final CharSequence prefix, final CharSequence... prefixes) {	    return prependIfMissing(str, prefix, false, prefixes);	}
protected String getArrayStart() {	    return arrayStart;	}
private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase) {	    if (str == null || prefix == null) {	        return str == null && prefix == null;	    }	    if (prefix.length() > str.length()) {	        return false;	    }	    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());	}
@Override	public DefaultExceptionContext setContextValue(final String label, final Object value) {	    for (final Iterator<Pair<String, Object>> iter = contextValues.iterator(); iter.hasNext(); ) {	        final Pair<String, Object> p = iter.next();	        if (StringUtils.equals(label, p.getKey())) {	            iter.remove();	        }	    }	    addContextValue(label, value);	    return this;	}
public StrBuilder deleteAll(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, -1);	}
public static String right(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(str.length() - len);	}
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return true;	    }	    if (lhs == null || rhs == null) {	        return false;	    }	    final Class<?> lhsClass = lhs.getClass();	    final Class<?> rhsClass = rhs.getClass();	    Class<?> testClass;	    if (lhsClass.isInstance(rhs)) {	        testClass = lhsClass;	        if (!rhsClass.isInstance(lhs)) {	            testClass = rhsClass;	        }	    } else if (rhsClass.isInstance(lhs)) {	        testClass = rhsClass;	        if (!lhsClass.isInstance(rhs)) {	            testClass = lhsClass;	        }	    } else {	        return false;	    }	    final EqualsBuilder equalsBuilder = new EqualsBuilder();	    try {	        reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {	            testClass = testClass.getSuperclass();	            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        }	    } catch (final IllegalArgumentException e) {	        return false;	    }	    return equalsBuilder.isEquals();	}
public static String getRootCauseMessage(final Throwable th) {	    Throwable root = ExceptionUtils.getRootCause(th);	    root = root == null ? th : root;	    return getMessage(root);	}
public String getNullText() {	    return nullText;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, true);	}
public int elementCompareTo(final T element) {	    if (element == null) {	        throw new NullPointerException("Element is null");	    }	    if (isAfter(element)) {	        return -1;	    } else if (isBefore(element)) {	        return 1;	    } else {	        return 0;	    }	}
public static CharSequence subSequence(final CharSequence cs, final int start) {	    return cs == null ? null : cs.subSequence(start, cs.length());	}
public int clear(final int holder) {	    return holder & ~_mask;	}
public static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) {	    if (0 == nBools) {	        return dst;	    }	    if (nBools - 1 + srcPos >= 32) {	        throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 32");	    }	    int shift = 0;	    for (int i = 0; i < nBools; i++) {	        shift = i * 1 + srcPos;	        dst[dstPos + i] = ((0x1 & (src >> shift)) != 0);	    }	    return dst;	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public int lastIndexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex >= size ? size - 1 : startIndex);	    if (matcher == null || startIndex < 0) {	        return -1;	    }	    final char[] buf = buffer;	    final int endIndex = startIndex + 1;	    for (int i = startIndex; i >= 0; i--) {	        if (matcher.isMatch(buf, i, 0, endIndex) > 0) {	            return i;	        }	    }	    return -1;	}
public boolean isEmpty() {	    return size == 0;	}
static boolean isOSNameMatch(final String osName, final String osNamePrefix) {	    if (osName == null) {	        return false;	    }	    return osName.startsWith(osNamePrefix);	}
public static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    final int beSrcPos = src.length - 1 - srcPos;	    final int srcLen = Math.min(4, beSrcPos + 1);	    final boolean[] paddedSrc = new boolean[4];	    System.arraycopy(src, beSrcPos + 1 - srcLen, paddedSrc, 4 - srcLen, srcLen);	    src = paddedSrc;	    srcPos = 0;	    if (src[srcPos]) {	        if (src.length > srcPos + 1 && src[srcPos + 1]) {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 1 && src[srcPos + 1]) {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
public StrBuilder replaceAll(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, -1);	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public String getNewLineText() {	    return newLine;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static String[] splitByCharacterTypeCamelCase(final String str) {	    return splitByCharacterType(str, true);	}
public int capacity() {	    return buffer.length;	}
public char getEscapeChar() {	    return this.escapeChar;	}
@Override	public int length() {	    return size;	}
public static Object invokeStaticMethod(final Class<?> cls, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {	    if (parameterTypes == null) {	        parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;	    }	    if (args == null) {	        args = ArrayUtils.EMPTY_OBJECT_ARRAY;	    }	    final Method method = getMatchingAccessibleMethod(cls, methodName, parameterTypes);	    if (method == null) {	        throw new NoSuchMethodException("No such accessible method: " + methodName + "() on class: " + cls.getName());	    }	    return method.invoke(null, args);	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
@Override	public Byte getValue() {	    return Byte.valueOf(this.value);	}
public static String removeStart(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.startsWith(remove)) {	        return str.substring(remove.length());	    }	    return str;	}
protected void setContentStart(String contentStart) {	    if (contentStart == null) {	        contentStart = "";	    }	    this.contentStart = contentStart;	}
@Override	public String toString() {	    if (toString == null) {	        toString = new StringBuilder(32).append(getNumerator()).append('/').append(getDenominator()).toString();	    }	    return toString;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public boolean isEmpty() {	    return size == 0;	}
public void unsplit() {	    if (this.splitState != STATE_SPLIT) {	        throw new IllegalStateException("Stopwatch has not been split. ");	    }	    this.splitState = STATE_UNSPLIT;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public String leftString(final int length) {	    if (length <= 0) {	        return "";	    } else if (length >= size) {	        return new String(buffer, 0, size);	    } else {	        return new String(buffer, 0, length);	    }	}
@Override	public Boolean getValue() {	    return Boolean.valueOf(this.value);	}
@Override	public int length() {	    return size;	}
public static boolean[] removeElements(final boolean[] array, final boolean... values) {	    if (isEmpty(array) || isEmpty(values)) {	        return clone(array);	    }	    final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2);	    for (final boolean v : values) {	        final Boolean boxed = Boolean.valueOf(v);	        final MutableInt count = occurrences.get(boxed);	        if (count == null) {	            occurrences.put(boxed, new MutableInt(1));	        } else {	            count.increment();	        }	    }	    final BitSet toRemove = new BitSet();	    for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) {	        final Boolean v = e.getKey();	        int found = 0;	        for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {	            found = indexOf(array, v.booleanValue(), found);	            if (found < 0) {	                break;	            }	            toRemove.set(found++);	        }	    }	    return (boolean[]) removeAll(array, toRemove);	}
public char getEnd() {	    return this.end;	}
public TimeUnit getUnit() {	    return unit;	}
@Override	public TimeZone getTimeZone() {	    return timeZone;	}
protected String getSizeEndText() {	    return sizeEndText;	}
public static Number createNumber(final String str) throws NumberFormatException {	    if (str == null) {	        return null;	    }	    if (StringUtils.isBlank(str)) {	        throw new NumberFormatException("A blank string is not a valid number");	    }	    final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" };	    int pfxLen = 0;	    for (final String pfx : hex_prefixes) {	        if (str.startsWith(pfx)) {	            pfxLen += pfx.length();	            break;	        }	    }	    if (pfxLen > 0) {	        final int hexDigits = str.length() - pfxLen;	        if (hexDigits > 16) {	            return createBigInteger(str);	        }	        if (hexDigits > 8) {	            return createLong(str);	        }	        return createInteger(str);	    }	    final char lastChar = str.charAt(str.length() - 1);	    String mant;	    String dec;	    String exp;	    final int decPos = str.indexOf('.');	    final int expPos = str.indexOf('e') + str.indexOf('E') + 1;	    int numDecimals = 0;	    if (decPos > -1) {	        if (expPos > -1) {	            if (expPos < decPos || expPos > str.length()) {	                throw new NumberFormatException(str + " is not a valid number.");	            }	            dec = str.substring(decPos + 1, expPos);	        } else {	            dec = str.substring(decPos + 1);	        }	        mant = str.substring(0, decPos);	        numDecimals = dec.length();	    } else {	        if (expPos > -1) {	            if (expPos > str.length()) {	                throw new NumberFormatException(str + " is not a valid number.");	            }	            mant = str.substring(0, expPos);	        } else {	            mant = str;	        }	        dec = null;	    }	    if (!Character.isDigit(lastChar) && lastChar != '.') {	        if (expPos > -1 && expPos < str.length() - 1) {	            exp = str.substring(expPos + 1, str.length() - 1);	        } else {	            exp = null;	        }	        final String numeric = str.substring(0, str.length() - 1);	        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);	        switch(lastChar) {	            case 'l':	            case 'L':	                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {	                    try {	                        return createLong(numeric);	                    } catch (final NumberFormatException nfe) {	                    }	                    return createBigInteger(numeric);	                }	                throw new NumberFormatException(str + " is not a valid number.");	            case 'f':	            case 'F':	                try {	                    final Float f = NumberUtils.createFloat(numeric);	                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {	                        return f;	                    }	                } catch (final NumberFormatException nfe) {	                }	            case 'd':	            case 'D':	                try {	                    final Double d = NumberUtils.createDouble(numeric);	                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {	                        return d;	                    }	                } catch (final NumberFormatException nfe) {	                }	                try {	                    return createBigDecimal(numeric);	                } catch (final NumberFormatException e) {	                }	            default:	                throw new NumberFormatException(str + " is not a valid number.");	        }	    }	    if (expPos > -1 && expPos < str.length() - 1) {	        exp = str.substring(expPos + 1, str.length());	    } else {	        exp = null;	    }	    if (dec == null && exp == null) {	        try {	            return createInteger(str);	        } catch (final NumberFormatException nfe) {	        }	        try {	            return createLong(str);	        } catch (final NumberFormatException nfe) {	        }	        return createBigInteger(str);	    }	    final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);	    try {	        if (numDecimals <= 7) {	            final Float f = createFloat(str);	            if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {	                return f;	            }	        }	    } catch (final NumberFormatException nfe) {	    }	    try {	        if (numDecimals <= 16) {	            final Double d = createDouble(str);	            if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {	                return d;	            }	        }	    } catch (final NumberFormatException nfe) {	    }	    return createBigDecimal(str);	}
@Override	public void remove() {	    throw new UnsupportedOperationException("remove() is unsupported");	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static <T> Future<T> constantFuture(final T value) {	    return new ConstantFuture<T>(value);	}
@Override	public int length() {	    return size;	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public static boolean startsWithIgnoreCase(final CharSequence str, final CharSequence prefix) {	    return startsWith(str, prefix, true);	}
public int size() {	    return size;	}
protected String getSizeEndText() {	    return sizeEndText;	}
public static String difference(final String str1, final String str2) {	    if (str1 == null) {	        return str2;	    }	    if (str2 == null) {	        return str1;	    }	    final int at = indexOfDifference(str1, str2);	    if (at == INDEX_NOT_FOUND) {	        return EMPTY;	    }	    return str2.substring(at);	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public String toString(final String format) {	    return String.format(format, getLeft(), getMiddle(), getRight());	}
public static JavaUnicodeEscaper outsideOf(final int codepointLow, final int codepointHigh) {	    return new JavaUnicodeEscaper(codepointLow, codepointHigh, false);	}
public static float min(final float a, final float b, final float c) {	    return Math.min(Math.min(a, b), c);	}
public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final E... values) {	    Validate.noNullElements(values);	    return generateBitVector(enumClass, Arrays.<E>asList(values));	}
public static boolean isNotEmpty(final boolean[] array) {	    return (array != null && array.length != 0);	}
protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) {	    if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {	        appendCyclicObject(buffer, fieldName, value);	        return;	    }	    register(value);	    try {	        if (value instanceof Collection<?>) {	            if (detail) {	                appendDetail(buffer, fieldName, (Collection<?>) value);	            } else {	                appendSummarySize(buffer, fieldName, ((Collection<?>) value).size());	            }	        } else if (value instanceof Map<?, ?>) {	            if (detail) {	                appendDetail(buffer, fieldName, (Map<?, ?>) value);	            } else {	                appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());	            }	        } else if (value instanceof long[]) {	            if (detail) {	                appendDetail(buffer, fieldName, (long[]) value);	            } else {	                appendSummary(buffer, fieldName, (long[]) value);	            }	        } else if (value instanceof int[]) {	            if (detail) {	                appendDetail(buffer, fieldName, (int[]) value);	            } else {	                appendSummary(buffer, fieldName, (int[]) value);	            }	        } else if (value instanceof short[]) {	            if (detail) {	                appendDetail(buffer, fieldName, (short[]) value);	            } else {	                appendSummary(buffer, fieldName, (short[]) value);	            }	        } else if (value instanceof byte[]) {	            if (detail) {	                appendDetail(buffer, fieldName, (byte[]) value);	            } else {	                appendSummary(buffer, fieldName, (byte[]) value);	            }	        } else if (value instanceof char[]) {	            if (detail) {	                appendDetail(buffer, fieldName, (char[]) value);	            } else {	                appendSummary(buffer, fieldName, (char[]) value);	            }	        } else if (value instanceof double[]) {	            if (detail) {	                appendDetail(buffer, fieldName, (double[]) value);	            } else {	                appendSummary(buffer, fieldName, (double[]) value);	            }	        } else if (value instanceof float[]) {	            if (detail) {	                appendDetail(buffer, fieldName, (float[]) value);	            } else {	                appendSummary(buffer, fieldName, (float[]) value);	            }	        } else if (value instanceof boolean[]) {	            if (detail) {	                appendDetail(buffer, fieldName, (boolean[]) value);	            } else {	                appendSummary(buffer, fieldName, (boolean[]) value);	            }	        } else if (value.getClass().isArray()) {	            if (detail) {	                appendDetail(buffer, fieldName, (Object[]) value);	            } else {	                appendSummary(buffer, fieldName, (Object[]) value);	            }	        } else {	            if (detail) {	                appendDetail(buffer, fieldName, value);	            } else {	                appendSummary(buffer, fieldName, value);	            }	        }	    } finally {	        unregister(value);	    }	}
public static StrTokenizer getTSVInstance(final char[] input) {	    final StrTokenizer tok = getTSVClone();	    tok.reset(input);	    return tok;	}
@Override	public int compare(final Object obj1, final Object obj2) {	    return ((Comparable) obj1).compareTo(obj2);	}
@Override	public L getLeft() {	    return left;	}
public String rightString(final int length) {	    if (length <= 0) {	        return "";	    } else if (length >= size) {	        return new String(buffer, 0, size);	    } else {	        return new String(buffer, size - length, length);	    }	}
public char getEscapeChar() {	    return this.escapeChar;	}
public static float max(final float a, final float b, final float c) {	    return Math.max(Math.max(a, b), c);	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException {	    return charsetName == null ? new String(bytes) : new String(bytes, charsetName);	}
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException {	    return charsetName == null ? new String(bytes) : new String(bytes, charsetName);	}
public static boolean isAlphaSpace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false && cs.charAt(i) != ' ') {	            return false;	        }	    }	    return true;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public abstract M getMiddle();
public int capacity() {	    return buffer.length;	}
public void addInitializer(final String name, final BackgroundInitializer<?> init) {	    if (name == null) {	        throw new IllegalArgumentException("Name of child initializer must not be null!");	    }	    if (init == null) {	        throw new IllegalArgumentException("Child initializer must not be null!");	    }	    synchronized (this) {	        if (isStarted()) {	            throw new IllegalStateException("addInitializer() must not be called after start()!");	        }	        childInitializers.put(name, init);	    }	}
protected boolean isDefaultFullDetail() {	    return defaultFullDetail;	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
@Override	public void flush() {	}
public boolean isEquals() {	    return this.isEquals;	}
public static String formatDuration(long durationMillis, final String format, final boolean padWithZeros) {	    final Token[] tokens = lexx(format);	    int days = 0;	    int hours = 0;	    int minutes = 0;	    int seconds = 0;	    int milliseconds = 0;	    if (Token.containsTokenWithValue(tokens, d)) {	        days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY);	        durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY);	    }	    if (Token.containsTokenWithValue(tokens, H)) {	        hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR);	        durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR);	    }	    if (Token.containsTokenWithValue(tokens, m)) {	        minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE);	        durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE);	    }	    if (Token.containsTokenWithValue(tokens, s)) {	        seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND);	        durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND);	    }	    if (Token.containsTokenWithValue(tokens, S)) {	        milliseconds = (int) durationMillis;	    }	    return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
public static String difference(final String str1, final String str2) {	    if (str1 == null) {	        return str2;	    }	    if (str2 == null) {	        return str1;	    }	    final int at = indexOfDifference(str1, str2);	    if (at == INDEX_NOT_FOUND) {	        return EMPTY;	    }	    return str2.substring(at);	}
private static Date add(final Date date, final int calendarField, final int amount) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final Calendar c = Calendar.getInstance();	    c.setTime(date);	    c.add(calendarField, amount);	    return c.getTime();	}
public boolean isAppendStatics() {	    return this.appendStatics;	}
public static Boolean[] toObject(final boolean[] array) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    final Boolean[] result = new Boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        result[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE);	    }	    return result;	}
@Override	public int length() {	    return size;	}
protected void setContentStart(String contentStart) {	    if (contentStart == null) {	        contentStart = "";	    }	    this.contentStart = contentStart;	}
public static String removePattern(final String source, final String regex) {	    return replacePattern(source, regex, StringUtils.EMPTY);	}
public static String center(String str, final int size, String padStr) {	    if (str == null || size <= 0) {	        return str;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    str = leftPad(str, strLen + pads / 2, padStr);	    str = rightPad(str, size, padStr);	    return str;	}
public int size() {	    return size;	}
public static String repeat(final char ch, final int repeat) {	    final char[] buf = new char[repeat];	    for (int i = repeat - 1; i >= 0; i--) {	        buf[i] = ch;	    }	    return new String(buf);	}
public static Class<?> getClass(final String className, final boolean initialize) throws ClassNotFoundException {	    final ClassLoader contextCL = Thread.currentThread().getContextClassLoader();	    final ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL;	    return getClass(loader, className, initialize);	}
public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) {	    if (it != null) {	        separator = ObjectUtils.toString(separator);	        while (it.hasNext()) {	            append(it.next());	            if (it.hasNext()) {	                append(separator);	            }	        }	    }	    return this;	}
void increment() {	    count++;	}
public static String[] splitByWholeSeparatorPreserveAllTokens(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, true);	}
@Override	public T getValue() {	    return this.value;	}
public String getNullText() {	    return nullText;	}
protected boolean isUseShortClassName() {	    return useShortClassName;	}
public boolean isEmpty() {	    return size == 0;	}
public StrBuilder deleteAll(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, -1);	}
public String getNewLineText() {	    return newLine;	}
public static Fraction getReducedFraction(int numerator, int denominator) {	    if (denominator == 0) {	        throw new ArithmeticException("The denominator must not be zero");	    }	    if (numerator == 0) {	        return ZERO;	    }	    if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) {	        numerator /= 2;	        denominator /= 2;	    }	    if (denominator < 0) {	        if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {	            throw new ArithmeticException("overflow: can't negate");	        }	        numerator = -numerator;	        denominator = -denominator;	    }	    final int gcd = greatestCommonDivisor(numerator, denominator);	    numerator /= gcd;	    denominator /= gcd;	    return new Fraction(numerator, denominator);	}
public static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes) {	    if ((src.length == 0 && srcPos == 0) || 0 == nBytes) {	        return dstInit;	    }	    if ((nBytes - 1) * 8 + dstPos >= 16) {	        throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 16");	    }	    short out = dstInit;	    int shift = 0;	    for (int i = 0; i < nBytes; i++) {	        shift = i * 8 + dstPos;	        final int bits = (0xff & src[i + srcPos]) << shift;	        final int mask = 0xff << shift;	        out = (short) ((out & ~mask) | bits);	    }	    return out;	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
@Override	protected List<String> tokenize(final char[] chars, final int offset, final int count) {	    if (chars == null) {	        return super.tokenize(StrBuilder.this.buffer, 0, StrBuilder.this.size());	    }	    return super.tokenize(chars, offset, count);	}
public void suspend() {	    if (this.runningState != STATE_RUNNING) {	        throw new IllegalStateException("Stopwatch must be running to suspend. ");	    }	    this.stopTime = System.nanoTime();	    this.runningState = STATE_SUSPENDED;	}
@Override	public Date parse(final String source, final ParsePosition pos) {	    final int offset = pos.getIndex();	    final Matcher matcher = parsePattern.matcher(source.substring(offset));	    if (!matcher.lookingAt()) {	        return null;	    }	    final Calendar cal = Calendar.getInstance(timeZone, locale);	    cal.clear();	    for (int i = 0; i < strategies.length; ) {	        final Strategy strategy = strategies[i++];	        strategy.setCalendar(this, cal, matcher.group(i));	    }	    pos.setIndex(offset + matcher.end());	    return cal.getTime();	}
public static <T> Range<T> is(final T element, final Comparator<T> comparator) {	    return between(element, element, comparator);	}
public boolean isEmpty() {	    return size == 0;	}
public static boolean isNumeric(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isDigit(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public void stop() {	    if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {	        throw new IllegalStateException("Stopwatch is not running. ");	    }	    if (this.runningState == STATE_RUNNING) {	        this.stopTime = System.nanoTime();	    }	    this.runningState = STATE_STOPPED;	}
public static <T> T deserialize(final byte[] objectData) {	    if (objectData == null) {	        throw new IllegalArgumentException("The byte[] must not be null");	    }	    return SerializationUtils.<T>deserialize(new ByteArrayInputStream(objectData));	}
public synchronized int getAcquireCount() {	    return acquireCount;	}
@Override	public String next() {	    if (hasNext()) {	        return tokens[tokenPos++];	    }	    throw new NoSuchElementException();	}
public static CharRange isNot(final char ch) {	    return new CharRange(ch, ch, true);	}
public StrSubstitutor setVariableSuffix(final String suffix) {	    if (suffix == null) {	        throw new IllegalArgumentException("Variable suffix must not be null!");	    }	    return setVariableSuffixMatcher(StrMatcher.stringMatcher(suffix));	}
public int toComparison() {	    return comparison;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
@Override	public int length() {	    return size;	}
public StrTokenizer setDelimiterChar(final char delim) {	    return setDelimiterMatcher(StrMatcher.charMatcher(delim));	}
public String getNewLineText() {	    return newLine;	}
public int toComparison() {	    return comparison;	}
@Override	public boolean markSupported() {	    return true;	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
@Override	public TimeZone getTimeZone() {	    return mTimeZone;	}
private static Date add(final Date date, final int calendarField, final int amount) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final Calendar c = Calendar.getInstance();	    c.setTime(date);	    c.add(calendarField, amount);	    return c.getTime();	}
public static boolean endsWithIgnoreCase(final CharSequence str, final CharSequence suffix) {	    return endsWith(str, suffix, true);	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
protected boolean isDefaultFullDetail() {	    return defaultFullDetail;	}
public static boolean isAsciiPrintable(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
@Override	public int length() {	    return size;	}
public static String random(final int count, final char... chars) {	    if (chars == null) {	        return random(count, 0, 0, false, false, null, RANDOM);	    }	    return random(count, 0, chars.length, false, false, chars, RANDOM);	}
protected String getSummaryObjectEndText() {	    return summaryObjectEndText;	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    int max = longest;	    if (index + longest > input.length()) {	        max = input.length() - index;	    }	    for (int i = max; i >= shortest; i--) {	        final CharSequence subSeq = input.subSequence(index, index + i);	        final CharSequence result = lookupMap.get(subSeq.toString());	        if (result != null) {	            out.write(result.toString());	            return i;	        }	    }	    return 0;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof MutableByte) {	        return value == ((MutableByte) obj).byteValue();	    }	    return false;	}
public static String formatPeriodISO(final long startMillis, final long endMillis) {	    return formatPeriod(startMillis, endMillis, ISO_EXTENDED_FORMAT_PATTERN, false, TimeZone.getDefault());	}
public static <T> void inclusiveBetween(final T start, final T end, final Comparable<T> value, final String message, final Object... values) {	    if (value.compareTo(start) < 0 || value.compareTo(end) > 0) {	        throw new IllegalArgumentException(String.format(message, values));	    }	}
public static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts) {	    if ((src.length == 0 && srcPos == 0) || 0 == nShorts) {	        return dstInit;	    }	    if ((nShorts - 1) * 16 + dstPos >= 64) {	        throw new IllegalArgumentException("(nShorts-1)*16+dstPos is greather or equal to than 64");	    }	    long out = dstInit;	    int shift = 0;	    for (int i = 0; i < nShorts; i++) {	        shift = i * 16 + dstPos;	        final long bits = (0xffffL & src[i + srcPos]) << shift;	        final long mask = 0xffffL << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
@Override	public String next() {	    if (hasNext()) {	        return tokens[tokenPos++];	    }	    throw new NoSuchElementException();	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static ConcurrentException extractCause(final ExecutionException ex) {	    if (ex == null || ex.getCause() == null) {	        return null;	    }	    throwCause(ex);	    return new ConcurrentException(ex.getMessage(), ex.getCause());	}
@Override	public int length() {	    return size;	}
@Override	public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) {	    return formatter.format(obj, toAppendTo, pos);	}
public static <T> T initializeUnchecked(final ConcurrentInitializer<T> initializer) {	    try {	        return initialize(initializer);	    } catch (final ConcurrentException cex) {	        throw new ConcurrentRuntimeException(cex.getCause());	    }	}
public static String substringBetween(final String str, final String open, final String close) {	    if (str == null || open == null || close == null) {	        return null;	    }	    final int start = str.indexOf(open);	    if (start != INDEX_NOT_FOUND) {	        final int end = str.indexOf(close, start + open.length());	        if (end != INDEX_NOT_FOUND) {	            return str.substring(start + open.length(), end);	        }	    }	    return null;	}
@Override	public double doubleValue() {	    return value;	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static int indexOfDifference(final CharSequence... css) {	    if (css == null || css.length <= 1) {	        return INDEX_NOT_FOUND;	    }	    boolean anyStringNull = false;	    boolean allStringsNull = true;	    final int arrayLen = css.length;	    int shortestStrLen = Integer.MAX_VALUE;	    int longestStrLen = 0;	    for (int i = 0; i < arrayLen; i++) {	        if (css[i] == null) {	            anyStringNull = true;	            shortestStrLen = 0;	        } else {	            allStringsNull = false;	            shortestStrLen = Math.min(css[i].length(), shortestStrLen);	            longestStrLen = Math.max(css[i].length(), longestStrLen);	        }	    }	    if (allStringsNull || longestStrLen == 0 && !anyStringNull) {	        return INDEX_NOT_FOUND;	    }	    if (shortestStrLen == 0) {	        return 0;	    }	    int firstDiff = -1;	    for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {	        final char comparisonChar = css[0].charAt(stringPos);	        for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {	            if (css[arrayPos].charAt(stringPos) != comparisonChar) {	                firstDiff = stringPos;	                break;	            }	        }	        if (firstDiff != -1) {	            break;	        }	    }	    if (firstDiff == -1 && shortestStrLen != longestStrLen) {	        return shortestStrLen;	    }	    return firstDiff;	}
public String getNewLineText() {	    return newLine;	}
protected boolean isUseShortClassName() {	    return useShortClassName;	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return true;	    }	    if (lhs == null || rhs == null) {	        return false;	    }	    final Class<?> lhsClass = lhs.getClass();	    final Class<?> rhsClass = rhs.getClass();	    Class<?> testClass;	    if (lhsClass.isInstance(rhs)) {	        testClass = lhsClass;	        if (!rhsClass.isInstance(lhs)) {	            testClass = rhsClass;	        }	    } else if (rhsClass.isInstance(lhs)) {	        testClass = rhsClass;	        if (!lhsClass.isInstance(rhs)) {	            testClass = lhsClass;	        }	    } else {	        return false;	    }	    final EqualsBuilder equalsBuilder = new EqualsBuilder();	    try {	        reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {	            testClass = testClass.getSuperclass();	            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        }	    } catch (final IllegalArgumentException e) {	        return false;	    }	    return equalsBuilder.isEquals();	}
public Writer asWriter() {	    return new StrBuilderWriter();	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
protected String getSizeEndText() {	    return sizeEndText;	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static <T extends CharSequence> T notEmpty(final T chars) {	    return notEmpty(chars, DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE);	}
public static float toFloat(final String str, final float defaultValue) {	    if (str == null) {	        return defaultValue;	    }	    try {	        return Float.parseFloat(str);	    } catch (final NumberFormatException nfe) {	        return defaultValue;	    }	}
public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) {	    if (toClass == null) {	        return false;	    }	    if (cls == null) {	        return !toClass.isPrimitive();	    }	    if (autoboxing) {	        if (cls.isPrimitive() && !toClass.isPrimitive()) {	            cls = primitiveToWrapper(cls);	            if (cls == null) {	                return false;	            }	        }	        if (toClass.isPrimitive() && !cls.isPrimitive()) {	            cls = wrapperToPrimitive(cls);	            if (cls == null) {	                return false;	            }	        }	    }	    if (cls.equals(toClass)) {	        return true;	    }	    if (cls.isPrimitive()) {	        if (toClass.isPrimitive() == false) {	            return false;	        }	        if (Integer.TYPE.equals(cls)) {	            return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Long.TYPE.equals(cls)) {	            return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Boolean.TYPE.equals(cls)) {	            return false;	        }	        if (Double.TYPE.equals(cls)) {	            return false;	        }	        if (Float.TYPE.equals(cls)) {	            return Double.TYPE.equals(toClass);	        }	        if (Character.TYPE.equals(cls)) {	            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Short.TYPE.equals(cls)) {	            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Byte.TYPE.equals(cls)) {	            return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        return false;	    }	    return toClass.isAssignableFrom(cls);	}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    buffer.append(arrayStart);	    for (int i = 0; i < array.length; i++) {	        if (i > 0) {	            buffer.append(arraySeparator);	        }	        appendDetail(buffer, fieldName, array[i]);	    }	    buffer.append(arrayEnd);	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static String formatDurationISO(final long durationMillis) {	    return formatDuration(durationMillis, ISO_EXTENDED_FORMAT_PATTERN, false);	}
public static Date truncate(final Object date, final int field) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (date instanceof Date) {	        return truncate((Date) date, field);	    } else if (date instanceof Calendar) {	        return truncate((Calendar) date, field).getTime();	    } else {	        throw new ClassCastException("Could not truncate " + date);	    }	}
protected boolean isArrayContentDetail() {	    return arrayContentDetail;	}
@Override	public T call() throws Exception {	    try {	        return initialize();	    } finally {	        if (execFinally != null) {	            execFinally.shutdown();	        }	    }	}
public String getNewLineText() {	    return newLine;	}
public static String getPackageName(String className) {	    if (StringUtils.isEmpty(className)) {	        return StringUtils.EMPTY;	    }	    while (className.charAt(0) == '[') {	        className = className.substring(1);	    }	    if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {	        className = className.substring(1);	    }	    final int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);	    if (i == -1) {	        return StringUtils.EMPTY;	    }	    return className.substring(0, i);	}
public boolean contains(final StrMatcher matcher) {	    return indexOf(matcher, 0) >= 0;	}
@Override	public R getRight() {	    return right;	}
public static String difference(final String str1, final String str2) {	    if (str1 == null) {	        return str2;	    }	    if (str2 == null) {	        return str1;	    }	    final int at = indexOfDifference(str1, str2);	    if (at == INDEX_NOT_FOUND) {	        return EMPTY;	    }	    return str2.substring(at);	}
protected String getArrayEnd() {	    return arrayEnd;	}
public static float max(final float a, final float b, final float c) {	    return Math.max(Math.max(a, b), c);	}
public String getNewLineText() {	    return newLine;	}
public long getStartTime() {	    if (this.runningState == STATE_UNSTARTED) {	        throw new IllegalStateException("Stopwatch has not been started");	    }	    return this.startTimeMillis;	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
protected boolean isUseClassName() {	    return useClassName;	}
public static String lowerCase(final String str, final Locale locale) {	    if (str == null) {	        return null;	    }	    return str.toLowerCase(locale);	}
public boolean isEmpty() {	    return size == 0;	}
public static boolean isSupported(final String name) {	    if (name == null) {	        return false;	    }	    try {	        return Charset.isSupported(name);	    } catch (final IllegalCharsetNameException ex) {	        return false;	    }	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
static int indexOf(final CharSequence cs, final CharSequence searchChar, final int start) {	    return cs.toString().indexOf(searchChar.toString(), start);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static String capitalize(final String str) {	    int strLen;	    if (str == null || (strLen = str.length()) == 0) {	        return str;	    }	    char firstChar = str.charAt(0);	    if (Character.isTitleCase(firstChar)) {	        return str;	    }	    return new StringBuilder(strLen).append(Character.toTitleCase(firstChar)).append(str.substring(1)).toString();	}
public static Date addMilliseconds(final Date date, final int amount) {	    return add(date, Calendar.MILLISECOND, amount);	}
public static String right(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(str.length() - len);	}
protected String getFieldNameValueSeparator() {	    return fieldNameValueSeparator;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
protected String getSizeEndText() {	    return sizeEndText;	}
@Override	public T call() throws Exception {	    try {	        return initialize();	    } finally {	        if (execFinally != null) {	            execFinally.shutdown();	        }	    }	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
public static boolean[] clone(final boolean[] array) {	    if (array == null) {	        return null;	    }	    return array.clone();	}
public static String wrap(final String str, int wrapLength, String newLineStr, final boolean wrapLongWords) {	    if (str == null) {	        return null;	    }	    if (newLineStr == null) {	        newLineStr = SystemUtils.LINE_SEPARATOR;	    }	    if (wrapLength < 1) {	        wrapLength = 1;	    }	    final int inputLineLength = str.length();	    int offset = 0;	    final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32);	    while (inputLineLength - offset > wrapLength) {	        if (str.charAt(offset) == ' ') {	            offset++;	            continue;	        }	        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);	        if (spaceToWrapAt >= offset) {	            wrappedLine.append(str.substring(offset, spaceToWrapAt));	            wrappedLine.append(newLineStr);	            offset = spaceToWrapAt + 1;	        } else {	            if (wrapLongWords) {	                wrappedLine.append(str.substring(offset, wrapLength + offset));	                wrappedLine.append(newLineStr);	                offset += wrapLength;	            } else {	                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);	                if (spaceToWrapAt >= 0) {	                    wrappedLine.append(str.substring(offset, spaceToWrapAt));	                    wrappedLine.append(newLineStr);	                    offset = spaceToWrapAt + 1;	                } else {	                    wrappedLine.append(str.substring(offset));	                    offset = inputLineLength;	                }	            }	        }	    }	    wrappedLine.append(str.substring(offset));	    return wrappedLine.toString();	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
public StrBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar) {	    return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public void getChars(final int startIndex, final int endIndex, final char[] destination, final int destinationIndex) {	    if (startIndex < 0) {	        throw new StringIndexOutOfBoundsException(startIndex);	    }	    if (endIndex < 0 || endIndex > length()) {	        throw new StringIndexOutOfBoundsException(endIndex);	    }	    if (startIndex > endIndex) {	        throw new StringIndexOutOfBoundsException("end < start");	    }	    System.arraycopy(buffer, startIndex, destination, destinationIndex, endIndex - startIndex);	}
@Override	public int length() {	    return size;	}
protected String getNullText() {	    return nullText;	}
@Override	public double doubleValue() {	    return value;	}
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, true);	}
public static <T> Range<T> is(final T element, final Comparator<T> comparator) {	    return between(element, element, comparator);	}
public static String lowerCase(final String str, final Locale locale) {	    if (str == null) {	        return null;	    }	    return str.toLowerCase(locale);	}
public static boolean isAlpha(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
@Override	public char charAt(final int index) {	    if (index < 0 || index >= length()) {	        throw new StringIndexOutOfBoundsException(index);	    }	    return buffer[index];	}
public String[] getExcludeFieldNames() {	    return this.excludeFieldNames.clone();	}
public static boolean containsOnly(final CharSequence cs, final String validChars) {	    if (cs == null || validChars == null) {	        return false;	    }	    return containsOnly(cs, validChars.toCharArray());	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
@Override	public int length() {	    return size;	}
public static <T extends Iterable<?>> T noNullElements(final T iterable) {	    return noNullElements(iterable, DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE);	}
public int toComparison() {	    return comparison;	}
public void start() {	    if (this.runningState == STATE_STOPPED) {	        throw new IllegalStateException("Stopwatch must be reset before being restarted. ");	    }	    if (this.runningState != STATE_UNSTARTED) {	        throw new IllegalStateException("Stopwatch already started. ");	    }	    this.startTime = System.nanoTime();	    this.startTimeMillis = System.currentTimeMillis();	    this.runningState = STATE_RUNNING;	}
public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale) {	    return cache.getInstance(pattern, timeZone, locale);	}
protected abstract T initialize() throws Exception;
public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) {	    final Token[] tokens = lexx(format);	    final Calendar start = Calendar.getInstance(timezone);	    start.setTime(new Date(startMillis));	    final Calendar end = Calendar.getInstance(timezone);	    end.setTime(new Date(endMillis));	    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);	    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);	    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);	    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);	    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);	    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);	    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);	    while (milliseconds < 0) {	        milliseconds += 1000;	        seconds -= 1;	    }	    while (seconds < 0) {	        seconds += 60;	        minutes -= 1;	    }	    while (minutes < 0) {	        minutes += 60;	        hours -= 1;	    }	    while (hours < 0) {	        hours += 24;	        days -= 1;	    }	    if (Token.containsTokenWithValue(tokens, M)) {	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	        while (months < 0) {	            months += 12;	            years -= 1;	        }	        if (!Token.containsTokenWithValue(tokens, y) && years != 0) {	            while (years != 0) {	                months += 12 * years;	                years = 0;	            }	        }	    } else {	        if (!Token.containsTokenWithValue(tokens, y)) {	            int target = end.get(Calendar.YEAR);	            if (months < 0) {	                target -= 1;	            }	            while (start.get(Calendar.YEAR) != target) {	                days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);	                if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) {	                    days += 1;	                }	                start.add(Calendar.YEAR, 1);	                days += start.get(Calendar.DAY_OF_YEAR);	            }	            years = 0;	        }	        while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            start.add(Calendar.MONTH, 1);	        }	        months = 0;	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	    }	    if (!Token.containsTokenWithValue(tokens, d)) {	        hours += 24 * days;	        days = 0;	    }	    if (!Token.containsTokenWithValue(tokens, H)) {	        minutes += 60 * hours;	        hours = 0;	    }	    if (!Token.containsTokenWithValue(tokens, m)) {	        seconds += 60 * minutes;	        minutes = 0;	    }	    if (!Token.containsTokenWithValue(tokens, s)) {	        milliseconds += 1000 * seconds;	        seconds = 0;	    }	    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
public int size() {	    return size;	}
public char getEnd() {	    return this.end;	}
public StrTokenizer reset(final char[] input) {	    reset();	    this.chars = ArrayUtils.clone(input);	    return this;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static String uncapitalize(final String str) {	    int strLen;	    if (str == null || (strLen = str.length()) == 0) {	        return str;	    }	    char firstChar = str.charAt(0);	    if (Character.isLowerCase(firstChar)) {	        return str;	    }	    return new StringBuilder(strLen).append(Character.toLowerCase(firstChar)).append(str.substring(1)).toString();	}
public static String abbreviate(final String str, int offset, final int maxWidth) {	    if (str == null) {	        return null;	    }	    if (maxWidth < 4) {	        throw new IllegalArgumentException("Minimum abbreviation width is 4");	    }	    if (str.length() <= maxWidth) {	        return str;	    }	    if (offset > str.length()) {	        offset = str.length();	    }	    if (str.length() - offset < maxWidth - 3) {	        offset = str.length() - (maxWidth - 3);	    }	    final String abrevMarker = "...";	    if (offset <= 4) {	        return str.substring(0, maxWidth - 3) + abrevMarker;	    }	    if (maxWidth < 7) {	        throw new IllegalArgumentException("Minimum abbreviation width with offset is 7");	    }	    if (offset + maxWidth - 3 < str.length()) {	        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);	    }	    return abrevMarker + str.substring(str.length() - (maxWidth - 3));	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
@Override	public BasicThreadFactory build() {	    final BasicThreadFactory factory = new BasicThreadFactory(this);	    reset();	    return factory;	}
public int getNumerator() {	    return numerator;	}
public StrBuilder appendPadding(final int length, final char padChar) {	    if (length >= 0) {	        ensureCapacity(size + length);	        for (int i = 0; i < length; i++) {	            buffer[size++] = padChar;	        }	    }	    return this;	}
static Throwable checkedException(final Throwable ex) {	    if (ex != null && !(ex instanceof RuntimeException) && !(ex instanceof Error)) {	        return ex;	    } else {	        throw new IllegalArgumentException("Not a checked exception: " + ex);	    }	}
public static String substringAfter(final String str, final String separator) {	    if (isEmpty(str)) {	        return str;	    }	    if (separator == null) {	        return EMPTY;	    }	    final int pos = str.indexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return EMPTY;	    }	    return str.substring(pos + separator.length());	}
public static String getShortCanonicalName(final String canonicalName) {	    return ClassUtils.getShortClassName(getCanonicalName(canonicalName));	}
public static <L> void bindEventsToMethod(final Object target, final String methodName, final Object eventSource, final Class<L> listenerType, final String... eventTypes) {	    final L listener = listenerType.cast(Proxy.newProxyInstance(target.getClass().getClassLoader(), new Class[] { listenerType }, new EventBindingInvocationHandler(target, methodName, eventTypes)));	    addEventListener(eventSource, listenerType, listener);	}
public StrBuilder setNullText(String nullText) {	    if (nullText != null && nullText.isEmpty()) {	        nullText = null;	    }	    this.nullText = nullText;	    return this;	}
public static String replaceOnce(final String text, final String searchString, final String replacement) {	    return replace(text, searchString, replacement, 1);	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
public StrBuilder appendNull() {	    if (nullText == null) {	        return this;	    }	    return append(nullText);	}
public static String reverse(final String str) {	    if (str == null) {	        return null;	    }	    return new StringBuilder(str).reverse().toString();	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static Integer toIntegerObject(final Boolean bool, final Integer trueValue, final Integer falseValue, final Integer nullValue) {	    if (bool == null) {	        return nullValue;	    }	    return bool.booleanValue() ? trueValue : falseValue;	}
public StrBuilder replaceAll(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, -1);	}
@Override	public int length() {	    return size;	}
public byte setByteBoolean(final byte holder, final boolean flag) {	    return flag ? setByte(holder) : clearByte(holder);	}
public static Boolean[] toObject(final boolean[] array) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    final Boolean[] result = new Boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        result[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE);	    }	    return result;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public String getNullText() {	    return nullText;	}
public boolean isEmpty() {	    return size == 0;	}
public String getNewLineText() {	    return newLine;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
@Override	public String toString() {	    return value == null ? "null" : value.toString();	}
@Override	public TimeZone getTimeZone() {	    return timeZone;	}
protected String getSummaryObjectStartText() {	    return summaryObjectStartText;	}
@Deprecated	public static String chomp(final String str, final String separator) {	    return removeEnd(str, separator);	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) {	    if (str == null) {	        if (trueString == null) {	            return Boolean.TRUE;	        }	        if (falseString == null) {	            return Boolean.FALSE;	        }	        if (nullString == null) {	            return null;	        }	    } else if (str.equals(trueString)) {	        return Boolean.TRUE;	    } else if (str.equals(falseString)) {	        return Boolean.FALSE;	    } else if (str.equals(nullString)) {	        return null;	    }	    throw new IllegalArgumentException("The String did not match any specified value");	}
static boolean isOSMatch(final String osName, final String osVersion, final String osNamePrefix, final String osVersionPrefix) {	    if (osName == null || osVersion == null) {	        return false;	    }	    return osName.startsWith(osNamePrefix) && osVersion.startsWith(osVersionPrefix);	}
public int capacity() {	    return buffer.length;	}
public Fraction subtract(final Fraction fraction) {	    return addSub(fraction, false);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) {	    if (str == null) {	        if (trueString == null) {	            return Boolean.TRUE;	        }	        if (falseString == null) {	            return Boolean.FALSE;	        }	        if (nullString == null) {	            return null;	        }	    } else if (str.equals(trueString)) {	        return Boolean.TRUE;	    } else if (str.equals(falseString)) {	        return Boolean.FALSE;	    } else if (str.equals(nullString)) {	        return null;	    }	    throw new IllegalArgumentException("The String did not match any specified value");	}
public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale) {	    return cache.getTimeInstance(style, timeZone, locale);	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) {	    if (it != null) {	        separator = ObjectUtils.toString(separator);	        while (it.hasNext()) {	            append(it.next());	            if (it.hasNext()) {	                append(separator);	            }	        }	    }	    return this;	}
public static CharRange is(final char ch) {	    return new CharRange(ch, ch, false);	}
public int lastIndexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex >= size ? size - 1 : startIndex);	    if (matcher == null || startIndex < 0) {	        return -1;	    }	    final char[] buf = buffer;	    final int endIndex = startIndex + 1;	    for (int i = startIndex; i >= 0; i--) {	        if (matcher.isMatch(buf, i, 0, endIndex) > 0) {	            return i;	        }	    }	    return -1;	}
public char getEscapeChar() {	    return this.escapeChar;	}
public void start() {	    if (this.runningState == STATE_STOPPED) {	        throw new IllegalStateException("Stopwatch must be reset before being restarted. ");	    }	    if (this.runningState != STATE_UNSTARTED) {	        throw new IllegalStateException("Stopwatch already started. ");	    }	    this.startTime = System.nanoTime();	    this.startTimeMillis = System.currentTimeMillis();	    this.runningState = STATE_RUNNING;	}
public static boolean isAscii(final char ch) {	    return ch < 128;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
@Override	public void setValue(final Number value) {	    this.value = value.floatValue();	}
@Override	public StringBuffer format(final Calendar calendar, final StringBuffer buf) {	    return printer.format(calendar, buf);	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public static String removeStart(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.startsWith(remove)) {	        return str.substring(remove.length());	    }	    return str;	}
public StrBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar) {	    return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public String getNewLineText() {	    return newLine;	}
public static boolean isNotEmpty(final boolean[] array) {	    return (array != null && array.length != 0);	}
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return true;	    }	    if (lhs == null || rhs == null) {	        return false;	    }	    final Class<?> lhsClass = lhs.getClass();	    final Class<?> rhsClass = rhs.getClass();	    Class<?> testClass;	    if (lhsClass.isInstance(rhs)) {	        testClass = lhsClass;	        if (!rhsClass.isInstance(lhs)) {	            testClass = rhsClass;	        }	    } else if (rhsClass.isInstance(lhs)) {	        testClass = rhsClass;	        if (!lhsClass.isInstance(rhs)) {	            testClass = lhsClass;	        }	    } else {	        return false;	    }	    final EqualsBuilder equalsBuilder = new EqualsBuilder();	    try {	        reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {	            testClass = testClass.getSuperclass();	            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        }	    } catch (final IllegalArgumentException e) {	        return false;	    }	    return equalsBuilder.isEquals();	}
public static CharRange isNotIn(final char start, final char end) {	    return new CharRange(start, end, true);	}
public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale) {	    return cache.getDateTimeInstance(dateStyle, timeStyle, timeZone, locale);	}
public boolean isNegated() {	    return negated;	}
public int capacity() {	    return buffer.length;	}
public static Number createNumber(final String str) throws NumberFormatException {	    if (str == null) {	        return null;	    }	    if (StringUtils.isBlank(str)) {	        throw new NumberFormatException("A blank string is not a valid number");	    }	    final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" };	    int pfxLen = 0;	    for (final String pfx : hex_prefixes) {	        if (str.startsWith(pfx)) {	            pfxLen += pfx.length();	            break;	        }	    }	    if (pfxLen > 0) {	        final int hexDigits = str.length() - pfxLen;	        if (hexDigits > 16) {	            return createBigInteger(str);	        }	        if (hexDigits > 8) {	            return createLong(str);	        }	        return createInteger(str);	    }	    final char lastChar = str.charAt(str.length() - 1);	    String mant;	    String dec;	    String exp;	    final int decPos = str.indexOf('.');	    final int expPos = str.indexOf('e') + str.indexOf('E') + 1;	    int numDecimals = 0;	    if (decPos > -1) {	        if (expPos > -1) {	            if (expPos < decPos || expPos > str.length()) {	                throw new NumberFormatException(str + " is not a valid number.");	            }	            dec = str.substring(decPos + 1, expPos);	        } else {	            dec = str.substring(decPos + 1);	        }	        mant = str.substring(0, decPos);	        numDecimals = dec.length();	    } else {	        if (expPos > -1) {	            if (expPos > str.length()) {	                throw new NumberFormatException(str + " is not a valid number.");	            }	            mant = str.substring(0, expPos);	        } else {	            mant = str;	        }	        dec = null;	    }	    if (!Character.isDigit(lastChar) && lastChar != '.') {	        if (expPos > -1 && expPos < str.length() - 1) {	            exp = str.substring(expPos + 1, str.length() - 1);	        } else {	            exp = null;	        }	        final String numeric = str.substring(0, str.length() - 1);	        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);	        switch(lastChar) {	            case 'l':	            case 'L':	                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {	                    try {	                        return createLong(numeric);	                    } catch (final NumberFormatException nfe) {	                    }	                    return createBigInteger(numeric);	                }	                throw new NumberFormatException(str + " is not a valid number.");	            case 'f':	            case 'F':	                try {	                    final Float f = NumberUtils.createFloat(numeric);	                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {	                        return f;	                    }	                } catch (final NumberFormatException nfe) {	                }	            case 'd':	            case 'D':	                try {	                    final Double d = NumberUtils.createDouble(numeric);	                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {	                        return d;	                    }	                } catch (final NumberFormatException nfe) {	                }	                try {	                    return createBigDecimal(numeric);	                } catch (final NumberFormatException e) {	                }	            default:	                throw new NumberFormatException(str + " is not a valid number.");	        }	    }	    if (expPos > -1 && expPos < str.length() - 1) {	        exp = str.substring(expPos + 1, str.length());	    } else {	        exp = null;	    }	    if (dec == null && exp == null) {	        try {	            return createInteger(str);	        } catch (final NumberFormatException nfe) {	        }	        try {	            return createLong(str);	        } catch (final NumberFormatException nfe) {	        }	        return createBigInteger(str);	    }	    final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);	    try {	        if (numDecimals <= 7) {	            final Float f = createFloat(str);	            if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {	                return f;	            }	        }	    } catch (final NumberFormatException nfe) {	    }	    try {	        if (numDecimals <= 16) {	            final Double d = createDouble(str);	            if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {	                return d;	            }	        }	    } catch (final NumberFormatException nfe) {	    }	    return createBigDecimal(str);	}
protected void setUseFieldNames(final boolean useFieldNames) {	    this.useFieldNames = useFieldNames;	}
private static boolean isAssignable(final Type type, final TypeVariable<?> toTypeVariable, final Map<TypeVariable<?>, Type> typeVarAssigns) {	    if (type == null) {	        return true;	    }	    if (toTypeVariable == null) {	        return false;	    }	    if (toTypeVariable.equals(type)) {	        return true;	    }	    if (type instanceof TypeVariable<?>) {	        final Type[] bounds = getImplicitBounds((TypeVariable<?>) type);	        for (final Type bound : bounds) {	            if (isAssignable(bound, toTypeVariable, typeVarAssigns)) {	                return true;	            }	        }	    }	    if (type instanceof Class<?> || type instanceof ParameterizedType || type instanceof GenericArrayType || type instanceof WildcardType) {	        return false;	    }	    throw new IllegalStateException("found an unhandled type: " + type);	}
@Override	public long skip(long n) {	    if (pos + n > StrBuilder.this.size()) {	        n = StrBuilder.this.size() - pos;	    }	    if (n < 0) {	        return 0;	    }	    pos += n;	    return n;	}
protected boolean isUseShortClassName() {	    return useShortClassName;	}
protected String getContentStart() {	    return contentStart;	}
public static String defaultString(final String str, final String defaultStr) {	    return str == null ? defaultStr : str;	}
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) {	    style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));	    return this;	}
public static char binaryToHexDigit(final boolean[] src, final int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    if (src.length > srcPos + 3 && src[srcPos + 3]) {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src[srcPos]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
public int toComparison() {	    return comparison;	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) {	    return new Range<T>(fromInclusive, toInclusive, comparator);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public boolean replaceIn(final StrBuilder source, final int offset, final int length) {	    if (source == null) {	        return false;	    }	    return substitute(source, offset, length);	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public int size() {	    return size;	}
public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width, final int precision, final char padChar, final CharSequence ellipsis) {	    Validate.isTrue(ellipsis == null || precision < 0 || ellipsis.length() <= precision, "Specified ellipsis '%1$s' exceeds precision of %2$s", ellipsis, Integer.valueOf(precision));	    final StringBuilder buf = new StringBuilder(seq);	    if (precision >= 0 && precision < seq.length()) {	        final CharSequence _ellipsis = ObjectUtils.defaultIfNull(ellipsis, StringUtils.EMPTY);	        buf.replace(precision - _ellipsis.length(), seq.length(), _ellipsis.toString());	    }	    final boolean leftJustify = (flags & LEFT_JUSTIFY) == LEFT_JUSTIFY;	    for (int i = buf.length(); i < width; i++) {	        buf.insert(leftJustify ? i : 0, padChar);	    }	    formatter.format(buf.toString());	    return formatter;	}
public void add(final Number operand) {	    this.value += operand.intValue();	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
@Override	public boolean equals(final Object obj) {	    if (obj == null) {	        return false;	    }	    if (this == obj) {	        return true;	    }	    if (this.getClass() == obj.getClass()) {	        final MutableObject<?> that = (MutableObject<?>) obj;	        return this.value.equals(that.value);	    } else {	        return false;	    }	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
@Override	public String getFormattedExceptionMessage(final String baseMessage) {	    final StringBuilder buffer = new StringBuilder(256);	    if (baseMessage != null) {	        buffer.append(baseMessage);	    }	    if (contextValues.size() > 0) {	        if (buffer.length() > 0) {	            buffer.append('\n');	        }	        buffer.append("Exception Context:\n");	        int i = 0;	        for (final Pair<String, Object> pair : contextValues) {	            buffer.append("\t[");	            buffer.append(++i);	            buffer.append(':');	            buffer.append(pair.getKey());	            buffer.append("=");	            final Object value = pair.getValue();	            if (value == null) {	                buffer.append("null");	            } else {	                String valueStr;	                try {	                    valueStr = value.toString();	                } catch (final Exception e) {	                    valueStr = "Exception thrown on toString(): " + ExceptionUtils.getStackTrace(e);	                }	                buffer.append(valueStr);	            }	            buffer.append("]\n");	        }	        buffer.append("---------------------------------");	    }	    return buffer.toString();	}
public int toHashCode() {	    return iTotal;	}
public void appendStart(final StringBuffer buffer, final Object object) {	    if (object != null) {	        appendClassName(buffer, object);	        appendIdentityHashCode(buffer, object);	        appendContentStart(buffer);	        if (fieldSeparatorAtStart) {	            appendFieldSeparator(buffer);	        }	    }	}
public static float min(final float a, final float b, final float c) {	    return Math.min(Math.min(a, b), c);	}
public static String trim(final String str) {	    return str == null ? null : str.trim();	}
public static boolean equals(final Annotation a1, final Annotation a2) {	    if (a1 == a2) {	        return true;	    }	    if (a1 == null || a2 == null) {	        return false;	    }	    final Class<? extends Annotation> type = a1.annotationType();	    final Class<? extends Annotation> type2 = a2.annotationType();	    Validate.notNull(type, "Annotation %s with null annotationType()", a1);	    Validate.notNull(type2, "Annotation %s with null annotationType()", a2);	    if (!type.equals(type2)) {	        return false;	    }	    try {	        for (final Method m : type.getDeclaredMethods()) {	            if (m.getParameterTypes().length == 0 && isValidAnnotationMemberType(m.getReturnType())) {	                final Object v1 = m.invoke(a1);	                final Object v2 = m.invoke(a2);	                if (!memberEquals(m.getReturnType(), v1, v2)) {	                    return false;	                }	            }	        }	    } catch (final IllegalAccessException ex) {	        return false;	    } catch (final InvocationTargetException ex) {	        return false;	    }	    return true;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {	    if (array == null) {	        if (index != 0) {	            throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0");	        }	        final Object joinedArray = Array.newInstance(clss, 1);	        Array.set(joinedArray, 0, element);	        return joinedArray;	    }	    final int length = Array.getLength(array);	    if (index > length || index < 0) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(clss, length + 1);	    System.arraycopy(array, 0, result, 0, index);	    Array.set(result, index, element);	    if (index < length) {	        System.arraycopy(array, index, result, index + 1, length - index);	    }	    return result;	}
public static float max(final float a, final float b, final float c) {	    return Math.max(Math.max(a, b), c);	}
public static boolean[] hexDigitToBinary(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return new boolean[] { false, false, false, false };	        case '1':	            return new boolean[] { true, false, false, false };	        case '2':	            return new boolean[] { false, true, false, false };	        case '3':	            return new boolean[] { true, true, false, false };	        case '4':	            return new boolean[] { false, false, true, false };	        case '5':	            return new boolean[] { true, false, true, false };	        case '6':	            return new boolean[] { false, true, true, false };	        case '7':	            return new boolean[] { true, true, true, false };	        case '8':	            return new boolean[] { false, false, false, true };	        case '9':	            return new boolean[] { true, false, false, true };	        case 'a':	        case 'A':	            return new boolean[] { false, true, false, true };	        case 'b':	        case 'B':	            return new boolean[] { true, true, false, true };	        case 'c':	        case 'C':	            return new boolean[] { false, false, true, true };	        case 'd':	        case 'D':	            return new boolean[] { true, false, true, true };	        case 'e':	        case 'E':	            return new boolean[] { false, true, true, true };	        case 'f':	        case 'F':	            return new boolean[] { true, true, true, true };	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public static String toString(final Annotation a) {	    final ToStringBuilder builder = new ToStringBuilder(a, TO_STRING_STYLE);	    for (final Method m : a.annotationType().getDeclaredMethods()) {	        if (m.getParameterTypes().length > 0) {	            continue;	        }	        try {	            builder.append(m.getName(), m.invoke(a));	        } catch (final RuntimeException ex) {	            throw ex;	        } catch (final Exception ex) {	            throw new RuntimeException(ex);	        }	    }	    return builder.build();	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public static String[] splitByCharacterTypeCamelCase(final String str) {	    return splitByCharacterType(str, true);	}
public StrBuilder setNewLineText(final String newLine) {	    this.newLine = newLine;	    return this;	}
private static String[] splitByCharacterType(final String str, final boolean camelCase) {	    if (str == null) {	        return null;	    }	    if (str.isEmpty()) {	        return ArrayUtils.EMPTY_STRING_ARRAY;	    }	    final char[] c = str.toCharArray();	    final List<String> list = new ArrayList<String>();	    int tokenStart = 0;	    int currentType = Character.getType(c[tokenStart]);	    for (int pos = tokenStart + 1; pos < c.length; pos++) {	        final int type = Character.getType(c[pos]);	        if (type == currentType) {	            continue;	        }	        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {	            final int newTokenStart = pos - 1;	            if (newTokenStart != tokenStart) {	                list.add(new String(c, tokenStart, newTokenStart - tokenStart));	                tokenStart = newTokenStart;	            }	        } else {	            list.add(new String(c, tokenStart, pos - tokenStart));	            tokenStart = pos;	        }	        currentType = type;	    }	    list.add(new String(c, tokenStart, c.length - tokenStart));	    return list.toArray(new String[list.size()]);	}
public int lastIndexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex >= size ? size - 1 : startIndex);	    if (matcher == null || startIndex < 0) {	        return -1;	    }	    final char[] buf = buffer;	    final int endIndex = startIndex + 1;	    for (int i = startIndex; i >= 0; i--) {	        if (matcher.isMatch(buf, i, 0, endIndex) > 0) {	            return i;	        }	    }	    return -1;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
protected String getContentStart() {	    return contentStart;	}
public boolean isAppendStatics() {	    return this.appendStatics;	}
public static String right(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(str.length() - len);	}
@Override	public int compareTo(final MutableBoolean other) {	    final boolean anotherVal = other.value;	    return value == anotherVal ? 0 : (value ? 1 : -1);	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
public static String replaceEachRepeatedly(final String text, final String[] searchList, final String[] replacementList) {	    final int timeToLive = searchList == null ? 0 : searchList.length;	    return replaceEach(text, searchList, replacementList, true, timeToLive);	}
@Override	public String getMessage() {	    return getFormattedExceptionMessage(super.getMessage());	}
public static boolean isAllUpperCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isUpperCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
static void register(final Object lhs, final Object rhs) {	    synchronized (EqualsBuilder.class) {	        if (getRegistry() == null) {	            REGISTRY.set(new HashSet<Pair<IDKey, IDKey>>());	        }	    }	    final Set<Pair<IDKey, IDKey>> registry = getRegistry();	    final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);	    registry.add(pair);	}
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) {	    style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));	    return this;	}
public static Object readStaticField(final Class<?> cls, final String fieldName, final boolean forceAccess) throws IllegalAccessException {	    final Field field = getField(cls, fieldName, forceAccess);	    if (field == null) {	        throw new IllegalArgumentException("Cannot locate field " + fieldName + " on " + cls);	    }	    return readStaticField(field, false);	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public void subtract(final Number operand) {	    this.value -= operand.doubleValue();	}
@Override	public int length() {	    return size;	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
public static NumericEntityEscaper above(final int codepoint) {	    return outsideOf(0, codepoint);	}
public static boolean isAllUpperCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isUpperCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public String getNewLineText() {	    return newLine;	}
static Token[] lexx(final String format) {	    final char[] array = format.toCharArray();	    final ArrayList<Token> list = new ArrayList<Token>(array.length);	    boolean inLiteral = false;	    StringBuilder buffer = null;	    Token previous = null;	    final int sz = array.length;	    for (int i = 0; i < sz; i++) {	        final char ch = array[i];	        if (inLiteral && ch != '\'') {	            buffer.append(ch);	            continue;	        }	        Object value = null;	        switch(ch) {	            case '\'':	                if (inLiteral) {	                    buffer = null;	                    inLiteral = false;	                } else {	                    buffer = new StringBuilder();	                    list.add(new Token(buffer));	                    inLiteral = true;	                }	                break;	            case 'y':	                value = y;	                break;	            case 'M':	                value = M;	                break;	            case 'd':	                value = d;	                break;	            case 'H':	                value = H;	                break;	            case 'm':	                value = m;	                break;	            case 's':	                value = s;	                break;	            case 'S':	                value = S;	                break;	            default:	                if (buffer == null) {	                    buffer = new StringBuilder();	                    list.add(new Token(buffer));	                }	                buffer.append(ch);	        }	        if (value != null) {	            if (previous != null && previous.getValue() == value) {	                previous.increment();	            } else {	                final Token token = new Token(value);	                list.add(token);	                previous = token;	            }	            buffer = null;	        }	    }	    return list.toArray(new Token[list.size()]);	}
public static <L, M, R> ImmutableTriple<L, M, R> of(final L left, final M middle, final R right) {	    return new ImmutableTriple<L, M, R>(left, middle, right);	}
public int toComparison() {	    return comparison;	}
public StrTokenizer setDelimiterString(final String delim) {	    return setDelimiterMatcher(StrMatcher.stringMatcher(delim));	}
public static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex) {	    if (0 == nHex) {	        return dstInit;	    }	    if ((nHex - 1) * 4 + dstPos >= 64) {	        throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 64");	    }	    long out = dstInit;	    int shift = 0;	    for (int i = 0; i < nHex; i++) {	        shift = i * 4 + dstPos;	        final long bits = (0xfL & hexDigitToInt(src.charAt(i + srcPos))) << shift;	        final long mask = 0xfL << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public String getNewLineText() {	    return newLine;	}
@Override	public boolean equals(final Object obj) {	    if (obj == this) {	        return true;	    }	    if (obj instanceof Map.Entry<?, ?>) {	        final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;	        return ObjectUtils.equals(getKey(), other.getKey()) && ObjectUtils.equals(getValue(), other.getValue());	    }	    return false;	}
public static boolean isEmpty(final boolean[] array) {	    return array == null || array.length == 0;	}
static Pair<IDKey, IDKey> getRegisterPair(final Object lhs, final Object rhs) {	    final IDKey left = new IDKey(lhs);	    final IDKey right = new IDKey(rhs);	    return Pair.of(left, right);	}
public void appendEnd(final StringBuffer buffer, final Object object) {	    if (this.fieldSeparatorAtEnd == false) {	        removeLastFieldSeparator(buffer);	    }	    appendContentEnd(buffer);	    unregister(object);	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public String getNewLineText() {	    return newLine;	}
public String getNewLineText() {	    return newLine;	}
public static String toString(final boolean bool, final String trueString, final String falseString) {	    return bool ? trueString : falseString;	}
public String getNullText() {	    return nullText;	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException {	    return parseDateWithLeniency(str, null, parsePatterns, false);	}
public static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex) {	    if (0 == nHex) {	        return dstInit;	    }	    if ((nHex - 1) * 4 + dstPos >= 8) {	        throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 8");	    }	    byte out = dstInit;	    int shift = 0;	    for (int i = 0; i < nHex; i++) {	        shift = i * 4 + dstPos;	        final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift;	        final int mask = 0xf << shift;	        out = (byte) ((out & ~mask) | bits);	    }	    return out;	}
@Override	public String toString() {	    return StringUtils.repeat(this.value.toString(), this.count);	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
@Override	public Date parse(final String source, final ParsePosition pos) {	    return parser.parse(source, pos);	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public boolean isOverlappedBy(final Range<T> otherRange) {	    if (otherRange == null) {	        return false;	    }	    return otherRange.contains(minimum) || otherRange.contains(maximum) || contains(otherRange.minimum);	}
protected String getNullText() {	    return nullText;	}
public static String randomNumeric(final int count) {	    return random(count, false, true);	}
@Override	public int compare(final Object obj1, final Object obj2) {	    return ((Comparable) obj1).compareTo(obj2);	}
public String getNullText() {	    return nullText;	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static String abbreviate(final String str, int offset, final int maxWidth) {	    if (str == null) {	        return null;	    }	    if (maxWidth < 4) {	        throw new IllegalArgumentException("Minimum abbreviation width is 4");	    }	    if (str.length() <= maxWidth) {	        return str;	    }	    if (offset > str.length()) {	        offset = str.length();	    }	    if (str.length() - offset < maxWidth - 3) {	        offset = str.length() - (maxWidth - 3);	    }	    final String abrevMarker = "...";	    if (offset <= 4) {	        return str.substring(0, maxWidth - 3) + abrevMarker;	    }	    if (maxWidth < 7) {	        throw new IllegalArgumentException("Minimum abbreviation width with offset is 7");	    }	    if (offset + maxWidth - 3 < str.length()) {	        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);	    }	    return abrevMarker + str.substring(str.length() - (maxWidth - 3));	}
public static String formatDuration(long durationMillis, final String format, final boolean padWithZeros) {	    final Token[] tokens = lexx(format);	    int days = 0;	    int hours = 0;	    int minutes = 0;	    int seconds = 0;	    int milliseconds = 0;	    if (Token.containsTokenWithValue(tokens, d)) {	        days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY);	        durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY);	    }	    if (Token.containsTokenWithValue(tokens, H)) {	        hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR);	        durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR);	    }	    if (Token.containsTokenWithValue(tokens, m)) {	        minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE);	        durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE);	    }	    if (Token.containsTokenWithValue(tokens, s)) {	        seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND);	        durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND);	    }	    if (Token.containsTokenWithValue(tokens, S)) {	        milliseconds = (int) durationMillis;	    }	    return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public StrBuilder appendSeparator(final char separator, final int loopIndex) {	    if (loopIndex > 0) {	        append(separator);	    }	    return this;	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static String removeEnd(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.endsWith(remove)) {	        return str.substring(0, str.length() - remove.length());	    }	    return str;	}
public static String substringBefore(final String str, final String separator) {	    if (isEmpty(str) || separator == null) {	        return str;	    }	    if (separator.isEmpty()) {	        return EMPTY;	    }	    final int pos = str.indexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return str;	    }	    return str.substring(0, pos);	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
static boolean containsTokenWithValue(final Token[] tokens, final Object value) {	    final int sz = tokens.length;	    for (int i = 0; i < sz; i++) {	        if (tokens[i].getValue() == value) {	            return true;	        }	    }	    return false;	}
public static float max(final float a, final float b, final float c) {	    return Math.max(Math.max(a, b), c);	}
public static <L> void addEventListener(final Object eventSource, final Class<L> listenerType, final L listener) {	    try {	        MethodUtils.invokeMethod(eventSource, "add" + listenerType.getSimpleName(), listener);	    } catch (final NoSuchMethodException e) {	        throw new IllegalArgumentException("Class " + eventSource.getClass().getName() + " does not have a public add" + listenerType.getSimpleName() + " method which takes a parameter of type " + listenerType.getName() + ".");	    } catch (final IllegalAccessException e) {	        throw new IllegalArgumentException("Class " + eventSource.getClass().getName() + " does not have an accessible add" + listenerType.getSimpleName() + " method which takes a parameter of type " + listenerType.getName() + ".");	    } catch (final InvocationTargetException e) {	        throw new RuntimeException("Unable to add listener.", e.getCause());	    }	}
public static String repeat(final char ch, final int repeat) {	    final char[] buf = new char[repeat];	    for (int i = repeat - 1; i >= 0; i--) {	        buf[i] = ch;	    }	    return new String(buf);	}
public static <T> void inclusiveBetween(final T start, final T end, final Comparable<T> value, final String message, final Object... values) {	    if (value.compareTo(start) < 0 || value.compareTo(end) > 0) {	        throw new IllegalArgumentException(String.format(message, values));	    }	}
public static void identityToString(final StringBuilder builder, final Object object) {	    if (object == null) {	        throw new NullPointerException("Cannot get the toString of a null identity");	    }	    builder.append(object.getClass().getName()).append('@').append(Integer.toHexString(System.identityHashCode(object)));	}
private static long getFragment(final Calendar calendar, final int fragment, final int unit) {	    if (calendar == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final long millisPerUnit = getMillisPerUnit(unit);	    long result = 0;	    switch(fragment) {	        case Calendar.YEAR:	            result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit;	            break;	        case Calendar.MONTH:	            result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit;	            break;	    }	    switch(fragment) {	        case Calendar.YEAR:	        case Calendar.MONTH:	        case Calendar.DAY_OF_YEAR:	        case Calendar.DATE:	            result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit;	        case Calendar.HOUR_OF_DAY:	            result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit;	        case Calendar.MINUTE:	            result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit;	        case Calendar.SECOND:	            result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit;	            break;	        case Calendar.MILLISECOND:	            break;	        default:	            throw new IllegalArgumentException("The fragment " + fragment + " is not supported");	    }	    return result;	}
public String getNullText() {	    return nullText;	}
public static String[][] HTML40_EXTENDED_ESCAPE() {	    return HTML40_EXTENDED_ESCAPE.clone();	}
protected String getFieldSeparator() {	    return fieldSeparator;	}
@Override	public int length() {	    return size;	}
protected String getSizeStartText() {	    return sizeStartText;	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
public static boolean containsAny(final CharSequence cs, final CharSequence searchChars) {	    if (searchChars == null) {	        return false;	    }	    return containsAny(cs, CharSequenceUtils.toCharArray(searchChars));	}
public synchronized boolean start() {	    if (!isStarted()) {	        ExecutorService tempExec;	        executor = getExternalExecutor();	        if (executor == null) {	            executor = tempExec = createExecutor();	        } else {	            tempExec = null;	        }	        future = executor.submit(createTask(tempExec));	        return true;	    }	    return false;	}
public static void identityToString(final StringBuilder builder, final Object object) {	    if (object == null) {	        throw new NullPointerException("Cannot get the toString of a null identity");	    }	    builder.append(object.getClass().getName()).append('@').append(Integer.toHexString(System.identityHashCode(object)));	}
public static Iterator<?> iterator(final Object focus, final int rangeStyle) {	    if (focus == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (focus instanceof Date) {	        return iterator((Date) focus, rangeStyle);	    } else if (focus instanceof Calendar) {	        return iterator((Calendar) focus, rangeStyle);	    } else {	        throw new ClassCastException("Could not iterate based on " + focus);	    }	}
public int size() {	    return size;	}
public static float max(final float a, final float b, final float c) {	    return Math.max(Math.max(a, b), c);	}
protected String getFieldNameValueSeparator() {	    return fieldNameValueSeparator;	}
public static Calendar toCalendar(final Date date) {	    final Calendar c = Calendar.getInstance();	    c.setTime(date);	    return c;	}
protected String getArrayStart() {	    return arrayStart;	}
public static boolean startsWithAny(final CharSequence string, final CharSequence... searchStrings) {	    if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {	        return false;	    }	    for (final CharSequence searchString : searchStrings) {	        if (StringUtils.startsWith(string, searchString)) {	            return true;	        }	    }	    return false;	}
public static Iterator<?> iterator(final Object focus, final int rangeStyle) {	    if (focus == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (focus instanceof Date) {	        return iterator((Date) focus, rangeStyle);	    } else if (focus instanceof Calendar) {	        return iterator((Calendar) focus, rangeStyle);	    } else {	        throw new ClassCastException("Could not iterate based on " + focus);	    }	}
public int size() {	    return size;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static Fraction getReducedFraction(int numerator, int denominator) {	    if (denominator == 0) {	        throw new ArithmeticException("The denominator must not be zero");	    }	    if (numerator == 0) {	        return ZERO;	    }	    if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) {	        numerator /= 2;	        denominator /= 2;	    }	    if (denominator < 0) {	        if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {	            throw new ArithmeticException("overflow: can't negate");	        }	        numerator = -numerator;	        denominator = -denominator;	    }	    final int gcd = greatestCommonDivisor(numerator, denominator);	    numerator /= gcd;	    denominator /= gcd;	    return new Fraction(numerator, denominator);	}
public static <T> Range<T> is(final T element, final Comparator<T> comparator) {	    return between(element, element, comparator);	}
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = Integer.MAX_VALUE;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.indexOf(str, search, 0);	        if (tmp == INDEX_NOT_FOUND) {	            continue;	        }	        if (tmp < ret) {	            ret = tmp;	        }	    }	    return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;	}
protected boolean isDefaultFullDetail() {	    return defaultFullDetail;	}
public void add(final Number operand) {	    this.value += operand.shortValue();	}
protected String getSummaryObjectStartText() {	    return summaryObjectStartText;	}
protected boolean isDefaultFullDetail() {	    return defaultFullDetail;	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public boolean isEmpty() {	    return size == 0;	}
public char getEscapeChar() {	    return this.escapeChar;	}
public static StrMatcher tabMatcher() {	    return TAB_MATCHER;	}
protected String getArrayEnd() {	    return arrayEnd;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public int capacity() {	    return buffer.length;	}
@Override	public int length() {	    return size;	}
public static String replaceChars(final String str, final String searchChars, String replaceChars) {	    if (isEmpty(str) || isEmpty(searchChars)) {	        return str;	    }	    if (replaceChars == null) {	        replaceChars = EMPTY;	    }	    boolean modified = false;	    final int replaceCharsLength = replaceChars.length();	    final int strLength = str.length();	    final StringBuilder buf = new StringBuilder(strLength);	    for (int i = 0; i < strLength; i++) {	        final char ch = str.charAt(i);	        final int index = searchChars.indexOf(ch);	        if (index >= 0) {	            modified = true;	            if (index < replaceCharsLength) {	                buf.append(replaceChars.charAt(index));	            }	        } else {	            buf.append(ch);	        }	    }	    if (modified) {	        return buf.toString();	    }	    return str;	}
@Override	public int read(final char[] b, final int off, int len) {	    if (off < 0 || len < 0 || off > b.length || (off + len) > b.length || (off + len) < 0) {	        throw new IndexOutOfBoundsException();	    }	    if (len == 0) {	        return 0;	    }	    if (pos >= StrBuilder.this.size()) {	        return -1;	    }	    if (pos + len > size()) {	        len = StrBuilder.this.size() - pos;	    }	    StrBuilder.this.getChars(pos, pos + len, b, off);	    pos += len;	    return len;	}
public String getNewLineText() {	    return newLine;	}
public static String replacePattern(final String source, final String regex, final String replacement) {	    return Pattern.compile(regex, Pattern.DOTALL).matcher(source).replaceAll(replacement);	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static Date addYears(final Date date, final int amount) {	    return add(date, Calendar.YEAR, amount);	}
@Override	public StringBuffer format(final Calendar calendar, final StringBuffer buf) {	    return printer.format(calendar, buf);	}
public HashCodeBuilder append(final short[] array) {	    if (array == null) {	        iTotal = iTotal * iConstant;	    } else {	        for (final short element : array) {	            append(element);	        }	    }	    return this;	}
@Override	public T call() throws Exception {	    try {	        return initialize();	    } finally {	        if (execFinally != null) {	            execFinally.shutdown();	        }	    }	}
public void setRight(final R right) {	    this.right = right;	}
protected String getSizeStartText() {	    return sizeStartText;	}
protected String getFieldNameValueSeparator() {	    return fieldNameValueSeparator;	}
public String leftString(final int length) {	    if (length <= 0) {	        return "";	    } else if (length >= size) {	        return new String(buffer, 0, size);	    } else {	        return new String(buffer, 0, length);	    }	}
public int toComparison() {	    return comparison;	}
public String getNewLineText() {	    return newLine;	}
public static char binaryToHexDigit(final boolean[] src, final int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    if (src.length > srcPos + 3 && src[srcPos + 3]) {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src[srcPos]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
public synchronized Future<T> getFuture() {	    if (future == null) {	        throw new IllegalStateException("start() must be called first!");	    }	    return future;	}
@Override	public int read(final char[] b, final int off, int len) {	    if (off < 0 || len < 0 || off > b.length || (off + len) > b.length || (off + len) < 0) {	        throw new IndexOutOfBoundsException();	    }	    if (len == 0) {	        return 0;	    }	    if (pos >= StrBuilder.this.size()) {	        return -1;	    }	    if (pos + len > size()) {	        len = StrBuilder.this.size() - pos;	    }	    StrBuilder.this.getChars(pos, pos + len, b, off);	    pos += len;	    return len;	}
public static String trim(final String str) {	    return str == null ? null : str.trim();	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
@Override	public int compare(final Object obj1, final Object obj2) {	    return ((Comparable) obj1).compareTo(obj2);	}
@Override	public char charAt(final int index) {	    if (index < 0 || index >= length()) {	        throw new StringIndexOutOfBoundsException(index);	    }	    return buffer[index];	}
public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) {	    final Token[] tokens = lexx(format);	    final Calendar start = Calendar.getInstance(timezone);	    start.setTime(new Date(startMillis));	    final Calendar end = Calendar.getInstance(timezone);	    end.setTime(new Date(endMillis));	    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);	    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);	    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);	    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);	    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);	    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);	    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);	    while (milliseconds < 0) {	        milliseconds += 1000;	        seconds -= 1;	    }	    while (seconds < 0) {	        seconds += 60;	        minutes -= 1;	    }	    while (minutes < 0) {	        minutes += 60;	        hours -= 1;	    }	    while (hours < 0) {	        hours += 24;	        days -= 1;	    }	    if (Token.containsTokenWithValue(tokens, M)) {	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	        while (months < 0) {	            months += 12;	            years -= 1;	        }	        if (!Token.containsTokenWithValue(tokens, y) && years != 0) {	            while (years != 0) {	                months += 12 * years;	                years = 0;	            }	        }	    } else {	        if (!Token.containsTokenWithValue(tokens, y)) {	            int target = end.get(Calendar.YEAR);	            if (months < 0) {	                target -= 1;	            }	            while (start.get(Calendar.YEAR) != target) {	                days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);	                if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) {	                    days += 1;	                }	                start.add(Calendar.YEAR, 1);	                days += start.get(Calendar.DAY_OF_YEAR);	            }	            years = 0;	        }	        while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            start.add(Calendar.MONTH, 1);	        }	        months = 0;	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	    }	    if (!Token.containsTokenWithValue(tokens, d)) {	        hours += 24 * days;	        days = 0;	    }	    if (!Token.containsTokenWithValue(tokens, H)) {	        minutes += 60 * hours;	        hours = 0;	    }	    if (!Token.containsTokenWithValue(tokens, m)) {	        seconds += 60 * minutes;	        minutes = 0;	    }	    if (!Token.containsTokenWithValue(tokens, s)) {	        milliseconds += 1000 * seconds;	        seconds = 0;	    }	    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public HashCodeBuilder append(final short[] array) {	    if (array == null) {	        iTotal = iTotal * iConstant;	    } else {	        for (final short element : array) {	            append(element);	        }	    }	    return this;	}
public static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools) {	    if ((src.length == 0 && srcPos == 0) || 0 == nBools) {	        return dstInit;	    }	    if (nBools - 1 + dstPos >= 32) {	        throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 32");	    }	    int out = dstInit;	    int shift = 0;	    for (int i = 0; i < nBools; i++) {	        shift = i * 1 + dstPos;	        final int bits = (src[i + srcPos] ? 1 : 0) << shift;	        final int mask = 0x1 << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public Writer asWriter() {	    return new StrBuilderWriter();	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public static String rightPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return rightPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return str.concat(padStr);	    } else if (pads < padLen) {	        return str.concat(padStr.substring(0, pads));	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return str.concat(new String(padding));	    }	}
@Override	public String getSizeEndText() {	    return super.getSizeEndText();	}
@Deprecated	public static String chomp(final String str, final String separator) {	    return removeEnd(str, separator);	}
public static <T extends CharSequence> T validIndex(final T chars, final int index) {	    return validIndex(chars, index, DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE, Integer.valueOf(index));	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
public Short toShort() {	    return Short.valueOf(shortValue());	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static Date setHours(final Date date, final int amount) {	    return set(date, Calendar.HOUR_OF_DAY, amount);	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
@Override	public double doubleValue() {	    return (double) numerator / (double) denominator;	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public static Character toCharacterObject(final String str) {	    if (StringUtils.isEmpty(str)) {	        return null;	    }	    return Character.valueOf(str.charAt(0));	}
public static byte[] serialize(final Serializable obj) {	    final ByteArrayOutputStream baos = new ByteArrayOutputStream(512);	    serialize(obj, baos);	    return baos.toByteArray();	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public void start() {	    if (this.runningState == STATE_STOPPED) {	        throw new IllegalStateException("Stopwatch must be reset before being restarted. ");	    }	    if (this.runningState != STATE_UNSTARTED) {	        throw new IllegalStateException("Stopwatch already started. ");	    }	    this.startTime = System.nanoTime();	    this.startTimeMillis = System.currentTimeMillis();	    this.runningState = STATE_RUNNING;	}
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) {	    return new Range<T>(fromInclusive, toInclusive, comparator);	}
@Override	public boolean isUseShortClassName() {	    return super.isUseShortClassName();	}
@Override	public int nextIndex() {	    return tokenPos;	}
static boolean isAccessible(final Member m) {	    return m != null && Modifier.isPublic(m.getModifiers()) && !m.isSynthetic();	}
public final void translate(final CharSequence input, final Writer out) throws IOException {	    if (out == null) {	        throw new IllegalArgumentException("The Writer must not be null");	    }	    if (input == null) {	        return;	    }	    int pos = 0;	    final int len = input.length();	    while (pos < len) {	        final int consumed = translate(input, pos, out);	        if (consumed == 0) {	            final char[] c = Character.toChars(Character.codePointAt(input, pos));	            out.write(c);	            pos += c.length;	            continue;	        }	        for (int pt = 0; pt < consumed; pt++) {	            pos += Character.charCount(Character.codePointAt(input, pt));	        }	    }	}
@Override	public float floatValue() {	    return (float) numerator / (float) denominator;	}
@Override	public void mark(final int readAheadLimit) {	    mark = pos;	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    if (input.charAt(index) == '\\' && index < (input.length() - 1) && Character.isDigit(input.charAt(index + 1))) {	        final int start = index + 1;	        int end = index + 2;	        while (end < input.length() && Character.isDigit(input.charAt(end))) {	            end++;	            if (Integer.parseInt(input.subSequence(start, end).toString(), 10) > OCTAL_MAX) {	                end--;	                break;	            }	        }	        out.write(Integer.parseInt(input.subSequence(start, end).toString(), 8));	        return 1 + end - start;	    }	    return 0;	}
public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width, final int precision, final char padChar, final CharSequence ellipsis) {	    Validate.isTrue(ellipsis == null || precision < 0 || ellipsis.length() <= precision, "Specified ellipsis '%1$s' exceeds precision of %2$s", ellipsis, Integer.valueOf(precision));	    final StringBuilder buf = new StringBuilder(seq);	    if (precision >= 0 && precision < seq.length()) {	        final CharSequence _ellipsis = ObjectUtils.defaultIfNull(ellipsis, StringUtils.EMPTY);	        buf.replace(precision - _ellipsis.length(), seq.length(), _ellipsis.toString());	    }	    final boolean leftJustify = (flags & LEFT_JUSTIFY) == LEFT_JUSTIFY;	    for (int i = buf.length(); i < width; i++) {	        buf.insert(leftJustify ? i : 0, padChar);	    }	    formatter.format(buf.toString());	    return formatter;	}
private static String[] splitByCharacterType(final String str, final boolean camelCase) {	    if (str == null) {	        return null;	    }	    if (str.isEmpty()) {	        return ArrayUtils.EMPTY_STRING_ARRAY;	    }	    final char[] c = str.toCharArray();	    final List<String> list = new ArrayList<String>();	    int tokenStart = 0;	    int currentType = Character.getType(c[tokenStart]);	    for (int pos = tokenStart + 1; pos < c.length; pos++) {	        final int type = Character.getType(c[pos]);	        if (type == currentType) {	            continue;	        }	        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {	            final int newTokenStart = pos - 1;	            if (newTokenStart != tokenStart) {	                list.add(new String(c, tokenStart, newTokenStart - tokenStart));	                tokenStart = newTokenStart;	            }	        } else {	            list.add(new String(c, tokenStart, pos - tokenStart));	            tokenStart = pos;	        }	        currentType = type;	    }	    list.add(new String(c, tokenStart, c.length - tokenStart));	    return list.toArray(new String[list.size()]);	}
public static final String escapeCsv(final String input) {	    return ESCAPE_CSV.translate(input);	}
public static String formatDuration(long durationMillis, final String format, final boolean padWithZeros) {	    final Token[] tokens = lexx(format);	    int days = 0;	    int hours = 0;	    int minutes = 0;	    int seconds = 0;	    int milliseconds = 0;	    if (Token.containsTokenWithValue(tokens, d)) {	        days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY);	        durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY);	    }	    if (Token.containsTokenWithValue(tokens, H)) {	        hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR);	        durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR);	    }	    if (Token.containsTokenWithValue(tokens, m)) {	        minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE);	        durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE);	    }	    if (Token.containsTokenWithValue(tokens, s)) {	        seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND);	        durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND);	    }	    if (Token.containsTokenWithValue(tokens, S)) {	        milliseconds = (int) durationMillis;	    }	    return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
@Override	public String toString() {	    if (this.getObject() == null) {	        return this.getStyle().getNullText();	    }	    Class<?> clazz = this.getObject().getClass();	    this.appendFieldsIn(clazz);	    while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {	        clazz = clazz.getSuperclass();	        this.appendFieldsIn(clazz);	    }	    return super.toString();	}
public static long getFragmentInDays(final Calendar calendar, final int fragment) {	    return getFragment(calendar, fragment, Calendar.DAY_OF_YEAR);	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
private static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns) {	    if (!isAssignable(cls, toClass)) {	        return null;	    }	    if (cls.isPrimitive()) {	        if (toClass.isPrimitive()) {	            return new HashMap<TypeVariable<?>, Type>();	        }	        cls = ClassUtils.primitiveToWrapper(cls);	    }	    final HashMap<TypeVariable<?>, Type> typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>() : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);	    if (toClass.equals(cls)) {	        return typeVarAssigns;	    }	    return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns);	}
public static boolean isAsciiAlpha(final char ch) {	    return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');	}
public void getChars(final int startIndex, final int endIndex, final char[] destination, final int destinationIndex) {	    if (startIndex < 0) {	        throw new StringIndexOutOfBoundsException(startIndex);	    }	    if (endIndex < 0 || endIndex > length()) {	        throw new StringIndexOutOfBoundsException(endIndex);	    }	    if (startIndex > endIndex) {	        throw new StringIndexOutOfBoundsException("end < start");	    }	    System.arraycopy(buffer, startIndex, destination, destinationIndex, endIndex - startIndex);	}
public String getNewLineText() {	    return newLine;	}
public int capacity() {	    return buffer.length;	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
@Deprecated	public static String[] getDefaultCauseMethodNames() {	    return ArrayUtils.clone(CAUSE_METHOD_NAMES);	}
@Override	public BasicThreadFactory build() {	    final BasicThreadFactory factory = new BasicThreadFactory(this);	    reset();	    return factory;	}
public static boolean[] clone(final boolean[] array) {	    if (array == null) {	        return null;	    }	    return array.clone();	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) {	    if (s == null || t == null) {	        throw new IllegalArgumentException("Strings must not be null");	    }	    if (threshold < 0) {	        throw new IllegalArgumentException("Threshold must not be negative");	    }	    int n = s.length();	    int m = t.length();	    if (n == 0) {	        return m <= threshold ? m : -1;	    } else if (m == 0) {	        return n <= threshold ? n : -1;	    }	    if (n > m) {	        final CharSequence tmp = s;	        s = t;	        t = tmp;	        n = m;	        m = t.length();	    }	    int[] p = new int[n + 1];	    int[] d = new int[n + 1];	    int[] _d;	    final int boundary = Math.min(n, threshold) + 1;	    for (int i = 0; i < boundary; i++) {	        p[i] = i;	    }	    Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);	    Arrays.fill(d, Integer.MAX_VALUE);	    for (int j = 1; j <= m; j++) {	        final char t_j = t.charAt(j - 1);	        d[0] = j;	        final int min = Math.max(1, j - threshold);	        final int max = Math.min(n, j + threshold);	        if (min > max) {	            return -1;	        }	        if (min > 1) {	            d[min - 1] = Integer.MAX_VALUE;	        }	        for (int i = min; i <= max; i++) {	            if (s.charAt(i - 1) == t_j) {	                d[i] = p[i - 1];	            } else {	                d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);	            }	        }	        _d = p;	        p = d;	        d = _d;	    }	    if (p[n] <= threshold) {	        return p[n];	    }	    return -1;	}
public Format getParser() {	    return this.parser;	}
public boolean contains(final StrMatcher matcher) {	    return indexOf(matcher, 0) >= 0;	}
public static short[] removeElement(final short[] array, final short element) {	    final int index = indexOf(array, element);	    if (index == INDEX_NOT_FOUND) {	        return clone(array);	    }	    return remove(array, index);	}
protected String getSizeEndText() {	    return sizeEndText;	}
public static byte[] serialize(final Serializable obj) {	    final ByteArrayOutputStream baos = new ByteArrayOutputStream(512);	    serialize(obj, baos);	    return baos.toByteArray();	}
public static boolean isWhitespace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isWhitespace(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
protected String getSizeStartText() {	    return sizeStartText;	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public int getProperNumerator() {	    return Math.abs(numerator % denominator);	}
public static String abbreviate(final String str, int offset, final int maxWidth) {	    if (str == null) {	        return null;	    }	    if (maxWidth < 4) {	        throw new IllegalArgumentException("Minimum abbreviation width is 4");	    }	    if (str.length() <= maxWidth) {	        return str;	    }	    if (offset > str.length()) {	        offset = str.length();	    }	    if (str.length() - offset < maxWidth - 3) {	        offset = str.length() - (maxWidth - 3);	    }	    final String abrevMarker = "...";	    if (offset <= 4) {	        return str.substring(0, maxWidth - 3) + abrevMarker;	    }	    if (maxWidth < 7) {	        throw new IllegalArgumentException("Minimum abbreviation width with offset is 7");	    }	    if (offset + maxWidth - 3 < str.length()) {	        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);	    }	    return abrevMarker + str.substring(str.length() - (maxWidth - 3));	}
public static float max(final float a, final float b) {	    if (Float.isNaN(a)) {	        return b;	    } else if (Float.isNaN(b)) {	        return a;	    } else {	        return Math.max(a, b);	    }	}
public static boolean isAllLowerCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLowerCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static <T> T invokeExactConstructor(final Class<T> cls, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {	    if (args == null) {	        args = ArrayUtils.EMPTY_OBJECT_ARRAY;	    }	    if (parameterTypes == null) {	        parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;	    }	    final Constructor<T> ctor = getAccessibleConstructor(cls, parameterTypes);	    if (ctor == null) {	        throw new NoSuchMethodException("No such accessible constructor on object: " + cls.getName());	    }	    return ctor.newInstance(args);	}
public int getProperWhole() {	    return numerator / denominator;	}
public static <L, M, R> MutableTriple<L, M, R> of(final L left, final M middle, final R right) {	    return new MutableTriple<L, M, R>(left, middle, right);	}
protected String parseToken(final String pattern, final int[] indexRef) {	    final StringBuilder buf = new StringBuilder();	    int i = indexRef[0];	    final int length = pattern.length();	    char c = pattern.charAt(i);	    if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {	        buf.append(c);	        while (i + 1 < length) {	            final char peek = pattern.charAt(i + 1);	            if (peek == c) {	                buf.append(c);	                i++;	            } else {	                break;	            }	        }	    } else {	        buf.append('\'');	        boolean inLiteral = false;	        for (; i < length; i++) {	            c = pattern.charAt(i);	            if (c == '\'') {	                if (i + 1 < length && pattern.charAt(i + 1) == '\'') {	                    i++;	                    buf.append(c);	                } else {	                    inLiteral = !inLiteral;	                }	            } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {	                i--;	                break;	            } else {	                buf.append(c);	            }	        }	    }	    indexRef[0] = i;	    return buf.toString();	}
public static final String unescapeCsv(final String input) {	    return UNESCAPE_CSV.translate(input);	}
protected boolean isUseIdentityHashCode() {	    return useIdentityHashCode;	}
public static String lowerCase(final String str, final Locale locale) {	    if (str == null) {	        return null;	    }	    return str.toLowerCase(locale);	}
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {	    if (array == null) {	        if (index != 0) {	            throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0");	        }	        final Object joinedArray = Array.newInstance(clss, 1);	        Array.set(joinedArray, 0, element);	        return joinedArray;	    }	    final int length = Array.getLength(array);	    if (index > length || index < 0) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(clss, length + 1);	    System.arraycopy(array, 0, result, 0, index);	    Array.set(result, index, element);	    if (index < length) {	        System.arraycopy(array, index, result, index + 1, length - index);	    }	    return result;	}
public static String trim(final String str) {	    return str == null ? null : str.trim();	}
protected String getSizeEndText() {	    return sizeEndText;	}
public String getNewLineText() {	    return newLine;	}
public int size() {	    return size;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {	    if (str == null || searchStr == null) {	        return INDEX_NOT_FOUND;	    }	    if (startPos > str.length() - searchStr.length()) {	        startPos = str.length() - searchStr.length();	    }	    if (startPos < 0) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return startPos;	    }	    for (int i = startPos; i >= 0; i--) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) {	    if (s == null || t == null) {	        throw new IllegalArgumentException("Strings must not be null");	    }	    if (threshold < 0) {	        throw new IllegalArgumentException("Threshold must not be negative");	    }	    int n = s.length();	    int m = t.length();	    if (n == 0) {	        return m <= threshold ? m : -1;	    } else if (m == 0) {	        return n <= threshold ? n : -1;	    }	    if (n > m) {	        final CharSequence tmp = s;	        s = t;	        t = tmp;	        n = m;	        m = t.length();	    }	    int[] p = new int[n + 1];	    int[] d = new int[n + 1];	    int[] _d;	    final int boundary = Math.min(n, threshold) + 1;	    for (int i = 0; i < boundary; i++) {	        p[i] = i;	    }	    Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);	    Arrays.fill(d, Integer.MAX_VALUE);	    for (int j = 1; j <= m; j++) {	        final char t_j = t.charAt(j - 1);	        d[0] = j;	        final int min = Math.max(1, j - threshold);	        final int max = Math.min(n, j + threshold);	        if (min > max) {	            return -1;	        }	        if (min > 1) {	            d[min - 1] = Integer.MAX_VALUE;	        }	        for (int i = min; i <= max; i++) {	            if (s.charAt(i - 1) == t_j) {	                d[i] = p[i - 1];	            } else {	                d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);	            }	        }	        _d = p;	        p = d;	        d = _d;	    }	    if (p[n] <= threshold) {	        return p[n];	    }	    return -1;	}
@Override	public boolean translate(final int codepoint, final Writer out) throws IOException {	    if (between) {	        if (codepoint < below || codepoint > above) {	            return false;	        }	    } else {	        if (codepoint >= below && codepoint <= above) {	            return false;	        }	    }	    if (codepoint > 0xffff) {	        out.write(toUtf16Escape(codepoint));	    } else if (codepoint > 0xfff) {	        out.write("\\u" + hex(codepoint));	    } else if (codepoint > 0xff) {	        out.write("\\u0" + hex(codepoint));	    } else if (codepoint > 0xf) {	        out.write("\\u00" + hex(codepoint));	    } else {	        out.write("\\u000" + hex(codepoint));	    }	    return true;	}
public void start() {	    if (this.runningState == STATE_STOPPED) {	        throw new IllegalStateException("Stopwatch must be reset before being restarted. ");	    }	    if (this.runningState != STATE_UNSTARTED) {	        throw new IllegalStateException("Stopwatch already started. ");	    }	    this.startTime = System.nanoTime();	    this.startTimeMillis = System.currentTimeMillis();	    this.runningState = STATE_RUNNING;	}
public Fraction pow(final int power) {	    if (power == 1) {	        return this;	    } else if (power == 0) {	        return ONE;	    } else if (power < 0) {	        if (power == Integer.MIN_VALUE) {	            return this.invert().pow(2).pow(-(power / 2));	        }	        return this.invert().pow(-power);	    } else {	        final Fraction f = this.multiplyBy(this);	        if (power % 2 == 0) {	            return f.pow(power / 2);	        } else {	            return f.pow(power / 2).multiplyBy(this);	        }	    }	}
public static final String unescapeJava(final String input) {	    return UNESCAPE_JAVA.translate(input);	}
public static List<Throwable> getThrowableList(Throwable throwable) {	    final List<Throwable> list = new ArrayList<Throwable>();	    while (throwable != null && list.contains(throwable) == false) {	        list.add(throwable);	        throwable = ExceptionUtils.getCause(throwable);	    }	    return list;	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public boolean isEquals() {	    return this.isEquals;	}
public static boolean containsOnly(final CharSequence cs, final String validChars) {	    if (cs == null || validChars == null) {	        return false;	    }	    return containsOnly(cs, validChars.toCharArray());	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public int size() {	    return size;	}
public String getNewLineText() {	    return newLine;	}
public static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools) {	    if ((src.length == 0 && srcPos == 0) || 0 == nBools) {	        return dstInit;	    }	    if (nBools - 1 + dstPos >= 8) {	        throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 8");	    }	    byte out = dstInit;	    int shift = 0;	    for (int i = 0; i < nBools; i++) {	        shift = i * 1 + dstPos;	        final int bits = (src[i + srcPos] ? 1 : 0) << shift;	        final int mask = 0x1 << shift;	        out = (byte) ((out & ~mask) | bits);	    }	    return out;	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    for (final CharSequenceTranslator translator : translators) {	        final int consumed = translator.translate(input, index, out);	        if (consumed != 0) {	            return consumed;	        }	    }	    return 0;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static boolean containsAny(final CharSequence cs, final CharSequence searchChars) {	    if (searchChars == null) {	        return false;	    }	    return containsAny(cs, CharSequenceUtils.toCharArray(searchChars));	}
@Override	public int length() {	    return size;	}
public static String rightPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return rightPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return str.concat(padStr);	    } else if (pads < padLen) {	        return str.concat(padStr.substring(0, pads));	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return str.concat(new String(padding));	    }	}
@Override	public boolean equals(final Object obj) {	    if (obj == this) {	        return true;	    }	    if (obj instanceof CharRange == false) {	        return false;	    }	    final CharRange other = (CharRange) obj;	    return start == other.start && end == other.end && negated == other.negated;	}
@Override	public int read(final char[] b, final int off, int len) {	    if (off < 0 || len < 0 || off > b.length || (off + len) > b.length || (off + len) < 0) {	        throw new IndexOutOfBoundsException();	    }	    if (len == 0) {	        return 0;	    }	    if (pos >= StrBuilder.this.size()) {	        return -1;	    }	    if (pos + len > size()) {	        len = StrBuilder.this.size() - pos;	    }	    StrBuilder.this.getChars(pos, pos + len, b, off);	    pos += len;	    return len;	}
public String getNewLineText() {	    return newLine;	}
public static <T> Range<T> is(final T element, final Comparator<T> comparator) {	    return between(element, element, comparator);	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException {	    return charsetName == null ? new String(bytes) : new String(bytes, charsetName);	}
public static float max(final float a, final float b, final float c) {	    return Math.max(Math.max(a, b), c);	}
@Override	public String next() {	    if (hasNext()) {	        return tokens[tokenPos++];	    }	    throw new NoSuchElementException();	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    if (index != 0) {	        throw new IllegalStateException("CsvUnescaper should never reach the [1] index");	    }	    if (input.charAt(0) != CSV_QUOTE || input.charAt(input.length() - 1) != CSV_QUOTE) {	        out.write(input.toString());	        return input.length();	    }	    final String quoteless = input.subSequence(1, input.length() - 1).toString();	    if (StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS)) {	        out.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR));	    } else {	        out.write(input.toString());	    }	    return input.length();	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static String substringBefore(final String str, final String separator) {	    if (isEmpty(str) || separator == null) {	        return str;	    }	    if (separator.isEmpty()) {	        return EMPTY;	    }	    final int pos = str.indexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return str;	    }	    return str.substring(0, pos);	}
public static StrTokenizer getTSVInstance(final char[] input) {	    final StrTokenizer tok = getTSVClone();	    tok.reset(input);	    return tok;	}
public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values) {	    final EnumSet<E> results = EnumSet.noneOf(asEnum(enumClass));	    values = ArrayUtils.clone(Validate.notNull(values));	    ArrayUtils.reverse(values);	    for (final E constant : enumClass.getEnumConstants()) {	        final int block = constant.ordinal() / Long.SIZE;	        if (block < values.length && (values[block] & 1 << (constant.ordinal() % Long.SIZE)) != 0) {	            results.add(constant);	        }	    }	    return results;	}
public Fraction multiplyBy(final Fraction fraction) {	    if (fraction == null) {	        throw new IllegalArgumentException("The fraction must not be null");	    }	    if (numerator == 0 || fraction.numerator == 0) {	        return ZERO;	    }	    final int d1 = greatestCommonDivisor(numerator, fraction.denominator);	    final int d2 = greatestCommonDivisor(fraction.numerator, denominator);	    return getReducedFraction(mulAndCheck(numerator / d1, fraction.numerator / d2), mulPosAndCheck(denominator / d2, fraction.denominator / d1));	}
public boolean isEmpty() {	    return size == 0;	}
public final CharSequenceTranslator with(final CharSequenceTranslator... translators) {	    final CharSequenceTranslator[] newArray = new CharSequenceTranslator[translators.length + 1];	    newArray[0] = this;	    System.arraycopy(translators, 0, newArray, 1, translators.length);	    return new AggregateTranslator(newArray);	}
protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf) {	    return printer.applyRules(calendar, buf);	}
public String getNewLineText() {	    return newLine;	}
@Override	public StringBuffer format(final Calendar calendar, final StringBuffer buf) {	    return applyRules(calendar, buf);	}
protected boolean isFieldSeparatorAtStart() {	    return fieldSeparatorAtStart;	}
public static int reflectionHashCode(final Object object, final String... excludeFields) {	    return reflectionHashCode(17, 37, object, false, null, excludeFields);	}
public Fraction reduce() {	    if (numerator == 0) {	        return equals(ZERO) ? this : ZERO;	    }	    final int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);	    if (gcd == 1) {	        return this;	    }	    return Fraction.getFraction(numerator / gcd, denominator / gcd);	}
public String getNullText() {	    return nullText;	}
protected boolean isUseFieldNames() {	    return useFieldNames;	}
public String getNullText() {	    return nullText;	}
public boolean isEnableSubstitutionInVariables() {	    return enableSubstitutionInVariables;	}
public StrBuilder deleteAll(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, -1);	}
public static Integer createInteger(final String str) {	    if (str == null) {	        return null;	    }	    return Integer.decode(str);	}
public static Boolean[] nullToEmpty(final Boolean[] array) {	    if (array == null || array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    return array;	}
public static String repeat(final char ch, final int repeat) {	    final char[] buf = new char[repeat];	    for (int i = repeat - 1; i >= 0; i--) {	        buf[i] = ch;	    }	    return new String(buf);	}
public static boolean isBlank(final CharSequence cs) {	    int strLen;	    if (cs == null || (strLen = cs.length()) == 0) {	        return true;	    }	    for (int i = 0; i < strLen; i++) {	        if (Character.isWhitespace(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
@Override	public StringBuffer format(final Calendar calendar, final StringBuffer buf) {	    return applyRules(calendar, buf);	}
public static <T> T notNull(final T object, final String message, final Object... values) {	    if (object == null) {	        throw new NullPointerException(String.format(message, values));	    }	    return object;	}
protected String getNullText() {	    return nullText;	}
@Override	public double doubleValue() {	    return value;	}
@Override	public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) {	    return buffer[pos] <= 32 ? 1 : 0;	}
public static String formatDuration(long durationMillis, final String format, final boolean padWithZeros) {	    final Token[] tokens = lexx(format);	    int days = 0;	    int hours = 0;	    int minutes = 0;	    int seconds = 0;	    int milliseconds = 0;	    if (Token.containsTokenWithValue(tokens, d)) {	        days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY);	        durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY);	    }	    if (Token.containsTokenWithValue(tokens, H)) {	        hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR);	        durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR);	    }	    if (Token.containsTokenWithValue(tokens, m)) {	        minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE);	        durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE);	    }	    if (Token.containsTokenWithValue(tokens, s)) {	        seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND);	        durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND);	    }	    if (Token.containsTokenWithValue(tokens, S)) {	        milliseconds = (int) durationMillis;	    }	    return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
@Override	public int length() {	    return size;	}
public Fraction subtract(final Fraction fraction) {	    return addSub(fraction, false);	}
public char getStart() {	    return this.start;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public StrTokenizer setIgnoredChar(final char ignored) {	    return setIgnoredMatcher(StrMatcher.charMatcher(ignored));	}
public int size() {	    return size;	}
public static String replacePattern(final String source, final String regex, final String replacement) {	    return Pattern.compile(regex, Pattern.DOTALL).matcher(source).replaceAll(replacement);	}
protected String getArrayStart() {	    return arrayStart;	}
public static void reverse(final boolean[] array) {	    if (array == null) {	        return;	    }	    int i = 0;	    int j = array.length - 1;	    boolean tmp;	    while (j > i) {	        tmp = array[j];	        array[j] = array[i];	        array[i] = tmp;	        j--;	        i++;	    }	}
public int capacity() {	    return buffer.length;	}
@Override	public int length() {	    return size;	}
protected String getSizeStartText() {	    return sizeStartText;	}
protected boolean isFieldSeparatorAtStart() {	    return fieldSeparatorAtStart;	}
public String getNullText() {	    return nullText;	}
public boolean isEmpty() {	    return size == 0;	}
protected String getContentStart() {	    return contentStart;	}
public int size() {	    return size;	}
@Override	public void mark(final int readAheadLimit) {	    mark = pos;	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
public int capacity() {	    return buffer.length;	}
@Override	public int nextIndex() {	    return tokenPos;	}
public boolean isEmpty() {	    return size == 0;	}
public boolean isIgnoreEmptyTokens() {	    return ignoreEmptyTokens;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
@Deprecated	public static String chomp(final String str, final String separator) {	    return removeEnd(str, separator);	}
public static CharSequence subSequence(final CharSequence cs, final int start) {	    return cs == null ? null : cs.subSequence(start, cs.length());	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static boolean isAscii(final char ch) {	    return ch < 128;	}
public StrBuilder deleteFirst(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, 1);	}
public int capacity() {	    return buffer.length;	}
public static String overlay(final String str, String overlay, int start, int end) {	    if (str == null) {	        return null;	    }	    if (overlay == null) {	        overlay = EMPTY;	    }	    final int len = str.length();	    if (start < 0) {	        start = 0;	    }	    if (start > len) {	        start = len;	    }	    if (end < 0) {	        end = 0;	    }	    if (end > len) {	        end = len;	    }	    if (start > end) {	        final int temp = start;	        start = end;	        end = temp;	    }	    return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString();	}
public static CharRange isNot(final char ch) {	    return new CharRange(ch, ch, true);	}
@Override	public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) {	    return buffer[pos] <= 32 ? 1 : 0;	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
@Override	public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) {	    return buffer[pos] <= 32 ? 1 : 0;	}
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = Integer.MAX_VALUE;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.indexOf(str, search, 0);	        if (tmp == INDEX_NOT_FOUND) {	            continue;	        }	        if (tmp < ret) {	            ret = tmp;	        }	    }	    return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static float min(final float a, final float b, final float c) {	    return Math.min(Math.min(a, b), c);	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public static float max(final float a, final float b, final float c) {	    return Math.max(Math.max(a, b), c);	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
@Override	public String toString() {	    if (this.getObject() == null) {	        return this.getStyle().getNullText();	    }	    Class<?> clazz = this.getObject().getClass();	    this.appendFieldsIn(clazz);	    while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {	        clazz = clazz.getSuperclass();	        this.appendFieldsIn(clazz);	    }	    return super.toString();	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public void increment() {	    value++;	}
public static Boolean and(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return and(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
@Override	public TimeZone getTimeZone() {	    return mTimeZone;	}
public static boolean containsAny(final CharSequence cs, final CharSequence searchChars) {	    if (searchChars == null) {	        return false;	    }	    return containsAny(cs, CharSequenceUtils.toCharArray(searchChars));	}
public static JavaUnicodeEscaper below(final int codepoint) {	    return outsideOf(codepoint, Integer.MAX_VALUE);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public int toComparison() {	    return comparison;	}
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return true;	    }	    if (lhs == null || rhs == null) {	        return false;	    }	    final Class<?> lhsClass = lhs.getClass();	    final Class<?> rhsClass = rhs.getClass();	    Class<?> testClass;	    if (lhsClass.isInstance(rhs)) {	        testClass = lhsClass;	        if (!rhsClass.isInstance(lhs)) {	            testClass = rhsClass;	        }	    } else if (rhsClass.isInstance(lhs)) {	        testClass = rhsClass;	        if (!lhsClass.isInstance(rhs)) {	            testClass = lhsClass;	        }	    } else {	        return false;	    }	    final EqualsBuilder equalsBuilder = new EqualsBuilder();	    try {	        reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {	            testClass = testClass.getSuperclass();	            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        }	    } catch (final IllegalArgumentException e) {	        return false;	    }	    return equalsBuilder.isEquals();	}
@Override	public R getRight() {	    return right;	}
public StrTokenizer setQuoteChar(final char quote) {	    return setQuoteMatcher(StrMatcher.charMatcher(quote));	}
@Override	public ContextedException addContextValue(final String label, final Object value) {	    exceptionContext.addContextValue(label, value);	    return this;	}
public static String abbreviateMiddle(final String str, final String middle, final int length) {	    if (isEmpty(str) || isEmpty(middle)) {	        return str;	    }	    if (length >= str.length() || length < middle.length() + 2) {	        return str;	    }	    final int targetSting = length - middle.length();	    final int startOffset = targetSting / 2 + targetSting % 2;	    final int endOffset = str.length() - targetSting / 2;	    final StringBuilder builder = new StringBuilder(length);	    builder.append(str.substring(0, startOffset));	    builder.append(middle);	    builder.append(str.substring(endOffset));	    return builder.toString();	}
public static String substringBetween(final String str, final String open, final String close) {	    if (str == null || open == null || close == null) {	        return null;	    }	    final int start = str.indexOf(open);	    if (start != INDEX_NOT_FOUND) {	        final int end = str.indexOf(close, start + open.length());	        if (end != INDEX_NOT_FOUND) {	            return str.substring(start + open.length(), end);	        }	    }	    return null;	}
public int size() {	    return size;	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public String getNullText() {	    return nullText;	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    if (index != 0) {	        throw new IllegalStateException("CsvUnescaper should never reach the [1] index");	    }	    if (input.charAt(0) != CSV_QUOTE || input.charAt(input.length() - 1) != CSV_QUOTE) {	        out.write(input.toString());	        return input.length();	    }	    final String quoteless = input.subSequence(1, input.length() - 1).toString();	    if (StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS)) {	        out.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR));	    } else {	        out.write(input.toString());	    }	    return input.length();	}
public static String[] stripAll(final String[] strs, final String stripChars) {	    int strsLen;	    if (strs == null || (strsLen = strs.length) == 0) {	        return strs;	    }	    final String[] newArr = new String[strsLen];	    for (int i = 0; i < strsLen; i++) {	        newArr[i] = strip(strs[i], stripChars);	    }	    return newArr;	}
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) {	    final StringBuilder buffer = new StringBuilder();	    boolean lastOutputSeconds = false;	    final int sz = tokens.length;	    for (int i = 0; i < sz; i++) {	        final Token token = tokens[i];	        final Object value = token.getValue();	        final int count = token.getCount();	        if (value instanceof StringBuilder) {	            buffer.append(value.toString());	        } else {	            if (value == y) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years));	                lastOutputSeconds = false;	            } else if (value == M) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months));	                lastOutputSeconds = false;	            } else if (value == d) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days));	                lastOutputSeconds = false;	            } else if (value == H) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours));	                lastOutputSeconds = false;	            } else if (value == m) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes));	                lastOutputSeconds = false;	            } else if (value == s) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds));	                lastOutputSeconds = true;	            } else if (value == S) {	                if (lastOutputSeconds) {	                    milliseconds += 1000;	                    final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds);	                    buffer.append(str.substring(1));	                } else {	                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds));	                }	                lastOutputSeconds = false;	            }	        }	    }	    return buffer.toString();	}
public static File getUserHome() {	    return new File(System.getProperty(USER_HOME_KEY));	}
public boolean isEmpty() {	    return size == 0;	}
public static short[] removeElement(final short[] array, final short element) {	    final int index = indexOf(array, element);	    if (index == INDEX_NOT_FOUND) {	        return clone(array);	    }	    return remove(array, index);	}
public static <K, V> V createIfAbsent(final ConcurrentMap<K, V> map, final K key, final ConcurrentInitializer<V> init) throws ConcurrentException {	    if (map == null || init == null) {	        return null;	    }	    final V value = map.get(key);	    if (value == null) {	        return putIfAbsent(map, key, init.get());	    }	    return value;	}
public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {	    if (str == null || searchStr == null) {	        return INDEX_NOT_FOUND;	    }	    if (startPos > str.length() - searchStr.length()) {	        startPos = str.length() - searchStr.length();	    }	    if (startPos < 0) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return startPos;	    }	    for (int i = startPos; i >= 0; i--) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts) {	    if ((src.length == 0 && srcPos == 0) || 0 == nShorts) {	        return dstInit;	    }	    if ((nShorts - 1) * 16 + dstPos >= 64) {	        throw new IllegalArgumentException("(nShorts-1)*16+dstPos is greather or equal to than 64");	    }	    long out = dstInit;	    int shift = 0;	    for (int i = 0; i < nShorts; i++) {	        shift = i * 16 + dstPos;	        final long bits = (0xffffL & src[i + srcPos]) << shift;	        final long mask = 0xffffL << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
protected void removeLastFieldSeparator(final StringBuffer buffer) {	    final int len = buffer.length();	    final int sepLen = fieldSeparator.length();	    if (len > 0 && sepLen > 0 && len >= sepLen) {	        boolean match = true;	        for (int i = 0; i < sepLen; i++) {	            if (buffer.charAt(len - 1 - i) != fieldSeparator.charAt(sepLen - 1 - i)) {	                match = false;	                break;	            }	        }	        if (match) {	            buffer.setLength(len - sepLen);	        }	    }	}
public static String[] stripAll(final String[] strs, final String stripChars) {	    int strsLen;	    if (strs == null || (strsLen = strs.length) == 0) {	        return strs;	    }	    final String[] newArr = new String[strsLen];	    for (int i = 0; i < strsLen; i++) {	        newArr[i] = strip(strs[i], stripChars);	    }	    return newArr;	}
@Override	public StringBuffer format(final Calendar calendar, final StringBuffer buf) {	    return applyRules(calendar, buf);	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public static boolean[] clone(final boolean[] array) {	    if (array == null) {	        return null;	    }	    return array.clone();	}
public static String normalizeSpace(final String str) {	    if (str == null) {	        return null;	    }	    return WHITESPACE_PATTERN.matcher(trim(str)).replaceAll(SPACE);	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public String getNullText() {	    return nullText;	}
@Override	public String toString() {	    if (this.getObject() == null) {	        return this.getStyle().getNullText();	    }	    Class<?> clazz = this.getObject().getClass();	    this.appendFieldsIn(clazz);	    while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {	        clazz = clazz.getSuperclass();	        this.appendFieldsIn(clazz);	    }	    return super.toString();	}
protected String getFieldNameValueSeparator() {	    return fieldNameValueSeparator;	}
private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) {	    if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {	        return text;	    }	    if (timeToLive < 0) {	        throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another");	    }	    final int searchLength = searchList.length;	    final int replacementLength = replacementList.length;	    if (searchLength != replacementLength) {	        throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength);	    }	    final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];	    int textIndex = -1;	    int replaceIndex = -1;	    int tempIndex = -1;	    for (int i = 0; i < searchLength; i++) {	        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {	            continue;	        }	        tempIndex = text.indexOf(searchList[i]);	        if (tempIndex == -1) {	            noMoreMatchesForReplIndex[i] = true;	        } else {	            if (textIndex == -1 || tempIndex < textIndex) {	                textIndex = tempIndex;	                replaceIndex = i;	            }	        }	    }	    if (textIndex == -1) {	        return text;	    }	    int start = 0;	    int increase = 0;	    for (int i = 0; i < searchList.length; i++) {	        if (searchList[i] == null || replacementList[i] == null) {	            continue;	        }	        final int greater = replacementList[i].length() - searchList[i].length();	        if (greater > 0) {	            increase += 3 * greater;	        }	    }	    increase = Math.min(increase, text.length() / 5);	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (textIndex != -1) {	        for (int i = start; i < textIndex; i++) {	            buf.append(text.charAt(i));	        }	        buf.append(replacementList[replaceIndex]);	        start = textIndex + searchList[replaceIndex].length();	        textIndex = -1;	        replaceIndex = -1;	        tempIndex = -1;	        for (int i = 0; i < searchLength; i++) {	            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {	                continue;	            }	            tempIndex = text.indexOf(searchList[i], start);	            if (tempIndex == -1) {	                noMoreMatchesForReplIndex[i] = true;	            } else {	                if (textIndex == -1 || tempIndex < textIndex) {	                    textIndex = tempIndex;	                    replaceIndex = i;	                }	            }	        }	    }	    final int textLength = text.length();	    for (int i = start; i < textLength; i++) {	        buf.append(text.charAt(i));	    }	    final String result = buf.toString();	    if (!repeat) {	        return result;	    }	    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);	}
public String getNewLineText() {	    return newLine;	}
public static StrTokenizer getCSVInstance(final char[] input) {	    final StrTokenizer tok = getCSVClone();	    tok.reset(input);	    return tok;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
private static Date add(final Date date, final int calendarField, final int amount) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final Calendar c = Calendar.getInstance();	    c.setTime(date);	    c.add(calendarField, amount);	    return c.getTime();	}
public String getNullText() {	    return nullText;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static boolean containsIgnoreCase(final CharSequence str, final CharSequence searchStr) {	    if (str == null || searchStr == null) {	        return false;	    }	    final int len = searchStr.length();	    final int max = str.length() - len;	    for (int i = 0; i <= max; i++) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, len)) {	            return true;	        }	    }	    return false;	}
public EqualsBuilder appendSuper(final boolean superEquals) {	    if (isEquals == false) {	        return this;	    }	    isEquals = superEquals;	    return this;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
@Override	public long skip(long n) {	    if (pos + n > StrBuilder.this.size()) {	        n = StrBuilder.this.size() - pos;	    }	    if (n < 0) {	        return 0;	    }	    pos += n;	    return n;	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
public boolean contains(final StrMatcher matcher) {	    return indexOf(matcher, 0) >= 0;	}
protected String getSummaryObjectStartText() {	    return summaryObjectStartText;	}
public String getNullText() {	    return nullText;	}
private static Date set(final Date date, final int calendarField, final int amount) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final Calendar c = Calendar.getInstance();	    c.setLenient(false);	    c.setTime(date);	    c.set(calendarField, amount);	    return c.getTime();	}
public int toHashCode() {	    return iTotal;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static short[] removeElement(final short[] array, final short element) {	    final int index = indexOf(array, element);	    if (index == INDEX_NOT_FOUND) {	        return clone(array);	    }	    return remove(array, index);	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
public static Date ceiling(final Object date, final int field) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (date instanceof Date) {	        return ceiling((Date) date, field);	    } else if (date instanceof Calendar) {	        return ceiling((Calendar) date, field).getTime();	    } else {	        throw new ClassCastException("Could not find ceiling of for type: " + date.getClass());	    }	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public static Calendar toCalendar(final Date date) {	    final Calendar c = Calendar.getInstance();	    c.setTime(date);	    return c;	}
public static ConcurrentException extractCause(final ExecutionException ex) {	    if (ex == null || ex.getCause() == null) {	        return null;	    }	    throwCause(ex);	    return new ConcurrentException(ex.getMessage(), ex.getCause());	}
@Override	public int compareTo(final Triple<L, M, R> other) {	    return new CompareToBuilder().append(getLeft(), other.getLeft()).append(getMiddle(), other.getMiddle()).append(getRight(), other.getRight()).toComparison();	}
public static String center(String str, final int size, String padStr) {	    if (str == null || size <= 0) {	        return str;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    str = leftPad(str, strLen + pads / 2, padStr);	    str = rightPad(str, size, padStr);	    return str;	}
@Override	public String next() {	    if (hasNext()) {	        return tokens[tokenPos++];	    }	    throw new NoSuchElementException();	}
public static String leftPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return leftPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return padStr.concat(str);	    } else if (pads < padLen) {	        return padStr.substring(0, pads).concat(str);	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return new String(padding).concat(str);	    }	}
public String getNewLineText() {	    return newLine;	}
public static String repeat(final char ch, final int repeat) {	    final char[] buf = new char[repeat];	    for (int i = repeat - 1; i >= 0; i--) {	        buf[i] = ch;	    }	    return new String(buf);	}
public static StrMatcher charSetMatcher(final String chars) {	    if (StringUtils.isEmpty(chars)) {	        return NONE_MATCHER;	    }	    if (chars.length() == 1) {	        return new CharMatcher(chars.charAt(0));	    }	    return new CharSetMatcher(chars.toCharArray());	}
public static char toChar(final String str, final char defaultValue) {	    if (StringUtils.isEmpty(str)) {	        return defaultValue;	    }	    return str.charAt(0);	}
public void subtract(final Number operand) {	    this.value -= operand.intValue();	}
public int capacity() {	    return buffer.length;	}
@Override	public Integer build() {	    return Integer.valueOf(toHashCode());	}
protected ScheduledFuture<?> startTimer() {	    return getExecutorService().scheduleAtFixedRate(new Runnable() {		        @Override	        public void run() {	            endOfPeriod();	        }	    }, getPeriod(), getPeriod(), getUnit());	}
public int getProperNumerator() {	    return Math.abs(numerator % denominator);	}
public String getNullText() {	    return nullText;	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
@Override	public int length() {	    return size;	}
public String substring(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    return new String(buffer, startIndex, endIndex - startIndex);	}
public static int toInt(final String str, final int defaultValue) {	    if (str == null) {	        return defaultValue;	    }	    try {	        return Integer.parseInt(str);	    } catch (final NumberFormatException nfe) {	        return defaultValue;	    }	}
public static String abbreviateMiddle(final String str, final String middle, final int length) {	    if (isEmpty(str) || isEmpty(middle)) {	        return str;	    }	    if (length >= str.length() || length < middle.length() + 2) {	        return str;	    }	    final int targetSting = length - middle.length();	    final int startOffset = targetSting / 2 + targetSting % 2;	    final int endOffset = str.length() - targetSting / 2;	    final StringBuilder builder = new StringBuilder(length);	    builder.append(str.substring(0, startOffset));	    builder.append(middle);	    builder.append(str.substring(endOffset));	    return builder.toString();	}
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {	    if (array == null) {	        if (index != 0) {	            throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0");	        }	        final Object joinedArray = Array.newInstance(clss, 1);	        Array.set(joinedArray, 0, element);	        return joinedArray;	    }	    final int length = Array.getLength(array);	    if (index > length || index < 0) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(clss, length + 1);	    System.arraycopy(array, 0, result, 0, index);	    Array.set(result, index, element);	    if (index < length) {	        System.arraycopy(array, index, result, index + 1, length - index);	    }	    return result;	}
@Override	public int length() {	    return size;	}
public static int hexDigitMsb0ToInt(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return 0x0;	        case '1':	            return 0x8;	        case '2':	            return 0x4;	        case '3':	            return 0xC;	        case '4':	            return 0x2;	        case '5':	            return 0xA;	        case '6':	            return 0x6;	        case '7':	            return 0xE;	        case '8':	            return 0x1;	        case '9':	            return 0x9;	        case 'a':	        case 'A':	            return 0x5;	        case 'b':	        case 'B':	            return 0xD;	        case 'c':	        case 'C':	            return 0x3;	        case 'd':	        case 'D':	            return 0xB;	        case 'e':	        case 'E':	            return 0x7;	        case 'f':	        case 'F':	            return 0xF;	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
@Override	public int intValue() {	    return value;	}
@Deprecated	public static String chomp(final String str, final String separator) {	    return removeEnd(str, separator);	}
public static CharRange isNot(final char ch) {	    return new CharRange(ch, ch, true);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
@Override	public StringBuffer format(final Calendar calendar, final StringBuffer buf) {	    return applyRules(calendar, buf);	}
@Override	protected T initialize() throws Exception {	    return callable.call();	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
public static boolean containsAny(final CharSequence cs, final CharSequence searchChars) {	    if (searchChars == null) {	        return false;	    }	    return containsAny(cs, CharSequenceUtils.toCharArray(searchChars));	}
public static Object invokeExactStaticMethod(final Class<?> cls, final String methodName, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {	    if (args == null) {	        args = ArrayUtils.EMPTY_OBJECT_ARRAY;	    }	    final Class<?>[] parameterTypes = ClassUtils.toClass(args);	    return invokeExactStaticMethod(cls, methodName, args, parameterTypes);	}
public static Type[] getImplicitLowerBounds(final WildcardType wildcardType) {	    final Type[] bounds = wildcardType.getLowerBounds();	    return bounds.length == 0 ? new Type[] { null } : bounds;	}
@Override	public List<Object> getContextValues(final String label) {	    final List<Object> values = new ArrayList<Object>();	    for (final Pair<String, Object> pair : contextValues) {	        if (StringUtils.equals(label, pair.getKey())) {	            values.add(pair.getValue());	        }	    }	    return values;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public String getNullText() {	    return nullText;	}
public static StrMatcher charSetMatcher(final String chars) {	    if (StringUtils.isEmpty(chars)) {	        return NONE_MATCHER;	    }	    if (chars.length() == 1) {	        return new CharMatcher(chars.charAt(0));	    }	    return new CharSetMatcher(chars.toCharArray());	}
@Override	public T call() throws Exception {	    try {	        return initialize();	    } finally {	        if (execFinally != null) {	            execFinally.shutdown();	        }	    }	}
public void subtract(final Number operand) {	    this.value -= operand.byteValue();	}
public static <L, M, R> Triple<L, M, R> of(final L left, final M middle, final R right) {	    return new ImmutableTriple<L, M, R>(left, middle, right);	}
@Override	public TimeZone getTimeZone() {	    return timeZone;	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public static <T> T deserialize(final byte[] objectData) {	    if (objectData == null) {	        throw new IllegalArgumentException("The byte[] must not be null");	    }	    return SerializationUtils.<T>deserialize(new ByteArrayInputStream(objectData));	}
public static String getShortClassName(String className) {	    if (StringUtils.isEmpty(className)) {	        return StringUtils.EMPTY;	    }	    final StringBuilder arrayPrefix = new StringBuilder();	    if (className.startsWith("[")) {	        while (className.charAt(0) == '[') {	            className = className.substring(1);	            arrayPrefix.append("[]");	        }	        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {	            className = className.substring(1, className.length() - 1);	        }	        if (reverseAbbreviationMap.containsKey(className)) {	            className = reverseAbbreviationMap.get(className);	        }	    }	    final int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);	    final int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);	    String out = className.substring(lastDotIdx + 1);	    if (innerIdx != -1) {	        out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);	    }	    return out + arrayPrefix;	}
public static String replacePattern(final String source, final String regex, final String replacement) {	    return Pattern.compile(regex, Pattern.DOTALL).matcher(source).replaceAll(replacement);	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public static <T extends CharSequence> T defaultIfEmpty(final T str, final T defaultStr) {	    return StringUtils.isEmpty(str) ? defaultStr : str;	}
public int size() {	    return size;	}
public static Locale toLocale(final String str) {	    if (str == null) {	        return null;	    }	    if (str.contains("#")) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final int len = str.length();	    if (len < 2) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final char ch0 = str.charAt(0);	    if (ch0 == '_') {	        if (len < 3) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        final char ch1 = str.charAt(1);	        final char ch2 = str.charAt(2);	        if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        if (len == 3) {	            return new Locale("", str.substring(1, 3));	        }	        if (len < 5) {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        if (str.charAt(3) != '_') {	            throw new IllegalArgumentException("Invalid locale format: " + str);	        }	        return new Locale("", str.substring(1, 3), str.substring(4));	    }	    final char ch1 = str.charAt(1);	    if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (len == 2) {	        return new Locale(str);	    }	    if (len < 5) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (str.charAt(2) != '_') {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    final char ch3 = str.charAt(3);	    if (ch3 == '_') {	        return new Locale(str.substring(0, 2), "", str.substring(4));	    }	    final char ch4 = str.charAt(4);	    if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (len == 5) {	        return new Locale(str.substring(0, 2), str.substring(3, 5));	    }	    if (len < 7) {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    if (str.charAt(5) != '_') {	        throw new IllegalArgumentException("Invalid locale format: " + str);	    }	    return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));	}
public boolean isEmpty() {	    return size == 0;	}
public HashCodeBuilder append(final short[] array) {	    if (array == null) {	        iTotal = iTotal * iConstant;	    } else {	        for (final short element : array) {	            append(element);	        }	    }	    return this;	}
@Override	public float floatValue() {	    return (float) numerator / (float) denominator;	}
public static boolean isNumericSpace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isDigit(cs.charAt(i)) == false && cs.charAt(i) != ' ') {	            return false;	        }	    }	    return true;	}
public static String capitalizeFully(String str, final char... delimiters) {	    final int delimLen = delimiters == null ? -1 : delimiters.length;	    if (StringUtils.isEmpty(str) || delimLen == 0) {	        return str;	    }	    str = str.toLowerCase();	    return capitalize(str, delimiters);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static boolean isAlpha(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static int indexOfDifference(final CharSequence... css) {	    if (css == null || css.length <= 1) {	        return INDEX_NOT_FOUND;	    }	    boolean anyStringNull = false;	    boolean allStringsNull = true;	    final int arrayLen = css.length;	    int shortestStrLen = Integer.MAX_VALUE;	    int longestStrLen = 0;	    for (int i = 0; i < arrayLen; i++) {	        if (css[i] == null) {	            anyStringNull = true;	            shortestStrLen = 0;	        } else {	            allStringsNull = false;	            shortestStrLen = Math.min(css[i].length(), shortestStrLen);	            longestStrLen = Math.max(css[i].length(), longestStrLen);	        }	    }	    if (allStringsNull || longestStrLen == 0 && !anyStringNull) {	        return INDEX_NOT_FOUND;	    }	    if (shortestStrLen == 0) {	        return 0;	    }	    int firstDiff = -1;	    for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {	        final char comparisonChar = css[0].charAt(stringPos);	        for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {	            if (css[arrayPos].charAt(stringPos) != comparisonChar) {	                firstDiff = stringPos;	                break;	            }	        }	        if (firstDiff != -1) {	            break;	        }	    }	    if (firstDiff == -1 && shortestStrLen != longestStrLen) {	        return shortestStrLen;	    }	    return firstDiff;	}
public int size() {	    return size;	}
public static String toString(final Object obj, final String nullStr) {	    return obj == null ? nullStr : obj.toString();	}
@Override	public void mark(final int readAheadLimit) {	    mark = pos;	}
public String getNullText() {	    return nullText;	}
public static Boolean[] nullToEmpty(final Boolean[] array) {	    if (array == null || array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    return array;	}
public StringBuilder toStringBuilder() {	    return new StringBuilder(size).append(buffer, 0, size);	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return new boolean[] { false, false, false, false };	        case '1':	            return new boolean[] { false, false, false, true };	        case '2':	            return new boolean[] { false, false, true, false };	        case '3':	            return new boolean[] { false, false, true, true };	        case '4':	            return new boolean[] { false, true, false, false };	        case '5':	            return new boolean[] { false, true, false, true };	        case '6':	            return new boolean[] { false, true, true, false };	        case '7':	            return new boolean[] { false, true, true, true };	        case '8':	            return new boolean[] { true, false, false, false };	        case '9':	            return new boolean[] { true, false, false, true };	        case 'a':	        case 'A':	            return new boolean[] { true, false, true, false };	        case 'b':	        case 'B':	            return new boolean[] { true, false, true, true };	        case 'c':	        case 'C':	            return new boolean[] { true, true, false, false };	        case 'd':	        case 'D':	            return new boolean[] { true, true, false, true };	        case 'e':	        case 'E':	            return new boolean[] { true, true, true, false };	        case 'f':	        case 'F':	            return new boolean[] { true, true, true, true };	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public void appendEnd(final StringBuffer buffer, final Object object) {	    if (this.fieldSeparatorAtEnd == false) {	        removeLastFieldSeparator(buffer);	    }	    appendContentEnd(buffer);	    unregister(object);	}
public static boolean containsAny(final String str, final String... set) {	    if (StringUtils.isEmpty(str) || deepEmpty(set)) {	        return false;	    }	    final CharSet chars = CharSet.getInstance(set);	    for (final char c : str.toCharArray()) {	        if (chars.contains(c)) {	            return true;	        }	    }	    return false;	}
public static boolean[] removeElements(final boolean[] array, final boolean... values) {	    if (isEmpty(array) || isEmpty(values)) {	        return clone(array);	    }	    final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2);	    for (final boolean v : values) {	        final Boolean boxed = Boolean.valueOf(v);	        final MutableInt count = occurrences.get(boxed);	        if (count == null) {	            occurrences.put(boxed, new MutableInt(1));	        } else {	            count.increment();	        }	    }	    final BitSet toRemove = new BitSet();	    for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) {	        final Boolean v = e.getKey();	        int found = 0;	        for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {	            found = indexOf(array, v.booleanValue(), found);	            if (found < 0) {	                break;	            }	            toRemove.set(found++);	        }	    }	    return (boolean[]) removeAll(array, toRemove);	}
protected boolean isDefaultFullDetail() {	    return defaultFullDetail;	}
public static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes) {	    if (0 == nBytes) {	        return dst;	    }	    if (nBytes > 16) {	        throw new IllegalArgumentException("nBytes is greather than 16");	    }	    longToByteArray(src.getMostSignificantBits(), 0, dst, dstPos, nBytes > 8 ? 8 : nBytes);	    if (nBytes >= 8) {	        longToByteArray(src.getLeastSignificantBits(), 0, dst, dstPos + 8, nBytes - 8);	    }	    return dst;	}
public static File getJavaHome() {	    return new File(System.getProperty(JAVA_HOME_KEY));	}
public static String getShortCanonicalName(final String canonicalName) {	    return ClassUtils.getShortClassName(getCanonicalName(canonicalName));	}
public String getNullText() {	    return nullText;	}
public String getNewLineText() {	    return newLine;	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public int indexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex < 0 ? 0 : startIndex);	    if (matcher == null || startIndex >= size) {	        return -1;	    }	    final int len = size;	    final char[] buf = buffer;	    for (int i = startIndex; i < len; i++) {	        if (matcher.isMatch(buf, i, startIndex, len) > 0) {	            return i;	        }	    }	    return -1;	}
public String getNullText() {	    return nullText;	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
static boolean containsTokenWithValue(final Token[] tokens, final Object value) {	    final int sz = tokens.length;	    for (int i = 0; i < sz; i++) {	        if (tokens[i].getValue() == value) {	            return true;	        }	    }	    return false;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static String overlay(final String str, String overlay, int start, int end) {	    if (str == null) {	        return null;	    }	    if (overlay == null) {	        overlay = EMPTY;	    }	    final int len = str.length();	    if (start < 0) {	        start = 0;	    }	    if (start > len) {	        start = len;	    }	    if (end < 0) {	        end = 0;	    }	    if (end > len) {	        end = len;	    }	    if (start > end) {	        final int temp = start;	        start = end;	        end = temp;	    }	    return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString();	}
public int size() {	    return size;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public static float min(final float a, final float b, final float c) {	    return Math.min(Math.min(a, b), c);	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static Type[] normalizeUpperBounds(final Type[] bounds) {	    if (bounds.length < 2) {	        return bounds;	    }	    final Set<Type> types = new HashSet<Type>(bounds.length);	    for (final Type type1 : bounds) {	        boolean subtypeFound = false;	        for (final Type type2 : bounds) {	            if (type1 != type2 && isAssignable(type2, type1, null)) {	                subtypeFound = true;	                break;	            }	        }	        if (!subtypeFound) {	            types.add(type1);	        }	    }	    return types.toArray(new Type[types.size()]);	}
public static float min(final float a, final float b, final float c) {	    return Math.min(Math.min(a, b), c);	}
public boolean isEquals() {	    return this.isEquals;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
@Override	public void write(final String str, final int off, final int len) {	    StrBuilder.this.append(str, off, len);	}
@Override	public Integer build() {	    return Integer.valueOf(toHashCode());	}
protected boolean isArrayContentDetail() {	    return arrayContentDetail;	}
public String getNewLineText() {	    return newLine;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static String removePattern(final String source, final String regex) {	    return replacePattern(source, regex, StringUtils.EMPTY);	}
public StrBuilder setNewLineText(final String newLine) {	    this.newLine = newLine;	    return this;	}
public String getNullText() {	    return nullText;	}
public static <T extends Comparable<? super T>> T max(final T... values) {	    T result = null;	    if (values != null) {	        for (final T value : values) {	            if (compare(value, result, false) > 0) {	                result = value;	            }	        }	    }	    return result;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static String capitalize(final String str, final char... delimiters) {	    final int delimLen = delimiters == null ? -1 : delimiters.length;	    if (StringUtils.isEmpty(str) || delimLen == 0) {	        return str;	    }	    final char[] buffer = str.toCharArray();	    boolean capitalizeNext = true;	    for (int i = 0; i < buffer.length; i++) {	        final char ch = buffer[i];	        if (isDelimiter(ch, delimiters)) {	            capitalizeNext = true;	        } else if (capitalizeNext) {	            buffer[i] = Character.toTitleCase(ch);	            capitalizeNext = false;	        }	    }	    return new String(buffer);	}
public static String getCommonPrefix(final String... strs) {	    if (strs == null || strs.length == 0) {	        return EMPTY;	    }	    final int smallestIndexOfDiff = indexOfDifference(strs);	    if (smallestIndexOfDiff == INDEX_NOT_FOUND) {	        if (strs[0] == null) {	            return EMPTY;	        }	        return strs[0];	    } else if (smallestIndexOfDiff == 0) {	        return EMPTY;	    } else {	        return strs[0].substring(0, smallestIndexOfDiff);	    }	}
public static boolean startsWithAny(final CharSequence string, final CharSequence... searchStrings) {	    if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {	        return false;	    }	    for (final CharSequence searchString : searchStrings) {	        if (StringUtils.startsWith(string, searchString)) {	            return true;	        }	    }	    return false;	}
public static CharRange is(final char ch) {	    return new CharRange(ch, ch, false);	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
public static float min(final float a, final float b, final float c) {	    return Math.min(Math.min(a, b), c);	}
@Override	public long longValue() {	    return value;	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    final int seqEnd = input.length();	    if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') {	        int start = index + 2;	        boolean isHex = false;	        final char firstChar = input.charAt(start);	        if (firstChar == 'x' || firstChar == 'X') {	            start++;	            isHex = true;	            if (start == seqEnd) {	                return 0;	            }	        }	        int end = start;	        while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) {	            end++;	        }	        final boolean semiNext = end != seqEnd && input.charAt(end) == ';';	        if (!semiNext) {	            if (isSet(OPTION.semiColonRequired)) {	                return 0;	            } else if (isSet(OPTION.errorIfNoSemiColon)) {	                throw new IllegalArgumentException("Semi-colon required at end of numeric entity");	            }	        }	        int entityValue;	        try {	            if (isHex) {	                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);	            } else {	                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);	            }	        } catch (final NumberFormatException nfe) {	            return 0;	        }	        if (entityValue > 0xFFFF) {	            final char[] chrs = Character.toChars(entityValue);	            out.write(chrs[0]);	            out.write(chrs[1]);	        } else {	            out.write(entityValue);	        }	        return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0);	    }	    return 0;	}
@Override	public StringBuffer format(final Calendar calendar, final StringBuffer buf) {	    return applyRules(calendar, buf);	}
public static <T extends CharSequence> T defaultIfBlank(final T str, final T defaultStr) {	    return StringUtils.isBlank(str) ? defaultStr : str;	}
@Override	public int length() {	    return size;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public CompareToBuilder appendSuper(final int superCompareTo) {	    if (comparison != 0) {	        return this;	    }	    comparison = superCompareTo;	    return this;	}
static JavaVersion get(final String nom) {	    if ("0.9".equals(nom)) {	        return JAVA_0_9;	    } else if ("1.1".equals(nom)) {	        return JAVA_1_1;	    } else if ("1.2".equals(nom)) {	        return JAVA_1_2;	    } else if ("1.3".equals(nom)) {	        return JAVA_1_3;	    } else if ("1.4".equals(nom)) {	        return JAVA_1_4;	    } else if ("1.5".equals(nom)) {	        return JAVA_1_5;	    } else if ("1.6".equals(nom)) {	        return JAVA_1_6;	    } else if ("1.7".equals(nom)) {	        return JAVA_1_7;	    } else if ("1.8".equals(nom)) {	        return JAVA_1_8;	    } else {	        return null;	    }	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public int capacity() {	    return buffer.length;	}
public static NumericEntityEscaper below(final int codepoint) {	    return outsideOf(codepoint, Integer.MAX_VALUE);	}
public static Date truncate(final Object date, final int field) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (date instanceof Date) {	        return truncate((Date) date, field);	    } else if (date instanceof Calendar) {	        return truncate((Calendar) date, field).getTime();	    } else {	        throw new ClassCastException("Could not truncate " + date);	    }	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
private static Date set(final Date date, final int calendarField, final int amount) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final Calendar c = Calendar.getInstance();	    c.setLenient(false);	    c.setTime(date);	    c.set(calendarField, amount);	    return c.getTime();	}
public static String lowerCase(final String str, final Locale locale) {	    if (str == null) {	        return null;	    }	    return str.toLowerCase(locale);	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
protected String getArrayEnd() {	    return arrayEnd;	}
public static String getPackageName(String className) {	    if (StringUtils.isEmpty(className)) {	        return StringUtils.EMPTY;	    }	    while (className.charAt(0) == '[') {	        className = className.substring(1);	    }	    if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {	        className = className.substring(1);	    }	    final int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);	    if (i == -1) {	        return StringUtils.EMPTY;	    }	    return className.substring(0, i);	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
static int lastIndexOf(final CharSequence cs, final CharSequence searchChar, final int start) {	    return cs.toString().lastIndexOf(searchChar.toString(), start);	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
@Override	public Double getValue() {	    return Double.valueOf(this.value);	}
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) {	    if (bool == null) {	        return nullValue;	    }	    return bool.booleanValue() ? trueValue : falseValue;	}
@Override	public int compare(final Object obj1, final Object obj2) {	    return ((Comparable) obj1).compareTo(obj2);	}
public static String center(String str, final int size, String padStr) {	    if (str == null || size <= 0) {	        return str;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    str = leftPad(str, strLen + pads / 2, padStr);	    str = rightPad(str, size, padStr);	    return str;	}
@Override	public int length() {	    return size;	}
public final void translate(final CharSequence input, final Writer out) throws IOException {	    if (out == null) {	        throw new IllegalArgumentException("The Writer must not be null");	    }	    if (input == null) {	        return;	    }	    int pos = 0;	    final int len = input.length();	    while (pos < len) {	        final int consumed = translate(input, pos, out);	        if (consumed == 0) {	            final char[] c = Character.toChars(Character.codePointAt(input, pos));	            out.write(c);	            pos += c.length;	            continue;	        }	        for (int pt = 0; pt < consumed; pt++) {	            pos += Character.charCount(Character.codePointAt(input, pt));	        }	    }	}
public String getNewLineText() {	    return newLine;	}
public static String random(final int count, final char... chars) {	    if (chars == null) {	        return random(count, 0, 0, false, false, null, RANDOM);	    }	    return random(count, 0, chars.length, false, false, chars, RANDOM);	}
protected boolean isUseClassName() {	    return useClassName;	}
public static CharRange is(final char ch) {	    return new CharRange(ch, ch, false);	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public Reader asReader() {	    return new StrBuilderReader();	}
@Override	public Date parse(final String source, final ParsePosition pos) {	    return parser.parse(source, pos);	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof MutableLong) {	        return value == ((MutableLong) obj).longValue();	    }	    return false;	}
public Fraction abs() {	    if (numerator >= 0) {	        return this;	    }	    return negate();	}
@Override	public int length() {	    return size;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public boolean isEquals() {	    return this.isEquals;	}
public int size() {	    return size;	}
public StrBuilder appendNewLine() {	    if (newLine == null) {	        append(SystemUtils.LINE_SEPARATOR);	        return this;	    }	    return append(newLine);	}
public static String removeStart(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.startsWith(remove)) {	        return str.substring(remove.length());	    }	    return str;	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
public int size() {	    return size;	}
public Float toFloat() {	    return Float.valueOf(floatValue());	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
protected String getArrayEnd() {	    return arrayEnd;	}
public final void translate(final CharSequence input, final Writer out) throws IOException {	    if (out == null) {	        throw new IllegalArgumentException("The Writer must not be null");	    }	    if (input == null) {	        return;	    }	    int pos = 0;	    final int len = input.length();	    while (pos < len) {	        final int consumed = translate(input, pos, out);	        if (consumed == 0) {	            final char[] c = Character.toChars(Character.codePointAt(input, pos));	            out.write(c);	            pos += c.length;	            continue;	        }	        for (int pt = 0; pt < consumed; pt++) {	            pos += Character.charCount(Character.codePointAt(input, pt));	        }	    }	}
@Override	public short shortValue() {	    return value;	}
public StrBuilder deleteFirst(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, 1);	}
public int size() {	    return size;	}
public StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, 1);	}
@Override	public int read(final char[] b, final int off, int len) {	    if (off < 0 || len < 0 || off > b.length || (off + len) > b.length || (off + len) < 0) {	        throw new IndexOutOfBoundsException();	    }	    if (len == 0) {	        return 0;	    }	    if (pos >= StrBuilder.this.size()) {	        return -1;	    }	    if (pos + len > size()) {	        len = StrBuilder.this.size() - pos;	    }	    StrBuilder.this.getChars(pos, pos + len, b, off);	    pos += len;	    return len;	}
public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) {	    String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'");	    if (suppressLeadingZeroElements) {	        duration = " " + duration;	        String tmp = StringUtils.replaceOnce(duration, " 0 days", "");	        if (tmp.length() != duration.length()) {	            duration = tmp;	            tmp = StringUtils.replaceOnce(duration, " 0 hours", "");	            if (tmp.length() != duration.length()) {	                duration = tmp;	                tmp = StringUtils.replaceOnce(duration, " 0 minutes", "");	                duration = tmp;	                if (tmp.length() != duration.length()) {	                    duration = StringUtils.replaceOnce(tmp, " 0 seconds", "");	                }	            }	        }	        if (duration.length() != 0) {	            duration = duration.substring(1);	        }	    }	    if (suppressTrailingZeroElements) {	        String tmp = StringUtils.replaceOnce(duration, " 0 seconds", "");	        if (tmp.length() != duration.length()) {	            duration = tmp;	            tmp = StringUtils.replaceOnce(duration, " 0 minutes", "");	            if (tmp.length() != duration.length()) {	                duration = tmp;	                tmp = StringUtils.replaceOnce(duration, " 0 hours", "");	                if (tmp.length() != duration.length()) {	                    duration = StringUtils.replaceOnce(tmp, " 0 days", "");	                }	            }	        }	    }	    duration = " " + duration;	    duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second");	    duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute");	    duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour");	    duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day");	    return duration.trim();	}
public static String capitalize(final String str, final char... delimiters) {	    final int delimLen = delimiters == null ? -1 : delimiters.length;	    if (StringUtils.isEmpty(str) || delimLen == 0) {	        return str;	    }	    final char[] buffer = str.toCharArray();	    boolean capitalizeNext = true;	    for (int i = 0; i < buffer.length; i++) {	        final char ch = buffer[i];	        if (isDelimiter(ch, delimiters)) {	            capitalizeNext = true;	        } else if (capitalizeNext) {	            buffer[i] = Character.toTitleCase(ch);	            capitalizeNext = false;	        }	    }	    return new String(buffer);	}
public static String repeat(final char ch, final int repeat) {	    final char[] buf = new char[repeat];	    for (int i = repeat - 1; i >= 0; i--) {	        buf[i] = ch;	    }	    return new String(buf);	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static Method getAccessibleMethod(Method method) {	    if (!MemberUtils.isAccessible(method)) {	        return null;	    }	    final Class<?> cls = method.getDeclaringClass();	    if (Modifier.isPublic(cls.getModifiers())) {	        return method;	    }	    final String methodName = method.getName();	    final Class<?>[] parameterTypes = method.getParameterTypes();	    method = getAccessibleMethodFromInterfaceNest(cls, methodName, parameterTypes);	    if (method == null) {	        method = getAccessibleMethodFromSuperclass(cls, methodName, parameterTypes);	    }	    return method;	}
public static String prependIfMissing(final String str, final CharSequence prefix, final CharSequence... prefixes) {	    return prependIfMissing(str, prefix, false, prefixes);	}
public static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools) {	    if ((src.length == 0 && srcPos == 0) || 0 == nBools) {	        return dstInit;	    }	    if (nBools - 1 + dstPos >= 16) {	        throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 16");	    }	    short out = dstInit;	    int shift = 0;	    for (int i = 0; i < nBools; i++) {	        shift = i * 1 + dstPos;	        final int bits = (src[i + srcPos] ? 1 : 0) << shift;	        final int mask = 0x1 << shift;	        out = (short) ((out & ~mask) | bits);	    }	    return out;	}
@Override	public TimeZone getTimeZone() {	    return mTimeZone;	}
public static Boolean[] nullToEmpty(final Boolean[] array) {	    if (array == null || array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    return array;	}
public static <T> T invokeConstructor(final Class<T> cls, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {	    if (parameterTypes == null) {	        parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;	    }	    if (args == null) {	        args = ArrayUtils.EMPTY_OBJECT_ARRAY;	    }	    final Constructor<T> ctor = getMatchingAccessibleConstructor(cls, parameterTypes);	    if (ctor == null) {	        throw new NoSuchMethodException("No such accessible constructor on object: " + cls.getName());	    }	    return ctor.newInstance(args);	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public int size() {	    return size;	}
public static String formatUTC(final Date date, final String pattern, final Locale locale) {	    return format(date, pattern, UTC_TIME_ZONE, locale);	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
@Override	public boolean markSupported() {	    return true;	}
public byte clearByte(final byte holder) {	    return (byte) clear(holder);	}
@Override	public StringBuffer format(final Calendar calendar, final StringBuffer buf) {	    return applyRules(calendar, buf);	}
@Override	public int length() {	    return size;	}
public static <T extends CharSequence> T validIndex(final T chars, final int index) {	    return validIndex(chars, index, DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE, Integer.valueOf(index));	}
@Override	public int intValue() {	    return numerator / denominator;	}
@Override	public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) {	    return buffer[pos] <= 32 ? 1 : 0;	}
@Override	public int read(final char[] b, final int off, int len) {	    if (off < 0 || len < 0 || off > b.length || (off + len) > b.length || (off + len) < 0) {	        throw new IndexOutOfBoundsException();	    }	    if (len == 0) {	        return 0;	    }	    if (pos >= StrBuilder.this.size()) {	        return -1;	    }	    if (pos + len > size()) {	        len = StrBuilder.this.size() - pos;	    }	    StrBuilder.this.getChars(pos, pos + len, b, off);	    pos += len;	    return len;	}
public static String randomAlphanumeric(final int count) {	    return random(count, true, true);	}
protected String getSummaryObjectEndText() {	    return summaryObjectEndText;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static int indexOfAnyBut(final CharSequence seq, final CharSequence searchChars) {	    if (isEmpty(seq) || isEmpty(searchChars)) {	        return INDEX_NOT_FOUND;	    }	    final int strLen = seq.length();	    for (int i = 0; i < strLen; i++) {	        final char ch = seq.charAt(i);	        final boolean chFound = CharSequenceUtils.indexOf(searchChars, ch, 0) >= 0;	        if (i + 1 < strLen && Character.isHighSurrogate(ch)) {	            final char ch2 = seq.charAt(i + 1);	            if (chFound && CharSequenceUtils.indexOf(searchChars, ch2, 0) < 0) {	                return i;	            }	        } else {	            if (!chFound) {	                return i;	            }	        }	    }	    return INDEX_NOT_FOUND;	}
@Override	public int intValue() {	    return (int) value;	}
@Override	public boolean equals(final Object obj) {	    if (obj == this) {	        return true;	    }	    if (obj instanceof Map.Entry<?, ?>) {	        final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;	        return ObjectUtils.equals(getKey(), other.getKey()) && ObjectUtils.equals(getValue(), other.getValue());	    }	    return false;	}
public boolean isEmpty() {	    return size == 0;	}
public StrBuilder trim() {	    if (size == 0) {	        return this;	    }	    int len = size;	    final char[] buf = buffer;	    int pos = 0;	    while (pos < len && buf[pos] <= ' ') {	        pos++;	    }	    while (pos < len && buf[len - 1] <= ' ') {	        len--;	    }	    if (len < size) {	        delete(len, size);	    }	    if (pos > 0) {	        delete(0, pos);	    }	    return this;	}
public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) {	    String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'");	    if (suppressLeadingZeroElements) {	        duration = " " + duration;	        String tmp = StringUtils.replaceOnce(duration, " 0 days", "");	        if (tmp.length() != duration.length()) {	            duration = tmp;	            tmp = StringUtils.replaceOnce(duration, " 0 hours", "");	            if (tmp.length() != duration.length()) {	                duration = tmp;	                tmp = StringUtils.replaceOnce(duration, " 0 minutes", "");	                duration = tmp;	                if (tmp.length() != duration.length()) {	                    duration = StringUtils.replaceOnce(tmp, " 0 seconds", "");	                }	            }	        }	        if (duration.length() != 0) {	            duration = duration.substring(1);	        }	    }	    if (suppressTrailingZeroElements) {	        String tmp = StringUtils.replaceOnce(duration, " 0 seconds", "");	        if (tmp.length() != duration.length()) {	            duration = tmp;	            tmp = StringUtils.replaceOnce(duration, " 0 minutes", "");	            if (tmp.length() != duration.length()) {	                duration = tmp;	                tmp = StringUtils.replaceOnce(duration, " 0 hours", "");	                if (tmp.length() != duration.length()) {	                    duration = StringUtils.replaceOnce(tmp, " 0 days", "");	                }	            }	        }	    }	    duration = " " + duration;	    duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second");	    duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute");	    duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour");	    duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day");	    return duration.trim();	}
public static String leftPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return leftPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return padStr.concat(str);	    } else if (pads < padLen) {	        return padStr.substring(0, pads).concat(str);	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return new String(padding).concat(str);	    }	}
public StrBuilder deleteCharAt(final int index) {	    if (index < 0 || index >= size) {	        throw new StringIndexOutOfBoundsException(index);	    }	    deleteImpl(index, index + 1, 1);	    return this;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] result = new boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        final Boolean b = array[i];	        result[i] = (b == null ? valueForNull : b.booleanValue());	    }	    return result;	}
public static Long createLong(final String str) {	    if (str == null) {	        return null;	    }	    return Long.decode(str);	}
public int size() {	    return size;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public StrBuilder minimizeCapacity() {	    if (buffer.length > length()) {	        final char[] old = buffer;	        buffer = new char[length()];	        System.arraycopy(old, 0, buffer, 0, size);	    }	    return this;	}
public static <T> T CONST(final T v) {	    return v;	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase) {	    if (str == null || prefix == null) {	        return str == null && prefix == null;	    }	    if (prefix.length() > str.length()) {	        return false;	    }	    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());	}
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) {	    return new Range<T>(fromInclusive, toInclusive, comparator);	}
public StrSubstitutor setVariablePrefix(final String prefix) {	    if (prefix == null) {	        throw new IllegalArgumentException("Variable prefix must not be null!");	    }	    return setVariablePrefixMatcher(StrMatcher.stringMatcher(prefix));	}
public static String capitalize(final String str, final char... delimiters) {	    final int delimLen = delimiters == null ? -1 : delimiters.length;	    if (StringUtils.isEmpty(str) || delimLen == 0) {	        return str;	    }	    final char[] buffer = str.toCharArray();	    boolean capitalizeNext = true;	    for (int i = 0; i < buffer.length; i++) {	        final char ch = buffer[i];	        if (isDelimiter(ch, delimiters)) {	            capitalizeNext = true;	        } else if (capitalizeNext) {	            buffer[i] = Character.toTitleCase(ch);	            capitalizeNext = false;	        }	    }	    return new String(buffer);	}
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return new boolean[] { false, false, false, false };	        case '1':	            return new boolean[] { false, false, false, true };	        case '2':	            return new boolean[] { false, false, true, false };	        case '3':	            return new boolean[] { false, false, true, true };	        case '4':	            return new boolean[] { false, true, false, false };	        case '5':	            return new boolean[] { false, true, false, true };	        case '6':	            return new boolean[] { false, true, true, false };	        case '7':	            return new boolean[] { false, true, true, true };	        case '8':	            return new boolean[] { true, false, false, false };	        case '9':	            return new boolean[] { true, false, false, true };	        case 'a':	        case 'A':	            return new boolean[] { true, false, true, false };	        case 'b':	        case 'B':	            return new boolean[] { true, false, true, true };	        case 'c':	        case 'C':	            return new boolean[] { true, true, false, false };	        case 'd':	        case 'D':	            return new boolean[] { true, true, false, true };	        case 'e':	        case 'E':	            return new boolean[] { true, true, true, false };	        case 'f':	        case 'F':	            return new boolean[] { true, true, true, true };	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) {	    style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));	    return this;	}
public static String leftPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return leftPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return padStr.concat(str);	    } else if (pads < padLen) {	        return padStr.substring(0, pads).concat(str);	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return new String(padding).concat(str);	    }	}
public String getNullText() {	    return nullText;	}
private static String[] splitByCharacterType(final String str, final boolean camelCase) {	    if (str == null) {	        return null;	    }	    if (str.isEmpty()) {	        return ArrayUtils.EMPTY_STRING_ARRAY;	    }	    final char[] c = str.toCharArray();	    final List<String> list = new ArrayList<String>();	    int tokenStart = 0;	    int currentType = Character.getType(c[tokenStart]);	    for (int pos = tokenStart + 1; pos < c.length; pos++) {	        final int type = Character.getType(c[pos]);	        if (type == currentType) {	            continue;	        }	        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {	            final int newTokenStart = pos - 1;	            if (newTokenStart != tokenStart) {	                list.add(new String(c, tokenStart, newTokenStart - tokenStart));	                tokenStart = newTokenStart;	            }	        } else {	            list.add(new String(c, tokenStart, pos - tokenStart));	            tokenStart = pos;	        }	        currentType = type;	    }	    list.add(new String(c, tokenStart, c.length - tokenStart));	    return list.toArray(new String[list.size()]);	}
protected String getSizeStartText() {	    return sizeStartText;	}
public static String keep(final String str, final String... set) {	    if (str == null) {	        return null;	    }	    if (str.isEmpty() || deepEmpty(set)) {	        return StringUtils.EMPTY;	    }	    return modify(str, set, true);	}
public void appendStart(final StringBuffer buffer, final Object object) {	    if (object != null) {	        appendClassName(buffer, object);	        appendIdentityHashCode(buffer, object);	        appendContentStart(buffer);	        if (fieldSeparatorAtStart) {	            appendFieldSeparator(buffer);	        }	    }	}
public static Integer toIntegerObject(final Boolean bool, final Integer trueValue, final Integer falseValue, final Integer nullValue) {	    if (bool == null) {	        return nullValue;	    }	    return bool.booleanValue() ? trueValue : falseValue;	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
@Override	public void mark(final int readAheadLimit) {	    mark = pos;	}
public static float min(final float a, final float b, final float c) {	    return Math.min(Math.min(a, b), c);	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
protected String getSizeEndText() {	    return sizeEndText;	}
public String midString(int index, final int length) {	    if (index < 0) {	        index = 0;	    }	    if (length <= 0 || index >= size) {	        return "";	    }	    if (size <= index + length) {	        return new String(buffer, index, size - index);	    }	    return new String(buffer, index, length);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static Throwable getRootCause(final Throwable throwable) {	    final List<Throwable> list = getThrowableList(throwable);	    return list.size() < 2 ? null : (Throwable) list.get(list.size() - 1);	}
static Object removeAll(final Object array, final BitSet indices) {	    final int srcLength = ArrayUtils.getLength(array);	    final int removals = indices.cardinality();	    final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals);	    int srcIndex = 0;	    int destIndex = 0;	    int count;	    int set;	    while ((set = indices.nextSetBit(srcIndex)) != -1) {	        count = set - srcIndex;	        if (count > 0) {	            System.arraycopy(array, srcIndex, result, destIndex, count);	            destIndex += count;	        }	        srcIndex = indices.nextClearBit(set);	    }	    count = srcLength - srcIndex;	    if (count > 0) {	        System.arraycopy(array, srcIndex, result, destIndex, count);	    }	    return result;	}
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] result = new boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        final Boolean b = array[i];	        result[i] = (b == null ? valueForNull : b.booleanValue());	    }	    return result;	}
public int size() {	    return size;	}
public static CharSequence subSequence(final CharSequence cs, final int start) {	    return cs == null ? null : cs.subSequence(start, cs.length());	}
@Override	public String toString() {	    if (tokens == null) {	        return "StrTokenizer[not tokenized yet]";	    }	    return "StrTokenizer" + getTokenList();	}
int getCount() {	    return count;	}
public static boolean isSameLength(final boolean[] array1, final boolean[] array2) {	    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {	        return false;	    }	    return true;	}
public static <T> T defaultIfNull(final T object, final T defaultValue) {	    return object != null ? object : defaultValue;	}
@Override	public int hashCode() {	    return toHashCode();	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public StrBuilder reverse() {	    if (size == 0) {	        return this;	    }	    final int half = size / 2;	    final char[] buf = buffer;	    for (int leftIdx = 0, rightIdx = size - 1; leftIdx < half; leftIdx++, rightIdx--) {	        final char swap = buf[leftIdx];	        buf[leftIdx] = buf[rightIdx];	        buf[rightIdx] = swap;	    }	    return this;	}
public boolean isOverlappedBy(final Range<T> otherRange) {	    if (otherRange == null) {	        return false;	    }	    return otherRange.contains(minimum) || otherRange.contains(maximum) || contains(otherRange.minimum);	}
public int size() {	    return size;	}
@Override	public int hashCode() {	    return value;	}
protected String getContentEnd() {	    return contentEnd;	}
public int capacity() {	    return buffer.length;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public int capacity() {	    return buffer.length;	}
public static String repeat(final char ch, final int repeat) {	    final char[] buf = new char[repeat];	    for (int i = repeat - 1; i >= 0; i--) {	        buf[i] = ch;	    }	    return new String(buf);	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
public int capacity() {	    return buffer.length;	}
public static boolean isEmpty(final boolean[] array) {	    return array == null || array.length == 0;	}
public StrBuilder deleteFirst(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, 1);	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
public int getValue(final int holder) {	    return getRawValue(holder) >> _shift_count;	}
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return new boolean[] { false, false, false, false };	        case '1':	            return new boolean[] { false, false, false, true };	        case '2':	            return new boolean[] { false, false, true, false };	        case '3':	            return new boolean[] { false, false, true, true };	        case '4':	            return new boolean[] { false, true, false, false };	        case '5':	            return new boolean[] { false, true, false, true };	        case '6':	            return new boolean[] { false, true, true, false };	        case '7':	            return new boolean[] { false, true, true, true };	        case '8':	            return new boolean[] { true, false, false, false };	        case '9':	            return new boolean[] { true, false, false, true };	        case 'a':	        case 'A':	            return new boolean[] { true, false, true, false };	        case 'b':	        case 'B':	            return new boolean[] { true, false, true, true };	        case 'c':	        case 'C':	            return new boolean[] { true, true, false, false };	        case 'd':	        case 'D':	            return new boolean[] { true, true, false, true };	        case 'e':	        case 'E':	            return new boolean[] { true, true, true, false };	        case 'f':	        case 'F':	            return new boolean[] { true, true, true, true };	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public static boolean[] removeElements(final boolean[] array, final boolean... values) {	    if (isEmpty(array) || isEmpty(values)) {	        return clone(array);	    }	    final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2);	    for (final boolean v : values) {	        final Boolean boxed = Boolean.valueOf(v);	        final MutableInt count = occurrences.get(boxed);	        if (count == null) {	            occurrences.put(boxed, new MutableInt(1));	        } else {	            count.increment();	        }	    }	    final BitSet toRemove = new BitSet();	    for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) {	        final Boolean v = e.getKey();	        int found = 0;	        for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {	            found = indexOf(array, v.booleanValue(), found);	            if (found < 0) {	                break;	            }	            toRemove.set(found++);	        }	    }	    return (boolean[]) removeAll(array, toRemove);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public StringBuffer getStringBuffer() {	    return buffer;	}
@Override	public Date parse(final String source, final ParsePosition pos) {	    final int offset = pos.getIndex();	    final Matcher matcher = parsePattern.matcher(source.substring(offset));	    if (!matcher.lookingAt()) {	        return null;	    }	    final Calendar cal = Calendar.getInstance(timeZone, locale);	    cal.clear();	    for (int i = 0; i < strategies.length; ) {	        final Strategy strategy = strategies[i++];	        strategy.setCalendar(this, cal, matcher.group(i));	    }	    pos.setIndex(offset + matcher.end());	    return cal.getTime();	}
protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart) {	    this.fieldSeparatorAtStart = fieldSeparatorAtStart;	}
public int lastIndexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex >= size ? size - 1 : startIndex);	    if (matcher == null || startIndex < 0) {	        return -1;	    }	    final char[] buf = buffer;	    final int endIndex = startIndex + 1;	    for (int i = startIndex; i >= 0; i--) {	        if (matcher.isMatch(buf, i, 0, endIndex) > 0) {	            return i;	        }	    }	    return -1;	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public static void matchesPattern(final CharSequence input, final String pattern, final String message, final Object... values) {	    if (Pattern.matches(pattern, input) == false) {	        throw new IllegalArgumentException(String.format(message, values));	    }	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
@Override	public void setValue(final Number value) {	    this.value = value.floatValue();	}
@Override	public int length() {	    return size;	}
public static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes) {	    if ((src.length == 0 && srcPos == 0) || 0 == nBytes) {	        return dstInit;	    }	    if ((nBytes - 1) * 8 + dstPos >= 16) {	        throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 16");	    }	    short out = dstInit;	    int shift = 0;	    for (int i = 0; i < nBytes; i++) {	        shift = i * 8 + dstPos;	        final int bits = (0xff & src[i + srcPos]) << shift;	        final int mask = 0xff << shift;	        out = (short) ((out & ~mask) | bits);	    }	    return out;	}
public static <T extends CharSequence> T notEmpty(final T chars) {	    return notEmpty(chars, DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE);	}
public static short toShort(final String str, final short defaultValue) {	    if (str == null) {	        return defaultValue;	    }	    try {	        return Short.parseShort(str);	    } catch (final NumberFormatException nfe) {	        return defaultValue;	    }	}
public int size() {	    return size;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) {	    if (array == null) {	        return null;	    }	    if (startIndexInclusive < 0) {	        startIndexInclusive = 0;	    }	    if (endIndexExclusive > array.length) {	        endIndexExclusive = array.length;	    }	    final int newSize = endIndexExclusive - startIndexInclusive;	    if (newSize <= 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] subarray = new boolean[newSize];	    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);	    return subarray;	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public static void writeStaticField(final Class<?> cls, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException {	    final Field field = getField(cls, fieldName, forceAccess);	    if (field == null) {	        throw new IllegalArgumentException("Cannot locate field " + fieldName + " on " + cls);	    }	    writeStaticField(field, value);	}
public static boolean[] hexDigitToBinary(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return new boolean[] { false, false, false, false };	        case '1':	            return new boolean[] { true, false, false, false };	        case '2':	            return new boolean[] { false, true, false, false };	        case '3':	            return new boolean[] { true, true, false, false };	        case '4':	            return new boolean[] { false, false, true, false };	        case '5':	            return new boolean[] { true, false, true, false };	        case '6':	            return new boolean[] { false, true, true, false };	        case '7':	            return new boolean[] { true, true, true, false };	        case '8':	            return new boolean[] { false, false, false, true };	        case '9':	            return new boolean[] { true, false, false, true };	        case 'a':	        case 'A':	            return new boolean[] { false, true, false, true };	        case 'b':	        case 'B':	            return new boolean[] { true, true, false, true };	        case 'c':	        case 'C':	            return new boolean[] { false, false, true, true };	        case 'd':	        case 'D':	            return new boolean[] { true, false, true, true };	        case 'e':	        case 'E':	            return new boolean[] { false, true, true, true };	        case 'f':	        case 'F':	            return new boolean[] { true, true, true, true };	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public abstract M getMiddle();
public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) {	    if (it != null) {	        separator = ObjectUtils.toString(separator);	        while (it.hasNext()) {	            append(it.next());	            if (it.hasNext()) {	                append(separator);	            }	        }	    }	    return this;	}
public char getEnd() {	    return this.end;	}
public static CharSequence subSequence(final CharSequence cs, final int start) {	    return cs == null ? null : cs.subSequence(start, cs.length());	}
public boolean isEmpty() {	    return size == 0;	}
@Override	public byte byteValue() {	    return value;	}
public static String reverse(final String str) {	    if (str == null) {	        return null;	    }	    return new StringBuilder(str).reverse().toString();	}
public int size() {	    return size;	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
protected String getArrayEnd() {	    return arrayEnd;	}
protected boolean isUseIdentityHashCode() {	    return useIdentityHashCode;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale) {	    return cache.getDateTimeInstance(dateStyle, timeStyle, timeZone, locale);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
@Override	public int read(final char[] b, final int off, int len) {	    if (off < 0 || len < 0 || off > b.length || (off + len) > b.length || (off + len) < 0) {	        throw new IndexOutOfBoundsException();	    }	    if (len == 0) {	        return 0;	    }	    if (pos >= StrBuilder.this.size()) {	        return -1;	    }	    if (pos + len > size()) {	        len = StrBuilder.this.size() - pos;	    }	    StrBuilder.this.getChars(pos, pos + len, b, off);	    pos += len;	    return len;	}
public void split() {	    if (this.runningState != STATE_RUNNING) {	        throw new IllegalStateException("Stopwatch is not running. ");	    }	    this.stopTime = System.nanoTime();	    this.splitState = STATE_SPLIT;	}
public int lastIndexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex >= size ? size - 1 : startIndex);	    if (matcher == null || startIndex < 0) {	        return -1;	    }	    final char[] buf = buffer;	    final int endIndex = startIndex + 1;	    for (int i = startIndex; i >= 0; i--) {	        if (matcher.isMatch(buf, i, 0, endIndex) > 0) {	            return i;	        }	    }	    return -1;	}
@Override	public boolean markSupported() {	    return true;	}
protected String getContentStart() {	    return contentStart;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static byte CONST_BYTE(final int v) throws IllegalArgumentException {	    if (v < Byte.MIN_VALUE || v > Byte.MAX_VALUE) {	        throw new IllegalArgumentException("Supplied value must be a valid byte literal between -128 and 127: [" + v + "]");	    }	    return (byte) v;	}
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] result = new boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        final Boolean b = array[i];	        result[i] = (b == null ? valueForNull : b.booleanValue());	    }	    return result;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
static void unregister(final Object lhs, final Object rhs) {	    Set<Pair<IDKey, IDKey>> registry = getRegistry();	    if (registry != null) {	        final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);	        registry.remove(pair);	        synchronized (EqualsBuilder.class) {	            registry = getRegistry();	            if (registry != null && registry.isEmpty()) {	                REGISTRY.remove();	            }	        }	    }	}
public byte setByte(final byte holder) {	    return (byte) set(holder);	}
public String getNewLineText() {	    return newLine;	}
public static boolean isWhitespace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isWhitespace(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
@Deprecated	public static String chomp(final String str, final String separator) {	    return removeEnd(str, separator);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public StrBuilder deleteAll(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, -1);	}
protected String getNullText() {	    return nullText;	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
@Override	public String getContentStart() {	    return super.getContentStart();	}
@Override	public float floatValue() {	    return value;	}
protected String getFieldSeparator() {	    return fieldSeparator;	}
public StrBuilder appendSeparator(final char separator, final int loopIndex) {	    if (loopIndex > 0) {	        append(separator);	    }	    return this;	}
public boolean contains(final StrMatcher matcher) {	    return indexOf(matcher, 0) >= 0;	}
public static StrMatcher doubleQuoteMatcher() {	    return DOUBLE_QUOTE_MATCHER;	}
public static String abbreviate(final String str, int offset, final int maxWidth) {	    if (str == null) {	        return null;	    }	    if (maxWidth < 4) {	        throw new IllegalArgumentException("Minimum abbreviation width is 4");	    }	    if (str.length() <= maxWidth) {	        return str;	    }	    if (offset > str.length()) {	        offset = str.length();	    }	    if (str.length() - offset < maxWidth - 3) {	        offset = str.length() - (maxWidth - 3);	    }	    final String abrevMarker = "...";	    if (offset <= 4) {	        return str.substring(0, maxWidth - 3) + abrevMarker;	    }	    if (maxWidth < 7) {	        throw new IllegalArgumentException("Minimum abbreviation width with offset is 7");	    }	    if (offset + maxWidth - 3 < str.length()) {	        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);	    }	    return abrevMarker + str.substring(str.length() - (maxWidth - 3));	}
public StrBuilder setNewLineText(final String newLine) {	    this.newLine = newLine;	    return this;	}
public static String upperCase(final String str, final Locale locale) {	    if (str == null) {	        return null;	    }	    return str.toUpperCase(locale);	}
protected boolean isFieldSeparatorAtEnd() {	    return fieldSeparatorAtEnd;	}
public int size() {	    return size;	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
void increment() {	    count++;	}
static Token[] lexx(final String format) {	    final char[] array = format.toCharArray();	    final ArrayList<Token> list = new ArrayList<Token>(array.length);	    boolean inLiteral = false;	    StringBuilder buffer = null;	    Token previous = null;	    final int sz = array.length;	    for (int i = 0; i < sz; i++) {	        final char ch = array[i];	        if (inLiteral && ch != '\'') {	            buffer.append(ch);	            continue;	        }	        Object value = null;	        switch(ch) {	            case '\'':	                if (inLiteral) {	                    buffer = null;	                    inLiteral = false;	                } else {	                    buffer = new StringBuilder();	                    list.add(new Token(buffer));	                    inLiteral = true;	                }	                break;	            case 'y':	                value = y;	                break;	            case 'M':	                value = M;	                break;	            case 'd':	                value = d;	                break;	            case 'H':	                value = H;	                break;	            case 'm':	                value = m;	                break;	            case 's':	                value = s;	                break;	            case 'S':	                value = S;	                break;	            default:	                if (buffer == null) {	                    buffer = new StringBuilder();	                    list.add(new Token(buffer));	                }	                buffer.append(ch);	        }	        if (value != null) {	            if (previous != null && previous.getValue() == value) {	                previous.increment();	            } else {	                final Token token = new Token(value);	                list.add(token);	                previous = token;	            }	            buffer = null;	        }	    }	    return list.toArray(new Token[list.size()]);	}
public static <T> void inclusiveBetween(final T start, final T end, final Comparable<T> value, final String message, final Object... values) {	    if (value.compareTo(start) < 0 || value.compareTo(end) > 0) {	        throw new IllegalArgumentException(String.format(message, values));	    }	}
public static Map<TypeVariable<?>, Type> determineTypeArguments(final Class<?> cls, final ParameterizedType superType) {	    final Class<?> superClass = getRawType(superType);	    if (!isAssignable(cls, superClass)) {	        return null;	    }	    if (cls.equals(superClass)) {	        return getTypeArguments(superType, superClass, null);	    }	    final Type midType = getClosestParentType(cls, superClass);	    if (midType instanceof Class<?>) {	        return determineTypeArguments((Class<?>) midType, superType);	    }	    final ParameterizedType midParameterizedType = (ParameterizedType) midType;	    final Class<?> midClass = getRawType(midParameterizedType);	    final Map<TypeVariable<?>, Type> typeVarAssigns = determineTypeArguments(midClass, superType);	    mapTypeVariablesToArguments(cls, midParameterizedType, typeVarAssigns);	    return typeVarAssigns;	}
public int toHashCode() {	    return iTotal;	}
Object getValue() {	    return value;	}
public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale) {	    return cache.getDateTimeInstance(dateStyle, timeStyle, timeZone, locale);	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
public int size() {	    return size;	}
public static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) {	    if (0 == nHexs) {	        return dstInit;	    }	    if ((nHexs - 1) * 4 + srcPos >= 16) {	        throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 16");	    }	    final StringBuilder sb = new StringBuilder(dstInit);	    int shift = 0;	    int append = sb.length();	    for (int i = 0; i < nHexs; i++) {	        shift = i * 4 + srcPos;	        final int bits = 0xF & (src >> shift);	        if (dstPos + i == append) {	            ++append;	            sb.append(intToHexDigit(bits));	        } else {	            sb.setCharAt(dstPos + i, intToHexDigit(bits));	        }	    }	    return sb.toString();	}
public static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    final int beSrcPos = src.length - 1 - srcPos;	    final int srcLen = Math.min(4, beSrcPos + 1);	    final boolean[] paddedSrc = new boolean[4];	    System.arraycopy(src, beSrcPos + 1 - srcLen, paddedSrc, 4 - srcLen, srcLen);	    src = paddedSrc;	    srcPos = 0;	    if (src[srcPos]) {	        if (src.length > srcPos + 1 && src[srcPos + 1]) {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 1 && src[srcPos + 1]) {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
protected boolean isUseShortClassName() {	    return useShortClassName;	}
protected String toUtf16Escape(final int codepoint) {	    return "\\u" + hex(codepoint);	}
public static StrTokenizer getCSVInstance(final char[] input) {	    final StrTokenizer tok = getCSVClone();	    tok.reset(input);	    return tok;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
static Object removeAll(final Object array, final BitSet indices) {	    final int srcLength = ArrayUtils.getLength(array);	    final int removals = indices.cardinality();	    final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals);	    int srcIndex = 0;	    int destIndex = 0;	    int count;	    int set;	    while ((set = indices.nextSetBit(srcIndex)) != -1) {	        count = set - srcIndex;	        if (count > 0) {	            System.arraycopy(array, srcIndex, result, destIndex, count);	            destIndex += count;	        }	        srcIndex = indices.nextClearBit(set);	    }	    count = srcLength - srcIndex;	    if (count > 0) {	        System.arraycopy(array, srcIndex, result, destIndex, count);	    }	    return result;	}
public static ConcurrentException extractCause(final ExecutionException ex) {	    if (ex == null || ex.getCause() == null) {	        return null;	    }	    throwCause(ex);	    return new ConcurrentException(ex.getMessage(), ex.getCause());	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public static String[] stripAll(final String[] strs, final String stripChars) {	    int strsLen;	    if (strs == null || (strsLen = strs.length) == 0) {	        return strs;	    }	    final String[] newArr = new String[strsLen];	    for (int i = 0; i < strsLen; i++) {	        newArr[i] = strip(strs[i], stripChars);	    }	    return newArr;	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    int max = longest;	    if (index + longest > input.length()) {	        max = input.length() - index;	    }	    for (int i = max; i >= shortest; i--) {	        final CharSequence subSeq = input.subSequence(index, index + i);	        final CharSequence result = lookupMap.get(subSeq.toString());	        if (result != null) {	            out.write(result.toString());	            return i;	        }	    }	    return 0;	}
public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {	    if (str == null || searchStr == null) {	        return INDEX_NOT_FOUND;	    }	    if (startPos > str.length() - searchStr.length()) {	        startPos = str.length() - searchStr.length();	    }	    if (startPos < 0) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return startPos;	    }	    for (int i = startPos; i >= 0; i--) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public boolean contains(final StrMatcher matcher) {	    return indexOf(matcher, 0) >= 0;	}
public static String leftPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return leftPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return padStr.concat(str);	    } else if (pads < padLen) {	        return padStr.substring(0, pads).concat(str);	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return new String(padding).concat(str);	    }	}
public static Boolean[] nullToEmpty(final Boolean[] array) {	    if (array == null || array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    return array;	}
@Override	public Short getValue() {	    return Short.valueOf(this.value);	}
public static CharRange isNotIn(final char start, final char end) {	    return new CharRange(start, end, true);	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
static Object removeAll(final Object array, final BitSet indices) {	    final int srcLength = ArrayUtils.getLength(array);	    final int removals = indices.cardinality();	    final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals);	    int srcIndex = 0;	    int destIndex = 0;	    int count;	    int set;	    while ((set = indices.nextSetBit(srcIndex)) != -1) {	        count = set - srcIndex;	        if (count > 0) {	            System.arraycopy(array, srcIndex, result, destIndex, count);	            destIndex += count;	        }	        srcIndex = indices.nextClearBit(set);	    }	    count = srcLength - srcIndex;	    if (count > 0) {	        System.arraycopy(array, srcIndex, result, destIndex, count);	    }	    return result;	}
public boolean isEmpty() {	    return size == 0;	}
public int capacity() {	    return buffer.length;	}
public static boolean startsWithAny(final CharSequence string, final CharSequence... searchStrings) {	    if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {	        return false;	    }	    for (final CharSequence searchString : searchStrings) {	        if (StringUtils.startsWith(string, searchString)) {	            return true;	        }	    }	    return false;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public static int reflectionHashCode(final Object object, final String... excludeFields) {	    return reflectionHashCode(17, 37, object, false, null, excludeFields);	}
public static Object invokeExactMethod(final Object object, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {	    if (args == null) {	        args = ArrayUtils.EMPTY_OBJECT_ARRAY;	    }	    if (parameterTypes == null) {	        parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;	    }	    final Method method = getAccessibleMethod(object.getClass(), methodName, parameterTypes);	    if (method == null) {	        throw new NoSuchMethodException("No such accessible method: " + methodName + "() on object: " + object.getClass().getName());	    }	    return method.invoke(object, args);	}
public static <T extends CharSequence> T defaultIfBlank(final T str, final T defaultStr) {	    return StringUtils.isBlank(str) ? defaultStr : str;	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
@Override	public StringBuffer format(final Calendar calendar, final StringBuffer buf) {	    return applyRules(calendar, buf);	}
public static Map<TypeVariable<?>, Type> determineTypeArguments(final Class<?> cls, final ParameterizedType superType) {	    final Class<?> superClass = getRawType(superType);	    if (!isAssignable(cls, superClass)) {	        return null;	    }	    if (cls.equals(superClass)) {	        return getTypeArguments(superType, superClass, null);	    }	    final Type midType = getClosestParentType(cls, superClass);	    if (midType instanceof Class<?>) {	        return determineTypeArguments((Class<?>) midType, superType);	    }	    final ParameterizedType midParameterizedType = (ParameterizedType) midType;	    final Class<?> midClass = getRawType(midParameterizedType);	    final Map<TypeVariable<?>, Type> typeVarAssigns = determineTypeArguments(midClass, superType);	    mapTypeVariablesToArguments(cls, midParameterizedType, typeVarAssigns);	    return typeVarAssigns;	}
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) {	    final StringBuilder buffer = new StringBuilder();	    boolean lastOutputSeconds = false;	    final int sz = tokens.length;	    for (int i = 0; i < sz; i++) {	        final Token token = tokens[i];	        final Object value = token.getValue();	        final int count = token.getCount();	        if (value instanceof StringBuilder) {	            buffer.append(value.toString());	        } else {	            if (value == y) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years));	                lastOutputSeconds = false;	            } else if (value == M) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months));	                lastOutputSeconds = false;	            } else if (value == d) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days));	                lastOutputSeconds = false;	            } else if (value == H) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours));	                lastOutputSeconds = false;	            } else if (value == m) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes));	                lastOutputSeconds = false;	            } else if (value == s) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds));	                lastOutputSeconds = true;	            } else if (value == S) {	                if (lastOutputSeconds) {	                    milliseconds += 1000;	                    final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds);	                    buffer.append(str.substring(1));	                } else {	                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds));	                }	                lastOutputSeconds = false;	            }	        }	    }	    return buffer.toString();	}
public String getNewLineText() {	    return newLine;	}
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] result = new boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        final Boolean b = array[i];	        result[i] = (b == null ? valueForNull : b.booleanValue());	    }	    return result;	}
public StrBuilder ensureCapacity(final int capacity) {	    if (capacity > buffer.length) {	        final char[] old = buffer;	        buffer = new char[capacity * 2];	        System.arraycopy(old, 0, buffer, 0, size);	    }	    return this;	}
public static boolean containsOnly(final CharSequence cs, final String validChars) {	    if (cs == null || validChars == null) {	        return false;	    }	    return containsOnly(cs, validChars.toCharArray());	}
public String getNewLineText() {	    return newLine;	}
public static int hexDigitMsb0ToInt(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return 0x0;	        case '1':	            return 0x8;	        case '2':	            return 0x4;	        case '3':	            return 0xC;	        case '4':	            return 0x2;	        case '5':	            return 0xA;	        case '6':	            return 0x6;	        case '7':	            return 0xE;	        case '8':	            return 0x1;	        case '9':	            return 0x9;	        case 'a':	        case 'A':	            return 0x5;	        case 'b':	        case 'B':	            return 0xD;	        case 'c':	        case 'C':	            return 0x3;	        case 'd':	        case 'D':	            return 0xB;	        case 'e':	        case 'E':	            return 0x7;	        case 'f':	        case 'F':	            return 0xF;	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
@Override	public String next() {	    if (hasNext()) {	        return tokens[tokenPos++];	    }	    throw new NoSuchElementException();	}
public static boolean isWhitespace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isWhitespace(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) {	    if (array == null) {	        return null;	    }	    if (startIndexInclusive < 0) {	        startIndexInclusive = 0;	    }	    if (endIndexExclusive > array.length) {	        endIndexExclusive = array.length;	    }	    final int newSize = endIndexExclusive - startIndexInclusive;	    if (newSize <= 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] subarray = new boolean[newSize];	    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);	    return subarray;	}
@Override	public boolean translate(final int codepoint, final Writer out) throws IOException {	    if (between) {	        if (codepoint < below || codepoint > above) {	            return false;	        }	    } else {	        if (codepoint >= below && codepoint <= above) {	            return false;	        }	    }	    if (codepoint > 0xffff) {	        out.write(toUtf16Escape(codepoint));	    } else if (codepoint > 0xfff) {	        out.write("\\u" + hex(codepoint));	    } else if (codepoint > 0xff) {	        out.write("\\u0" + hex(codepoint));	    } else if (codepoint > 0xf) {	        out.write("\\u00" + hex(codepoint));	    } else {	        out.write("\\u000" + hex(codepoint));	    }	    return true;	}
protected String getArrayStart() {	    return arrayStart;	}
public synchronized boolean start() {	    if (!isStarted()) {	        ExecutorService tempExec;	        executor = getExternalExecutor();	        if (executor == null) {	            executor = tempExec = createExecutor();	        } else {	            tempExec = null;	        }	        future = executor.submit(createTask(tempExec));	        return true;	    }	    return false;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
protected String getSummaryObjectEndText() {	    return summaryObjectEndText;	}
public static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes) {	    if (0 == nBytes) {	        return dst;	    }	    if ((nBytes - 1) * 8 + srcPos >= 32) {	        throw new IllegalArgumentException("(nBytes-1)*8+srcPos is greather or equal to than 32");	    }	    int shift = 0;	    for (int i = 0; i < nBytes; i++) {	        shift = i * 8 + srcPos;	        dst[dstPos + i] = (byte) (0xff & (src >> shift));	    }	    return dst;	}
public static String leftPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return leftPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return padStr.concat(str);	    } else if (pads < padLen) {	        return padStr.substring(0, pads).concat(str);	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return new String(padding).concat(str);	    }	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    final int seqEnd = input.length();	    if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') {	        int start = index + 2;	        boolean isHex = false;	        final char firstChar = input.charAt(start);	        if (firstChar == 'x' || firstChar == 'X') {	            start++;	            isHex = true;	            if (start == seqEnd) {	                return 0;	            }	        }	        int end = start;	        while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) {	            end++;	        }	        final boolean semiNext = end != seqEnd && input.charAt(end) == ';';	        if (!semiNext) {	            if (isSet(OPTION.semiColonRequired)) {	                return 0;	            } else if (isSet(OPTION.errorIfNoSemiColon)) {	                throw new IllegalArgumentException("Semi-colon required at end of numeric entity");	            }	        }	        int entityValue;	        try {	            if (isHex) {	                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);	            } else {	                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);	            }	        } catch (final NumberFormatException nfe) {	            return 0;	        }	        if (entityValue > 0xFFFF) {	            final char[] chrs = Character.toChars(entityValue);	            out.write(chrs[0]);	            out.write(chrs[1]);	        } else {	            out.write(entityValue);	        }	        return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0);	    }	    return 0;	}
protected String getFieldSeparator() {	    return fieldSeparator;	}
@Override	public boolean equals(final Object obj) {	    if (obj == this) {	        return true;	    }	    if (obj instanceof CharRange == false) {	        return false;	    }	    final CharRange other = (CharRange) obj;	    return start == other.start && end == other.end && negated == other.negated;	}
public static String rightPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return rightPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return str.concat(padStr);	    } else if (pads < padLen) {	        return str.concat(padStr.substring(0, pads));	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return str.concat(new String(padding));	    }	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public String reformat(final String input) throws ParseException {	    return format(parseObject(input));	}
public StrTokenizer reset(final char[] input) {	    reset();	    this.chars = ArrayUtils.clone(input);	    return this;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public static String prependIfMissing(final String str, final CharSequence prefix, final CharSequence... prefixes) {	    return prependIfMissing(str, prefix, false, prefixes);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
@Override	public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) {	    return formatter.format(obj, toAppendTo, pos);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    buffer.append(arrayStart);	    for (int i = 0; i < array.length; i++) {	        if (i > 0) {	            buffer.append(arraySeparator);	        }	        appendDetail(buffer, fieldName, array[i]);	    }	    buffer.append(arrayEnd);	}
public StrTokenizer setIgnoreEmptyTokens(final boolean ignoreEmptyTokens) {	    this.ignoreEmptyTokens = ignoreEmptyTokens;	    return this;	}
public static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex) {	    if (0 == nHex) {	        return dstInit;	    }	    if ((nHex - 1) * 4 + dstPos >= 64) {	        throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 64");	    }	    long out = dstInit;	    int shift = 0;	    for (int i = 0; i < nHex; i++) {	        shift = i * 4 + dstPos;	        final long bits = (0xfL & hexDigitToInt(src.charAt(i + srcPos))) << shift;	        final long mask = 0xfL << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
public static boolean isSameDay(final Calendar cal1, final Calendar cal2) {	    if (cal1 == null || cal2 == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    return (cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR));	}
public static boolean isAsciiAlphaUpper(final char ch) {	    return ch >= 'A' && ch <= 'Z';	}
public String getNewLineText() {	    return newLine;	}
public static String leftPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return leftPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return padStr.concat(str);	    } else if (pads < padLen) {	        return padStr.substring(0, pads).concat(str);	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return new String(padding).concat(str);	    }	}
public String getNullText() {	    return nullText;	}
public static boolean isAllLowerCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLowerCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
static int lastIndexOf(final CharSequence cs, final CharSequence searchChar, final int start) {	    return cs.toString().lastIndexOf(searchChar.toString(), start);	}
@Override	public Iterator<Character> iterator() {	    return new CharacterIterator(this);	}
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) {	    style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));	    return this;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public static String getCommonPrefix(final String... strs) {	    if (strs == null || strs.length == 0) {	        return EMPTY;	    }	    final int smallestIndexOfDiff = indexOfDifference(strs);	    if (smallestIndexOfDiff == INDEX_NOT_FOUND) {	        if (strs[0] == null) {	            return EMPTY;	        }	        return strs[0];	    } else if (smallestIndexOfDiff == 0) {	        return EMPTY;	    } else {	        return strs[0].substring(0, smallestIndexOfDiff);	    }	}
protected void setSizeEndText(String sizeEndText) {	    if (sizeEndText == null) {	        sizeEndText = "";	    }	    this.sizeEndText = sizeEndText;	}
public String getNewLineText() {	    return newLine;	}
public boolean isEnableSubstitutionInVariables() {	    return enableSubstitutionInVariables;	}
public char getEscapeChar() {	    return this.escapeChar;	}
protected boolean isArrayContentDetail() {	    return arrayContentDetail;	}
public String getNewLineText() {	    return newLine;	}
public StrBuilder deleteCharAt(final int index) {	    if (index < 0 || index >= size) {	        throw new StringIndexOutOfBoundsException(index);	    }	    deleteImpl(index, index + 1, 1);	    return this;	}
public final void translate(final CharSequence input, final Writer out) throws IOException {	    if (out == null) {	        throw new IllegalArgumentException("The Writer must not be null");	    }	    if (input == null) {	        return;	    }	    int pos = 0;	    final int len = input.length();	    while (pos < len) {	        final int consumed = translate(input, pos, out);	        if (consumed == 0) {	            final char[] c = Character.toChars(Character.codePointAt(input, pos));	            out.write(c);	            pos += c.length;	            continue;	        }	        for (int pt = 0; pt < consumed; pt++) {	            pos += Character.charCount(Character.codePointAt(input, pt));	        }	    }	}
public static ConcurrentException extractCause(final ExecutionException ex) {	    if (ex == null || ex.getCause() == null) {	        return null;	    }	    throwCause(ex);	    return new ConcurrentException(ex.getMessage(), ex.getCause());	}
@Override	public TimeZone getTimeZone() {	    return mTimeZone;	}
@Override	public void mark(final int readAheadLimit) {	    mark = pos;	}
public StrBuilder deleteAll(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, -1);	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public String getNullText() {	    return nullText;	}
public static <T> Range<T> is(final T element, final Comparator<T> comparator) {	    return between(element, element, comparator);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static String trimToEmpty(final String str) {	    return str == null ? EMPTY : str.trim();	}
public int capacity() {	    return buffer.length;	}
public static String toString(final Formattable formattable) {	    return String.format(SIMPLEST_FORMAT, formattable);	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public StrBuilder ensureCapacity(final int capacity) {	    if (capacity > buffer.length) {	        final char[] old = buffer;	        buffer = new char[capacity * 2];	        System.arraycopy(old, 0, buffer, 0, size);	    }	    return this;	}
public static boolean isNotEmpty(final boolean[] array) {	    return (array != null && array.length != 0);	}
public static boolean isAlphanumeric(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetterOrDigit(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
@Override	public T get() throws ConcurrentException {	    try {	        return getFuture().get();	    } catch (final ExecutionException execex) {	        ConcurrentUtils.handleCause(execex);	        return null;	    } catch (final InterruptedException iex) {	        Thread.currentThread().interrupt();	        throw new ConcurrentException(iex);	    }	}
public boolean isOverlappedBy(final Range<T> otherRange) {	    if (otherRange == null) {	        return false;	    }	    return otherRange.contains(minimum) || otherRange.contains(maximum) || contains(otherRange.minimum);	}
public static CharRange isNot(final char ch) {	    return new CharRange(ch, ch, true);	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public int size() {	    return size;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public String getNewLineText() {	    return newLine;	}
public String getNewLineText() {	    return newLine;	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public final synchronized void setLimit(final int limit) {	    this.limit = limit;	}
public static String delete(final String str, final String... set) {	    if (StringUtils.isEmpty(str) || deepEmpty(set)) {	        return str;	    }	    return modify(str, set, false);	}
public Long toLong() {	    return Long.valueOf(longValue());	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public static Float createFloat(final String str) {	    if (str == null) {	        return null;	    }	    return Float.valueOf(str);	}
protected String getArraySeparator() {	    return arraySeparator;	}
public static String toString(final Object obj, final String nullStr) {	    return obj == null ? nullStr : obj.toString();	}
private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase) {	    if (str == null || prefix == null) {	        return str == null && prefix == null;	    }	    if (prefix.length() > str.length()) {	        return false;	    }	    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());	}
public int capacity() {	    return buffer.length;	}
public StrBuilder deleteAll(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, -1);	}
@Override	public boolean equals(final Object obj) {	    if (obj == this) {	        return true;	    } else if (obj == null || obj.getClass() != getClass()) {	        return false;	    } else {	        @SuppressWarnings("unchecked")	        final Range<T> range = (Range<T>) obj;	        return minimum.equals(range.minimum) && maximum.equals(range.maximum);	    }	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static boolean isTrue(final Boolean bool) {	    return Boolean.TRUE.equals(bool);	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    if (input.charAt(index) == '\\' && index < (input.length() - 1) && Character.isDigit(input.charAt(index + 1))) {	        final int start = index + 1;	        int end = index + 2;	        while (end < input.length() && Character.isDigit(input.charAt(end))) {	            end++;	            if (Integer.parseInt(input.subSequence(start, end).toString(), 10) > OCTAL_MAX) {	                end--;	                break;	            }	        }	        out.write(Integer.parseInt(input.subSequence(start, end).toString(), 8));	        return 1 + end - start;	    }	    return 0;	}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    buffer.append(arrayStart);	    for (int i = 0; i < array.length; i++) {	        if (i > 0) {	            buffer.append(arraySeparator);	        }	        appendDetail(buffer, fieldName, array[i]);	    }	    buffer.append(arrayEnd);	}
public StrBuilder replaceAll(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, -1);	}
public static String substringAfterLast(final String str, final String separator) {	    if (isEmpty(str)) {	        return str;	    }	    if (isEmpty(separator)) {	        return EMPTY;	    }	    final int pos = str.lastIndexOf(separator);	    if (pos == INDEX_NOT_FOUND || pos == str.length() - separator.length()) {	        return EMPTY;	    }	    return str.substring(pos + separator.length());	}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    buffer.append(arrayStart);	    for (int i = 0; i < array.length; i++) {	        if (i > 0) {	            buffer.append(arraySeparator);	        }	        appendDetail(buffer, fieldName, array[i]);	    }	    buffer.append(arrayEnd);	}
@Override	public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) {	    return formatter.format(obj, toAppendTo, pos);	}
public StrBuilder appendSeparator(final char separator, final int loopIndex) {	    if (loopIndex > 0) {	        append(separator);	    }	    return this;	}
public static boolean isNotEmpty(final CharSequence cs) {	    return !StringUtils.isEmpty(cs);	}
public static Boolean[] toObject(final boolean[] array) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    final Boolean[] result = new Boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        result[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE);	    }	    return result;	}
static void unregister(final Object value) {	    if (value != null) {	        final Map<Object, Object> m = getRegistry();	        if (m != null) {	            m.remove(value);	            if (m.isEmpty()) {	                REGISTRY.remove();	            }	        }	    }	}
public static String abbreviate(final String str, int offset, final int maxWidth) {	    if (str == null) {	        return null;	    }	    if (maxWidth < 4) {	        throw new IllegalArgumentException("Minimum abbreviation width is 4");	    }	    if (str.length() <= maxWidth) {	        return str;	    }	    if (offset > str.length()) {	        offset = str.length();	    }	    if (str.length() - offset < maxWidth - 3) {	        offset = str.length() - (maxWidth - 3);	    }	    final String abrevMarker = "...";	    if (offset <= 4) {	        return str.substring(0, maxWidth - 3) + abrevMarker;	    }	    if (maxWidth < 7) {	        throw new IllegalArgumentException("Minimum abbreviation width with offset is 7");	    }	    if (offset + maxWidth - 3 < str.length()) {	        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);	    }	    return abrevMarker + str.substring(str.length() - (maxWidth - 3));	}
protected void setUseIdentityHashCode(final boolean useIdentityHashCode) {	    this.useIdentityHashCode = useIdentityHashCode;	}
static void register(final Object lhs, final Object rhs) {	    synchronized (EqualsBuilder.class) {	        if (getRegistry() == null) {	            REGISTRY.set(new HashSet<Pair<IDKey, IDKey>>());	        }	    }	    final Set<Pair<IDKey, IDKey>> registry = getRegistry();	    final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);	    registry.add(pair);	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
public int clear(final int holder) {	    return holder & ~_mask;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static char toChar(final String str, final char defaultValue) {	    if (StringUtils.isEmpty(str)) {	        return defaultValue;	    }	    return str.charAt(0);	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public int toComparison() {	    return comparison;	}
protected boolean isUseIdentityHashCode() {	    return useIdentityHashCode;	}
public static boolean startsWithAny(final CharSequence string, final CharSequence... searchStrings) {	    if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {	        return false;	    }	    for (final CharSequence searchString : searchStrings) {	        if (StringUtils.startsWith(string, searchString)) {	            return true;	        }	    }	    return false;	}
public String getNewLineText() {	    return newLine;	}
public static int hashCodeMulti(final Object... objects) {	    int hash = 1;	    if (objects != null) {	        for (final Object object : objects) {	            hash = hash * 31 + ObjectUtils.hashCode(object);	        }	    }	    return hash;	}
public String getNewLineText() {	    return newLine;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public int capacity() {	    return buffer.length;	}
public StrTokenizer setIgnoredMatcher(final StrMatcher ignored) {	    if (ignored != null) {	        this.ignoredMatcher = ignored;	    }	    return this;	}
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) {	    return new Range<T>(fromInclusive, toInclusive, comparator);	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public static String abbreviate(final String str, int offset, final int maxWidth) {	    if (str == null) {	        return null;	    }	    if (maxWidth < 4) {	        throw new IllegalArgumentException("Minimum abbreviation width is 4");	    }	    if (str.length() <= maxWidth) {	        return str;	    }	    if (offset > str.length()) {	        offset = str.length();	    }	    if (str.length() - offset < maxWidth - 3) {	        offset = str.length() - (maxWidth - 3);	    }	    final String abrevMarker = "...";	    if (offset <= 4) {	        return str.substring(0, maxWidth - 3) + abrevMarker;	    }	    if (maxWidth < 7) {	        throw new IllegalArgumentException("Minimum abbreviation width with offset is 7");	    }	    if (offset + maxWidth - 3 < str.length()) {	        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);	    }	    return abrevMarker + str.substring(str.length() - (maxWidth - 3));	}
public ToStringBuilder appendAsObjectToString(final Object object) {	    ObjectUtils.identityToString(this.getStringBuffer(), object);	    return this;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
@Override	public Object parseObject(final String source, final ParsePosition pos) {	    return parser.parseObject(source, pos);	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static String substringAfter(final String str, final String separator) {	    if (isEmpty(str)) {	        return str;	    }	    if (separator == null) {	        return EMPTY;	    }	    final int pos = str.indexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return EMPTY;	    }	    return str.substring(pos + separator.length());	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
@Override	public float floatValue() {	    return (float) value;	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public int indexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex < 0 ? 0 : startIndex);	    if (matcher == null || startIndex >= size) {	        return -1;	    }	    final int len = size;	    final char[] buf = buffer;	    for (int i = startIndex; i < len; i++) {	        if (matcher.isMatch(buf, i, startIndex, len) > 0) {	            return i;	        }	    }	    return -1;	}
public static boolean isEmpty(final boolean[] array) {	    return array == null || array.length == 0;	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static int indexOfAnyBut(final CharSequence seq, final CharSequence searchChars) {	    if (isEmpty(seq) || isEmpty(searchChars)) {	        return INDEX_NOT_FOUND;	    }	    final int strLen = seq.length();	    for (int i = 0; i < strLen; i++) {	        final char ch = seq.charAt(i);	        final boolean chFound = CharSequenceUtils.indexOf(searchChars, ch, 0) >= 0;	        if (i + 1 < strLen && Character.isHighSurrogate(ch)) {	            final char ch2 = seq.charAt(i + 1);	            if (chFound && CharSequenceUtils.indexOf(searchChars, ch2, 0) < 0) {	                return i;	            }	        } else {	            if (!chFound) {	                return i;	            }	        }	    }	    return INDEX_NOT_FOUND;	}
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) {	    return new Range<T>(fromInclusive, toInclusive, comparator);	}
public static String leftPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return leftPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return padStr.concat(str);	    } else if (pads < padLen) {	        return padStr.substring(0, pads).concat(str);	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return new String(padding).concat(str);	    }	}
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, true);	}
@Override	public int hashCode() {	    return value;	}
protected String getSizeStartText() {	    return sizeStartText;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public static String right(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(str.length() - len);	}
public static String random(final int count, final char... chars) {	    if (chars == null) {	        return random(count, 0, 0, false, false, null, RANDOM);	    }	    return random(count, 0, chars.length, false, false, chars, RANDOM);	}
public Fraction multiplyBy(final Fraction fraction) {	    if (fraction == null) {	        throw new IllegalArgumentException("The fraction must not be null");	    }	    if (numerator == 0 || fraction.numerator == 0) {	        return ZERO;	    }	    final int d1 = greatestCommonDivisor(numerator, fraction.denominator);	    final int d2 = greatestCommonDivisor(fraction.numerator, denominator);	    return getReducedFraction(mulAndCheck(numerator / d1, fraction.numerator / d2), mulPosAndCheck(denominator / d2, fraction.denominator / d1));	}
public static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) {	    if (0 == nHexs) {	        return dstInit;	    }	    if ((nHexs - 1) * 4 + srcPos >= 32) {	        throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 32");	    }	    final StringBuilder sb = new StringBuilder(dstInit);	    int shift = 0;	    int append = sb.length();	    for (int i = 0; i < nHexs; i++) {	        shift = i * 4 + srcPos;	        final int bits = 0xF & (src >> shift);	        if (dstPos + i == append) {	            ++append;	            sb.append(intToHexDigit(bits));	        } else {	            sb.setCharAt(dstPos + i, intToHexDigit(bits));	        }	    }	    return sb.toString();	}
public static <E extends Enum<E>> boolean isValidEnum(final Class<E> enumClass, final String enumName) {	    if (enumName == null) {	        return false;	    }	    try {	        Enum.valueOf(enumClass, enumName);	        return true;	    } catch (final IllegalArgumentException ex) {	        return false;	    }	}
public static String removePattern(final String source, final String regex) {	    return replacePattern(source, regex, StringUtils.EMPTY);	}
@Override	public int compare(final Object obj1, final Object obj2) {	    return ((Comparable) obj1).compareTo(obj2);	}
public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex) {	    return indexOf(throwable, type, fromIndex, true);	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public int size() {	    return size;	}
public static final String unescapeEcmaScript(final String input) {	    return UNESCAPE_ECMASCRIPT.translate(input);	}
public void split() {	    if (this.runningState != STATE_RUNNING) {	        throw new IllegalStateException("Stopwatch is not running. ");	    }	    this.stopTime = System.nanoTime();	    this.splitState = STATE_SPLIT;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public boolean isAppendTransients() {	    return this.appendTransients;	}
public static Integer toIntegerObject(final Boolean bool, final Integer trueValue, final Integer falseValue, final Integer nullValue) {	    if (bool == null) {	        return nullValue;	    }	    return bool.booleanValue() ? trueValue : falseValue;	}
protected String getNullText() {	    return nullText;	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final E... values) {	    Validate.noNullElements(values);	    return generateBitVector(enumClass, Arrays.<E>asList(values));	}
@Override	public boolean equals(final Object obj) {	    if (obj == this) {	        return true;	    } else if (obj == null || obj.getClass() != getClass()) {	        return false;	    } else {	        @SuppressWarnings("unchecked")	        final Range<T> range = (Range<T>) obj;	        return minimum.equals(range.minimum) && maximum.equals(range.maximum);	    }	}
public static String randomAlphanumeric(final int count) {	    return random(count, true, true);	}
public StrTokenizer asTokenizer() {	    return new StrBuilderTokenizer();	}
@Override	public String previous() {	    if (hasPrevious()) {	        return tokens[--tokenPos];	    }	    throw new NoSuchElementException();	}
public static String mid(final String str, int pos, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0 || pos > str.length()) {	        return EMPTY;	    }	    if (pos < 0) {	        pos = 0;	    }	    if (str.length() <= pos + len) {	        return str.substring(pos);	    }	    return str.substring(pos, pos + len);	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
public static String reverse(final String str) {	    if (str == null) {	        return null;	    }	    return new StringBuilder(str).reverse().toString();	}
public static String substringAfter(final String str, final String separator) {	    if (isEmpty(str)) {	        return str;	    }	    if (separator == null) {	        return EMPTY;	    }	    final int pos = str.indexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return EMPTY;	    }	    return str.substring(pos + separator.length());	}
public boolean isEmpty() {	    return size == 0;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public String getNullText() {	    return nullText;	}
@Override	public String previous() {	    if (hasPrevious()) {	        return tokens[--tokenPos];	    }	    throw new NoSuchElementException();	}
public StrBuilder setLength(final int length) {	    if (length < 0) {	        throw new StringIndexOutOfBoundsException(length);	    }	    if (length < size) {	        size = length;	    } else if (length > size) {	        ensureCapacity(length);	        final int oldEnd = size;	        final int newEnd = length;	        size = length;	        for (int i = oldEnd; i < newEnd; i++) {	            buffer[i] = '\0';	        }	    }	    return this;	}
public Long toLong() {	    return Long.valueOf(longValue());	}
public int capacity() {	    return buffer.length;	}
public boolean isAppendTransients() {	    return this.appendTransients;	}
public static String mid(final String str, int pos, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0 || pos > str.length()) {	        return EMPTY;	    }	    if (pos < 0) {	        pos = 0;	    }	    if (str.length() <= pos + len) {	        return str.substring(pos);	    }	    return str.substring(pos, pos + len);	}
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, true);	}
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = Integer.MAX_VALUE;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.indexOf(str, search, 0);	        if (tmp == INDEX_NOT_FOUND) {	            continue;	        }	        if (tmp < ret) {	            ret = tmp;	        }	    }	    return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
static String[] getStackFrames(final String stackTrace) {	    final String linebreak = SystemUtils.LINE_SEPARATOR;	    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);	    final List<String> list = new ArrayList<String>();	    while (frames.hasMoreTokens()) {	        list.add(frames.nextToken());	    }	    return list.toArray(new String[list.size()]);	}
public int capacity() {	    return buffer.length;	}
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] result = new boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        final Boolean b = array[i];	        result[i] = (b == null ? valueForNull : b.booleanValue());	    }	    return result;	}
public String getNullText() {	    return nullText;	}
@Override	public void write(final String str, final int off, final int len) {	    StrBuilder.this.append(str, off, len);	}
public static <L, R> Pair<L, R> of(final L left, final R right) {	    return new ImmutablePair<L, R>(left, right);	}
protected String getContentStart() {	    return contentStart;	}
public boolean isEquals() {	    return this.isEquals;	}
@Override	public String toString() {	    return String.valueOf(value);	}
@Override	public int length() {	    return size;	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
public static String center(String str, final int size, String padStr) {	    if (str == null || size <= 0) {	        return str;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    str = leftPad(str, strLen + pads / 2, padStr);	    str = rightPad(str, size, padStr);	    return str;	}
@Override	public StringBuffer format(final Calendar calendar, final StringBuffer buf) {	    return applyRules(calendar, buf);	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public String getNullText() {	    return nullText;	}
synchronized void endOfPeriod() {	    lastCallsPerPeriod = acquireCount;	    totalAcquireCount += acquireCount;	    periodCount++;	    acquireCount = 0;	    notifyAll();	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static String toString(final boolean bool, final String trueString, final String falseString) {	    return bool ? trueString : falseString;	}
public static final String unescapeXml(final String input) {	    return UNESCAPE_XML.translate(input);	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
static boolean isOSMatch(final String osName, final String osVersion, final String osNamePrefix, final String osVersionPrefix) {	    if (osName == null || osVersion == null) {	        return false;	    }	    return osName.startsWith(osNamePrefix) && osVersion.startsWith(osVersionPrefix);	}
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return new boolean[] { false, false, false, false };	        case '1':	            return new boolean[] { false, false, false, true };	        case '2':	            return new boolean[] { false, false, true, false };	        case '3':	            return new boolean[] { false, false, true, true };	        case '4':	            return new boolean[] { false, true, false, false };	        case '5':	            return new boolean[] { false, true, false, true };	        case '6':	            return new boolean[] { false, true, true, false };	        case '7':	            return new boolean[] { false, true, true, true };	        case '8':	            return new boolean[] { true, false, false, false };	        case '9':	            return new boolean[] { true, false, false, true };	        case 'a':	        case 'A':	            return new boolean[] { true, false, true, false };	        case 'b':	        case 'B':	            return new boolean[] { true, false, true, true };	        case 'c':	        case 'C':	            return new boolean[] { true, true, false, false };	        case 'd':	        case 'D':	            return new boolean[] { true, true, false, true };	        case 'e':	        case 'E':	            return new boolean[] { true, true, true, false };	        case 'f':	        case 'F':	            return new boolean[] { true, true, true, true };	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return 0;	    }	    if (lhs == null || rhs == null) {	        throw new NullPointerException();	    }	    Class<?> lhsClazz = lhs.getClass();	    if (!lhsClazz.isInstance(rhs)) {	        throw new ClassCastException();	    }	    final CompareToBuilder compareToBuilder = new CompareToBuilder();	    reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);	    while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) {	        lhsClazz = lhsClazz.getSuperclass();	        reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);	    }	    return compareToBuilder.toComparison();	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static boolean isSameLength(final boolean[] array1, final boolean[] array2) {	    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {	        return false;	    }	    return true;	}
public static List<Throwable> getThrowableList(Throwable throwable) {	    final List<Throwable> list = new ArrayList<Throwable>();	    while (throwable != null && list.contains(throwable) == false) {	        list.add(throwable);	        throwable = ExceptionUtils.getCause(throwable);	    }	    return list;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
@Override	public int compareTo(final Triple<L, M, R> other) {	    return new CompareToBuilder().append(getLeft(), other.getLeft()).append(getMiddle(), other.getMiddle()).append(getRight(), other.getRight()).toComparison();	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
@Override	public void setValue(final Number value) {	    this.value = value.floatValue();	}
public StrBuilder deleteCharAt(final int index) {	    if (index < 0 || index >= size) {	        throw new StringIndexOutOfBoundsException(index);	    }	    deleteImpl(index, index + 1, 1);	    return this;	}
public static String formatUTC(final Date date, final String pattern, final Locale locale) {	    return format(date, pattern, UTC_TIME_ZONE, locale);	}
public int capacity() {	    return buffer.length;	}
public int size() {	    return size;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public static <T> Range<T> is(final T element, final Comparator<T> comparator) {	    return between(element, element, comparator);	}
@Override	public T get(final long timeout, final TimeUnit unit) {	    return value;	}
@Override	public int length() {	    return size;	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public static char binaryToHexDigit(final boolean[] src, final int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    if (src.length > srcPos + 3 && src[srcPos + 3]) {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src[srcPos]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
protected boolean isUseFieldNames() {	    return useFieldNames;	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
protected String getSummaryObjectStartText() {	    return summaryObjectStartText;	}
public static boolean containsOnly(final CharSequence cs, final String validChars) {	    if (cs == null || validChars == null) {	        return false;	    }	    return containsOnly(cs, validChars.toCharArray());	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static float max(final float a, final float b) {	    if (Float.isNaN(a)) {	        return b;	    } else if (Float.isNaN(b)) {	        return a;	    } else {	        return Math.max(a, b);	    }	}
public StrBuilder appendSeparator(final char separator, final int loopIndex) {	    if (loopIndex > 0) {	        append(separator);	    }	    return this;	}
public static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools) {	    if ((src.length == 0 && srcPos == 0) || 0 == nBools) {	        return dstInit;	    }	    if (nBools - 1 + dstPos >= 8) {	        throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 8");	    }	    byte out = dstInit;	    int shift = 0;	    for (int i = 0; i < nBools; i++) {	        shift = i * 1 + dstPos;	        final int bits = (src[i + srcPos] ? 1 : 0) << shift;	        final int mask = 0x1 << shift;	        out = (byte) ((out & ~mask) | bits);	    }	    return out;	}
public static String[] stripAll(final String[] strs, final String stripChars) {	    int strsLen;	    if (strs == null || (strsLen = strs.length) == 0) {	        return strs;	    }	    final String[] newArr = new String[strsLen];	    for (int i = 0; i < strsLen; i++) {	        newArr[i] = strip(strs[i], stripChars);	    }	    return newArr;	}
public char getStart() {	    return this.start;	}
@Override	public int length() {	    return size;	}
public String getNewLineText() {	    return newLine;	}
public static Boolean[] nullToEmpty(final Boolean[] array) {	    if (array == null || array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    return array;	}
public static Class<?>[] toClass(final Object... array) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return ArrayUtils.EMPTY_CLASS_ARRAY;	    }	    final Class<?>[] classes = new Class[array.length];	    for (int i = 0; i < array.length; i++) {	        classes[i] = array[i] == null ? null : array[i].getClass();	    }	    return classes;	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public void add(final Number operand) {	    this.value += operand.byteValue();	}
public static String getStackTrace(final Throwable throwable) {	    final StringWriter sw = new StringWriter();	    final PrintWriter pw = new PrintWriter(sw, true);	    throwable.printStackTrace(pw);	    return sw.getBuffer().toString();	}
@Override	public int nextIndex() {	    return tokenPos;	}
public static File getUserDir() {	    return new File(System.getProperty(USER_DIR_KEY));	}
public static boolean isAllUpperCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isUpperCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
@Override	public void write(final String str, final int off, final int len) {	    StrBuilder.this.append(str, off, len);	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public StrBuilder setLength(final int length) {	    if (length < 0) {	        throw new StringIndexOutOfBoundsException(length);	    }	    if (length < size) {	        size = length;	    } else if (length > size) {	        ensureCapacity(length);	        final int oldEnd = size;	        final int newEnd = length;	        size = length;	        for (int i = oldEnd; i < newEnd; i++) {	            buffer[i] = '\0';	        }	    }	    return this;	}
protected boolean isFieldSeparatorAtStart() {	    return fieldSeparatorAtStart;	}
public static String defaultString(final String str, final String defaultStr) {	    return str == null ? defaultStr : str;	}
static boolean isRegistered(final Object value) {	    final Map<Object, Object> m = getRegistry();	    return m != null && m.containsKey(value);	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    final int beSrcPos = src.length - 1 - srcPos;	    final int srcLen = Math.min(4, beSrcPos + 1);	    final boolean[] paddedSrc = new boolean[4];	    System.arraycopy(src, beSrcPos + 1 - srcLen, paddedSrc, 4 - srcLen, srcLen);	    src = paddedSrc;	    srcPos = 0;	    if (src[srcPos]) {	        if (src.length > srcPos + 1 && src[srcPos + 1]) {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 1 && src[srcPos + 1]) {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
protected String getFieldSeparator() {	    return fieldSeparator;	}
public StrBuilder replaceAll(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, -1);	}
public boolean isIgnoreEmptyTokens() {	    return ignoreEmptyTokens;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
synchronized void endOfPeriod() {	    lastCallsPerPeriod = acquireCount;	    totalAcquireCount += acquireCount;	    periodCount++;	    acquireCount = 0;	    notifyAll();	}
public StrBuilder deleteAll(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, -1);	}
public static short[] removeElement(final short[] array, final short element) {	    final int index = indexOf(array, element);	    if (index == INDEX_NOT_FOUND) {	        return clone(array);	    }	    return remove(array, index);	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
public HashCodeBuilder append(final short[] array) {	    if (array == null) {	        iTotal = iTotal * iConstant;	    } else {	        for (final short element : array) {	            append(element);	        }	    }	    return this;	}
public static <L, M, R> Triple<L, M, R> of(final L left, final M middle, final R right) {	    return new ImmutableTriple<L, M, R>(left, middle, right);	}
@Override	public int length() {	    return size;	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) {	    final StringBuilder buffer = new StringBuilder();	    boolean lastOutputSeconds = false;	    final int sz = tokens.length;	    for (int i = 0; i < sz; i++) {	        final Token token = tokens[i];	        final Object value = token.getValue();	        final int count = token.getCount();	        if (value instanceof StringBuilder) {	            buffer.append(value.toString());	        } else {	            if (value == y) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years));	                lastOutputSeconds = false;	            } else if (value == M) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months));	                lastOutputSeconds = false;	            } else if (value == d) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days));	                lastOutputSeconds = false;	            } else if (value == H) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours));	                lastOutputSeconds = false;	            } else if (value == m) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes));	                lastOutputSeconds = false;	            } else if (value == s) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds));	                lastOutputSeconds = true;	            } else if (value == S) {	                if (lastOutputSeconds) {	                    milliseconds += 1000;	                    final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds);	                    buffer.append(str.substring(1));	                } else {	                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds));	                }	                lastOutputSeconds = false;	            }	        }	    }	    return buffer.toString();	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
@Override	public void close() {	}
public synchronized void acquire() throws InterruptedException {	    if (isShutdown()) {	        throw new IllegalStateException("TimedSemaphore is shut down!");	    }	    if (task == null) {	        task = startTimer();	    }	    boolean canPass = false;	    do {	        canPass = getLimit() <= NO_LIMIT || acquireCount < getLimit();	        if (!canPass) {	            wait();	        } else {	            acquireCount++;	        }	    } while (!canPass);	}
@Override	public int read(final char[] b, final int off, int len) {	    if (off < 0 || len < 0 || off > b.length || (off + len) > b.length || (off + len) < 0) {	        throw new IndexOutOfBoundsException();	    }	    if (len == 0) {	        return 0;	    }	    if (pos >= StrBuilder.this.size()) {	        return -1;	    }	    if (pos + len > size()) {	        len = StrBuilder.this.size() - pos;	    }	    StrBuilder.this.getChars(pos, pos + len, b, off);	    pos += len;	    return len;	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
public static String defaultString(final String str, final String defaultStr) {	    return str == null ? defaultStr : str;	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public String getNullText() {	    return nullText;	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static void isInstanceOf(final Class<?> type, final Object obj, final String message, final Object... values) {	    if (type.isInstance(obj) == false) {	        throw new IllegalArgumentException(String.format(message, values));	    }	}
public char getStart() {	    return this.start;	}
public short setShort(final short holder) {	    return (short) set(holder);	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public static boolean isAscii(final char ch) {	    return ch < 128;	}
@Override	public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) {	    return formatter.format(obj, toAppendTo, pos);	}
public int set(final int holder) {	    return holder | _mask;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
@Override	public int length() {	    return size;	}
public void subtract(final Number operand) {	    this.value -= operand.doubleValue();	}
public static String lowerCase(final String str, final Locale locale) {	    if (str == null) {	        return null;	    }	    return str.toLowerCase(locale);	}
public static String normalizeSpace(final String str) {	    if (str == null) {	        return null;	    }	    return WHITESPACE_PATTERN.matcher(trim(str)).replaceAll(SPACE);	}
@Override	public int length() {	    return size;	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static float max(final float a, final float b, final float c) {	    return Math.max(Math.max(a, b), c);	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public boolean isEmpty() {	    return size == 0;	}
public StrBuilder replaceAll(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, -1);	}
public static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) {	    if (0 == nHexs) {	        return dstInit;	    }	    if ((nHexs - 1) * 4 + srcPos >= 64) {	        throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 64");	    }	    final StringBuilder sb = new StringBuilder(dstInit);	    int shift = 0;	    int append = sb.length();	    for (int i = 0; i < nHexs; i++) {	        shift = i * 4 + srcPos;	        final int bits = (int) (0xF & (src >> shift));	        if (dstPos + i == append) {	            ++append;	            sb.append(intToHexDigit(bits));	        } else {	            sb.setCharAt(dstPos + i, intToHexDigit(bits));	        }	    }	    return sb.toString();	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public static <T extends Comparable<? super T>> T max(final T... values) {	    T result = null;	    if (values != null) {	        for (final T value : values) {	            if (compare(value, result, false) > 0) {	                result = value;	            }	        }	    }	    return result;	}
protected boolean isUseClassName() {	    return useClassName;	}
static Token[] lexx(final String format) {	    final char[] array = format.toCharArray();	    final ArrayList<Token> list = new ArrayList<Token>(array.length);	    boolean inLiteral = false;	    StringBuilder buffer = null;	    Token previous = null;	    final int sz = array.length;	    for (int i = 0; i < sz; i++) {	        final char ch = array[i];	        if (inLiteral && ch != '\'') {	            buffer.append(ch);	            continue;	        }	        Object value = null;	        switch(ch) {	            case '\'':	                if (inLiteral) {	                    buffer = null;	                    inLiteral = false;	                } else {	                    buffer = new StringBuilder();	                    list.add(new Token(buffer));	                    inLiteral = true;	                }	                break;	            case 'y':	                value = y;	                break;	            case 'M':	                value = M;	                break;	            case 'd':	                value = d;	                break;	            case 'H':	                value = H;	                break;	            case 'm':	                value = m;	                break;	            case 's':	                value = s;	                break;	            case 'S':	                value = S;	                break;	            default:	                if (buffer == null) {	                    buffer = new StringBuilder();	                    list.add(new Token(buffer));	                }	                buffer.append(ch);	        }	        if (value != null) {	            if (previous != null && previous.getValue() == value) {	                previous.increment();	            } else {	                final Token token = new Token(value);	                list.add(token);	                previous = token;	            }	            buffer = null;	        }	    }	    return list.toArray(new Token[list.size()]);	}
@Override	public void write(final String str, final int off, final int len) {	    StrBuilder.this.append(str, off, len);	}
public void add(final Number operand) {	    this.value += operand.shortValue();	}
public Long toLong() {	    return Long.valueOf(longValue());	}
public int set(final int holder) {	    return holder | _mask;	}
private static Date add(final Date date, final int calendarField, final int amount) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final Calendar c = Calendar.getInstance();	    c.setTime(date);	    c.add(calendarField, amount);	    return c.getTime();	}
public static <L, R> Pair<L, R> of(final L left, final R right) {	    return new ImmutablePair<L, R>(left, right);	}
public String getNullText() {	    return nullText;	}
boolean isNextNumber() {	    return nextStrategy != null && nextStrategy.isNumber();	}
public static String chop(final String str) {	    if (str == null) {	        return null;	    }	    final int strLen = str.length();	    if (strLen < 2) {	        return EMPTY;	    }	    final int lastIdx = strLen - 1;	    final String ret = str.substring(0, lastIdx);	    final char last = str.charAt(lastIdx);	    if (last == CharUtils.LF && ret.charAt(lastIdx - 1) == CharUtils.CR) {	        return ret.substring(0, lastIdx - 1);	    }	    return ret;	}
@Override	public String toString() {	    return "FastDateFormat[" + printer.getPattern() + "," + printer.getLocale() + "," + printer.getTimeZone().getID() + "]";	}
protected boolean isUseFieldNames() {	    return useFieldNames;	}
@Override	public int hashCode() {	    return toHashCode();	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
private static long getFragment(final Calendar calendar, final int fragment, final int unit) {	    if (calendar == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final long millisPerUnit = getMillisPerUnit(unit);	    long result = 0;	    switch(fragment) {	        case Calendar.YEAR:	            result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit;	            break;	        case Calendar.MONTH:	            result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit;	            break;	    }	    switch(fragment) {	        case Calendar.YEAR:	        case Calendar.MONTH:	        case Calendar.DAY_OF_YEAR:	        case Calendar.DATE:	            result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit;	        case Calendar.HOUR_OF_DAY:	            result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit;	        case Calendar.MINUTE:	            result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit;	        case Calendar.SECOND:	            result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit;	            break;	        case Calendar.MILLISECOND:	            break;	        default:	            throw new IllegalArgumentException("The fragment " + fragment + " is not supported");	    }	    return result;	}
@Deprecated	public static String chomp(final String str, final String separator) {	    return removeEnd(str, separator);	}
public String getNullText() {	    return nullText;	}
public static boolean isNotEmpty(final boolean[] array) {	    return (array != null && array.length != 0);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public String getNewLineText() {	    return newLine;	}
public boolean isEmpty() {	    return size == 0;	}
@Override	public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) {	    return formatter.format(obj, toAppendTo, pos);	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) {	    final StringBuilder buffer = new StringBuilder();	    boolean lastOutputSeconds = false;	    final int sz = tokens.length;	    for (int i = 0; i < sz; i++) {	        final Token token = tokens[i];	        final Object value = token.getValue();	        final int count = token.getCount();	        if (value instanceof StringBuilder) {	            buffer.append(value.toString());	        } else {	            if (value == y) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years));	                lastOutputSeconds = false;	            } else if (value == M) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months));	                lastOutputSeconds = false;	            } else if (value == d) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days));	                lastOutputSeconds = false;	            } else if (value == H) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours));	                lastOutputSeconds = false;	            } else if (value == m) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes));	                lastOutputSeconds = false;	            } else if (value == s) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds));	                lastOutputSeconds = true;	            } else if (value == S) {	                if (lastOutputSeconds) {	                    milliseconds += 1000;	                    final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds);	                    buffer.append(str.substring(1));	                } else {	                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds));	                }	                lastOutputSeconds = false;	            }	        }	    }	    return buffer.toString();	}
public abstract L getLeft();
public String getNullText() {	    return nullText;	}
public void addInitializer(final String name, final BackgroundInitializer<?> init) {	    if (name == null) {	        throw new IllegalArgumentException("Name of child initializer must not be null!");	    }	    if (init == null) {	        throw new IllegalArgumentException("Child initializer must not be null!");	    }	    synchronized (this) {	        if (isStarted()) {	            throw new IllegalStateException("addInitializer() must not be called after start()!");	        }	        childInitializers.put(name, init);	    }	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public CompareToBuilder appendSuper(final int superCompareTo) {	    if (comparison != 0) {	        return this;	    }	    comparison = superCompareTo;	    return this;	}
public StrLookup<?> getVariableResolver() {	    return this.variableResolver;	}
public static Type[] normalizeUpperBounds(final Type[] bounds) {	    if (bounds.length < 2) {	        return bounds;	    }	    final Set<Type> types = new HashSet<Type>(bounds.length);	    for (final Type type1 : bounds) {	        boolean subtypeFound = false;	        for (final Type type2 : bounds) {	            if (type1 != type2 && isAssignable(type2, type1, null)) {	                subtypeFound = true;	                break;	            }	        }	        if (!subtypeFound) {	            types.add(type1);	        }	    }	    return types.toArray(new Type[types.size()]);	}
@Override	public boolean translate(final int codepoint, final Writer out) throws IOException {	    if (between) {	        if (codepoint < below || codepoint > above) {	            return false;	        }	    } else {	        if (codepoint >= below && codepoint <= above) {	            return false;	        }	    }	    if (codepoint > 0xffff) {	        out.write(toUtf16Escape(codepoint));	    } else if (codepoint > 0xfff) {	        out.write("\\u" + hex(codepoint));	    } else if (codepoint > 0xff) {	        out.write("\\u0" + hex(codepoint));	    } else if (codepoint > 0xf) {	        out.write("\\u00" + hex(codepoint));	    } else {	        out.write("\\u000" + hex(codepoint));	    }	    return true;	}
public static void handleCause(final ExecutionException ex) throws ConcurrentException {	    final ConcurrentException cex = extractCause(ex);	    if (cex != null) {	        throw cex;	    }	}
public int size() {	    return size;	}
public Double toDouble() {	    return Double.valueOf(doubleValue());	}
public static float max(final float a, final float b, final float c) {	    return Math.max(Math.max(a, b), c);	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static String stripStart(final String str, final String stripChars) {	    int strLen;	    if (str == null || (strLen = str.length()) == 0) {	        return str;	    }	    int start = 0;	    if (stripChars == null) {	        while (start != strLen && Character.isWhitespace(str.charAt(start))) {	            start++;	        }	    } else if (stripChars.isEmpty()) {	        return str;	    } else {	        while (start != strLen && stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND) {	            start++;	        }	    }	    return str.substring(start);	}
protected String getSizeEndText() {	    return sizeEndText;	}
public static <T extends CharSequence> T notEmpty(final T chars) {	    return notEmpty(chars, DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE);	}
protected String getSummaryObjectStartText() {	    return summaryObjectStartText;	}
public int size() {	    return size;	}
public static String mid(final String str, int pos, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0 || pos > str.length()) {	        return EMPTY;	    }	    if (pos < 0) {	        pos = 0;	    }	    if (str.length() <= pos + len) {	        return str.substring(pos);	    }	    return str.substring(pos, pos + len);	}
public static float min(final float a, final float b, final float c) {	    return Math.min(Math.min(a, b), c);	}
public static String deleteWhitespace(final String str) {	    if (isEmpty(str)) {	        return str;	    }	    final int sz = str.length();	    final char[] chs = new char[sz];	    int count = 0;	    for (int i = 0; i < sz; i++) {	        if (!Character.isWhitespace(str.charAt(i))) {	            chs[count++] = str.charAt(i);	        }	    }	    if (count == sz) {	        return str;	    }	    return new String(chs, 0, count);	}
public StrBuilder appendSeparator(final char separator, final int loopIndex) {	    if (loopIndex > 0) {	        append(separator);	    }	    return this;	}
public static void handleCause(final ExecutionException ex) throws ConcurrentException {	    final ConcurrentException cex = extractCause(ex);	    if (cex != null) {	        throw cex;	    }	}
public static int indexOfDifference(final CharSequence... css) {	    if (css == null || css.length <= 1) {	        return INDEX_NOT_FOUND;	    }	    boolean anyStringNull = false;	    boolean allStringsNull = true;	    final int arrayLen = css.length;	    int shortestStrLen = Integer.MAX_VALUE;	    int longestStrLen = 0;	    for (int i = 0; i < arrayLen; i++) {	        if (css[i] == null) {	            anyStringNull = true;	            shortestStrLen = 0;	        } else {	            allStringsNull = false;	            shortestStrLen = Math.min(css[i].length(), shortestStrLen);	            longestStrLen = Math.max(css[i].length(), longestStrLen);	        }	    }	    if (allStringsNull || longestStrLen == 0 && !anyStringNull) {	        return INDEX_NOT_FOUND;	    }	    if (shortestStrLen == 0) {	        return 0;	    }	    int firstDiff = -1;	    for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {	        final char comparisonChar = css[0].charAt(stringPos);	        for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {	            if (css[arrayPos].charAt(stringPos) != comparisonChar) {	                firstDiff = stringPos;	                break;	            }	        }	        if (firstDiff != -1) {	            break;	        }	    }	    if (firstDiff == -1 && shortestStrLen != longestStrLen) {	        return shortestStrLen;	    }	    return firstDiff;	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
int getCount() {	    return count;	}
public static Boolean or(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
public static String removeStartIgnoreCase(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (startsWithIgnoreCase(str, remove)) {	        return str.substring(remove.length());	    }	    return str;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public StrBuilder ensureCapacity(final int capacity) {	    if (capacity > buffer.length) {	        final char[] old = buffer;	        buffer = new char[capacity * 2];	        System.arraycopy(old, 0, buffer, 0, size);	    }	    return this;	}
public Range<T> intersectionWith(final Range<T> other) {	    if (!this.isOverlappedBy(other)) {	        throw new IllegalArgumentException(String.format("Cannot calculate intersection with non-overlapping range %s", other));	    }	    if (this.equals(other)) {	        return this;	    }	    final T min = getComparator().compare(minimum, other.minimum) < 0 ? other.minimum : minimum;	    final T max = getComparator().compare(maximum, other.maximum) < 0 ? maximum : other.maximum;	    return between(min, max, getComparator());	}
public static boolean startsWithIgnoreCase(final CharSequence str, final CharSequence prefix) {	    return startsWith(str, prefix, true);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
@Override	public int compareTo(final Fraction other) {	    if (this == other) {	        return 0;	    }	    if (numerator == other.numerator && denominator == other.denominator) {	        return 0;	    }	    final long first = (long) numerator * (long) other.denominator;	    final long second = (long) other.numerator * (long) denominator;	    if (first == second) {	        return 0;	    } else if (first < second) {	        return -1;	    } else {	        return 1;	    }	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
protected String getArrayEnd() {	    return arrayEnd;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale) {	    return cache.getInstance(pattern, timeZone, locale);	}
public StrBuilder appendFixedWidthPadRight(final int value, final int width, final char padChar) {	    return appendFixedWidthPadRight(String.valueOf(value), width, padChar);	}
public static String center(String str, final int size, String padStr) {	    if (str == null || size <= 0) {	        return str;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    str = leftPad(str, strLen + pads / 2, padStr);	    str = rightPad(str, size, padStr);	    return str;	}
public static void handleCause(final ExecutionException ex) throws ConcurrentException {	    final ConcurrentException cex = extractCause(ex);	    if (cex != null) {	        throw cex;	    }	}
public String getNullText() {	    return nullText;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
@Override	public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) {	    return buffer[pos] <= 32 ? 1 : 0;	}
public static boolean isSupported(final String name) {	    if (name == null) {	        return false;	    }	    try {	        return Charset.isSupported(name);	    } catch (final IllegalCharsetNameException ex) {	        return false;	    }	}
@Override	public double doubleValue() {	    return value;	}
public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) {	    final Token[] tokens = lexx(format);	    final Calendar start = Calendar.getInstance(timezone);	    start.setTime(new Date(startMillis));	    final Calendar end = Calendar.getInstance(timezone);	    end.setTime(new Date(endMillis));	    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);	    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);	    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);	    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);	    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);	    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);	    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);	    while (milliseconds < 0) {	        milliseconds += 1000;	        seconds -= 1;	    }	    while (seconds < 0) {	        seconds += 60;	        minutes -= 1;	    }	    while (minutes < 0) {	        minutes += 60;	        hours -= 1;	    }	    while (hours < 0) {	        hours += 24;	        days -= 1;	    }	    if (Token.containsTokenWithValue(tokens, M)) {	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	        while (months < 0) {	            months += 12;	            years -= 1;	        }	        if (!Token.containsTokenWithValue(tokens, y) && years != 0) {	            while (years != 0) {	                months += 12 * years;	                years = 0;	            }	        }	    } else {	        if (!Token.containsTokenWithValue(tokens, y)) {	            int target = end.get(Calendar.YEAR);	            if (months < 0) {	                target -= 1;	            }	            while (start.get(Calendar.YEAR) != target) {	                days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);	                if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) {	                    days += 1;	                }	                start.add(Calendar.YEAR, 1);	                days += start.get(Calendar.DAY_OF_YEAR);	            }	            years = 0;	        }	        while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            start.add(Calendar.MONTH, 1);	        }	        months = 0;	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	    }	    if (!Token.containsTokenWithValue(tokens, d)) {	        hours += 24 * days;	        days = 0;	    }	    if (!Token.containsTokenWithValue(tokens, H)) {	        minutes += 60 * hours;	        hours = 0;	    }	    if (!Token.containsTokenWithValue(tokens, m)) {	        seconds += 60 * minutes;	        minutes = 0;	    }	    if (!Token.containsTokenWithValue(tokens, s)) {	        milliseconds += 1000 * seconds;	        seconds = 0;	    }	    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
public static float max(final float a, final float b, final float c) {	    return Math.max(Math.max(a, b), c);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static JavaUnicodeEscaper above(final int codepoint) {	    return outsideOf(0, codepoint);	}
public int lastIndexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex >= size ? size - 1 : startIndex);	    if (matcher == null || startIndex < 0) {	        return -1;	    }	    final char[] buf = buffer;	    final int endIndex = startIndex + 1;	    for (int i = startIndex; i >= 0; i--) {	        if (matcher.isMatch(buf, i, 0, endIndex) > 0) {	            return i;	        }	    }	    return -1;	}
public static String leftPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return leftPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return padStr.concat(str);	    } else if (pads < padLen) {	        return padStr.substring(0, pads).concat(str);	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return new String(padding).concat(str);	    }	}
protected String getSizeStartText() {	    return sizeStartText;	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
public boolean isIgnoreEmptyTokens() {	    return ignoreEmptyTokens;	}
public String getNullText() {	    return nullText;	}
protected String getNullText() {	    return nullText;	}
public boolean isEmpty() {	    return size == 0;	}
public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale) {	    return cache.getInstance(pattern, timeZone, locale);	}
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, true);	}
public char getEscapeChar() {	    return this.escapeChar;	}
public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width, final int precision, final char padChar, final CharSequence ellipsis) {	    Validate.isTrue(ellipsis == null || precision < 0 || ellipsis.length() <= precision, "Specified ellipsis '%1$s' exceeds precision of %2$s", ellipsis, Integer.valueOf(precision));	    final StringBuilder buf = new StringBuilder(seq);	    if (precision >= 0 && precision < seq.length()) {	        final CharSequence _ellipsis = ObjectUtils.defaultIfNull(ellipsis, StringUtils.EMPTY);	        buf.replace(precision - _ellipsis.length(), seq.length(), _ellipsis.toString());	    }	    final boolean leftJustify = (flags & LEFT_JUSTIFY) == LEFT_JUSTIFY;	    for (int i = buf.length(); i < width; i++) {	        buf.insert(leftJustify ? i : 0, padChar);	    }	    formatter.format(buf.toString());	    return formatter;	}
public static Date ceiling(final Object date, final int field) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (date instanceof Date) {	        return ceiling((Date) date, field);	    } else if (date instanceof Calendar) {	        return ceiling((Calendar) date, field).getTime();	    } else {	        throw new ClassCastException("Could not find ceiling of for type: " + date.getClass());	    }	}
protected String getContentEnd() {	    return contentEnd;	}
public static Class<?> getRawType(final Type type, final Type assigningType) {	    if (type instanceof Class<?>) {	        return (Class<?>) type;	    }	    if (type instanceof ParameterizedType) {	        return getRawType((ParameterizedType) type);	    }	    if (type instanceof TypeVariable<?>) {	        if (assigningType == null) {	            return null;	        }	        final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration();	        if (!(genericDeclaration instanceof Class<?>)) {	            return null;	        }	        final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType, (Class<?>) genericDeclaration);	        if (typeVarAssigns == null) {	            return null;	        }	        final Type typeArgument = typeVarAssigns.get(type);	        if (typeArgument == null) {	            return null;	        }	        return getRawType(typeArgument, assigningType);	    }	    if (type instanceof GenericArrayType) {	        final Class<?> rawComponentType = getRawType(((GenericArrayType) type).getGenericComponentType(), assigningType);	        return Array.newInstance(rawComponentType, 0).getClass();	    }	    if (type instanceof WildcardType) {	        return null;	    }	    throw new IllegalArgumentException("unknown type: " + type);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
@Override	public String toString() {	    return "FastDateFormat[" + printer.getPattern() + "," + printer.getLocale() + "," + printer.getTimeZone().getID() + "]";	}
public static float min(final float a, final float b, final float c) {	    return Math.min(Math.min(a, b), c);	}
public String toString(final String format) {	    return String.format(format, minimum, maximum, comparator);	}
public static String trimToNull(final String str) {	    final String ts = trim(str);	    return isEmpty(ts) ? null : ts;	}
public static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) {	    if (0 == nBools) {	        return dst;	    }	    if (nBools - 1 + srcPos >= 16) {	        throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 16");	    }	    int shift = 0;	    assert ((nBools - 1) * 1 < 16 - srcPos);	    for (int i = 0; i < nBools; i++) {	        shift = i * 1 + srcPos;	        dst[dstPos + i] = ((0x1 & (src >> shift)) != 0);	    }	    return dst;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof FastDateFormat == false) {	        return false;	    }	    final FastDateFormat other = (FastDateFormat) obj;	    return printer.equals(other.printer);	}
@Override	public int hashCode() {	    return toHashCode();	}
@Override	public boolean equals(final Object obj) {	    if (obj == this) {	        return true;	    }	    if (obj instanceof Triple<?, ?, ?>) {	        final Triple<?, ?, ?> other = (Triple<?, ?, ?>) obj;	        return ObjectUtils.equals(getLeft(), other.getLeft()) && ObjectUtils.equals(getMiddle(), other.getMiddle()) && ObjectUtils.equals(getRight(), other.getRight());	    }	    return false;	}
@Override	public TimeZone getTimeZone() {	    return timeZone;	}
public static String random(final int count, final char... chars) {	    if (chars == null) {	        return random(count, 0, 0, false, false, null, RANDOM);	    }	    return random(count, 0, chars.length, false, false, chars, RANDOM);	}
public String getNewLineText() {	    return newLine;	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
public static final String unescapeXml(final String input) {	    return UNESCAPE_XML.translate(input);	}
private static Date add(final Date date, final int calendarField, final int amount) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final Calendar c = Calendar.getInstance();	    c.setTime(date);	    c.add(calendarField, amount);	    return c.getTime();	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
@Override	public StringBuffer format(final Calendar calendar, final StringBuffer buf) {	    return printer.format(calendar, buf);	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    int max = longest;	    if (index + longest > input.length()) {	        max = input.length() - index;	    }	    for (int i = max; i >= shortest; i--) {	        final CharSequence subSeq = input.subSequence(index, index + i);	        final CharSequence result = lookupMap.get(subSeq.toString());	        if (result != null) {	            out.write(result.toString());	            return i;	        }	    }	    return 0;	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public static String randomAscii(final int count) {	    return random(count, 32, 127, false, false);	}
public void reset() {	    this.isEquals = true;	}
public static boolean isNumeric(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isDigit(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
public static String stripEnd(final String str, final String stripChars) {	    int end;	    if (str == null || (end = str.length()) == 0) {	        return str;	    }	    if (stripChars == null) {	        while (end != 0 && Character.isWhitespace(str.charAt(end - 1))) {	            end--;	        }	    } else if (stripChars.isEmpty()) {	        return str;	    } else {	        while (end != 0 && stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND) {	            end--;	        }	    }	    return str.substring(0, end);	}
public static StrTokenizer getTSVInstance(final char[] input) {	    final StrTokenizer tok = getTSVClone();	    tok.reset(input);	    return tok;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public boolean contains(final T element) {	    if (element == null) {	        return false;	    }	    return comparator.compare(element, minimum) > -1 && comparator.compare(element, maximum) < 1;	}
public static <T> T invokeConstructor(final Class<T> cls, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {	    if (parameterTypes == null) {	        parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;	    }	    if (args == null) {	        args = ArrayUtils.EMPTY_OBJECT_ARRAY;	    }	    final Constructor<T> ctor = getMatchingAccessibleConstructor(cls, parameterTypes);	    if (ctor == null) {	        throw new NoSuchMethodException("No such accessible constructor on object: " + cls.getName());	    }	    return ctor.newInstance(args);	}
public static float min(final float a, final float b, final float c) {	    return Math.min(Math.min(a, b), c);	}
public static boolean isEmpty(final CharSequence cs) {	    return cs == null || cs.length() == 0;	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public boolean isEmpty() {	    return size == 0;	}
@Override	public int read(final char[] b, final int off, int len) {	    if (off < 0 || len < 0 || off > b.length || (off + len) > b.length || (off + len) < 0) {	        throw new IndexOutOfBoundsException();	    }	    if (len == 0) {	        return 0;	    }	    if (pos >= StrBuilder.this.size()) {	        return -1;	    }	    if (pos + len > size()) {	        len = StrBuilder.this.size() - pos;	    }	    StrBuilder.this.getChars(pos, pos + len, b, off);	    pos += len;	    return len;	}
private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) {	    if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {	        return text;	    }	    if (timeToLive < 0) {	        throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another");	    }	    final int searchLength = searchList.length;	    final int replacementLength = replacementList.length;	    if (searchLength != replacementLength) {	        throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength);	    }	    final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];	    int textIndex = -1;	    int replaceIndex = -1;	    int tempIndex = -1;	    for (int i = 0; i < searchLength; i++) {	        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {	            continue;	        }	        tempIndex = text.indexOf(searchList[i]);	        if (tempIndex == -1) {	            noMoreMatchesForReplIndex[i] = true;	        } else {	            if (textIndex == -1 || tempIndex < textIndex) {	                textIndex = tempIndex;	                replaceIndex = i;	            }	        }	    }	    if (textIndex == -1) {	        return text;	    }	    int start = 0;	    int increase = 0;	    for (int i = 0; i < searchList.length; i++) {	        if (searchList[i] == null || replacementList[i] == null) {	            continue;	        }	        final int greater = replacementList[i].length() - searchList[i].length();	        if (greater > 0) {	            increase += 3 * greater;	        }	    }	    increase = Math.min(increase, text.length() / 5);	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (textIndex != -1) {	        for (int i = start; i < textIndex; i++) {	            buf.append(text.charAt(i));	        }	        buf.append(replacementList[replaceIndex]);	        start = textIndex + searchList[replaceIndex].length();	        textIndex = -1;	        replaceIndex = -1;	        tempIndex = -1;	        for (int i = 0; i < searchLength; i++) {	            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {	                continue;	            }	            tempIndex = text.indexOf(searchList[i], start);	            if (tempIndex == -1) {	                noMoreMatchesForReplIndex[i] = true;	            } else {	                if (textIndex == -1 || tempIndex < textIndex) {	                    textIndex = tempIndex;	                    replaceIndex = i;	                }	            }	        }	    }	    final int textLength = text.length();	    for (int i = start; i < textLength; i++) {	        buf.append(text.charAt(i));	    }	    final String result = buf.toString();	    if (!repeat) {	        return result;	    }	    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
public char getEscapeChar() {	    return this.escapeChar;	}
@Override	public boolean equals(final Object obj) {	    if (obj == null) {	        return false;	    }	    if (this == obj) {	        return true;	    }	    if (this.getClass() == obj.getClass()) {	        final MutableObject<?> that = (MutableObject<?>) obj;	        return this.value.equals(that.value);	    } else {	        return false;	    }	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
protected String getSizeStartText() {	    return sizeStartText;	}
@Override	public Integer build() {	    return Integer.valueOf(toHashCode());	}
private static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal, final boolean lastIndex) {	    if (str == null || searchStr == null || ordinal <= 0) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return lastIndex ? str.length() : 0;	    }	    int found = 0;	    int index = lastIndex ? str.length() : INDEX_NOT_FOUND;	    do {	        if (lastIndex) {	            index = CharSequenceUtils.lastIndexOf(str, searchStr, index - 1);	        } else {	            index = CharSequenceUtils.indexOf(str, searchStr, index + 1);	        }	        if (index < 0) {	            return index;	        }	        found++;	    } while (found < ordinal);	    return index;	}
public static String toStringYesNo(final boolean bool) {	    return toString(bool, "yes", "no");	}
public int lastIndexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex >= size ? size - 1 : startIndex);	    if (matcher == null || startIndex < 0) {	        return -1;	    }	    final char[] buf = buffer;	    final int endIndex = startIndex + 1;	    for (int i = startIndex; i >= 0; i--) {	        if (matcher.isMatch(buf, i, 0, endIndex) > 0) {	            return i;	        }	    }	    return -1;	}
public static <T extends CharSequence> T validIndex(final T chars, final int index) {	    return validIndex(chars, index, DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE, Integer.valueOf(index));	}
public static byte[] serialize(final Serializable obj) {	    final ByteArrayOutputStream baos = new ByteArrayOutputStream(512);	    serialize(obj, baos);	    return baos.toByteArray();	}
public static String uncapitalize(final String str) {	    int strLen;	    if (str == null || (strLen = str.length()) == 0) {	        return str;	    }	    char firstChar = str.charAt(0);	    if (Character.isLowerCase(firstChar)) {	        return str;	    }	    return new StringBuilder(strLen).append(Character.toLowerCase(firstChar)).append(str.substring(1)).toString();	}
@Deprecated	public static String chomp(final String str, final String separator) {	    return removeEnd(str, separator);	}
public boolean isBefore(final T element) {	    if (element == null) {	        return false;	    }	    return comparator.compare(element, maximum) > 0;	}
static JavaVersion get(final String nom) {	    if ("0.9".equals(nom)) {	        return JAVA_0_9;	    } else if ("1.1".equals(nom)) {	        return JAVA_1_1;	    } else if ("1.2".equals(nom)) {	        return JAVA_1_2;	    } else if ("1.3".equals(nom)) {	        return JAVA_1_3;	    } else if ("1.4".equals(nom)) {	        return JAVA_1_4;	    } else if ("1.5".equals(nom)) {	        return JAVA_1_5;	    } else if ("1.6".equals(nom)) {	        return JAVA_1_6;	    } else if ("1.7".equals(nom)) {	        return JAVA_1_7;	    } else if ("1.8".equals(nom)) {	        return JAVA_1_8;	    } else {	        return null;	    }	}
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) {	    if (str == null) {	        if (trueString == null) {	            return Boolean.TRUE;	        }	        if (falseString == null) {	            return Boolean.FALSE;	        }	        if (nullString == null) {	            return null;	        }	    } else if (str.equals(trueString)) {	        return Boolean.TRUE;	    } else if (str.equals(falseString)) {	        return Boolean.FALSE;	    } else if (str.equals(nullString)) {	        return null;	    }	    throw new IllegalArgumentException("The String did not match any specified value");	}
public Builder namingPattern(final String pattern) {	    if (pattern == null) {	        throw new NullPointerException("Naming pattern must not be null!");	    }	    namingPattern = pattern;	    return this;	}
public static void validState(final boolean expression, final String message, final Object... values) {	    if (expression == false) {	        throw new IllegalStateException(String.format(message, values));	    }	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public void decrement() {	    value--;	}
@Override	public T get(final long timeout, final TimeUnit unit) {	    return value;	}
public static boolean isNumber(final String str) {	    if (StringUtils.isEmpty(str)) {	        return false;	    }	    final char[] chars = str.toCharArray();	    int sz = chars.length;	    boolean hasExp = false;	    boolean hasDecPoint = false;	    boolean allowSigns = false;	    boolean foundDigit = false;	    final int start = (chars[0] == '-') ? 1 : 0;	    if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') {	        int i = start + 2;	        if (i == sz) {	            return false;	        }	        for (; i < chars.length; i++) {	            if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) {	                return false;	            }	        }	        return true;	    }	    sz--;	    int i = start;	    while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {	        if (chars[i] >= '0' && chars[i] <= '9') {	            foundDigit = true;	            allowSigns = false;	        } else if (chars[i] == '.') {	            if (hasDecPoint || hasExp) {	                return false;	            }	            hasDecPoint = true;	        } else if (chars[i] == 'e' || chars[i] == 'E') {	            if (hasExp) {	                return false;	            }	            if (!foundDigit) {	                return false;	            }	            hasExp = true;	            allowSigns = true;	        } else if (chars[i] == '+' || chars[i] == '-') {	            if (!allowSigns) {	                return false;	            }	            allowSigns = false;	            foundDigit = false;	        } else {	            return false;	        }	        i++;	    }	    if (i < chars.length) {	        if (chars[i] >= '0' && chars[i] <= '9') {	            return true;	        }	        if (chars[i] == 'e' || chars[i] == 'E') {	            return false;	        }	        if (chars[i] == '.') {	            if (hasDecPoint || hasExp) {	                return false;	            }	            return foundDigit;	        }	        if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) {	            return foundDigit;	        }	        if (chars[i] == 'l' || chars[i] == 'L') {	            return foundDigit && !hasExp && !hasDecPoint;	        }	        return false;	    }	    return !allowSigns && foundDigit;	}
@Override	public boolean translate(final int codepoint, final Writer out) throws IOException {	    if (between) {	        if (codepoint < below || codepoint > above) {	            return false;	        }	    } else {	        if (codepoint >= below && codepoint <= above) {	            return false;	        }	    }	    out.write("&#");	    out.write(Integer.toString(codepoint, 10));	    out.write(';');	    return true;	}
public static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) {	    if (0 == nHexs) {	        return dstInit;	    }	    if ((nHexs - 1) * 4 + srcPos >= 8) {	        throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 8");	    }	    final StringBuilder sb = new StringBuilder(dstInit);	    int shift = 0;	    int append = sb.length();	    for (int i = 0; i < nHexs; i++) {	        shift = i * 4 + srcPos;	        final int bits = 0xF & (src >> shift);	        if (dstPos + i == append) {	            ++append;	            sb.append(intToHexDigit(bits));	        } else {	            sb.setCharAt(dstPos + i, intToHexDigit(bits));	        }	    }	    return sb.toString();	}
@Override	public int length() {	    return size;	}
public static <K, V> V createIfAbsent(final ConcurrentMap<K, V> map, final K key, final ConcurrentInitializer<V> init) throws ConcurrentException {	    if (map == null || init == null) {	        return null;	    }	    final V value = map.get(key);	    if (value == null) {	        return putIfAbsent(map, key, init.get());	    }	    return value;	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) {	    String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'");	    if (suppressLeadingZeroElements) {	        duration = " " + duration;	        String tmp = StringUtils.replaceOnce(duration, " 0 days", "");	        if (tmp.length() != duration.length()) {	            duration = tmp;	            tmp = StringUtils.replaceOnce(duration, " 0 hours", "");	            if (tmp.length() != duration.length()) {	                duration = tmp;	                tmp = StringUtils.replaceOnce(duration, " 0 minutes", "");	                duration = tmp;	                if (tmp.length() != duration.length()) {	                    duration = StringUtils.replaceOnce(tmp, " 0 seconds", "");	                }	            }	        }	        if (duration.length() != 0) {	            duration = duration.substring(1);	        }	    }	    if (suppressTrailingZeroElements) {	        String tmp = StringUtils.replaceOnce(duration, " 0 seconds", "");	        if (tmp.length() != duration.length()) {	            duration = tmp;	            tmp = StringUtils.replaceOnce(duration, " 0 minutes", "");	            if (tmp.length() != duration.length()) {	                duration = tmp;	                tmp = StringUtils.replaceOnce(duration, " 0 hours", "");	                if (tmp.length() != duration.length()) {	                    duration = StringUtils.replaceOnce(tmp, " 0 days", "");	                }	            }	        }	    }	    duration = " " + duration;	    duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second");	    duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute");	    duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour");	    duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day");	    return duration.trim();	}
synchronized void endOfPeriod() {	    lastCallsPerPeriod = acquireCount;	    totalAcquireCount += acquireCount;	    periodCount++;	    acquireCount = 0;	    notifyAll();	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public void subtract(final Number operand) {	    this.value -= operand.doubleValue();	}
public static String replaceChars(final String str, final String searchChars, String replaceChars) {	    if (isEmpty(str) || isEmpty(searchChars)) {	        return str;	    }	    if (replaceChars == null) {	        replaceChars = EMPTY;	    }	    boolean modified = false;	    final int replaceCharsLength = replaceChars.length();	    final int strLength = str.length();	    final StringBuilder buf = new StringBuilder(strLength);	    for (int i = 0; i < strLength; i++) {	        final char ch = str.charAt(i);	        final int index = searchChars.indexOf(ch);	        if (index >= 0) {	            modified = true;	            if (index < replaceCharsLength) {	                buf.append(replaceChars.charAt(index));	            }	        } else {	            buf.append(ch);	        }	    }	    if (modified) {	        return buf.toString();	    }	    return str;	}
public static String trim(final String str) {	    return str == null ? null : str.trim();	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
public static boolean equalsIgnoreCase(final CharSequence str1, final CharSequence str2) {	    if (str1 == null || str2 == null) {	        return str1 == str2;	    } else if (str1 == str2) {	        return true;	    } else if (str1.length() != str2.length()) {	        return false;	    } else {	        return CharSequenceUtils.regionMatches(str1, true, 0, str2, 0, str1.length());	    }	}
@Override	public String toString() {	    return String.valueOf(value);	}
public static final String unescapeJson(final String input) {	    return UNESCAPE_JSON.translate(input);	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
@Override	public boolean ready() {	    return pos < StrBuilder.this.size();	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
public int capacity() {	    return buffer.length;	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
Pattern getParsePattern() {	    return parsePattern;	}
@Override	public boolean markSupported() {	    return true;	}
public int toComparison() {	    return comparison;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public static String right(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(str.length() - len);	}
protected boolean isFullDetail(final Boolean fullDetailRequest) {	    if (fullDetailRequest == null) {	        return defaultFullDetail;	    }	    return fullDetailRequest.booleanValue();	}
public int toHashCode() {	    return iTotal;	}
public boolean isEmptyTokenAsNull() {	    return this.emptyAsNull;	}
public static boolean isWhitespace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isWhitespace(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
@Override	public void setFormatsByArgumentIndex(final Format[] newFormats) {	    throw new UnsupportedOperationException();	}
public static boolean isJavaAwtHeadless() {	    return JAVA_AWT_HEADLESS != null ? JAVA_AWT_HEADLESS.equals(Boolean.TRUE.toString()) : false;	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public static String trim(final String str) {	    return str == null ? null : str.trim();	}
@Override	public Integer build() {	    return Integer.valueOf(toHashCode());	}
protected boolean isArrayContentDetail() {	    return arrayContentDetail;	}
public static boolean isEmpty(final CharSequence cs) {	    return cs == null || cs.length() == 0;	}
public long getTime() {	    return getNanoTime() / NANO_2_MILLIS;	}
protected boolean isDefaultFullDetail() {	    return defaultFullDetail;	}
public boolean isEquals() {	    return this.isEquals;	}
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = Integer.MAX_VALUE;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.indexOf(str, search, 0);	        if (tmp == INDEX_NOT_FOUND) {	            continue;	        }	        if (tmp < ret) {	            ret = tmp;	        }	    }	    return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public boolean isIgnoreEmptyTokens() {	    return ignoreEmptyTokens;	}
@Override	public void mark(final int readAheadLimit) {	    mark = pos;	}
public StrBuilder appendNewLine() {	    if (newLine == null) {	        append(SystemUtils.LINE_SEPARATOR);	        return this;	    }	    return append(newLine);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static String swapCase(final String str) {	    if (StringUtils.isEmpty(str)) {	        return str;	    }	    final char[] buffer = str.toCharArray();	    for (int i = 0; i < buffer.length; i++) {	        final char ch = buffer[i];	        if (Character.isUpperCase(ch)) {	            buffer[i] = Character.toLowerCase(ch);	        } else if (Character.isTitleCase(ch)) {	            buffer[i] = Character.toLowerCase(ch);	        } else if (Character.isLowerCase(ch)) {	            buffer[i] = Character.toUpperCase(ch);	        }	    }	    return new String(buffer);	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static String[] substringsBetween(final String str, final String open, final String close) {	    if (str == null || isEmpty(open) || isEmpty(close)) {	        return null;	    }	    final int strLen = str.length();	    if (strLen == 0) {	        return ArrayUtils.EMPTY_STRING_ARRAY;	    }	    final int closeLen = close.length();	    final int openLen = open.length();	    final List<String> list = new ArrayList<String>();	    int pos = 0;	    while (pos < strLen - closeLen) {	        int start = str.indexOf(open, pos);	        if (start < 0) {	            break;	        }	        start += openLen;	        final int end = str.indexOf(close, start);	        if (end < 0) {	            break;	        }	        list.add(str.substring(start, end));	        pos = end + closeLen;	    }	    if (list.isEmpty()) {	        return null;	    }	    return list.toArray(new String[list.size()]);	}
protected String getFieldNameValueSeparator() {	    return fieldNameValueSeparator;	}
public static short[] removeElement(final short[] array, final short element) {	    final int index = indexOf(array, element);	    if (index == INDEX_NOT_FOUND) {	        return clone(array);	    }	    return remove(array, index);	}
private static Date set(final Date date, final int calendarField, final int amount) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final Calendar c = Calendar.getInstance();	    c.setLenient(false);	    c.setTime(date);	    c.set(calendarField, amount);	    return c.getTime();	}
public int clear(final int holder) {	    return holder & ~_mask;	}
@Override	public int compareTo(final Triple<L, M, R> other) {	    return new CompareToBuilder().append(getLeft(), other.getLeft()).append(getMiddle(), other.getMiddle()).append(getRight(), other.getRight()).toComparison();	}
public static String random(final int count, final char... chars) {	    if (chars == null) {	        return random(count, 0, 0, false, false, null, RANDOM);	    }	    return random(count, 0, chars.length, false, false, chars, RANDOM);	}
@Override	public int length() {	    return size;	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    buffer.append(arrayStart);	    for (int i = 0; i < array.length; i++) {	        if (i > 0) {	            buffer.append(arraySeparator);	        }	        appendDetail(buffer, fieldName, array[i]);	    }	    buffer.append(arrayEnd);	}
protected String getContentEnd() {	    return contentEnd;	}
public static float min(final float a, final float b, final float c) {	    return Math.min(Math.min(a, b), c);	}
public static boolean equalsIgnoreCase(final CharSequence str1, final CharSequence str2) {	    if (str1 == null || str2 == null) {	        return str1 == str2;	    } else if (str1 == str2) {	        return true;	    } else if (str1.length() != str2.length()) {	        return false;	    } else {	        return CharSequenceUtils.regionMatches(str1, true, 0, str2, 0, str1.length());	    }	}
public static float min(final float a, final float b) {	    if (Float.isNaN(a)) {	        return b;	    } else if (Float.isNaN(b)) {	        return a;	    } else {	        return Math.min(a, b);	    }	}
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) {	    style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));	    return this;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static String lowerCase(final String str, final Locale locale) {	    if (str == null) {	        return null;	    }	    return str.toLowerCase(locale);	}
public String getNewLineText() {	    return newLine;	}
@Override	public boolean translate(final int codepoint, final Writer out) throws IOException {	    if (between) {	        if (codepoint < below || codepoint > above) {	            return false;	        }	    } else {	        if (codepoint >= below && codepoint <= above) {	            return false;	        }	    }	    out.write("&#");	    out.write(Integer.toString(codepoint, 10));	    out.write(';');	    return true;	}
public String getNewLineText() {	    return newLine;	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public static <T> T notNull(final T object, final String message, final Object... values) {	    if (object == null) {	        throw new NullPointerException(String.format(message, values));	    }	    return object;	}
public static String formatDuration(long durationMillis, final String format, final boolean padWithZeros) {	    final Token[] tokens = lexx(format);	    int days = 0;	    int hours = 0;	    int minutes = 0;	    int seconds = 0;	    int milliseconds = 0;	    if (Token.containsTokenWithValue(tokens, d)) {	        days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY);	        durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY);	    }	    if (Token.containsTokenWithValue(tokens, H)) {	        hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR);	        durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR);	    }	    if (Token.containsTokenWithValue(tokens, m)) {	        minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE);	        durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE);	    }	    if (Token.containsTokenWithValue(tokens, s)) {	        seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND);	        durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND);	    }	    if (Token.containsTokenWithValue(tokens, S)) {	        milliseconds = (int) durationMillis;	    }	    return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) {	    final StringBuilder buffer = new StringBuilder();	    boolean lastOutputSeconds = false;	    final int sz = tokens.length;	    for (int i = 0; i < sz; i++) {	        final Token token = tokens[i];	        final Object value = token.getValue();	        final int count = token.getCount();	        if (value instanceof StringBuilder) {	            buffer.append(value.toString());	        } else {	            if (value == y) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years));	                lastOutputSeconds = false;	            } else if (value == M) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months));	                lastOutputSeconds = false;	            } else if (value == d) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days));	                lastOutputSeconds = false;	            } else if (value == H) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours));	                lastOutputSeconds = false;	            } else if (value == m) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes));	                lastOutputSeconds = false;	            } else if (value == s) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds));	                lastOutputSeconds = true;	            } else if (value == S) {	                if (lastOutputSeconds) {	                    milliseconds += 1000;	                    final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds);	                    buffer.append(str.substring(1));	                } else {	                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds));	                }	                lastOutputSeconds = false;	            }	        }	    }	    return buffer.toString();	}
public StrBuilder appendNull() {	    if (nullText == null) {	        return this;	    }	    return append(nullText);	}
@Override	public String previous() {	    if (hasPrevious()) {	        return tokens[--tokenPos];	    }	    throw new NoSuchElementException();	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public int lastIndexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex >= size ? size - 1 : startIndex);	    if (matcher == null || startIndex < 0) {	        return -1;	    }	    final char[] buf = buffer;	    final int endIndex = startIndex + 1;	    for (int i = startIndex; i >= 0; i--) {	        if (matcher.isMatch(buf, i, 0, endIndex) > 0) {	            return i;	        }	    }	    return -1;	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public byte setByte(final byte holder) {	    return (byte) set(holder);	}
public static String removeEnd(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.endsWith(remove)) {	        return str.substring(0, str.length() - remove.length());	    }	    return str;	}
public static final String escapeHtml4(final String input) {	    return ESCAPE_HTML4.translate(input);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
@Override	public String getFormattedExceptionMessage(final String baseMessage) {	    return exceptionContext.getFormattedExceptionMessage(baseMessage);	}
public static StrTokenizer getTSVInstance(final char[] input) {	    final StrTokenizer tok = getTSVClone();	    tok.reset(input);	    return tok;	}
public static final String unescapeHtml4(final String input) {	    return UNESCAPE_HTML4.translate(input);	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
protected boolean isUseClassName() {	    return useClassName;	}
public static String getCommonPrefix(final String... strs) {	    if (strs == null || strs.length == 0) {	        return EMPTY;	    }	    final int smallestIndexOfDiff = indexOfDifference(strs);	    if (smallestIndexOfDiff == INDEX_NOT_FOUND) {	        if (strs[0] == null) {	            return EMPTY;	        }	        return strs[0];	    } else if (smallestIndexOfDiff == 0) {	        return EMPTY;	    } else {	        return strs[0].substring(0, smallestIndexOfDiff);	    }	}
public StrTokenizer reset(final char[] input) {	    reset();	    this.chars = ArrayUtils.clone(input);	    return this;	}
public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {	    if (str == null || searchStr == null) {	        return INDEX_NOT_FOUND;	    }	    if (startPos > str.length() - searchStr.length()) {	        startPos = str.length() - searchStr.length();	    }	    if (startPos < 0) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return startPos;	    }	    for (int i = startPos; i >= 0; i--) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    for (final CharSequenceTranslator translator : translators) {	        final int consumed = translator.translate(input, index, out);	        if (consumed != 0) {	            return consumed;	        }	    }	    return 0;	}
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = Integer.MAX_VALUE;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.indexOf(str, search, 0);	        if (tmp == INDEX_NOT_FOUND) {	            continue;	        }	        if (tmp < ret) {	            ret = tmp;	        }	    }	    return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) {	    if (s == null || t == null) {	        throw new IllegalArgumentException("Strings must not be null");	    }	    if (threshold < 0) {	        throw new IllegalArgumentException("Threshold must not be negative");	    }	    int n = s.length();	    int m = t.length();	    if (n == 0) {	        return m <= threshold ? m : -1;	    } else if (m == 0) {	        return n <= threshold ? n : -1;	    }	    if (n > m) {	        final CharSequence tmp = s;	        s = t;	        t = tmp;	        n = m;	        m = t.length();	    }	    int[] p = new int[n + 1];	    int[] d = new int[n + 1];	    int[] _d;	    final int boundary = Math.min(n, threshold) + 1;	    for (int i = 0; i < boundary; i++) {	        p[i] = i;	    }	    Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);	    Arrays.fill(d, Integer.MAX_VALUE);	    for (int j = 1; j <= m; j++) {	        final char t_j = t.charAt(j - 1);	        d[0] = j;	        final int min = Math.max(1, j - threshold);	        final int max = Math.min(n, j + threshold);	        if (min > max) {	            return -1;	        }	        if (min > 1) {	            d[min - 1] = Integer.MAX_VALUE;	        }	        for (int i = min; i <= max; i++) {	            if (s.charAt(i - 1) == t_j) {	                d[i] = p[i - 1];	            } else {	                d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);	            }	        }	        _d = p;	        p = d;	        d = _d;	    }	    if (p[n] <= threshold) {	        return p[n];	    }	    return -1;	}
public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment) {	    return getFragment(calendar, fragment, Calendar.MILLISECOND);	}
@Override	public String toString() {	    return name;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public int capacity() {	    return buffer.length;	}
protected boolean isUseShortClassName() {	    return useShortClassName;	}
protected String getContentStart() {	    return contentStart;	}
public static File getJavaIoTmpDir() {	    return new File(System.getProperty(JAVA_IO_TMPDIR_KEY));	}
@Override	public TimeZone getTimeZone() {	    return timeZone;	}
@Override	public boolean hasNext() {	    return spot.before(endFinal);	}
public boolean isEquals() {	    return this.isEquals;	}
static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {	    final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);	    String pattern = cDateTimeInstanceCache.get(key);	    if (pattern == null) {	        try {	            DateFormat formatter;	            if (dateStyle == null) {	                formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);	            } else if (timeStyle == null) {	                formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);	            } else {	                formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);	            }	            pattern = ((SimpleDateFormat) formatter).toPattern();	            final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);	            if (previous != null) {	                pattern = previous;	            }	        } catch (final ClassCastException ex) {	            throw new IllegalArgumentException("No date time pattern for locale: " + locale);	        }	    }	    return pattern;	}
public static short toShort(final String str, final short defaultValue) {	    if (str == null) {	        return defaultValue;	    }	    try {	        return Short.parseShort(str);	    } catch (final NumberFormatException nfe) {	        return defaultValue;	    }	}
protected boolean isUseFieldNames() {	    return useFieldNames;	}
protected String getArrayEnd() {	    return arrayEnd;	}
@Override	public boolean isFieldSeparatorAtStart() {	    return super.isFieldSeparatorAtStart();	}
public static String squeeze(final String str, final String... set) {	    if (StringUtils.isEmpty(str) || deepEmpty(set)) {	        return str;	    }	    final CharSet chars = CharSet.getInstance(set);	    final StringBuilder buffer = new StringBuilder(str.length());	    final char[] chrs = str.toCharArray();	    final int sz = chrs.length;	    char lastChar = ' ';	    char ch = ' ';	    for (int i = 0; i < sz; i++) {	        ch = chrs[i];	        if (ch == lastChar && i != 0 && chars.contains(ch)) {	            continue;	        }	        buffer.append(ch);	        lastChar = ch;	    }	    return buffer.toString();	}
protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    appendSummarySize(buffer, fieldName, array.length);	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) {	    if (str == null) {	        if (trueString == null) {	            return Boolean.TRUE;	        }	        if (falseString == null) {	            return Boolean.FALSE;	        }	        if (nullString == null) {	            return null;	        }	    } else if (str.equals(trueString)) {	        return Boolean.TRUE;	    } else if (str.equals(falseString)) {	        return Boolean.FALSE;	    } else if (str.equals(nullString)) {	        return null;	    }	    throw new IllegalArgumentException("The String did not match any specified value");	}
private static Date set(final Date date, final int calendarField, final int amount) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final Calendar c = Calendar.getInstance();	    c.setLenient(false);	    c.setTime(date);	    c.set(calendarField, amount);	    return c.getTime();	}
public StrTokenizer setEmptyTokenAsNull(final boolean emptyAsNull) {	    this.emptyAsNull = emptyAsNull;	    return this;	}
public static String replaceOnce(final String text, final String searchString, final String replacement) {	    return replace(text, searchString, replacement, 1);	}
protected String getContentStart() {	    return contentStart;	}
@Override	public Date parse(final String source, final ParsePosition pos) {	    final int offset = pos.getIndex();	    final Matcher matcher = parsePattern.matcher(source.substring(offset));	    if (!matcher.lookingAt()) {	        return null;	    }	    final Calendar cal = Calendar.getInstance(timeZone, locale);	    cal.clear();	    for (int i = 0; i < strategies.length; ) {	        final Strategy strategy = strategies[i++];	        strategy.setCalendar(this, cal, matcher.group(i));	    }	    pos.setIndex(offset + matcher.end());	    return cal.getTime();	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static String removePattern(final String source, final String regex) {	    return replacePattern(source, regex, StringUtils.EMPTY);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public Fraction subtract(final Fraction fraction) {	    return addSub(fraction, false);	}
public StrBuilder appendFixedWidthPadRight(final int value, final int width, final char padChar) {	    return appendFixedWidthPadRight(String.valueOf(value), width, padChar);	}
public StrBuilder trim() {	    if (size == 0) {	        return this;	    }	    int len = size;	    final char[] buf = buffer;	    int pos = 0;	    while (pos < len && buf[pos] <= ' ') {	        pos++;	    }	    while (pos < len && buf[len - 1] <= ' ') {	        len--;	    }	    if (len < size) {	        delete(len, size);	    }	    if (pos > 0) {	        delete(0, pos);	    }	    return this;	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public static final String unescapeHtml3(final String input) {	    return UNESCAPE_HTML3.translate(input);	}
protected void appendNullText(final StringBuffer buffer, final String fieldName) {	    buffer.append(nullText);	}
public int size() {	    return size;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static String replacePattern(final String source, final String regex, final String replacement) {	    return Pattern.compile(regex, Pattern.DOTALL).matcher(source).replaceAll(replacement);	}
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException {	    return charsetName == null ? new String(bytes) : new String(bytes, charsetName);	}
public boolean isIgnoreEmptyTokens() {	    return ignoreEmptyTokens;	}
public static Class<?> getClass(final String className, final boolean initialize) throws ClassNotFoundException {	    final ClassLoader contextCL = Thread.currentThread().getContextClassLoader();	    final ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL;	    return getClass(loader, className, initialize);	}
@Override	public void reset() {	    pos = mark;	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public boolean isEquals() {	    return this.isEquals;	}
public static Boolean[] nullToEmpty(final Boolean[] array) {	    if (array == null || array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    return array;	}
public static boolean contains(final boolean[] array, final boolean valueToFind) {	    return indexOf(array, valueToFind) != INDEX_NOT_FOUND;	}
public static boolean isEmpty(final CharSequence cs) {	    return cs == null || cs.length() == 0;	}
public static Class<?> getRawType(final Type type, final Type assigningType) {	    if (type instanceof Class<?>) {	        return (Class<?>) type;	    }	    if (type instanceof ParameterizedType) {	        return getRawType((ParameterizedType) type);	    }	    if (type instanceof TypeVariable<?>) {	        if (assigningType == null) {	            return null;	        }	        final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration();	        if (!(genericDeclaration instanceof Class<?>)) {	            return null;	        }	        final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType, (Class<?>) genericDeclaration);	        if (typeVarAssigns == null) {	            return null;	        }	        final Type typeArgument = typeVarAssigns.get(type);	        if (typeArgument == null) {	            return null;	        }	        return getRawType(typeArgument, assigningType);	    }	    if (type instanceof GenericArrayType) {	        final Class<?> rawComponentType = getRawType(((GenericArrayType) type).getGenericComponentType(), assigningType);	        return Array.newInstance(rawComponentType, 0).getClass();	    }	    if (type instanceof WildcardType) {	        return null;	    }	    throw new IllegalArgumentException("unknown type: " + type);	}
@Override	public int hashCode() {	    return Float.floatToIntBits(value);	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public static String replaceEachRepeatedly(final String text, final String[] searchList, final String[] replacementList) {	    final int timeToLive = searchList == null ? 0 : searchList.length;	    return replaceEach(text, searchList, replacementList, true, timeToLive);	}
public static String[] stripAll(final String[] strs, final String stripChars) {	    int strsLen;	    if (strs == null || (strsLen = strs.length) == 0) {	        return strs;	    }	    final String[] newArr = new String[strsLen];	    for (int i = 0; i < strsLen; i++) {	        newArr[i] = strip(strs[i], stripChars);	    }	    return newArr;	}
@Override	public boolean translate(final int codepoint, final Writer out) throws IOException {	    if (between) {	        if (codepoint < below || codepoint > above) {	            return false;	        }	    } else {	        if (codepoint >= below && codepoint <= above) {	            return false;	        }	    }	    if (codepoint > 0xffff) {	        out.write(toUtf16Escape(codepoint));	    } else if (codepoint > 0xfff) {	        out.write("\\u" + hex(codepoint));	    } else if (codepoint > 0xff) {	        out.write("\\u0" + hex(codepoint));	    } else if (codepoint > 0xf) {	        out.write("\\u00" + hex(codepoint));	    } else {	        out.write("\\u000" + hex(codepoint));	    }	    return true;	}
public static String substringBeforeLast(final String str, final String separator) {	    if (isEmpty(str) || isEmpty(separator)) {	        return str;	    }	    final int pos = str.lastIndexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return str;	    }	    return str.substring(0, pos);	}
@Override	public TimeZone getTimeZone() {	    return mTimeZone;	}
public boolean contains(final StrMatcher matcher) {	    return indexOf(matcher, 0) >= 0;	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public static int truncatedCompareTo(final Date date1, final Date date2, final int field) {	    final Date truncatedDate1 = truncate(date1, field);	    final Date truncatedDate2 = truncate(date2, field);	    return truncatedDate1.compareTo(truncatedDate2);	}
public HashCodeBuilder append(final short[] array) {	    if (array == null) {	        iTotal = iTotal * iConstant;	    } else {	        for (final short element : array) {	            append(element);	        }	    }	    return this;	}
protected String getContentStart() {	    return contentStart;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
@Override	public boolean isDone() {	    return true;	}
public static float min(final float a, final float b) {	    if (Float.isNaN(a)) {	        return b;	    } else if (Float.isNaN(b)) {	        return a;	    } else {	        return Math.min(a, b);	    }	}
public static Object readField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException {	    if (target == null) {	        throw new IllegalArgumentException("target object must not be null");	    }	    final Class<?> cls = target.getClass();	    final Field field = getField(cls, fieldName, forceAccess);	    if (field == null) {	        throw new IllegalArgumentException("Cannot locate field " + fieldName + " on " + cls);	    }	    return readField(field, target);	}
public static boolean startsWithAny(final CharSequence string, final CharSequence... searchStrings) {	    if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {	        return false;	    }	    for (final CharSequence searchString : searchStrings) {	        if (StringUtils.startsWith(string, searchString)) {	            return true;	        }	    }	    return false;	}
public static String[] stripAll(final String[] strs, final String stripChars) {	    int strsLen;	    if (strs == null || (strsLen = strs.length) == 0) {	        return strs;	    }	    final String[] newArr = new String[strsLen];	    for (int i = 0; i < strsLen; i++) {	        newArr[i] = strip(strs[i], stripChars);	    }	    return newArr;	}
public static float min(final float a, final float b) {	    if (Float.isNaN(a)) {	        return b;	    } else if (Float.isNaN(b)) {	        return a;	    } else {	        return Math.min(a, b);	    }	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
public StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, 1);	}
public boolean isEquals() {	    return this.isEquals;	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public boolean isEmpty() {	    return size == 0;	}
@Override	public Short getValue() {	    return Short.valueOf(this.value);	}
public static boolean contains(final boolean[] array, final boolean valueToFind) {	    return indexOf(array, valueToFind) != INDEX_NOT_FOUND;	}
@Override	public long skip(long n) {	    if (pos + n > StrBuilder.this.size()) {	        n = StrBuilder.this.size() - pos;	    }	    if (n < 0) {	        return 0;	    }	    pos += n;	    return n;	}
public static boolean isAllLowerCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLowerCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
protected String getArrayEnd() {	    return arrayEnd;	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
@Override	public BasicThreadFactory build() {	    final BasicThreadFactory factory = new BasicThreadFactory(this);	    reset();	    return factory;	}
public static <T extends CharSequence> T notEmpty(final T chars) {	    return notEmpty(chars, DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE);	}
@Override	public boolean equals(final Object obj) {	    if (obj == this) {	        return true;	    }	    if (obj instanceof Triple<?, ?, ?>) {	        final Triple<?, ?, ?> other = (Triple<?, ?, ?>) obj;	        return ObjectUtils.equals(getLeft(), other.getLeft()) && ObjectUtils.equals(getMiddle(), other.getMiddle()) && ObjectUtils.equals(getRight(), other.getRight());	    }	    return false;	}
public static String[] stripAll(final String[] strs, final String stripChars) {	    int strsLen;	    if (strs == null || (strsLen = strs.length) == 0) {	        return strs;	    }	    final String[] newArr = new String[strsLen];	    for (int i = 0; i < strsLen; i++) {	        newArr[i] = strip(strs[i], stripChars);	    }	    return newArr;	}
public static String trim(final String str) {	    return str == null ? null : str.trim();	}
public int capacity() {	    return buffer.length;	}
public static Boolean or(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
public static int countMatches(final CharSequence str, final CharSequence sub) {	    if (isEmpty(str) || isEmpty(sub)) {	        return 0;	    }	    int count = 0;	    int idx = 0;	    while ((idx = CharSequenceUtils.indexOf(str, sub, idx)) != INDEX_NOT_FOUND) {	        count++;	        idx += sub.length();	    }	    return count;	}
protected boolean isArrayContentDetail() {	    return arrayContentDetail;	}
public StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, 1);	}
@Override	public R getRight() {	    return right;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static String normalizeSpace(final String str) {	    if (str == null) {	        return null;	    }	    return WHITESPACE_PATTERN.matcher(trim(str)).replaceAll(SPACE);	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
@Override	public int length() {	    return size;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
@Override	public String previous() {	    if (hasPrevious()) {	        return tokens[--tokenPos];	    }	    throw new NoSuchElementException();	}
public int capacity() {	    return buffer.length;	}
@Override	public StringBuffer format(final Calendar calendar, final StringBuffer buf) {	    return printer.format(calendar, buf);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static Class<?> getRawType(final Type type, final Type assigningType) {	    if (type instanceof Class<?>) {	        return (Class<?>) type;	    }	    if (type instanceof ParameterizedType) {	        return getRawType((ParameterizedType) type);	    }	    if (type instanceof TypeVariable<?>) {	        if (assigningType == null) {	            return null;	        }	        final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration();	        if (!(genericDeclaration instanceof Class<?>)) {	            return null;	        }	        final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType, (Class<?>) genericDeclaration);	        if (typeVarAssigns == null) {	            return null;	        }	        final Type typeArgument = typeVarAssigns.get(type);	        if (typeArgument == null) {	            return null;	        }	        return getRawType(typeArgument, assigningType);	    }	    if (type instanceof GenericArrayType) {	        final Class<?> rawComponentType = getRawType(((GenericArrayType) type).getGenericComponentType(), assigningType);	        return Array.newInstance(rawComponentType, 0).getClass();	    }	    if (type instanceof WildcardType) {	        return null;	    }	    throw new IllegalArgumentException("unknown type: " + type);	}
@Override	public int compareTo(final MutableFloat other) {	    final float anotherVal = other.value;	    return Float.compare(value, anotherVal);	}
public StrBuilder appendSeparator(final char separator, final int loopIndex) {	    if (loopIndex > 0) {	        append(separator);	    }	    return this;	}
public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) {	    if (s == null || t == null) {	        throw new IllegalArgumentException("Strings must not be null");	    }	    if (threshold < 0) {	        throw new IllegalArgumentException("Threshold must not be negative");	    }	    int n = s.length();	    int m = t.length();	    if (n == 0) {	        return m <= threshold ? m : -1;	    } else if (m == 0) {	        return n <= threshold ? n : -1;	    }	    if (n > m) {	        final CharSequence tmp = s;	        s = t;	        t = tmp;	        n = m;	        m = t.length();	    }	    int[] p = new int[n + 1];	    int[] d = new int[n + 1];	    int[] _d;	    final int boundary = Math.min(n, threshold) + 1;	    for (int i = 0; i < boundary; i++) {	        p[i] = i;	    }	    Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);	    Arrays.fill(d, Integer.MAX_VALUE);	    for (int j = 1; j <= m; j++) {	        final char t_j = t.charAt(j - 1);	        d[0] = j;	        final int min = Math.max(1, j - threshold);	        final int max = Math.min(n, j + threshold);	        if (min > max) {	            return -1;	        }	        if (min > 1) {	            d[min - 1] = Integer.MAX_VALUE;	        }	        for (int i = min; i <= max; i++) {	            if (s.charAt(i - 1) == t_j) {	                d[i] = p[i - 1];	            } else {	                d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);	            }	        }	        _d = p;	        p = d;	        d = _d;	    }	    if (p[n] <= threshold) {	        return p[n];	    }	    return -1;	}
public static Boolean[] toObject(final boolean[] array) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    final Boolean[] result = new Boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        result[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE);	    }	    return result;	}
public short clearShort(final short holder) {	    return (short) clear(holder);	}
public static long getFragmentInMinutes(final Calendar calendar, final int fragment) {	    return getFragment(calendar, fragment, Calendar.MINUTE);	}
public boolean isIgnoreEmptyTokens() {	    return ignoreEmptyTokens;	}
public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer) {	    if (throwable == null) {	        return;	    }	    if (writer == null) {	        throw new IllegalArgumentException("The PrintWriter must not be null");	    }	    final String[] trace = getRootCauseStackTrace(throwable);	    for (final String element : trace) {	        writer.println(element);	    }	    writer.flush();	}
public int size() {	    return size;	}
Object getValue() {	    return value;	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
@Override	public Object clone() {	    try {	        return cloneReset();	    } catch (final CloneNotSupportedException ex) {	        return null;	    }	}
public char[] toCharArray(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len == 0) {	        return ArrayUtils.EMPTY_CHAR_ARRAY;	    }	    final char[] chars = new char[len];	    System.arraycopy(buffer, startIndex, chars, 0, len);	    return chars;	}
public static int indexOfAnyBut(final CharSequence seq, final CharSequence searchChars) {	    if (isEmpty(seq) || isEmpty(searchChars)) {	        return INDEX_NOT_FOUND;	    }	    final int strLen = seq.length();	    for (int i = 0; i < strLen; i++) {	        final char ch = seq.charAt(i);	        final boolean chFound = CharSequenceUtils.indexOf(searchChars, ch, 0) >= 0;	        if (i + 1 < strLen && Character.isHighSurrogate(ch)) {	            final char ch2 = seq.charAt(i + 1);	            if (chFound && CharSequenceUtils.indexOf(searchChars, ch2, 0) < 0) {	                return i;	            }	        } else {	            if (!chFound) {	                return i;	            }	        }	    }	    return INDEX_NOT_FOUND;	}
public int set(final int holder) {	    return holder | _mask;	}
@Override	public String toString() {	    if (tokens == null) {	        return "StrTokenizer[not tokenized yet]";	    }	    return "StrTokenizer" + getTokenList();	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public static Boolean[] nullToEmpty(final Boolean[] array) {	    if (array == null || array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    return array;	}
@Override	public boolean markSupported() {	    return true;	}
@Override	public int compare(final Object obj1, final Object obj2) {	    return ((Comparable) obj1).compareTo(obj2);	}
public String getNullText() {	    return nullText;	}
public String getNewLineText() {	    return newLine;	}
public StrTokenizer setEmptyTokenAsNull(final boolean emptyAsNull) {	    this.emptyAsNull = emptyAsNull;	    return this;	}
public static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) {	    if (0 == nBools) {	        return dst;	    }	    if (nBools - 1 + srcPos >= 64) {	        throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 64");	    }	    int shift = 0;	    for (int i = 0; i < nBools; i++) {	        shift = i * 1 + srcPos;	        dst[dstPos + i] = ((0x1 & (src >> shift)) != 0);	    }	    return dst;	}
public boolean isEmpty() {	    return size == 0;	}
public static boolean isAlpha(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static Object readStaticField(final Class<?> cls, final String fieldName, final boolean forceAccess) throws IllegalAccessException {	    final Field field = getField(cls, fieldName, forceAccess);	    if (field == null) {	        throw new IllegalArgumentException("Cannot locate field " + fieldName + " on " + cls);	    }	    return readStaticField(field, false);	}
protected String getFieldSeparator() {	    return fieldSeparator;	}
public StrBuilder deleteAll(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, -1);	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public String getNullText() {	    return nullText;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public static boolean isNotEmpty(final boolean[] array) {	    return (array != null && array.length != 0);	}
public static String stripAccents(final String input) {	    if (input == null) {	        return null;	    }	    final Pattern pattern = Pattern.compile("\\p{InCombiningDiacriticalMarks}+");	    final String decomposed = Normalizer.normalize(input, Normalizer.Form.NFD);	    return pattern.matcher(decomposed).replaceAll("");	}
protected boolean isArrayContentDetail() {	    return arrayContentDetail;	}
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = Integer.MAX_VALUE;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.indexOf(str, search, 0);	        if (tmp == INDEX_NOT_FOUND) {	            continue;	        }	        if (tmp < ret) {	            ret = tmp;	        }	    }	    return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;	}
public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) {	    if (array == null) {	        return null;	    }	    if (startIndexInclusive < 0) {	        startIndexInclusive = 0;	    }	    if (endIndexExclusive > array.length) {	        endIndexExclusive = array.length;	    }	    final int newSize = endIndexExclusive - startIndexInclusive;	    if (newSize <= 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] subarray = new boolean[newSize];	    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);	    return subarray;	}
@Override	public String toString() {	    return "FastDateParser[" + pattern + "," + locale + "," + timeZone.getID() + "]";	}
private static Date add(final Date date, final int calendarField, final int amount) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final Calendar c = Calendar.getInstance();	    c.setTime(date);	    c.add(calendarField, amount);	    return c.getTime();	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static String[] splitByCharacterTypeCamelCase(final String str) {	    return splitByCharacterType(str, true);	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public Integer toInteger() {	    return Integer.valueOf(intValue());	}
private static Date add(final Date date, final int calendarField, final int amount) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final Calendar c = Calendar.getInstance();	    c.setTime(date);	    c.add(calendarField, amount);	    return c.getTime();	}
public static String getCommonPrefix(final String... strs) {	    if (strs == null || strs.length == 0) {	        return EMPTY;	    }	    final int smallestIndexOfDiff = indexOfDifference(strs);	    if (smallestIndexOfDiff == INDEX_NOT_FOUND) {	        if (strs[0] == null) {	            return EMPTY;	        }	        return strs[0];	    } else if (smallestIndexOfDiff == 0) {	        return EMPTY;	    } else {	        return strs[0].substring(0, smallestIndexOfDiff);	    }	}
protected String getArraySeparator() {	    return arraySeparator;	}
private static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal, final boolean lastIndex) {	    if (str == null || searchStr == null || ordinal <= 0) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return lastIndex ? str.length() : 0;	    }	    int found = 0;	    int index = lastIndex ? str.length() : INDEX_NOT_FOUND;	    do {	        if (lastIndex) {	            index = CharSequenceUtils.lastIndexOf(str, searchStr, index - 1);	        } else {	            index = CharSequenceUtils.indexOf(str, searchStr, index + 1);	        }	        if (index < 0) {	            return index;	        }	        found++;	    } while (found < ordinal);	    return index;	}
private static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal, final boolean lastIndex) {	    if (str == null || searchStr == null || ordinal <= 0) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return lastIndex ? str.length() : 0;	    }	    int found = 0;	    int index = lastIndex ? str.length() : INDEX_NOT_FOUND;	    do {	        if (lastIndex) {	            index = CharSequenceUtils.lastIndexOf(str, searchStr, index - 1);	        } else {	            index = CharSequenceUtils.indexOf(str, searchStr, index + 1);	        }	        if (index < 0) {	            return index;	        }	        found++;	    } while (found < ordinal);	    return index;	}
protected String getFieldSeparator() {	    return fieldSeparator;	}
public static String capitalize(final String str) {	    int strLen;	    if (str == null || (strLen = str.length()) == 0) {	        return str;	    }	    char firstChar = str.charAt(0);	    if (Character.isTitleCase(firstChar)) {	        return str;	    }	    return new StringBuilder(strLen).append(Character.toTitleCase(firstChar)).append(str.substring(1)).toString();	}
public static int hexDigitMsb0ToInt(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return 0x0;	        case '1':	            return 0x8;	        case '2':	            return 0x4;	        case '3':	            return 0xC;	        case '4':	            return 0x2;	        case '5':	            return 0xA;	        case '6':	            return 0x6;	        case '7':	            return 0xE;	        case '8':	            return 0x1;	        case '9':	            return 0x9;	        case 'a':	        case 'A':	            return 0x5;	        case 'b':	        case 'B':	            return 0xD;	        case 'c':	        case 'C':	            return 0x3;	        case 'd':	        case 'D':	            return 0xB;	        case 'e':	        case 'E':	            return 0x7;	        case 'f':	        case 'F':	            return 0xF;	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
@Override	public int compareTo(final Pair<L, R> other) {	    return new CompareToBuilder().append(getLeft(), other.getLeft()).append(getRight(), other.getRight()).toComparison();	}
protected boolean isFieldSeparatorAtStart() {	    return fieldSeparatorAtStart;	}
public static Character toCharacterObject(final String str) {	    if (StringUtils.isEmpty(str)) {	        return null;	    }	    return Character.valueOf(str.charAt(0));	}
protected void setArrayEnd(String arrayEnd) {	    if (arrayEnd == null) {	        arrayEnd = "";	    }	    this.arrayEnd = arrayEnd;	}
protected String getNullText() {	    return nullText;	}
public static String upperCase(final String str, final Locale locale) {	    if (str == null) {	        return null;	    }	    return str.toUpperCase(locale);	}
@Override	public StringBuffer format(final Calendar calendar, final StringBuffer buf) {	    return applyRules(calendar, buf);	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public Fraction negate() {	    if (numerator == Integer.MIN_VALUE) {	        throw new ArithmeticException("overflow: too large to negate");	    }	    return new Fraction(-numerator, denominator);	}
public static boolean isAllUpperCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isUpperCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static CharRange is(final char ch) {	    return new CharRange(ch, ch, false);	}
public int lastIndexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex >= size ? size - 1 : startIndex);	    if (matcher == null || startIndex < 0) {	        return -1;	    }	    final char[] buf = buffer;	    final int endIndex = startIndex + 1;	    for (int i = startIndex; i >= 0; i--) {	        if (matcher.isMatch(buf, i, 0, endIndex) > 0) {	            return i;	        }	    }	    return -1;	}
public static String formatPeriodISO(final long startMillis, final long endMillis) {	    return formatPeriod(startMillis, endMillis, ISO_EXTENDED_FORMAT_PATTERN, false, TimeZone.getDefault());	}
@Override	public Integer build() {	    return Integer.valueOf(toHashCode());	}
public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) {	    if (it != null) {	        separator = ObjectUtils.toString(separator);	        while (it.hasNext()) {	            append(it.next());	            if (it.hasNext()) {	                append(separator);	            }	        }	    }	    return this;	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public int lastIndexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex >= size ? size - 1 : startIndex);	    if (matcher == null || startIndex < 0) {	        return -1;	    }	    final char[] buf = buffer;	    final int endIndex = startIndex + 1;	    for (int i = startIndex; i >= 0; i--) {	        if (matcher.isMatch(buf, i, 0, endIndex) > 0) {	            return i;	        }	    }	    return -1;	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) {	    if (str == null) {	        if (trueString == null) {	            return Boolean.TRUE;	        }	        if (falseString == null) {	            return Boolean.FALSE;	        }	        if (nullString == null) {	            return null;	        }	    } else if (str.equals(trueString)) {	        return Boolean.TRUE;	    } else if (str.equals(falseString)) {	        return Boolean.FALSE;	    } else if (str.equals(nullString)) {	        return null;	    }	    throw new IllegalArgumentException("The String did not match any specified value");	}
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {	    if (array == null) {	        if (index != 0) {	            throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0");	        }	        final Object joinedArray = Array.newInstance(clss, 1);	        Array.set(joinedArray, 0, element);	        return joinedArray;	    }	    final int length = Array.getLength(array);	    if (index > length || index < 0) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(clss, length + 1);	    System.arraycopy(array, 0, result, 0, index);	    Array.set(result, index, element);	    if (index < length) {	        System.arraycopy(array, index, result, index + 1, length - index);	    }	    return result;	}
public boolean isEmpty() {	    return size == 0;	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static String removeEnd(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.endsWith(remove)) {	        return str.substring(0, str.length() - remove.length());	    }	    return str;	}
public boolean contains(final CharRange range) {	    if (range == null) {	        throw new IllegalArgumentException("The Range must not be null");	    }	    if (negated) {	        if (range.negated) {	            return start >= range.start && end <= range.end;	        }	        return range.end < start || range.start > end;	    }	    if (range.negated) {	        return start == 0 && end == Character.MAX_VALUE;	    }	    return start <= range.start && end >= range.end;	}
public static int countMatches(final CharSequence str, final CharSequence sub) {	    if (isEmpty(str) || isEmpty(sub)) {	        return 0;	    }	    int count = 0;	    int idx = 0;	    while ((idx = CharSequenceUtils.indexOf(str, sub, idx)) != INDEX_NOT_FOUND) {	        count++;	        idx += sub.length();	    }	    return count;	}
public StrBuilder setLength(final int length) {	    if (length < 0) {	        throw new StringIndexOutOfBoundsException(length);	    }	    if (length < size) {	        size = length;	    } else if (length > size) {	        ensureCapacity(length);	        final int oldEnd = size;	        final int newEnd = length;	        size = length;	        for (int i = oldEnd; i < newEnd; i++) {	            buffer[i] = '\0';	        }	    }	    return this;	}
public void getChars(final int startIndex, final int endIndex, final char[] destination, final int destinationIndex) {	    if (startIndex < 0) {	        throw new StringIndexOutOfBoundsException(startIndex);	    }	    if (endIndex < 0 || endIndex > length()) {	        throw new StringIndexOutOfBoundsException(endIndex);	    }	    if (startIndex > endIndex) {	        throw new StringIndexOutOfBoundsException("end < start");	    }	    System.arraycopy(buffer, startIndex, destination, destinationIndex, endIndex - startIndex);	}
public static float min(final float a, final float b, final float c) {	    return Math.min(Math.min(a, b), c);	}
@Override	public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) {	    return formatter.format(obj, toAppendTo, pos);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return true;	    }	    if (lhs == null || rhs == null) {	        return false;	    }	    final Class<?> lhsClass = lhs.getClass();	    final Class<?> rhsClass = rhs.getClass();	    Class<?> testClass;	    if (lhsClass.isInstance(rhs)) {	        testClass = lhsClass;	        if (!rhsClass.isInstance(lhs)) {	            testClass = rhsClass;	        }	    } else if (rhsClass.isInstance(lhs)) {	        testClass = rhsClass;	        if (!lhsClass.isInstance(rhs)) {	            testClass = lhsClass;	        }	    } else {	        return false;	    }	    final EqualsBuilder equalsBuilder = new EqualsBuilder();	    try {	        reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {	            testClass = testClass.getSuperclass();	            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        }	    } catch (final IllegalArgumentException e) {	        return false;	    }	    return equalsBuilder.isEquals();	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public boolean contains(final CharRange range) {	    if (range == null) {	        throw new IllegalArgumentException("The Range must not be null");	    }	    if (negated) {	        if (range.negated) {	            return start >= range.start && end <= range.end;	        }	        return range.end < start || range.start > end;	    }	    if (range.negated) {	        return start == 0 && end == Character.MAX_VALUE;	    }	    return start <= range.start && end >= range.end;	}
public static String[] stripAll(final String[] strs, final String stripChars) {	    int strsLen;	    if (strs == null || (strsLen = strs.length) == 0) {	        return strs;	    }	    final String[] newArr = new String[strsLen];	    for (int i = 0; i < strsLen; i++) {	        newArr[i] = strip(strs[i], stripChars);	    }	    return newArr;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public static char intToHexDigit(final int nibble) {	    final char c = Character.forDigit(nibble, 16);	    if (c == Character.MIN_VALUE) {	        throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble);	    }	    return c;	}
public void start() {	    if (this.runningState == STATE_STOPPED) {	        throw new IllegalStateException("Stopwatch must be reset before being restarted. ");	    }	    if (this.runningState != STATE_UNSTARTED) {	        throw new IllegalStateException("Stopwatch already started. ");	    }	    this.startTime = System.nanoTime();	    this.startTimeMillis = System.currentTimeMillis();	    this.runningState = STATE_RUNNING;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, true);	}
public static Date truncate(final Object date, final int field) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (date instanceof Date) {	        return truncate((Date) date, field);	    } else if (date instanceof Calendar) {	        return truncate((Calendar) date, field).getTime();	    } else {	        throw new ClassCastException("Could not truncate " + date);	    }	}
public int capacity() {	    return buffer.length;	}
public static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts) {	    if (0 == nInts) {	        return dst;	    }	    if ((nInts - 1) * 32 + srcPos >= 64) {	        throw new IllegalArgumentException("(nInts-1)*32+srcPos is greather or equal to than 64");	    }	    int shift = 0;	    for (int i = 0; i < nInts; i++) {	        shift = i * 32 + srcPos;	        dst[dstPos + i] = (int) (0xffffffff & (src >> shift));	    }	    return dst;	}
protected String getContentEnd() {	    return contentEnd;	}
public static String replaceChars(final String str, final String searchChars, String replaceChars) {	    if (isEmpty(str) || isEmpty(searchChars)) {	        return str;	    }	    if (replaceChars == null) {	        replaceChars = EMPTY;	    }	    boolean modified = false;	    final int replaceCharsLength = replaceChars.length();	    final int strLength = str.length();	    final StringBuilder buf = new StringBuilder(strLength);	    for (int i = 0; i < strLength; i++) {	        final char ch = str.charAt(i);	        final int index = searchChars.indexOf(ch);	        if (index >= 0) {	            modified = true;	            if (index < replaceCharsLength) {	                buf.append(replaceChars.charAt(index));	            }	        } else {	            buf.append(ch);	        }	    }	    if (modified) {	        return buf.toString();	    }	    return str;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public boolean isEmptyTokenAsNull() {	    return this.emptyAsNull;	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
public static float max(final float a, final float b) {	    if (Float.isNaN(a)) {	        return b;	    } else if (Float.isNaN(b)) {	        return a;	    } else {	        return Math.max(a, b);	    }	}
public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException {	    return parseDateWithLeniency(str, locale, parsePatterns, true);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
public boolean isEmptyTokenAsNull() {	    return this.emptyAsNull;	}
public String getNullText() {	    return nullText;	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
public ToStringBuilder appendToString(final String toString) {	    if (toString != null) {	        style.appendToString(buffer, toString);	    }	    return this;	}
public static <T extends CharSequence> T notBlank(final T chars) {	    return notBlank(chars, DEFAULT_NOT_BLANK_EX_MESSAGE);	}
public static boolean isAlphanumericSpace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetterOrDigit(cs.charAt(i)) == false && cs.charAt(i) != ' ') {	            return false;	        }	    }	    return true;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
protected String getSizeStartText() {	    return sizeStartText;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static BigInteger createBigInteger(final String str) {	    if (str == null) {	        return null;	    }	    int pos = 0;	    int radix = 10;	    boolean negate = false;	    if (str.startsWith("-")) {	        negate = true;	        pos = 1;	    }	    if (str.startsWith("0x", pos) || str.startsWith("0x", pos)) {	        radix = 16;	        pos += 2;	    } else if (str.startsWith("#", pos)) {	        radix = 16;	        pos++;	    } else if (str.startsWith("0", pos) && str.length() > pos + 1) {	        radix = 8;	        pos++;	    }	    final BigInteger value = new BigInteger(str.substring(pos), radix);	    return negate ? value.negate() : value;	}
public static boolean containsOnly(final CharSequence cs, final String validChars) {	    if (cs == null || validChars == null) {	        return false;	    }	    return containsOnly(cs, validChars.toCharArray());	}
public int size() {	    return size;	}
public static boolean contains(final boolean[] array, final boolean valueToFind) {	    return indexOf(array, valueToFind) != INDEX_NOT_FOUND;	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public static <K, V> V createIfAbsent(final ConcurrentMap<K, V> map, final K key, final ConcurrentInitializer<V> init) throws ConcurrentException {	    if (map == null || init == null) {	        return null;	    }	    final V value = map.get(key);	    if (value == null) {	        return putIfAbsent(map, key, init.get());	    }	    return value;	}
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] result = new boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        final Boolean b = array[i];	        result[i] = (b == null ? valueForNull : b.booleanValue());	    }	    return result;	}
@Override	public String next() {	    if (hasNext()) {	        return tokens[tokenPos++];	    }	    throw new NoSuchElementException();	}
@Override	public int length() {	    return size;	}
public static void handleCause(final ExecutionException ex) throws ConcurrentException {	    final ConcurrentException cex = extractCause(ex);	    if (cex != null) {	        throw cex;	    }	}
public boolean isEmpty() {	    return size == 0;	}
private static long getFragment(final Calendar calendar, final int fragment, final int unit) {	    if (calendar == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final long millisPerUnit = getMillisPerUnit(unit);	    long result = 0;	    switch(fragment) {	        case Calendar.YEAR:	            result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit;	            break;	        case Calendar.MONTH:	            result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit;	            break;	    }	    switch(fragment) {	        case Calendar.YEAR:	        case Calendar.MONTH:	        case Calendar.DAY_OF_YEAR:	        case Calendar.DATE:	            result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit;	        case Calendar.HOUR_OF_DAY:	            result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit;	        case Calendar.MINUTE:	            result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit;	        case Calendar.SECOND:	            result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit;	            break;	        case Calendar.MILLISECOND:	            break;	        default:	            throw new IllegalArgumentException("The fragment " + fragment + " is not supported");	    }	    return result;	}
public boolean contains(final T element) {	    if (element == null) {	        return false;	    }	    return comparator.compare(element, minimum) > -1 && comparator.compare(element, maximum) < 1;	}
public String getNewLineText() {	    return newLine;	}
public StrBuilder appendSeparator(final char separator, final int loopIndex) {	    if (loopIndex > 0) {	        append(separator);	    }	    return this;	}
public static String random(final int count, final char... chars) {	    if (chars == null) {	        return random(count, 0, 0, false, false, null, RANDOM);	    }	    return random(count, 0, chars.length, false, false, chars, RANDOM);	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static String substringBeforeLast(final String str, final String separator) {	    if (isEmpty(str) || isEmpty(separator)) {	        return str;	    }	    final int pos = str.lastIndexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return str;	    }	    return str.substring(0, pos);	}
protected boolean isFieldSeparatorAtEnd() {	    return fieldSeparatorAtEnd;	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
public int toHashCode() {	    return iTotal;	}
@Override	public TimeZone getTimeZone() {	    return printer.getTimeZone();	}
public EqualsBuilder appendSuper(final boolean superEquals) {	    if (isEquals == false) {	        return this;	    }	    isEquals = superEquals;	    return this;	}
public StrTokenizer setEmptyTokenAsNull(final boolean emptyAsNull) {	    this.emptyAsNull = emptyAsNull;	    return this;	}
public abstract R getRight();
public static String abbreviate(final String str, int offset, final int maxWidth) {	    if (str == null) {	        return null;	    }	    if (maxWidth < 4) {	        throw new IllegalArgumentException("Minimum abbreviation width is 4");	    }	    if (str.length() <= maxWidth) {	        return str;	    }	    if (offset > str.length()) {	        offset = str.length();	    }	    if (str.length() - offset < maxWidth - 3) {	        offset = str.length() - (maxWidth - 3);	    }	    final String abrevMarker = "...";	    if (offset <= 4) {	        return str.substring(0, maxWidth - 3) + abrevMarker;	    }	    if (maxWidth < 7) {	        throw new IllegalArgumentException("Minimum abbreviation width with offset is 7");	    }	    if (offset + maxWidth - 3 < str.length()) {	        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);	    }	    return abrevMarker + str.substring(str.length() - (maxWidth - 3));	}
static JavaVersion getJavaVersion(final String nom) {	    return get(nom);	}
public String getNewLineText() {	    return newLine;	}
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] result = new boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        final Boolean b = array[i];	        result[i] = (b == null ? valueForNull : b.booleanValue());	    }	    return result;	}
public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) {	    String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'");	    if (suppressLeadingZeroElements) {	        duration = " " + duration;	        String tmp = StringUtils.replaceOnce(duration, " 0 days", "");	        if (tmp.length() != duration.length()) {	            duration = tmp;	            tmp = StringUtils.replaceOnce(duration, " 0 hours", "");	            if (tmp.length() != duration.length()) {	                duration = tmp;	                tmp = StringUtils.replaceOnce(duration, " 0 minutes", "");	                duration = tmp;	                if (tmp.length() != duration.length()) {	                    duration = StringUtils.replaceOnce(tmp, " 0 seconds", "");	                }	            }	        }	        if (duration.length() != 0) {	            duration = duration.substring(1);	        }	    }	    if (suppressTrailingZeroElements) {	        String tmp = StringUtils.replaceOnce(duration, " 0 seconds", "");	        if (tmp.length() != duration.length()) {	            duration = tmp;	            tmp = StringUtils.replaceOnce(duration, " 0 minutes", "");	            if (tmp.length() != duration.length()) {	                duration = tmp;	                tmp = StringUtils.replaceOnce(duration, " 0 hours", "");	                if (tmp.length() != duration.length()) {	                    duration = StringUtils.replaceOnce(tmp, " 0 days", "");	                }	            }	        }	    }	    duration = " " + duration;	    duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second");	    duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute");	    duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour");	    duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day");	    return duration.trim();	}
public Fraction divideBy(final Fraction fraction) {	    if (fraction == null) {	        throw new IllegalArgumentException("The fraction must not be null");	    }	    if (fraction.numerator == 0) {	        throw new ArithmeticException("The fraction to divide by must not be zero");	    }	    return multiplyBy(fraction.invert());	}
public static boolean isNumeric(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isDigit(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static <T extends Iterable<?>> T noNullElements(final T iterable) {	    return noNullElements(iterable, DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE);	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static boolean isAlpha(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) {	    return new Range<T>(fromInclusive, toInclusive, comparator);	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) {	    if (s == null || t == null) {	        throw new IllegalArgumentException("Strings must not be null");	    }	    if (threshold < 0) {	        throw new IllegalArgumentException("Threshold must not be negative");	    }	    int n = s.length();	    int m = t.length();	    if (n == 0) {	        return m <= threshold ? m : -1;	    } else if (m == 0) {	        return n <= threshold ? n : -1;	    }	    if (n > m) {	        final CharSequence tmp = s;	        s = t;	        t = tmp;	        n = m;	        m = t.length();	    }	    int[] p = new int[n + 1];	    int[] d = new int[n + 1];	    int[] _d;	    final int boundary = Math.min(n, threshold) + 1;	    for (int i = 0; i < boundary; i++) {	        p[i] = i;	    }	    Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);	    Arrays.fill(d, Integer.MAX_VALUE);	    for (int j = 1; j <= m; j++) {	        final char t_j = t.charAt(j - 1);	        d[0] = j;	        final int min = Math.max(1, j - threshold);	        final int max = Math.min(n, j + threshold);	        if (min > max) {	            return -1;	        }	        if (min > 1) {	            d[min - 1] = Integer.MAX_VALUE;	        }	        for (int i = min; i <= max; i++) {	            if (s.charAt(i - 1) == t_j) {	                d[i] = p[i - 1];	            } else {	                d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);	            }	        }	        _d = p;	        p = d;	        d = _d;	    }	    if (p[n] <= threshold) {	        return p[n];	    }	    return -1;	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public boolean isEmpty() {	    return size == 0;	}
public static CharRange isNot(final char ch) {	    return new CharRange(ch, ch, true);	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public int toComparison() {	    return comparison;	}
protected boolean isFieldSeparatorAtStart() {	    return fieldSeparatorAtStart;	}
@Deprecated	public static Throwable getCause(final Throwable throwable, String[] methodNames) {	    if (throwable == null) {	        return null;	    }	    if (methodNames == null) {	        methodNames = CAUSE_METHOD_NAMES;	    }	    for (final String methodName : methodNames) {	        if (methodName != null) {	            final Throwable cause = getCauseUsingMethodName(throwable, methodName);	            if (cause != null) {	                return cause;	            }	        }	    }	    return null;	}
public static boolean isAlpha(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
@Override	public int read(final char[] b, final int off, int len) {	    if (off < 0 || len < 0 || off > b.length || (off + len) > b.length || (off + len) < 0) {	        throw new IndexOutOfBoundsException();	    }	    if (len == 0) {	        return 0;	    }	    if (pos >= StrBuilder.this.size()) {	        return -1;	    }	    if (pos + len > size()) {	        len = StrBuilder.this.size() - pos;	    }	    StrBuilder.this.getChars(pos, pos + len, b, off);	    pos += len;	    return len;	}
protected boolean isFieldSeparatorAtEnd() {	    return fieldSeparatorAtEnd;	}
@Override	public int length() {	    return size;	}
public static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) {	    if (0 == nHexs) {	        return dstInit;	    }	    if ((nHexs - 1) * 4 + srcPos >= 64) {	        throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 64");	    }	    final StringBuilder sb = new StringBuilder(dstInit);	    int shift = 0;	    int append = sb.length();	    for (int i = 0; i < nHexs; i++) {	        shift = i * 4 + srcPos;	        final int bits = (int) (0xF & (src >> shift));	        if (dstPos + i == append) {	            ++append;	            sb.append(intToHexDigit(bits));	        } else {	            sb.setCharAt(dstPos + i, intToHexDigit(bits));	        }	    }	    return sb.toString();	}
@Override	public String toString() {	    if (this.getObject() == null) {	        return this.getStyle().getNullText();	    }	    Class<?> clazz = this.getObject().getClass();	    this.appendFieldsIn(clazz);	    while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {	        clazz = clazz.getSuperclass();	        this.appendFieldsIn(clazz);	    }	    return super.toString();	}
public static String[] stripAll(final String[] strs, final String stripChars) {	    int strsLen;	    if (strs == null || (strsLen = strs.length) == 0) {	        return strs;	    }	    final String[] newArr = new String[strsLen];	    for (int i = 0; i < strsLen; i++) {	        newArr[i] = strip(strs[i], stripChars);	    }	    return newArr;	}
@Override	public int length() {	    return size;	}
public static boolean containsOnly(final CharSequence cs, final String validChars) {	    if (cs == null || validChars == null) {	        return false;	    }	    return containsOnly(cs, validChars.toCharArray());	}
public static Class<?>[] primitivesToWrappers(final Class<?>... classes) {	    if (classes == null) {	        return null;	    }	    if (classes.length == 0) {	        return classes;	    }	    final Class<?>[] convertedClasses = new Class[classes.length];	    for (int i = 0; i < classes.length; i++) {	        convertedClasses[i] = primitiveToWrapper(classes[i]);	    }	    return convertedClasses;	}
public static String removeStartIgnoreCase(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (startsWithIgnoreCase(str, remove)) {	        return str.substring(remove.length());	    }	    return str;	}
public static <T> Range<T> is(final T element, final Comparator<T> comparator) {	    return between(element, element, comparator);	}
public static Boolean[] nullToEmpty(final Boolean[] array) {	    if (array == null || array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    return array;	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public static int toIntValue(final Character ch, final int defaultValue) {	    if (ch == null) {	        return defaultValue;	    }	    return toIntValue(ch.charValue(), defaultValue);	}
public int size() {	    return size;	}
public static Method getPublicMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) throws SecurityException, NoSuchMethodException {	    final Method declaredMethod = cls.getMethod(methodName, parameterTypes);	    if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) {	        return declaredMethod;	    }	    final List<Class<?>> candidateClasses = new ArrayList<Class<?>>();	    candidateClasses.addAll(getAllInterfaces(cls));	    candidateClasses.addAll(getAllSuperclasses(cls));	    for (final Class<?> candidateClass : candidateClasses) {	        if (!Modifier.isPublic(candidateClass.getModifiers())) {	            continue;	        }	        Method candidateMethod;	        try {	            candidateMethod = candidateClass.getMethod(methodName, parameterTypes);	        } catch (final NoSuchMethodException ex) {	            continue;	        }	        if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) {	            return candidateMethod;	        }	    }	    throw new NoSuchMethodException("Can't find a public method for " + methodName + " " + ArrayUtils.toString(parameterTypes));	}
public static short[] removeElement(final short[] array, final short element) {	    final int index = indexOf(array, element);	    if (index == INDEX_NOT_FOUND) {	        return clone(array);	    }	    return remove(array, index);	}
public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) {	    if (array == null) {	        return null;	    }	    if (startIndexInclusive < 0) {	        startIndexInclusive = 0;	    }	    if (endIndexExclusive > array.length) {	        endIndexExclusive = array.length;	    }	    final int newSize = endIndexExclusive - startIndexInclusive;	    if (newSize <= 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] subarray = new boolean[newSize];	    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);	    return subarray;	}
public int size() {	    return size;	}
public boolean isEmpty() {	    return size == 0;	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public static <T> T initialize(final ConcurrentInitializer<T> initializer) throws ConcurrentException {	    return initializer != null ? initializer.get() : null;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public StrBuilder setLength(final int length) {	    if (length < 0) {	        throw new StringIndexOutOfBoundsException(length);	    }	    if (length < size) {	        size = length;	    } else if (length > size) {	        ensureCapacity(length);	        final int oldEnd = size;	        final int newEnd = length;	        size = length;	        for (int i = oldEnd; i < newEnd; i++) {	            buffer[i] = '\0';	        }	    }	    return this;	}
public static char toChar(final String str, final char defaultValue) {	    if (StringUtils.isEmpty(str)) {	        return defaultValue;	    }	    return str.charAt(0);	}
public int size() {	    return size;	}
public static boolean equalsIgnoreCase(final CharSequence str1, final CharSequence str2) {	    if (str1 == null || str2 == null) {	        return str1 == str2;	    } else if (str1 == str2) {	        return true;	    } else if (str1.length() != str2.length()) {	        return false;	    } else {	        return CharSequenceUtils.regionMatches(str1, true, 0, str2, 0, str1.length());	    }	}
public StrBuilder setCharAt(final int index, final char ch) {	    if (index < 0 || index >= length()) {	        throw new StringIndexOutOfBoundsException(index);	    }	    buffer[index] = ch;	    return this;	}
public static int hexDigitMsb0ToInt(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return 0x0;	        case '1':	            return 0x8;	        case '2':	            return 0x4;	        case '3':	            return 0xC;	        case '4':	            return 0x2;	        case '5':	            return 0xA;	        case '6':	            return 0x6;	        case '7':	            return 0xE;	        case '8':	            return 0x1;	        case '9':	            return 0x9;	        case 'a':	        case 'A':	            return 0x5;	        case 'b':	        case 'B':	            return 0xD;	        case 'c':	        case 'C':	            return 0x3;	        case 'd':	        case 'D':	            return 0xB;	        case 'e':	        case 'E':	            return 0x7;	        case 'f':	        case 'F':	            return 0xF;	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public StrTokenizer setTrimmerMatcher(final StrMatcher trimmer) {	    if (trimmer != null) {	        this.trimmerMatcher = trimmer;	    }	    return this;	}
public static String abbreviate(final String str, int offset, final int maxWidth) {	    if (str == null) {	        return null;	    }	    if (maxWidth < 4) {	        throw new IllegalArgumentException("Minimum abbreviation width is 4");	    }	    if (str.length() <= maxWidth) {	        return str;	    }	    if (offset > str.length()) {	        offset = str.length();	    }	    if (str.length() - offset < maxWidth - 3) {	        offset = str.length() - (maxWidth - 3);	    }	    final String abrevMarker = "...";	    if (offset <= 4) {	        return str.substring(0, maxWidth - 3) + abrevMarker;	    }	    if (maxWidth < 7) {	        throw new IllegalArgumentException("Minimum abbreviation width with offset is 7");	    }	    if (offset + maxWidth - 3 < str.length()) {	        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);	    }	    return abrevMarker + str.substring(str.length() - (maxWidth - 3));	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
protected boolean isArrayContentDetail() {	    return arrayContentDetail;	}
public static int hexDigitToInt(final char hexDigit) {	    final int digit = Character.digit(hexDigit, 16);	    if (digit < 0) {	        throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	    return digit;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) {	    String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'");	    if (suppressLeadingZeroElements) {	        duration = " " + duration;	        String tmp = StringUtils.replaceOnce(duration, " 0 days", "");	        if (tmp.length() != duration.length()) {	            duration = tmp;	            tmp = StringUtils.replaceOnce(duration, " 0 hours", "");	            if (tmp.length() != duration.length()) {	                duration = tmp;	                tmp = StringUtils.replaceOnce(duration, " 0 minutes", "");	                duration = tmp;	                if (tmp.length() != duration.length()) {	                    duration = StringUtils.replaceOnce(tmp, " 0 seconds", "");	                }	            }	        }	        if (duration.length() != 0) {	            duration = duration.substring(1);	        }	    }	    if (suppressTrailingZeroElements) {	        String tmp = StringUtils.replaceOnce(duration, " 0 seconds", "");	        if (tmp.length() != duration.length()) {	            duration = tmp;	            tmp = StringUtils.replaceOnce(duration, " 0 minutes", "");	            if (tmp.length() != duration.length()) {	                duration = tmp;	                tmp = StringUtils.replaceOnce(duration, " 0 hours", "");	                if (tmp.length() != duration.length()) {	                    duration = StringUtils.replaceOnce(tmp, " 0 days", "");	                }	            }	        }	    }	    duration = " " + duration;	    duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second");	    duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute");	    duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour");	    duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day");	    return duration.trim();	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static byte[] serialize(final Serializable obj) {	    final ByteArrayOutputStream baos = new ByteArrayOutputStream(512);	    serialize(obj, baos);	    return baos.toByteArray();	}
public static String getPackageCanonicalName(final String canonicalName) {	    return ClassUtils.getPackageName(getCanonicalName(canonicalName));	}
public static String trimToNull(final String str) {	    final String ts = trim(str);	    return isEmpty(ts) ? null : ts;	}
@Override	public int length() {	    return size;	}
public static String getPackageName(String className) {	    if (StringUtils.isEmpty(className)) {	        return StringUtils.EMPTY;	    }	    while (className.charAt(0) == '[') {	        className = className.substring(1);	    }	    if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {	        className = className.substring(1);	    }	    final int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);	    if (i == -1) {	        return StringUtils.EMPTY;	    }	    return className.substring(0, i);	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public static String stripAccents(final String input) {	    if (input == null) {	        return null;	    }	    final Pattern pattern = Pattern.compile("\\p{InCombiningDiacriticalMarks}+");	    final String decomposed = Normalizer.normalize(input, Normalizer.Form.NFD);	    return pattern.matcher(decomposed).replaceAll("");	}
public static String prependIfMissing(final String str, final CharSequence prefix, final CharSequence... prefixes) {	    return prependIfMissing(str, prefix, false, prefixes);	}
public static Method getMatchingAccessibleMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) {	    try {	        final Method method = cls.getMethod(methodName, parameterTypes);	        MemberUtils.setAccessibleWorkaround(method);	        return method;	    } catch (final NoSuchMethodException e) {	    }	    Method bestMatch = null;	    final Method[] methods = cls.getMethods();	    for (final Method method : methods) {	        if (method.getName().equals(methodName) && ClassUtils.isAssignable(parameterTypes, method.getParameterTypes(), true)) {	            final Method accessibleMethod = getAccessibleMethod(method);	            if (accessibleMethod != null && (bestMatch == null || MemberUtils.compareParameterTypes(accessibleMethod.getParameterTypes(), bestMatch.getParameterTypes(), parameterTypes) < 0)) {	                bestMatch = accessibleMethod;	            }	        }	    }	    if (bestMatch != null) {	        MemberUtils.setAccessibleWorkaround(bestMatch);	    }	    return bestMatch;	}
public static ConcurrentRuntimeException extractCauseUnchecked(final ExecutionException ex) {	    if (ex == null || ex.getCause() == null) {	        return null;	    }	    throwCause(ex);	    return new ConcurrentRuntimeException(ex.getMessage(), ex.getCause());	}
@Override	public boolean equals(final Object obj) {	    if (obj == this) {	        return true;	    }	    if (obj == null) {	        return false;	    }	    if (!super.equals(obj)) {	        return false;	    }	    if (ObjectUtils.notEqual(getClass(), obj.getClass())) {	        return false;	    }	    final ExtendedMessageFormat rhs = (ExtendedMessageFormat) obj;	    if (ObjectUtils.notEqual(toPattern, rhs.toPattern)) {	        return false;	    }	    if (ObjectUtils.notEqual(registry, rhs.registry)) {	        return false;	    }	    return true;	}
public Fraction pow(final int power) {	    if (power == 1) {	        return this;	    } else if (power == 0) {	        return ONE;	    } else if (power < 0) {	        if (power == Integer.MIN_VALUE) {	            return this.invert().pow(2).pow(-(power / 2));	        }	        return this.invert().pow(-power);	    } else {	        final Fraction f = this.multiplyBy(this);	        if (power % 2 == 0) {	            return f.pow(power / 2);	        } else {	            return f.pow(power / 2).multiplyBy(this);	        }	    }	}
public StrSubstitutor setVariableSuffix(final String suffix) {	    if (suffix == null) {	        throw new IllegalArgumentException("Variable suffix must not be null!");	    }	    return setVariableSuffixMatcher(StrMatcher.stringMatcher(suffix));	}
protected boolean isUseIdentityHashCode() {	    return useIdentityHashCode;	}
public int capacity() {	    return buffer.length;	}
public String getNewLineText() {	    return newLine;	}
public int capacity() {	    return buffer.length;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public static <E extends Enum<E>> EnumSet<E> processBitVector(final Class<E> enumClass, final long value) {	    checkBitVectorable(enumClass).getEnumConstants();	    return processBitVectors(enumClass, value);	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static boolean[] clone(final boolean[] array) {	    if (array == null) {	        return null;	    }	    return array.clone();	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public String midString(int index, final int length) {	    if (index < 0) {	        index = 0;	    }	    if (length <= 0 || index >= size) {	        return "";	    }	    if (size <= index + length) {	        return new String(buffer, index, size - index);	    }	    return new String(buffer, index, length);	}
public ConcurrentException getException(final String name) {	    checkName(name);	    return exceptions.get(name);	}
public static <T extends CharSequence> T notEmpty(final T chars) {	    return notEmpty(chars, DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE);	}
public long getPeriod() {	    return period;	}
public static String substringBeforeLast(final String str, final String separator) {	    if (isEmpty(str) || isEmpty(separator)) {	        return str;	    }	    final int pos = str.lastIndexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return str;	    }	    return str.substring(0, pos);	}
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return true;	    }	    if (lhs == null || rhs == null) {	        return false;	    }	    final Class<?> lhsClass = lhs.getClass();	    final Class<?> rhsClass = rhs.getClass();	    Class<?> testClass;	    if (lhsClass.isInstance(rhs)) {	        testClass = lhsClass;	        if (!rhsClass.isInstance(lhs)) {	            testClass = rhsClass;	        }	    } else if (rhsClass.isInstance(lhs)) {	        testClass = rhsClass;	        if (!lhsClass.isInstance(rhs)) {	            testClass = lhsClass;	        }	    } else {	        return false;	    }	    final EqualsBuilder equalsBuilder = new EqualsBuilder();	    try {	        reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {	            testClass = testClass.getSuperclass();	            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        }	    } catch (final IllegalArgumentException e) {	        return false;	    }	    return equalsBuilder.isEquals();	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
@Override	protected List<String> tokenize(final char[] chars, final int offset, final int count) {	    if (chars == null) {	        return super.tokenize(StrBuilder.this.buffer, 0, StrBuilder.this.size());	    }	    return super.tokenize(chars, offset, count);	}
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) {	    style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));	    return this;	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
public char getStart() {	    return this.start;	}
@Override	public int length() {	    return size;	}
public int capacity() {	    return buffer.length;	}
@Override	public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) {	    return buffer[pos] <= 32 ? 1 : 0;	}
public int size() {	    return size;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof FastDateFormat == false) {	        return false;	    }	    final FastDateFormat other = (FastDateFormat) obj;	    return printer.equals(other.printer);	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, true);	}
public static boolean isEmpty(final CharSequence cs) {	    return cs == null || cs.length() == 0;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public static String formatPeriodISO(final long startMillis, final long endMillis) {	    return formatPeriod(startMillis, endMillis, ISO_EXTENDED_FORMAT_PATTERN, false, TimeZone.getDefault());	}
public StrBuilder setLength(final int length) {	    if (length < 0) {	        throw new StringIndexOutOfBoundsException(length);	    }	    if (length < size) {	        size = length;	    } else if (length > size) {	        ensureCapacity(length);	        final int oldEnd = size;	        final int newEnd = length;	        size = length;	        for (int i = oldEnd; i < newEnd; i++) {	            buffer[i] = '\0';	        }	    }	    return this;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public static int indexOfDifference(final CharSequence... css) {	    if (css == null || css.length <= 1) {	        return INDEX_NOT_FOUND;	    }	    boolean anyStringNull = false;	    boolean allStringsNull = true;	    final int arrayLen = css.length;	    int shortestStrLen = Integer.MAX_VALUE;	    int longestStrLen = 0;	    for (int i = 0; i < arrayLen; i++) {	        if (css[i] == null) {	            anyStringNull = true;	            shortestStrLen = 0;	        } else {	            allStringsNull = false;	            shortestStrLen = Math.min(css[i].length(), shortestStrLen);	            longestStrLen = Math.max(css[i].length(), longestStrLen);	        }	    }	    if (allStringsNull || longestStrLen == 0 && !anyStringNull) {	        return INDEX_NOT_FOUND;	    }	    if (shortestStrLen == 0) {	        return 0;	    }	    int firstDiff = -1;	    for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {	        final char comparisonChar = css[0].charAt(stringPos);	        for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {	            if (css[arrayPos].charAt(stringPos) != comparisonChar) {	                firstDiff = stringPos;	                break;	            }	        }	        if (firstDiff != -1) {	            break;	        }	    }	    if (firstDiff == -1 && shortestStrLen != longestStrLen) {	        return shortestStrLen;	    }	    return firstDiff;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public static char binaryToHexDigit(final boolean[] src, final int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    if (src.length > srcPos + 3 && src[srcPos + 3]) {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src[srcPos]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof MutableShort) {	        return value == ((MutableShort) obj).shortValue();	    }	    return false;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static void identityToString(final StringBuilder builder, final Object object) {	    if (object == null) {	        throw new NullPointerException("Cannot get the toString of a null identity");	    }	    builder.append(object.getClass().getName()).append('@').append(Integer.toHexString(System.identityHashCode(object)));	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    final int seqEnd = input.length();	    if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') {	        int start = index + 2;	        boolean isHex = false;	        final char firstChar = input.charAt(start);	        if (firstChar == 'x' || firstChar == 'X') {	            start++;	            isHex = true;	            if (start == seqEnd) {	                return 0;	            }	        }	        int end = start;	        while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) {	            end++;	        }	        final boolean semiNext = end != seqEnd && input.charAt(end) == ';';	        if (!semiNext) {	            if (isSet(OPTION.semiColonRequired)) {	                return 0;	            } else if (isSet(OPTION.errorIfNoSemiColon)) {	                throw new IllegalArgumentException("Semi-colon required at end of numeric entity");	            }	        }	        int entityValue;	        try {	            if (isHex) {	                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);	            } else {	                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);	            }	        } catch (final NumberFormatException nfe) {	            return 0;	        }	        if (entityValue > 0xFFFF) {	            final char[] chrs = Character.toChars(entityValue);	            out.write(chrs[0]);	            out.write(chrs[1]);	        } else {	            out.write(entityValue);	        }	        return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0);	    }	    return 0;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static Boolean or(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) {	    if (it != null) {	        separator = ObjectUtils.toString(separator);	        while (it.hasNext()) {	            append(it.next());	            if (it.hasNext()) {	                append(separator);	            }	        }	    }	    return this;	}
@Override	public boolean markSupported() {	    return true;	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale) {	    return cache.getInstance(pattern, timeZone, locale);	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
public String getNullText() {	    return nullText;	}
public static int hexDigitMsb0ToInt(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return 0x0;	        case '1':	            return 0x8;	        case '2':	            return 0x4;	        case '3':	            return 0xC;	        case '4':	            return 0x2;	        case '5':	            return 0xA;	        case '6':	            return 0x6;	        case '7':	            return 0xE;	        case '8':	            return 0x1;	        case '9':	            return 0x9;	        case 'a':	        case 'A':	            return 0x5;	        case 'b':	        case 'B':	            return 0xD;	        case 'c':	        case 'C':	            return 0x3;	        case 'd':	        case 'D':	            return 0xB;	        case 'e':	        case 'E':	            return 0x7;	        case 'f':	        case 'F':	            return 0xF;	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public static String removeEndIgnoreCase(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (endsWithIgnoreCase(str, remove)) {	        return str.substring(0, str.length() - remove.length());	    }	    return str;	}
public StringBuffer getStringBuffer() {	    return buffer;	}
public StrBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar) {	    return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);	}
public boolean isAppendTransients() {	    return this.appendTransients;	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    if (index != 0) {	        throw new IllegalStateException("CsvUnescaper should never reach the [1] index");	    }	    if (input.charAt(0) != CSV_QUOTE || input.charAt(input.length() - 1) != CSV_QUOTE) {	        out.write(input.toString());	        return input.length();	    }	    final String quoteless = input.subSequence(1, input.length() - 1).toString();	    if (StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS)) {	        out.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR));	    } else {	        out.write(input.toString());	    }	    return input.length();	}
public String getNullText() {	    return nullText;	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public static <V> StrLookup<V> mapLookup(final Map<String, V> map) {	    return new MapStrLookup<V>(map);	}
public static String appendIfMissing(final String str, final CharSequence suffix, final CharSequence... suffixes) {	    return appendIfMissing(str, suffix, false, suffixes);	}
public short getShortRawValue(final short holder) {	    return (short) getRawValue(holder);	}
public static String formatPeriodISO(final long startMillis, final long endMillis) {	    return formatPeriod(startMillis, endMillis, ISO_EXTENDED_FORMAT_PATTERN, false, TimeZone.getDefault());	}
public static String getPackageName(String className) {	    if (StringUtils.isEmpty(className)) {	        return StringUtils.EMPTY;	    }	    while (className.charAt(0) == '[') {	        className = className.substring(1);	    }	    if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {	        className = className.substring(1);	    }	    final int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);	    if (i == -1) {	        return StringUtils.EMPTY;	    }	    return className.substring(0, i);	}
public String getNullText() {	    return nullText;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static <T> T cloneIfPossible(final T obj) {	    final T clone = clone(obj);	    return clone == null ? obj : clone;	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
@Override	public int length() {	    return size;	}
protected boolean isFieldSeparatorAtStart() {	    return fieldSeparatorAtStart;	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
@Override	public Integer build() {	    return Integer.valueOf(toHashCode());	}
public short setShortValue(final short holder, final short value) {	    return (short) setValue(holder, value);	}
public Fraction negate() {	    if (numerator == Integer.MIN_VALUE) {	        throw new ArithmeticException("overflow: too large to negate");	    }	    return new Fraction(-numerator, denominator);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static char binaryToHexDigit(final boolean[] src, final int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    if (src.length > srcPos + 3 && src[srcPos + 3]) {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src[srcPos]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
public static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes) {	    if ((src.length == 0 && srcPos == 0) || 0 == nBytes) {	        return dstInit;	    }	    if ((nBytes - 1) * 8 + dstPos >= 16) {	        throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 16");	    }	    short out = dstInit;	    int shift = 0;	    for (int i = 0; i < nBytes; i++) {	        shift = i * 8 + dstPos;	        final int bits = (0xff & src[i + srcPos]) << shift;	        final int mask = 0xff << shift;	        out = (short) ((out & ~mask) | bits);	    }	    return out;	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
@Override	public float floatValue() {	    return value;	}
protected boolean isUseFieldNames() {	    return useFieldNames;	}
public static boolean isBlank(final CharSequence cs) {	    int strLen;	    if (cs == null || (strLen = cs.length()) == 0) {	        return true;	    }	    for (int i = 0; i < strLen; i++) {	        if (Character.isWhitespace(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) {	    style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));	    return this;	}
protected String getSizeStartText() {	    return sizeStartText;	}
public static String removeStart(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.startsWith(remove)) {	        return str.substring(remove.length());	    }	    return str;	}
public static boolean isEmpty(final CharSequence cs) {	    return cs == null || cs.length() == 0;	}
protected String getFieldNameValueSeparator() {	    return fieldNameValueSeparator;	}
public static <T> T CONST(final T v) {	    return v;	}
public StrBuilder deleteAll(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, -1);	}
public String getNullText() {	    return nullText;	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
protected boolean isFieldSeparatorAtStart() {	    return fieldSeparatorAtStart;	}
public boolean contains(final CharRange range) {	    if (range == null) {	        throw new IllegalArgumentException("The Range must not be null");	    }	    if (negated) {	        if (range.negated) {	            return start >= range.start && end <= range.end;	        }	        return range.end < start || range.start > end;	    }	    if (range.negated) {	        return start == 0 && end == Character.MAX_VALUE;	    }	    return start <= range.start && end >= range.end;	}
public void setUpToClass(final Class<?> clazz) {	    if (clazz != null) {	        final Object object = getObject();	        if (object != null && clazz.isInstance(object) == false) {	            throw new IllegalArgumentException("Specified class is not a superclass of the object");	        }	    }	    this.upToClass = clazz;	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
protected String getArrayEnd() {	    return arrayEnd;	}
protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf) {	    for (final Rule rule : mRules) {	        rule.appendTo(buf, calendar);	    }	    return buf;	}
public int size() {	    return size;	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static String removeStart(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.startsWith(remove)) {	        return str.substring(remove.length());	    }	    return str;	}
public static String right(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(str.length() - len);	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return true;	    }	    if (lhs == null || rhs == null) {	        return false;	    }	    final Class<?> lhsClass = lhs.getClass();	    final Class<?> rhsClass = rhs.getClass();	    Class<?> testClass;	    if (lhsClass.isInstance(rhs)) {	        testClass = lhsClass;	        if (!rhsClass.isInstance(lhs)) {	            testClass = rhsClass;	        }	    } else if (rhsClass.isInstance(lhs)) {	        testClass = rhsClass;	        if (!lhsClass.isInstance(rhs)) {	            testClass = lhsClass;	        }	    } else {	        return false;	    }	    final EqualsBuilder equalsBuilder = new EqualsBuilder();	    try {	        reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {	            testClass = testClass.getSuperclass();	            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        }	    } catch (final IllegalArgumentException e) {	        return false;	    }	    return equalsBuilder.isEquals();	}
public static boolean isAllUpperCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isUpperCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public boolean isAppendStatics() {	    return this.appendStatics;	}
public StrBuilder appendSeparator(final char separator, final int loopIndex) {	    if (loopIndex > 0) {	        append(separator);	    }	    return this;	}
public static <T> void inclusiveBetween(final T start, final T end, final Comparable<T> value, final String message, final Object... values) {	    if (value.compareTo(start) < 0 || value.compareTo(end) > 0) {	        throw new IllegalArgumentException(String.format(message, values));	    }	}
public boolean contains(final StrMatcher matcher) {	    return indexOf(matcher, 0) >= 0;	}
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, false);	}
public char[] toCharArray(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len == 0) {	        return ArrayUtils.EMPTY_CHAR_ARRAY;	    }	    final char[] chars = new char[len];	    System.arraycopy(buffer, startIndex, chars, 0, len);	    return chars;	}
@Override	public int intValue() {	    return value;	}
@Override	public String getSummaryObjectStartText() {	    return super.getSummaryObjectStartText();	}
public boolean isEmpty() {	    return size == 0;	}
protected ScheduledFuture<?> startTimer() {	    return getExecutorService().scheduleAtFixedRate(new Runnable() {		        @Override	        public void run() {	            endOfPeriod();	        }	    }, getPeriod(), getPeriod(), getUnit());	}
static boolean regionMatches(final CharSequence cs, final boolean ignoreCase, final int thisStart, final CharSequence substring, final int start, final int length) {	    if (cs instanceof String && substring instanceof String) {	        return ((String) cs).regionMatches(ignoreCase, thisStart, (String) substring, start, length);	    } else {	        int index1 = thisStart;	        int index2 = start;	        int tmpLen = length;	        while (tmpLen-- > 0) {	            char c1 = cs.charAt(index1++);	            char c2 = substring.charAt(index2++);	            if (c1 == c2) {	                continue;	            }	            if (!ignoreCase) {	                return false;	            }	            if (Character.toUpperCase(c1) != Character.toUpperCase(c2) && Character.toLowerCase(c1) != Character.toLowerCase(c2)) {	                return false;	            }	        }	        return true;	    }	}
private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase) {	    if (str == null || prefix == null) {	        return str == null && prefix == null;	    }	    if (prefix.length() > str.length()) {	        return false;	    }	    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());	}
public boolean contains(final StrMatcher matcher) {	    return indexOf(matcher, 0) >= 0;	}
@Override	public int length() {	    return size;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
static Object removeAll(final Object array, final BitSet indices) {	    final int srcLength = ArrayUtils.getLength(array);	    final int removals = indices.cardinality();	    final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals);	    int srcIndex = 0;	    int destIndex = 0;	    int count;	    int set;	    while ((set = indices.nextSetBit(srcIndex)) != -1) {	        count = set - srcIndex;	        if (count > 0) {	            System.arraycopy(array, srcIndex, result, destIndex, count);	            destIndex += count;	        }	        srcIndex = indices.nextClearBit(set);	    }	    count = srcLength - srcIndex;	    if (count > 0) {	        System.arraycopy(array, srcIndex, result, destIndex, count);	    }	    return result;	}
public static boolean isAlpha(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public Writer asWriter() {	    return new StrBuilderWriter();	}
protected String getFieldNameValueSeparator() {	    return fieldNameValueSeparator;	}
public int size() {	    return size;	}
@Override	public boolean markSupported() {	    return true;	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
public boolean isAppendTransients() {	    return this.appendTransients;	}
@Override	public CharSequence subSequence(final int startIndex, final int endIndex) {	    if (startIndex < 0) {	        throw new StringIndexOutOfBoundsException(startIndex);	    }	    if (endIndex > size) {	        throw new StringIndexOutOfBoundsException(endIndex);	    }	    if (startIndex > endIndex) {	        throw new StringIndexOutOfBoundsException(endIndex - startIndex);	    }	    return substring(startIndex, endIndex);	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
@Override	public boolean hasPrevious() {	    checkTokenized();	    return tokenPos > 0;	}
public boolean isEmpty() {	    return size == 0;	}
@Override	public double doubleValue() {	    return (double) numerator / (double) denominator;	}
public static String upperCase(final String str, final Locale locale) {	    if (str == null) {	        return null;	    }	    return str.toUpperCase(locale);	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    final int beSrcPos = src.length - 1 - srcPos;	    final int srcLen = Math.min(4, beSrcPos + 1);	    final boolean[] paddedSrc = new boolean[4];	    System.arraycopy(src, beSrcPos + 1 - srcLen, paddedSrc, 4 - srcLen, srcLen);	    src = paddedSrc;	    srcPos = 0;	    if (src[srcPos]) {	        if (src.length > srcPos + 1 && src[srcPos + 1]) {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 1 && src[srcPos + 1]) {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
@Override	public void mark(final int readAheadLimit) {	    mark = pos;	}
@Override	public int read(final char[] b, final int off, int len) {	    if (off < 0 || len < 0 || off > b.length || (off + len) > b.length || (off + len) < 0) {	        throw new IndexOutOfBoundsException();	    }	    if (len == 0) {	        return 0;	    }	    if (pos >= StrBuilder.this.size()) {	        return -1;	    }	    if (pos + len > size()) {	        len = StrBuilder.this.size() - pos;	    }	    StrBuilder.this.getChars(pos, pos + len, b, off);	    pos += len;	    return len;	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
public boolean equalsIgnoreCase(final StrBuilder other) {	    if (this == other) {	        return true;	    }	    if (this.size != other.size) {	        return false;	    }	    final char[] thisBuf = this.buffer;	    final char[] otherBuf = other.buffer;	    for (int i = size - 1; i >= 0; i--) {	        final char c1 = thisBuf[i];	        final char c2 = otherBuf[i];	        if (c1 != c2 && Character.toUpperCase(c1) != Character.toUpperCase(c2)) {	            return false;	        }	    }	    return true;	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public EqualsBuilder appendSuper(final boolean superEquals) {	    if (isEquals == false) {	        return this;	    }	    isEquals = superEquals;	    return this;	}
public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException {	    return parseDateWithLeniency(str, locale, parsePatterns, true);	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public String getNewLineText() {	    return newLine;	}
@Override	public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) {	    return formatter.format(obj, toAppendTo, pos);	}
public static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) {	    if (0 == nHexs) {	        return dstInit;	    }	    if ((nHexs - 1) * 4 + srcPos >= 8) {	        throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 8");	    }	    final StringBuilder sb = new StringBuilder(dstInit);	    int shift = 0;	    int append = sb.length();	    for (int i = 0; i < nHexs; i++) {	        shift = i * 4 + srcPos;	        final int bits = 0xF & (src >> shift);	        if (dstPos + i == append) {	            ++append;	            sb.append(intToHexDigit(bits));	        } else {	            sb.setCharAt(dstPos + i, intToHexDigit(bits));	        }	    }	    return sb.toString();	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
protected String getNullText() {	    return nullText;	}
public static Date truncate(final Object date, final int field) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (date instanceof Date) {	        return truncate((Date) date, field);	    } else if (date instanceof Calendar) {	        return truncate((Calendar) date, field).getTime();	    } else {	        throw new ClassCastException("Could not truncate " + date);	    }	}
public static <T> Range<T> is(final T element, final Comparator<T> comparator) {	    return between(element, element, comparator);	}
public static Fraction getReducedFraction(int numerator, int denominator) {	    if (denominator == 0) {	        throw new ArithmeticException("The denominator must not be zero");	    }	    if (numerator == 0) {	        return ZERO;	    }	    if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) {	        numerator /= 2;	        denominator /= 2;	    }	    if (denominator < 0) {	        if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {	            throw new ArithmeticException("overflow: can't negate");	        }	        numerator = -numerator;	        denominator = -denominator;	    }	    final int gcd = greatestCommonDivisor(numerator, denominator);	    numerator /= gcd;	    denominator /= gcd;	    return new Fraction(numerator, denominator);	}
public int getNumerator() {	    return numerator;	}
public final void translate(final CharSequence input, final Writer out) throws IOException {	    if (out == null) {	        throw new IllegalArgumentException("The Writer must not be null");	    }	    if (input == null) {	        return;	    }	    int pos = 0;	    final int len = input.length();	    while (pos < len) {	        final int consumed = translate(input, pos, out);	        if (consumed == 0) {	            final char[] c = Character.toChars(Character.codePointAt(input, pos));	            out.write(c);	            pos += c.length;	            continue;	        }	        for (int pt = 0; pt < consumed; pt++) {	            pos += Character.charCount(Character.codePointAt(input, pt));	        }	    }	}
public boolean isEmpty() {	    return size == 0;	}
protected String getContentStart() {	    return contentStart;	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
@Override	public int length() {	    return size;	}
public static String center(String str, final int size, String padStr) {	    if (str == null || size <= 0) {	        return str;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    str = leftPad(str, strLen + pads / 2, padStr);	    str = rightPad(str, size, padStr);	    return str;	}
public static CharRange isNot(final char ch) {	    return new CharRange(ch, ch, true);	}
public String getNewLineText() {	    return newLine;	}
@Override	public int length() {	    return size;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public static <T> T median(final Comparator<T> comparator, final T... items) {	    Validate.notEmpty(items, "null/empty items");	    Validate.noNullElements(items);	    Validate.notNull(comparator, "null comparator");	    final TreeSet<T> sort = new TreeSet<T>(comparator);	    Collections.addAll(sort, items);	    @SuppressWarnings("unchecked")	    final T result = (T) sort.toArray()[(sort.size() - 1) / 2];	    return result;	}
public boolean contains(final StrMatcher matcher) {	    return indexOf(matcher, 0) >= 0;	}
@Override	protected MultiBackgroundInitializerResults initialize() throws Exception {	    Map<String, BackgroundInitializer<?>> inits;	    synchronized (this) {	        inits = new HashMap<String, BackgroundInitializer<?>>(childInitializers);	    }	    final ExecutorService exec = getActiveExecutor();	    for (final BackgroundInitializer<?> bi : inits.values()) {	        if (bi.getExternalExecutor() == null) {	            bi.setExternalExecutor(exec);	        }	        bi.start();	    }	    final Map<String, Object> results = new HashMap<String, Object>();	    final Map<String, ConcurrentException> excepts = new HashMap<String, ConcurrentException>();	    for (final Map.Entry<String, BackgroundInitializer<?>> e : inits.entrySet()) {	        try {	            results.put(e.getKey(), e.getValue().get());	        } catch (final ConcurrentException cex) {	            excepts.put(e.getKey(), cex);	        }	    }	    return new MultiBackgroundInitializerResults(inits, results, excepts);	}
public int capacity() {	    return buffer.length;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
public static String rightPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return rightPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return str.concat(padStr);	    } else if (pads < padLen) {	        return str.concat(padStr.substring(0, pads));	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return str.concat(new String(padding));	    }	}
public static <T extends CharSequence> T defaultIfBlank(final T str, final T defaultStr) {	    return StringUtils.isBlank(str) ? defaultStr : str;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static <T extends Iterable<?>> T noNullElements(final T iterable) {	    return noNullElements(iterable, DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE);	}
@Override	public BasicThreadFactory build() {	    final BasicThreadFactory factory = new BasicThreadFactory(this);	    reset();	    return factory;	}
public static String replacePattern(final String source, final String regex, final String replacement) {	    return Pattern.compile(regex, Pattern.DOTALL).matcher(source).replaceAll(replacement);	}
protected String getSizeStartText() {	    return sizeStartText;	}
public static final String unescapeJson(final String input) {	    return UNESCAPE_JSON.translate(input);	}
public static int hexDigitMsb0ToInt(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return 0x0;	        case '1':	            return 0x8;	        case '2':	            return 0x4;	        case '3':	            return 0xC;	        case '4':	            return 0x2;	        case '5':	            return 0xA;	        case '6':	            return 0x6;	        case '7':	            return 0xE;	        case '8':	            return 0x1;	        case '9':	            return 0x9;	        case 'a':	        case 'A':	            return 0x5;	        case 'b':	        case 'B':	            return 0xD;	        case 'c':	        case 'C':	            return 0x3;	        case 'd':	        case 'D':	            return 0xB;	        case 'e':	        case 'E':	            return 0x7;	        case 'f':	        case 'F':	            return 0xF;	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public void split() {	    if (this.runningState != STATE_RUNNING) {	        throw new IllegalStateException("Stopwatch is not running. ");	    }	    this.stopTime = System.nanoTime();	    this.splitState = STATE_SPLIT;	}
public void split() {	    if (this.runningState != STATE_RUNNING) {	        throw new IllegalStateException("Stopwatch is not running. ");	    }	    this.stopTime = System.nanoTime();	    this.splitState = STATE_SPLIT;	}
public boolean isEmpty() {	    return size == 0;	}
@Override	public boolean equals(final Object other) {	    if (!(other instanceof IDKey)) {	        return false;	    }	    final IDKey idKey = (IDKey) other;	    if (id != idKey.id) {	        return false;	    }	    return value == idKey.value;	}
public static String substringBeforeLast(final String str, final String separator) {	    if (isEmpty(str) || isEmpty(separator)) {	        return str;	    }	    final int pos = str.lastIndexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return str;	    }	    return str.substring(0, pos);	}
public StrBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar) {	    return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);	}
@Override	public TimeZone getTimeZone() {	    return timeZone;	}
public static String[] stripAll(final String[] strs, final String stripChars) {	    int strsLen;	    if (strs == null || (strsLen = strs.length) == 0) {	        return strs;	    }	    final String[] newArr = new String[strsLen];	    for (int i = 0; i < strsLen; i++) {	        newArr[i] = strip(strs[i], stripChars);	    }	    return newArr;	}
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) {	    style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));	    return this;	}
@Override	public double doubleValue() {	    return (double) numerator / (double) denominator;	}
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) {	    style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));	    return this;	}
public static ConcurrentException extractCause(final ExecutionException ex) {	    if (ex == null || ex.getCause() == null) {	        return null;	    }	    throwCause(ex);	    return new ConcurrentException(ex.getMessage(), ex.getCause());	}
private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase) {	    if (str == null || prefix == null) {	        return str == null && prefix == null;	    }	    if (prefix.length() > str.length()) {	        return false;	    }	    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());	}
public StringBuffer toStringBuffer() {	    return new StringBuffer(size).append(buffer, 0, size);	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public static String replaceEachRepeatedly(final String text, final String[] searchList, final String[] replacementList) {	    final int timeToLive = searchList == null ? 0 : searchList.length;	    return replaceEach(text, searchList, replacementList, true, timeToLive);	}
public char getStart() {	    return this.start;	}
public static boolean isNumeric(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isDigit(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) {	    if (array == null) {	        return null;	    }	    if (startIndexInclusive < 0) {	        startIndexInclusive = 0;	    }	    if (endIndexExclusive > array.length) {	        endIndexExclusive = array.length;	    }	    final int newSize = endIndexExclusive - startIndexInclusive;	    if (newSize <= 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] subarray = new boolean[newSize];	    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);	    return subarray;	}
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) {	    if (str == null) {	        if (trueString == null) {	            return Boolean.TRUE;	        }	        if (falseString == null) {	            return Boolean.FALSE;	        }	        if (nullString == null) {	            return null;	        }	    } else if (str.equals(trueString)) {	        return Boolean.TRUE;	    } else if (str.equals(falseString)) {	        return Boolean.FALSE;	    } else if (str.equals(nullString)) {	        return null;	    }	    throw new IllegalArgumentException("The String did not match any specified value");	}
public static String upperCase(final String str, final Locale locale) {	    if (str == null) {	        return null;	    }	    return str.toUpperCase(locale);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
protected boolean isArrayContentDetail() {	    return arrayContentDetail;	}
protected boolean isDefaultFullDetail() {	    return defaultFullDetail;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public int getDenominator() {	    return denominator;	}
public static String random(final int count, final char... chars) {	    if (chars == null) {	        return random(count, 0, 0, false, false, null, RANDOM);	    }	    return random(count, 0, chars.length, false, false, chars, RANDOM);	}
public StrTokenizer setEmptyTokenAsNull(final boolean emptyAsNull) {	    this.emptyAsNull = emptyAsNull;	    return this;	}
@Override	public String toString() {	    return name;	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
@Override	public int hashCode() {	    return (getKey() == null ? 0 : getKey().hashCode()) ^ (getValue() == null ? 0 : getValue().hashCode());	}
public void add(final Number operand) {	    this.value += operand.longValue();	}
public String getNullText() {	    return nullText;	}
protected String getArrayStart() {	    return arrayStart;	}
public static <T extends CharSequence> T notEmpty(final T chars) {	    return notEmpty(chars, DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE);	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static <T> T defaultIfNull(final T object, final T defaultValue) {	    return object != null ? object : defaultValue;	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static String squeeze(final String str, final String... set) {	    if (StringUtils.isEmpty(str) || deepEmpty(set)) {	        return str;	    }	    final CharSet chars = CharSet.getInstance(set);	    final StringBuilder buffer = new StringBuilder(str.length());	    final char[] chrs = str.toCharArray();	    final int sz = chrs.length;	    char lastChar = ' ';	    char ch = ' ';	    for (int i = 0; i < sz; i++) {	        ch = chrs[i];	        if (ch == lastChar && i != 0 && chars.contains(ch)) {	            continue;	        }	        buffer.append(ch);	        lastChar = ch;	    }	    return buffer.toString();	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
protected String getFieldNameValueSeparator() {	    return fieldNameValueSeparator;	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
protected boolean isUseFieldNames() {	    return useFieldNames;	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public static boolean isWhitespace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isWhitespace(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static boolean endsWithAny(final CharSequence string, final CharSequence... searchStrings) {	    if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {	        return false;	    }	    for (final CharSequence searchString : searchStrings) {	        if (StringUtils.endsWith(string, searchString)) {	            return true;	        }	    }	    return false;	}
public static String[] substringsBetween(final String str, final String open, final String close) {	    if (str == null || isEmpty(open) || isEmpty(close)) {	        return null;	    }	    final int strLen = str.length();	    if (strLen == 0) {	        return ArrayUtils.EMPTY_STRING_ARRAY;	    }	    final int closeLen = close.length();	    final int openLen = open.length();	    final List<String> list = new ArrayList<String>();	    int pos = 0;	    while (pos < strLen - closeLen) {	        int start = str.indexOf(open, pos);	        if (start < 0) {	            break;	        }	        start += openLen;	        final int end = str.indexOf(close, start);	        if (end < 0) {	            break;	        }	        list.add(str.substring(start, end));	        pos = end + closeLen;	    }	    if (list.isEmpty()) {	        return null;	    }	    return list.toArray(new String[list.size()]);	}
@Override	public Integer getValue() {	    return Integer.valueOf(this.value);	}
public char getEnd() {	    return this.end;	}
protected String getArrayStart() {	    return arrayStart;	}
@Override	public int length() {	    return size;	}
public String getNewLineText() {	    return newLine;	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public int capacity() {	    return buffer.length;	}
public Fraction divideBy(final Fraction fraction) {	    if (fraction == null) {	        throw new IllegalArgumentException("The fraction must not be null");	    }	    if (fraction.numerator == 0) {	        throw new ArithmeticException("The fraction to divide by must not be zero");	    }	    return multiplyBy(fraction.invert());	}
@Override	public List<Pair<String, Object>> getContextEntries() {	    return this.exceptionContext.getContextEntries();	}
static void unregister(final Object lhs, final Object rhs) {	    Set<Pair<IDKey, IDKey>> registry = getRegistry();	    if (registry != null) {	        final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);	        registry.remove(pair);	        synchronized (EqualsBuilder.class) {	            registry = getRegistry();	            if (registry != null && registry.isEmpty()) {	                REGISTRY.remove();	            }	        }	    }	}
public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) {	    if (it != null) {	        separator = ObjectUtils.toString(separator);	        while (it.hasNext()) {	            append(it.next());	            if (it.hasNext()) {	                append(separator);	            }	        }	    }	    return this;	}
protected void setNullText(String nullText) {	    if (nullText == null) {	        nullText = "";	    }	    this.nullText = nullText;	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public static boolean isAllUpperCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isUpperCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
@Override	public int nextIndex() {	    return tokenPos;	}
public static <T> Range<T> is(final T element, final Comparator<T> comparator) {	    return between(element, element, comparator);	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static CharRange isIn(final char start, final char end) {	    return new CharRange(start, end, false);	}
public Fraction subtract(final Fraction fraction) {	    return addSub(fraction, false);	}
protected String getArraySeparator() {	    return arraySeparator;	}
public static <T> T invokeConstructor(final Class<T> cls, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {	    if (parameterTypes == null) {	        parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;	    }	    if (args == null) {	        args = ArrayUtils.EMPTY_OBJECT_ARRAY;	    }	    final Constructor<T> ctor = getMatchingAccessibleConstructor(cls, parameterTypes);	    if (ctor == null) {	        throw new NoSuchMethodException("No such accessible constructor on object: " + cls.getName());	    }	    return ctor.newInstance(args);	}
public static String mid(final String str, int pos, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0 || pos > str.length()) {	        return EMPTY;	    }	    if (pos < 0) {	        pos = 0;	    }	    if (str.length() <= pos + len) {	        return str.substring(pos);	    }	    return str.substring(pos, pos + len);	}
public static Date truncate(final Object date, final int field) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (date instanceof Date) {	        return truncate((Date) date, field);	    } else if (date instanceof Calendar) {	        return truncate((Calendar) date, field).getTime();	    } else {	        throw new ClassCastException("Could not truncate " + date);	    }	}
protected String getFieldSeparator() {	    return fieldSeparator;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
@Override	public String build() {	    return toString();	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
@Override	protected MultiBackgroundInitializerResults initialize() throws Exception {	    Map<String, BackgroundInitializer<?>> inits;	    synchronized (this) {	        inits = new HashMap<String, BackgroundInitializer<?>>(childInitializers);	    }	    final ExecutorService exec = getActiveExecutor();	    for (final BackgroundInitializer<?> bi : inits.values()) {	        if (bi.getExternalExecutor() == null) {	            bi.setExternalExecutor(exec);	        }	        bi.start();	    }	    final Map<String, Object> results = new HashMap<String, Object>();	    final Map<String, ConcurrentException> excepts = new HashMap<String, ConcurrentException>();	    for (final Map.Entry<String, BackgroundInitializer<?>> e : inits.entrySet()) {	        try {	            results.put(e.getKey(), e.getValue().get());	        } catch (final ConcurrentException cex) {	            excepts.put(e.getKey(), cex);	        }	    }	    return new MultiBackgroundInitializerResults(inits, results, excepts);	}
public boolean isEmptyTokenAsNull() {	    return this.emptyAsNull;	}
@Override	public float floatValue() {	    return (float) numerator / (float) denominator;	}
@Override	public double doubleValue() {	    return value;	}
public StrBuilder deleteFirst(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, 1);	}
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {	    if (array == null) {	        if (index != 0) {	            throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0");	        }	        final Object joinedArray = Array.newInstance(clss, 1);	        Array.set(joinedArray, 0, element);	        return joinedArray;	    }	    final int length = Array.getLength(array);	    if (index > length || index < 0) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(clss, length + 1);	    System.arraycopy(array, 0, result, 0, index);	    Array.set(result, index, element);	    if (index < length) {	        System.arraycopy(array, index, result, index + 1, length - index);	    }	    return result;	}
private static boolean endsWith(final CharSequence str, final CharSequence suffix, final boolean ignoreCase) {	    if (str == null || suffix == null) {	        return str == null && suffix == null;	    }	    if (suffix.length() > str.length()) {	        return false;	    }	    final int strOffset = str.length() - suffix.length();	    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, suffix, 0, suffix.length());	}
public static double[] addAll(final double[] array1, final double... array2) {	    if (array1 == null) {	        return clone(array2);	    } else if (array2 == null) {	        return clone(array1);	    }	    final double[] joinedArray = new double[array1.length + array2.length];	    System.arraycopy(array1, 0, joinedArray, 0, array1.length);	    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);	    return joinedArray;	}
public static boolean containsNone(final CharSequence cs, final String invalidChars) {	    if (cs == null || invalidChars == null) {	        return true;	    }	    return containsNone(cs, invalidChars.toCharArray());	}
public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) {	    if (src.length > 8) {	        throw new IllegalArgumentException("src.length>8: src.length=" + src.length);	    }	    if (src.length - srcPos < 4) {	        throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos);	    }	    if (src[srcPos + 3]) {	        if (src[srcPos + 2]) {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return '7';	                }	            } else {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return '3';	                }	            }	        } else {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return '5';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '1';	                }	            }	        }	    } else {	        if (src[srcPos + 2]) {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'e';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return 'a';	                } else {	                    return '2';	                }	            }	        } else {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'c';	                } else {	                    return '4';	                }	            } else {	                if (src[srcPos]) {	                    return '8';	                } else {	                    return '0';	                }	            }	        }	    }	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
public String getNewLineText() {	    return newLine;	}
@Override	public int length() {	    return size;	}
public String getNewLineText() {	    return newLine;	}
@Override	public void setValue(final Number value) {	    this.value = value.doubleValue();	}
public char[] toCharArray(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len == 0) {	        return ArrayUtils.EMPTY_CHAR_ARRAY;	    }	    final char[] chars = new char[len];	    System.arraycopy(buffer, startIndex, chars, 0, len);	    return chars;	}
public static void handleCauseUnchecked(final ExecutionException ex) {	    final ConcurrentRuntimeException crex = extractCauseUnchecked(ex);	    if (crex != null) {	        throw crex;	    }	}
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException {	    return charsetName == null ? new String(bytes) : new String(bytes, charsetName);	}
public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale) {	    return cache.getInstance(pattern, timeZone, locale);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static String substringAfter(final String str, final String separator) {	    if (isEmpty(str)) {	        return str;	    }	    if (separator == null) {	        return EMPTY;	    }	    final int pos = str.indexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return EMPTY;	    }	    return str.substring(pos + separator.length());	}
@Override	public DefaultExceptionContext setContextValue(final String label, final Object value) {	    for (final Iterator<Pair<String, Object>> iter = contextValues.iterator(); iter.hasNext(); ) {	        final Pair<String, Object> p = iter.next();	        if (StringUtils.equals(label, p.getKey())) {	            iter.remove();	        }	    }	    addContextValue(label, value);	    return this;	}
public boolean isEmpty() {	    return size == 0;	}
public static Boolean[] toObject(final boolean[] array) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    final Boolean[] result = new Boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        result[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE);	    }	    return result;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public static char binaryToHexDigit(final boolean[] src, final int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    if (src.length > srcPos + 3 && src[srcPos + 3]) {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src[srcPos]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
public abstract M getMiddle();
public static String capitalize(final String str, final char... delimiters) {	    final int delimLen = delimiters == null ? -1 : delimiters.length;	    if (StringUtils.isEmpty(str) || delimLen == 0) {	        return str;	    }	    final char[] buffer = str.toCharArray();	    boolean capitalizeNext = true;	    for (int i = 0; i < buffer.length; i++) {	        final char ch = buffer[i];	        if (isDelimiter(ch, delimiters)) {	            capitalizeNext = true;	        } else if (capitalizeNext) {	            buffer[i] = Character.toTitleCase(ch);	            capitalizeNext = false;	        }	    }	    return new String(buffer);	}
public void setMiddle(final M middle) {	    this.middle = middle;	}
public static int lastOrdinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal) {	    return ordinalIndexOf(str, searchStr, ordinal, true);	}
public static boolean containsOnly(final CharSequence cs, final String validChars) {	    if (cs == null || validChars == null) {	        return false;	    }	    return containsOnly(cs, validChars.toCharArray());	}
public static String center(String str, final int size, String padStr) {	    if (str == null || size <= 0) {	        return str;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    str = leftPad(str, strLen + pads / 2, padStr);	    str = rightPad(str, size, padStr);	    return str;	}
public static String repeat(final char ch, final int repeat) {	    final char[] buf = new char[repeat];	    for (int i = repeat - 1; i >= 0; i--) {	        buf[i] = ch;	    }	    return new String(buf);	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public int capacity() {	    return buffer.length;	}
public String getNewLineText() {	    return newLine;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, true);	}
public static String prependIfMissingIgnoreCase(final String str, final CharSequence prefix, final CharSequence... prefixes) {	    return prependIfMissing(str, prefix, true, prefixes);	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static void isAssignableFrom(final Class<?> superType, final Class<?> type, final String message, final Object... values) {	    if (superType.isAssignableFrom(type) == false) {	        throw new IllegalArgumentException(String.format(message, values));	    }	}
public static float max(final float a, final float b, final float c) {	    return Math.max(Math.max(a, b), c);	}
public static boolean containsAny(final CharSequence cs, final CharSequence searchChars) {	    if (searchChars == null) {	        return false;	    }	    return containsAny(cs, CharSequenceUtils.toCharArray(searchChars));	}
public static String getPackageCanonicalName(final String canonicalName) {	    return ClassUtils.getPackageName(getCanonicalName(canonicalName));	}
public boolean contains(final StrMatcher matcher) {	    return indexOf(matcher, 0) >= 0;	}
public static ConcurrentException extractCause(final ExecutionException ex) {	    if (ex == null || ex.getCause() == null) {	        return null;	    }	    throwCause(ex);	    return new ConcurrentException(ex.getMessage(), ex.getCause());	}
public static String chop(final String str) {	    if (str == null) {	        return null;	    }	    final int strLen = str.length();	    if (strLen < 2) {	        return EMPTY;	    }	    final int lastIdx = strLen - 1;	    final String ret = str.substring(0, lastIdx);	    final char last = str.charAt(lastIdx);	    if (last == CharUtils.LF && ret.charAt(lastIdx - 1) == CharUtils.CR) {	        return ret.substring(0, lastIdx - 1);	    }	    return ret;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public static boolean containsNone(final CharSequence cs, final String invalidChars) {	    if (cs == null || invalidChars == null) {	        return true;	    }	    return containsNone(cs, invalidChars.toCharArray());	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
public Builder daemon(final boolean f) {	    daemonFlag = Boolean.valueOf(f);	    return this;	}
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = Integer.MAX_VALUE;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.indexOf(str, search, 0);	        if (tmp == INDEX_NOT_FOUND) {	            continue;	        }	        if (tmp < ret) {	            ret = tmp;	        }	    }	    return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;	}
@Override	public String toString() {	    return String.valueOf(value);	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    if (index != 0) {	        throw new IllegalStateException("CsvUnescaper should never reach the [1] index");	    }	    if (input.charAt(0) != CSV_QUOTE || input.charAt(input.length() - 1) != CSV_QUOTE) {	        out.write(input.toString());	        return input.length();	    }	    final String quoteless = input.subSequence(1, input.length() - 1).toString();	    if (StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS)) {	        out.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR));	    } else {	        out.write(input.toString());	    }	    return input.length();	}
public String getNewLineText() {	    return newLine;	}
@Override	public Long getValue() {	    return Long.valueOf(this.value);	}
public String getNewLineText() {	    return newLine;	}
public int getDenominator() {	    return denominator;	}
public boolean isEmpty() {	    return size == 0;	}
public Fraction add(final Fraction fraction) {	    return addSub(fraction, true);	}
@Override	public int length() {	    return size;	}
public static String chop(final String str) {	    if (str == null) {	        return null;	    }	    final int strLen = str.length();	    if (strLen < 2) {	        return EMPTY;	    }	    final int lastIdx = strLen - 1;	    final String ret = str.substring(0, lastIdx);	    final char last = str.charAt(lastIdx);	    if (last == CharUtils.LF && ret.charAt(lastIdx - 1) == CharUtils.CR) {	        return ret.substring(0, lastIdx - 1);	    }	    return ret;	}
public int capacity() {	    return buffer.length;	}
void increment() {	    count++;	}
@Override	public int compareTo(final Fraction other) {	    if (this == other) {	        return 0;	    }	    if (numerator == other.numerator && denominator == other.denominator) {	        return 0;	    }	    final long first = (long) numerator * (long) other.denominator;	    final long second = (long) other.numerator * (long) denominator;	    if (first == second) {	        return 0;	    } else if (first < second) {	        return -1;	    } else {	        return 1;	    }	}
protected String getSizeStartText() {	    return sizeStartText;	}
public boolean isEmpty() {	    return size == 0;	}
public static boolean isAlphanumericSpace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetterOrDigit(cs.charAt(i)) == false && cs.charAt(i) != ' ') {	            return false;	        }	    }	    return true;	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {	    if (str == null || searchStr == null) {	        return INDEX_NOT_FOUND;	    }	    if (startPos > str.length() - searchStr.length()) {	        startPos = str.length() - searchStr.length();	    }	    if (startPos < 0) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return startPos;	    }	    for (int i = startPos; i >= 0; i--) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
protected String toUtf16Escape(final int codepoint) {	    return "\\u" + hex(codepoint);	}
@Override	public long longValue() {	    return (long) numerator / denominator;	}
public static <T> T deserialize(final byte[] objectData) {	    if (objectData == null) {	        throw new IllegalArgumentException("The byte[] must not be null");	    }	    return SerializationUtils.<T>deserialize(new ByteArrayInputStream(objectData));	}
public StrTokenizer setEmptyTokenAsNull(final boolean emptyAsNull) {	    this.emptyAsNull = emptyAsNull;	    return this;	}
public static boolean isNumeric(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isDigit(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
@Deprecated	public static String chomp(final String str, final String separator) {	    return removeEnd(str, separator);	}
public static String center(String str, final int size, String padStr) {	    if (str == null || size <= 0) {	        return str;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    str = leftPad(str, strLen + pads / 2, padStr);	    str = rightPad(str, size, padStr);	    return str;	}
public boolean isNegated() {	    return negated;	}
public int capacity() {	    return buffer.length;	}
public static String abbreviateMiddle(final String str, final String middle, final int length) {	    if (isEmpty(str) || isEmpty(middle)) {	        return str;	    }	    if (length >= str.length() || length < middle.length() + 2) {	        return str;	    }	    final int targetSting = length - middle.length();	    final int startOffset = targetSting / 2 + targetSting % 2;	    final int endOffset = str.length() - targetSting / 2;	    final StringBuilder builder = new StringBuilder(length);	    builder.append(str.substring(0, startOffset));	    builder.append(middle);	    builder.append(str.substring(endOffset));	    return builder.toString();	}
public int capacity() {	    return buffer.length;	}
public int size() {	    return size;	}
public int indexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex < 0 ? 0 : startIndex);	    if (matcher == null || startIndex >= size) {	        return -1;	    }	    final int len = size;	    final char[] buf = buffer;	    for (int i = startIndex; i < len; i++) {	        if (matcher.isMatch(buf, i, startIndex, len) > 0) {	            return i;	        }	    }	    return -1;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static boolean isAsciiAlphanumeric(final char ch) {	    return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9');	}
public String substring(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    return new String(buffer, startIndex, endIndex - startIndex);	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
@Override	public boolean translate(final int codepoint, final Writer out) throws IOException {	    if (between) {	        if (codepoint < below || codepoint > above) {	            return false;	        }	    } else {	        if (codepoint >= below && codepoint <= above) {	            return false;	        }	    }	    if (codepoint > 0xffff) {	        out.write(toUtf16Escape(codepoint));	    } else if (codepoint > 0xfff) {	        out.write("\\u" + hex(codepoint));	    } else if (codepoint > 0xff) {	        out.write("\\u0" + hex(codepoint));	    } else if (codepoint > 0xf) {	        out.write("\\u00" + hex(codepoint));	    } else {	        out.write("\\u000" + hex(codepoint));	    }	    return true;	}
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] result = new boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        final Boolean b = array[i];	        result[i] = (b == null ? valueForNull : b.booleanValue());	    }	    return result;	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public Long toLong() {	    return Long.valueOf(longValue());	}
@Override	public int length() {	    return size;	}
public static int hashCode(final Object obj) {	    return obj == null ? 0 : obj.hashCode();	}
@Override	public int hashCode() {	    return toHashCode();	}
@Override	public int read(final char[] b, final int off, int len) {	    if (off < 0 || len < 0 || off > b.length || (off + len) > b.length || (off + len) < 0) {	        throw new IndexOutOfBoundsException();	    }	    if (len == 0) {	        return 0;	    }	    if (pos >= StrBuilder.this.size()) {	        return -1;	    }	    if (pos + len > size()) {	        len = StrBuilder.this.size() - pos;	    }	    StrBuilder.this.getChars(pos, pos + len, b, off);	    pos += len;	    return len;	}
@Override	public ContextedException setContextValue(final String label, final Object value) {	    exceptionContext.setContextValue(label, value);	    return this;	}
public HashCodeBuilder append(final short[] array) {	    if (array == null) {	        iTotal = iTotal * iConstant;	    } else {	        for (final short element : array) {	            append(element);	        }	    }	    return this;	}
public static String stripEnd(final String str, final String stripChars) {	    int end;	    if (str == null || (end = str.length()) == 0) {	        return str;	    }	    if (stripChars == null) {	        while (end != 0 && Character.isWhitespace(str.charAt(end - 1))) {	            end--;	        }	    } else if (stripChars.isEmpty()) {	        return str;	    } else {	        while (end != 0 && stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND) {	            end--;	        }	    }	    return str.substring(0, end);	}
public String getNewLineText() {	    return newLine;	}
public String getNewLineText() {	    return newLine;	}
public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException {	    return parseDateWithLeniency(str, locale, parsePatterns, true);	}
public static String stripToEmpty(final String str) {	    return str == null ? EMPTY : strip(str, null);	}
public static String abbreviateMiddle(final String str, final String middle, final int length) {	    if (isEmpty(str) || isEmpty(middle)) {	        return str;	    }	    if (length >= str.length() || length < middle.length() + 2) {	        return str;	    }	    final int targetSting = length - middle.length();	    final int startOffset = targetSting / 2 + targetSting % 2;	    final int endOffset = str.length() - targetSting / 2;	    final StringBuilder builder = new StringBuilder(length);	    builder.append(str.substring(0, startOffset));	    builder.append(middle);	    builder.append(str.substring(endOffset));	    return builder.toString();	}
public static String leftPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return leftPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return padStr.concat(str);	    } else if (pads < padLen) {	        return padStr.substring(0, pads).concat(str);	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return new String(padding).concat(str);	    }	}
public String getNullText() {	    return nullText;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
private static Date add(final Date date, final int calendarField, final int amount) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final Calendar c = Calendar.getInstance();	    c.setTime(date);	    c.add(calendarField, amount);	    return c.getTime();	}
@Override	public M getMiddle() {	    return middle;	}
public int set(final int holder) {	    return holder | _mask;	}
public static boolean isEmpty(final CharSequence cs) {	    return cs == null || cs.length() == 0;	}
static boolean isAccessible(final Member m) {	    return m != null && Modifier.isPublic(m.getModifiers()) && !m.isSynthetic();	}
public String getRawMessage() {	    return super.getMessage();	}
protected String getContentEnd() {	    return contentEnd;	}
public static String removePattern(final String source, final String regex) {	    return replacePattern(source, regex, StringUtils.EMPTY);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
@Override	public void mark(final int readAheadLimit) {	    mark = pos;	}
public long getSplitTime() {	    return getSplitNanoTime() / NANO_2_MILLIS;	}
public static float min(final float a, final float b, final float c) {	    return Math.min(Math.min(a, b), c);	}
public static float min(final float a, final float b) {	    if (Float.isNaN(a)) {	        return b;	    } else if (Float.isNaN(b)) {	        return a;	    } else {	        return Math.min(a, b);	    }	}
public static Boolean or(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
public static String prependIfMissingIgnoreCase(final String str, final CharSequence prefix, final CharSequence... prefixes) {	    return prependIfMissing(str, prefix, true, prefixes);	}
public boolean isEmpty() {	    return size == 0;	}
public StringBuffer toStringBuffer() {	    return new StringBuffer(size).append(buffer, 0, size);	}
public static char binaryToHexDigit(final boolean[] src, final int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    if (src.length > srcPos + 3 && src[srcPos + 3]) {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src[srcPos]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
public void increment() {	    value++;	}
protected boolean isUseClassName() {	    return useClassName;	}
public String getNewLineText() {	    return newLine;	}
public static void reverse(final boolean[] array) {	    if (array == null) {	        return;	    }	    int i = 0;	    int j = array.length - 1;	    boolean tmp;	    while (j > i) {	        tmp = array[j];	        array[j] = array[i];	        array[i] = tmp;	        j--;	        i++;	    }	}
public static String random(final int count, final char... chars) {	    if (chars == null) {	        return random(count, 0, 0, false, false, null, RANDOM);	    }	    return random(count, 0, chars.length, false, false, chars, RANDOM);	}
public void start() {	    if (this.runningState == STATE_STOPPED) {	        throw new IllegalStateException("Stopwatch must be reset before being restarted. ");	    }	    if (this.runningState != STATE_UNSTARTED) {	        throw new IllegalStateException("Stopwatch already started. ");	    }	    this.startTime = System.nanoTime();	    this.startTimeMillis = System.currentTimeMillis();	    this.runningState = STATE_RUNNING;	}
public static Date round(final Object date, final int field) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (date instanceof Date) {	        return round((Date) date, field);	    } else if (date instanceof Calendar) {	        return round((Calendar) date, field).getTime();	    } else {	        throw new ClassCastException("Could not round " + date);	    }	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public static boolean isSameDay(final Calendar cal1, final Calendar cal2) {	    if (cal1 == null || cal2 == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    return (cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR));	}
protected String getArrayEnd() {	    return arrayEnd;	}
public static boolean containsWhitespace(final CharSequence seq) {	    if (isEmpty(seq)) {	        return false;	    }	    final int strLen = seq.length();	    for (int i = 0; i < strLen; i++) {	        if (Character.isWhitespace(seq.charAt(i))) {	            return true;	        }	    }	    return false;	}
public void stop() {	    if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {	        throw new IllegalStateException("Stopwatch is not running. ");	    }	    if (this.runningState == STATE_RUNNING) {	        this.stopTime = System.nanoTime();	    }	    this.runningState = STATE_STOPPED;	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    buffer.append(arrayStart);	    for (int i = 0; i < array.length; i++) {	        if (i > 0) {	            buffer.append(arraySeparator);	        }	        appendDetail(buffer, fieldName, array[i]);	    }	    buffer.append(arrayEnd);	}
private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) {	    if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {	        return text;	    }	    if (timeToLive < 0) {	        throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another");	    }	    final int searchLength = searchList.length;	    final int replacementLength = replacementList.length;	    if (searchLength != replacementLength) {	        throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength);	    }	    final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];	    int textIndex = -1;	    int replaceIndex = -1;	    int tempIndex = -1;	    for (int i = 0; i < searchLength; i++) {	        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {	            continue;	        }	        tempIndex = text.indexOf(searchList[i]);	        if (tempIndex == -1) {	            noMoreMatchesForReplIndex[i] = true;	        } else {	            if (textIndex == -1 || tempIndex < textIndex) {	                textIndex = tempIndex;	                replaceIndex = i;	            }	        }	    }	    if (textIndex == -1) {	        return text;	    }	    int start = 0;	    int increase = 0;	    for (int i = 0; i < searchList.length; i++) {	        if (searchList[i] == null || replacementList[i] == null) {	            continue;	        }	        final int greater = replacementList[i].length() - searchList[i].length();	        if (greater > 0) {	            increase += 3 * greater;	        }	    }	    increase = Math.min(increase, text.length() / 5);	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (textIndex != -1) {	        for (int i = start; i < textIndex; i++) {	            buf.append(text.charAt(i));	        }	        buf.append(replacementList[replaceIndex]);	        start = textIndex + searchList[replaceIndex].length();	        textIndex = -1;	        replaceIndex = -1;	        tempIndex = -1;	        for (int i = 0; i < searchLength; i++) {	            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {	                continue;	            }	            tempIndex = text.indexOf(searchList[i], start);	            if (tempIndex == -1) {	                noMoreMatchesForReplIndex[i] = true;	            } else {	                if (textIndex == -1 || tempIndex < textIndex) {	                    textIndex = tempIndex;	                    replaceIndex = i;	                }	            }	        }	    }	    final int textLength = text.length();	    for (int i = start; i < textLength; i++) {	        buf.append(text.charAt(i));	    }	    final String result = buf.toString();	    if (!repeat) {	        return result;	    }	    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);	}
protected synchronized final ExecutorService getActiveExecutor() {	    return executor;	}
protected String getSizeStartText() {	    return sizeStartText;	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
private static Date set(final Date date, final int calendarField, final int amount) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final Calendar c = Calendar.getInstance();	    c.setLenient(false);	    c.setTime(date);	    c.set(calendarField, amount);	    return c.getTime();	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static String getPackageCanonicalName(final String canonicalName) {	    return ClassUtils.getPackageName(getCanonicalName(canonicalName));	}
@Override	public String previous() {	    if (hasPrevious()) {	        return tokens[--tokenPos];	    }	    throw new NoSuchElementException();	}
public void decrement() {	    value--;	}
public String getNullText() {	    return nullText;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static boolean isNumeric(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isDigit(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
protected String getShortClassName(final Class<?> cls) {	    return ClassUtils.getShortClassName(cls);	}
public synchronized boolean start() {	    if (!isStarted()) {	        ExecutorService tempExec;	        executor = getExternalExecutor();	        if (executor == null) {	            executor = tempExec = createExecutor();	        } else {	            tempExec = null;	        }	        future = executor.submit(createTask(tempExec));	        return true;	    }	    return false;	}
@Override	public T get() throws ConcurrentException {	    try {	        return getFuture().get();	    } catch (final ExecutionException execex) {	        ConcurrentUtils.handleCause(execex);	        return null;	    } catch (final InterruptedException iex) {	        Thread.currentThread().interrupt();	        throw new ConcurrentException(iex);	    }	}
public StrBuilder replaceAll(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, -1);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
static int indexOf(final CharSequence cs, final CharSequence searchChar, final int start) {	    return cs.toString().indexOf(searchChar.toString(), start);	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public StrBuilder appendSeparator(final char separator, final int loopIndex) {	    if (loopIndex > 0) {	        append(separator);	    }	    return this;	}
public static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes) {	    if ((src.length == 0 && srcPos == 0) || 0 == nBytes) {	        return dstInit;	    }	    if ((nBytes - 1) * 8 + dstPos >= 64) {	        throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 64");	    }	    long out = dstInit;	    int shift = 0;	    for (int i = 0; i < nBytes; i++) {	        shift = i * 8 + dstPos;	        final long bits = (0xffL & src[i + srcPos]) << shift;	        final long mask = 0xffL << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
public static int indexOfAnyBut(final CharSequence seq, final CharSequence searchChars) {	    if (isEmpty(seq) || isEmpty(searchChars)) {	        return INDEX_NOT_FOUND;	    }	    final int strLen = seq.length();	    for (int i = 0; i < strLen; i++) {	        final char ch = seq.charAt(i);	        final boolean chFound = CharSequenceUtils.indexOf(searchChars, ch, 0) >= 0;	        if (i + 1 < strLen && Character.isHighSurrogate(ch)) {	            final char ch2 = seq.charAt(i + 1);	            if (chFound && CharSequenceUtils.indexOf(searchChars, ch2, 0) < 0) {	                return i;	            }	        } else {	            if (!chFound) {	                return i;	            }	        }	    }	    return INDEX_NOT_FOUND;	}
public static <T> T CONST(final T v) {	    return v;	}
public static float min(final float a, final float b, final float c) {	    return Math.min(Math.min(a, b), c);	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
@Override	public int intValue() {	    return (int) value;	}
public static String mid(final String str, int pos, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0 || pos > str.length()) {	        return EMPTY;	    }	    if (pos < 0) {	        pos = 0;	    }	    if (str.length() <= pos + len) {	        return str.substring(pos);	    }	    return str.substring(pos, pos + len);	}
@Override	public boolean isCancelled() {	    return false;	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) {	    if (array == null) {	        return null;	    }	    if (startIndexInclusive < 0) {	        startIndexInclusive = 0;	    }	    if (endIndexExclusive > array.length) {	        endIndexExclusive = array.length;	    }	    final int newSize = endIndexExclusive - startIndexInclusive;	    if (newSize <= 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] subarray = new boolean[newSize];	    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);	    return subarray;	}
public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale) {	    return cache.getTimeInstance(style, timeZone, locale);	}
public static boolean isAllLowerCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLowerCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
@Override	public int length() {	    return size;	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    appendSummarySize(buffer, fieldName, array.length);	}
public static boolean isAlpha(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex) {	    return indexOf(throwable, clazz, fromIndex, false);	}
public static boolean isNumber(final String str) {	    if (StringUtils.isEmpty(str)) {	        return false;	    }	    final char[] chars = str.toCharArray();	    int sz = chars.length;	    boolean hasExp = false;	    boolean hasDecPoint = false;	    boolean allowSigns = false;	    boolean foundDigit = false;	    final int start = (chars[0] == '-') ? 1 : 0;	    if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') {	        int i = start + 2;	        if (i == sz) {	            return false;	        }	        for (; i < chars.length; i++) {	            if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) {	                return false;	            }	        }	        return true;	    }	    sz--;	    int i = start;	    while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {	        if (chars[i] >= '0' && chars[i] <= '9') {	            foundDigit = true;	            allowSigns = false;	        } else if (chars[i] == '.') {	            if (hasDecPoint || hasExp) {	                return false;	            }	            hasDecPoint = true;	        } else if (chars[i] == 'e' || chars[i] == 'E') {	            if (hasExp) {	                return false;	            }	            if (!foundDigit) {	                return false;	            }	            hasExp = true;	            allowSigns = true;	        } else if (chars[i] == '+' || chars[i] == '-') {	            if (!allowSigns) {	                return false;	            }	            allowSigns = false;	            foundDigit = false;	        } else {	            return false;	        }	        i++;	    }	    if (i < chars.length) {	        if (chars[i] >= '0' && chars[i] <= '9') {	            return true;	        }	        if (chars[i] == 'e' || chars[i] == 'E') {	            return false;	        }	        if (chars[i] == '.') {	            if (hasDecPoint || hasExp) {	                return false;	            }	            return foundDigit;	        }	        if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) {	            return foundDigit;	        }	        if (chars[i] == 'l' || chars[i] == 'L') {	            return foundDigit && !hasExp && !hasDecPoint;	        }	        return false;	    }	    return !allowSigns && foundDigit;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public static String difference(final String str1, final String str2) {	    if (str1 == null) {	        return str2;	    }	    if (str2 == null) {	        return str1;	    }	    final int at = indexOfDifference(str1, str2);	    if (at == INDEX_NOT_FOUND) {	        return EMPTY;	    }	    return str2.substring(at);	}
public static int indexOfAnyBut(final CharSequence seq, final CharSequence searchChars) {	    if (isEmpty(seq) || isEmpty(searchChars)) {	        return INDEX_NOT_FOUND;	    }	    final int strLen = seq.length();	    for (int i = 0; i < strLen; i++) {	        final char ch = seq.charAt(i);	        final boolean chFound = CharSequenceUtils.indexOf(searchChars, ch, 0) >= 0;	        if (i + 1 < strLen && Character.isHighSurrogate(ch)) {	            final char ch2 = seq.charAt(i + 1);	            if (chFound && CharSequenceUtils.indexOf(searchChars, ch2, 0) < 0) {	                return i;	            }	        } else {	            if (!chFound) {	                return i;	            }	        }	    }	    return INDEX_NOT_FOUND;	}
@Override	public final L getKey() {	    return getLeft();	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public boolean isEmpty() {	    return size == 0;	}
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {	    if (array == null) {	        if (index != 0) {	            throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0");	        }	        final Object joinedArray = Array.newInstance(clss, 1);	        Array.set(joinedArray, 0, element);	        return joinedArray;	    }	    final int length = Array.getLength(array);	    if (index > length || index < 0) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(clss, length + 1);	    System.arraycopy(array, 0, result, 0, index);	    Array.set(result, index, element);	    if (index < length) {	        System.arraycopy(array, index, result, index + 1, length - index);	    }	    return result;	}
public synchronized void acquire() throws InterruptedException {	    if (isShutdown()) {	        throw new IllegalStateException("TimedSemaphore is shut down!");	    }	    if (task == null) {	        task = startTimer();	    }	    boolean canPass = false;	    do {	        canPass = getLimit() <= NO_LIMIT || acquireCount < getLimit();	        if (!canPass) {	            wait();	        } else {	            acquireCount++;	        }	    } while (!canPass);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static long getFragmentInSeconds(final Calendar calendar, final int fragment) {	    return getFragment(calendar, fragment, Calendar.SECOND);	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
protected boolean isUseClassName() {	    return useClassName;	}
public String getNewLineText() {	    return newLine;	}
protected String getArraySeparator() {	    return arraySeparator;	}
public static boolean isAllUpperCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isUpperCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {	    if (array == null) {	        if (index != 0) {	            throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0");	        }	        final Object joinedArray = Array.newInstance(clss, 1);	        Array.set(joinedArray, 0, element);	        return joinedArray;	    }	    final int length = Array.getLength(array);	    if (index > length || index < 0) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(clss, length + 1);	    System.arraycopy(array, 0, result, 0, index);	    Array.set(result, index, element);	    if (index < length) {	        System.arraycopy(array, index, result, index + 1, length - index);	    }	    return result;	}
public void addInitializer(final String name, final BackgroundInitializer<?> init) {	    if (name == null) {	        throw new IllegalArgumentException("Name of child initializer must not be null!");	    }	    if (init == null) {	        throw new IllegalArgumentException("Child initializer must not be null!");	    }	    synchronized (this) {	        if (isStarted()) {	            throw new IllegalStateException("addInitializer() must not be called after start()!");	        }	        childInitializers.put(name, init);	    }	}
@Override	public int length() {	    return size;	}
public int capacity() {	    return buffer.length;	}
public static boolean isAllUpperCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isUpperCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public int size() {	    return size;	}
@Override	public void write(final String str, final int off, final int len) {	    StrBuilder.this.append(str, off, len);	}
public static final String escapeXml(final String input) {	    return ESCAPE_XML.translate(input);	}
protected String getFieldSeparator() {	    return fieldSeparator;	}
public static float min(final float a, final float b, final float c) {	    return Math.min(Math.min(a, b), c);	}
@Override	public TimeZone getTimeZone() {	    return printer.getTimeZone();	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public boolean contains(final StrMatcher matcher) {	    return indexOf(matcher, 0) >= 0;	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
@Override	public int length() {	    return size;	}
public static boolean isAllUpperCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isUpperCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public void split() {	    if (this.runningState != STATE_RUNNING) {	        throw new IllegalStateException("Stopwatch is not running. ");	    }	    this.stopTime = System.nanoTime();	    this.splitState = STATE_SPLIT;	}
protected String getSummaryObjectStartText() {	    return summaryObjectStartText;	}
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException {	    return charsetName == null ? new String(bytes) : new String(bytes, charsetName);	}
public static boolean isWhitespace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isWhitespace(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static byte[] serialize(final Serializable obj) {	    final ByteArrayOutputStream baos = new ByteArrayOutputStream(512);	    serialize(obj, baos);	    return baos.toByteArray();	}
public static String substringBefore(final String str, final String separator) {	    if (isEmpty(str) || separator == null) {	        return str;	    }	    if (separator.isEmpty()) {	        return EMPTY;	    }	    final int pos = str.indexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return str;	    }	    return str.substring(0, pos);	}
@Override	public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) {	    return formatter.format(obj, toAppendTo, pos);	}
protected String getContentStart() {	    return contentStart;	}
public boolean isAppendStatics() {	    return this.appendStatics;	}
public String getNewLineText() {	    return newLine;	}
public ReflectionToStringBuilder reflectionAppendArray(final Object array) {	    this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);	    return this;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
@Override	public void write(final String str, final int off, final int len) {	    StrBuilder.this.append(str, off, len);	}
@Override	public long longValue() {	    return value;	}
public StrTokenizer reset(final char[] input) {	    reset();	    this.chars = ArrayUtils.clone(input);	    return this;	}
public int indexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex < 0 ? 0 : startIndex);	    if (matcher == null || startIndex >= size) {	        return -1;	    }	    final int len = size;	    final char[] buf = buffer;	    for (int i = startIndex; i < len; i++) {	        if (matcher.isMatch(buf, i, startIndex, len) > 0) {	            return i;	        }	    }	    return -1;	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
protected String getContentStart() {	    return contentStart;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static char intToHexDigitMsb0(final int nibble) {	    switch(nibble) {	        case 0x0:	            return '0';	        case 0x1:	            return '8';	        case 0x2:	            return '4';	        case 0x3:	            return 'c';	        case 0x4:	            return '2';	        case 0x5:	            return 'a';	        case 0x6:	            return '6';	        case 0x7:	            return 'e';	        case 0x8:	            return '1';	        case 0x9:	            return '9';	        case 0xA:	            return '5';	        case 0xB:	            return 'd';	        case 0xC:	            return '3';	        case 0xD:	            return 'b';	        case 0xE:	            return '7';	        case 0xF:	            return 'f';	        default:	            throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble);	    }	}
public static String center(String str, final int size, String padStr) {	    if (str == null || size <= 0) {	        return str;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    str = leftPad(str, strLen + pads / 2, padStr);	    str = rightPad(str, size, padStr);	    return str;	}
public static <T> String reflectionToString(final T object, final ToStringStyle style, final boolean outputTransients, final Class<? super T> reflectUpToClass) {	    return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass);	}
protected String getArraySeparator() {	    return arraySeparator;	}
public static String formatDurationISO(final long durationMillis) {	    return formatDuration(durationMillis, ISO_EXTENDED_FORMAT_PATTERN, false);	}
public short setShort(final short holder) {	    return (short) set(holder);	}
public static <T extends CharSequence> T notEmpty(final T chars) {	    return notEmpty(chars, DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE);	}
protected boolean isFieldSeparatorAtStart() {	    return fieldSeparatorAtStart;	}
public static String removeEnd(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.endsWith(remove)) {	        return str.substring(0, str.length() - remove.length());	    }	    return str;	}
public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) {	    if (array == null) {	        return null;	    }	    if (startIndexInclusive < 0) {	        startIndexInclusive = 0;	    }	    if (endIndexExclusive > array.length) {	        endIndexExclusive = array.length;	    }	    final int newSize = endIndexExclusive - startIndexInclusive;	    if (newSize <= 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] subarray = new boolean[newSize];	    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);	    return subarray;	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
@Override	protected MultiBackgroundInitializerResults initialize() throws Exception {	    Map<String, BackgroundInitializer<?>> inits;	    synchronized (this) {	        inits = new HashMap<String, BackgroundInitializer<?>>(childInitializers);	    }	    final ExecutorService exec = getActiveExecutor();	    for (final BackgroundInitializer<?> bi : inits.values()) {	        if (bi.getExternalExecutor() == null) {	            bi.setExternalExecutor(exec);	        }	        bi.start();	    }	    final Map<String, Object> results = new HashMap<String, Object>();	    final Map<String, ConcurrentException> excepts = new HashMap<String, ConcurrentException>();	    for (final Map.Entry<String, BackgroundInitializer<?>> e : inits.entrySet()) {	        try {	            results.put(e.getKey(), e.getValue().get());	        } catch (final ConcurrentException cex) {	            excepts.put(e.getKey(), cex);	        }	    }	    return new MultiBackgroundInitializerResults(inits, results, excepts);	}
public static StrTokenizer getCSVInstance(final char[] input) {	    final StrTokenizer tok = getCSVClone();	    tok.reset(input);	    return tok;	}
public static Boolean or(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
public static List<Locale> countriesByLanguage(final String languageCode) {	    if (languageCode == null) {	        return Collections.emptyList();	    }	    List<Locale> countries = cCountriesByLanguage.get(languageCode);	    if (countries == null) {	        countries = new ArrayList<Locale>();	        final List<Locale> locales = availableLocaleList();	        for (int i = 0; i < locales.size(); i++) {	            final Locale locale = locales.get(i);	            if (languageCode.equals(locale.getLanguage()) && locale.getCountry().length() != 0 && locale.getVariant().isEmpty()) {	                countries.add(locale);	            }	        }	        countries = Collections.unmodifiableList(countries);	        cCountriesByLanguage.putIfAbsent(languageCode, countries);	        countries = cCountriesByLanguage.get(languageCode);	    }	    return countries;	}
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] result = new boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        final Boolean b = array[i];	        result[i] = (b == null ? valueForNull : b.booleanValue());	    }	    return result;	}
@Override	public long longValue() {	    return (long) value;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public int capacity() {	    return buffer.length;	}
public char getEnd() {	    return this.end;	}
public static int lastIndexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = INDEX_NOT_FOUND;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.lastIndexOf(str, search, str.length());	        if (tmp > ret) {	            ret = tmp;	        }	    }	    return ret;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public String getNullText() {	    return nullText;	}
public String getNullText() {	    return nullText;	}
protected boolean isFieldSeparatorAtStart() {	    return fieldSeparatorAtStart;	}
public StrBuilder appendSeparator(final char separator, final int loopIndex) {	    if (loopIndex > 0) {	        append(separator);	    }	    return this;	}
public static Class<?> getRawType(final Type type, final Type assigningType) {	    if (type instanceof Class<?>) {	        return (Class<?>) type;	    }	    if (type instanceof ParameterizedType) {	        return getRawType((ParameterizedType) type);	    }	    if (type instanceof TypeVariable<?>) {	        if (assigningType == null) {	            return null;	        }	        final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration();	        if (!(genericDeclaration instanceof Class<?>)) {	            return null;	        }	        final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType, (Class<?>) genericDeclaration);	        if (typeVarAssigns == null) {	            return null;	        }	        final Type typeArgument = typeVarAssigns.get(type);	        if (typeArgument == null) {	            return null;	        }	        return getRawType(typeArgument, assigningType);	    }	    if (type instanceof GenericArrayType) {	        final Class<?> rawComponentType = getRawType(((GenericArrayType) type).getGenericComponentType(), assigningType);	        return Array.newInstance(rawComponentType, 0).getClass();	    }	    if (type instanceof WildcardType) {	        return null;	    }	    throw new IllegalArgumentException("unknown type: " + type);	}
public boolean isAppendTransients() {	    return this.appendTransients;	}
public String getNewLineText() {	    return newLine;	}
private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) {	    if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {	        return text;	    }	    if (timeToLive < 0) {	        throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another");	    }	    final int searchLength = searchList.length;	    final int replacementLength = replacementList.length;	    if (searchLength != replacementLength) {	        throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength);	    }	    final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];	    int textIndex = -1;	    int replaceIndex = -1;	    int tempIndex = -1;	    for (int i = 0; i < searchLength; i++) {	        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {	            continue;	        }	        tempIndex = text.indexOf(searchList[i]);	        if (tempIndex == -1) {	            noMoreMatchesForReplIndex[i] = true;	        } else {	            if (textIndex == -1 || tempIndex < textIndex) {	                textIndex = tempIndex;	                replaceIndex = i;	            }	        }	    }	    if (textIndex == -1) {	        return text;	    }	    int start = 0;	    int increase = 0;	    for (int i = 0; i < searchList.length; i++) {	        if (searchList[i] == null || replacementList[i] == null) {	            continue;	        }	        final int greater = replacementList[i].length() - searchList[i].length();	        if (greater > 0) {	            increase += 3 * greater;	        }	    }	    increase = Math.min(increase, text.length() / 5);	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (textIndex != -1) {	        for (int i = start; i < textIndex; i++) {	            buf.append(text.charAt(i));	        }	        buf.append(replacementList[replaceIndex]);	        start = textIndex + searchList[replaceIndex].length();	        textIndex = -1;	        replaceIndex = -1;	        tempIndex = -1;	        for (int i = 0; i < searchLength; i++) {	            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {	                continue;	            }	            tempIndex = text.indexOf(searchList[i], start);	            if (tempIndex == -1) {	                noMoreMatchesForReplIndex[i] = true;	            } else {	                if (textIndex == -1 || tempIndex < textIndex) {	                    textIndex = tempIndex;	                    replaceIndex = i;	                }	            }	        }	    }	    final int textLength = text.length();	    for (int i = start; i < textLength; i++) {	        buf.append(text.charAt(i));	    }	    final String result = buf.toString();	    if (!repeat) {	        return result;	    }	    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);	}
public static Iterator<?> iterator(final Object focus, final int rangeStyle) {	    if (focus == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (focus instanceof Date) {	        return iterator((Date) focus, rangeStyle);	    } else if (focus instanceof Calendar) {	        return iterator((Calendar) focus, rangeStyle);	    } else {	        throw new ClassCastException("Could not iterate based on " + focus);	    }	}
public static String mid(final String str, int pos, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0 || pos > str.length()) {	        return EMPTY;	    }	    if (pos < 0) {	        pos = 0;	    }	    if (str.length() <= pos + len) {	        return str.substring(pos);	    }	    return str.substring(pos, pos + len);	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public static String[] splitByCharacterTypeCamelCase(final String str) {	    return splitByCharacterType(str, true);	}
@Override	public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) {	    return formatter.format(obj, toAppendTo, pos);	}
public String toString(final String format) {	    return String.format(format, getLeft(), getRight());	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) {	    final StringBuilder buffer = new StringBuilder();	    boolean lastOutputSeconds = false;	    final int sz = tokens.length;	    for (int i = 0; i < sz; i++) {	        final Token token = tokens[i];	        final Object value = token.getValue();	        final int count = token.getCount();	        if (value instanceof StringBuilder) {	            buffer.append(value.toString());	        } else {	            if (value == y) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years));	                lastOutputSeconds = false;	            } else if (value == M) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months));	                lastOutputSeconds = false;	            } else if (value == d) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days));	                lastOutputSeconds = false;	            } else if (value == H) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours));	                lastOutputSeconds = false;	            } else if (value == m) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes));	                lastOutputSeconds = false;	            } else if (value == s) {	                buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds));	                lastOutputSeconds = true;	            } else if (value == S) {	                if (lastOutputSeconds) {	                    milliseconds += 1000;	                    final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds);	                    buffer.append(str.substring(1));	                } else {	                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds));	                }	                lastOutputSeconds = false;	            }	        }	    }	    return buffer.toString();	}
public String getNullText() {	    return nullText;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public int capacity() {	    return buffer.length;	}
public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) {	    if (s == null || t == null) {	        throw new IllegalArgumentException("Strings must not be null");	    }	    if (threshold < 0) {	        throw new IllegalArgumentException("Threshold must not be negative");	    }	    int n = s.length();	    int m = t.length();	    if (n == 0) {	        return m <= threshold ? m : -1;	    } else if (m == 0) {	        return n <= threshold ? n : -1;	    }	    if (n > m) {	        final CharSequence tmp = s;	        s = t;	        t = tmp;	        n = m;	        m = t.length();	    }	    int[] p = new int[n + 1];	    int[] d = new int[n + 1];	    int[] _d;	    final int boundary = Math.min(n, threshold) + 1;	    for (int i = 0; i < boundary; i++) {	        p[i] = i;	    }	    Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);	    Arrays.fill(d, Integer.MAX_VALUE);	    for (int j = 1; j <= m; j++) {	        final char t_j = t.charAt(j - 1);	        d[0] = j;	        final int min = Math.max(1, j - threshold);	        final int max = Math.min(n, j + threshold);	        if (min > max) {	            return -1;	        }	        if (min > 1) {	            d[min - 1] = Integer.MAX_VALUE;	        }	        for (int i = min; i <= max; i++) {	            if (s.charAt(i - 1) == t_j) {	                d[i] = p[i - 1];	            } else {	                d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);	            }	        }	        _d = p;	        p = d;	        d = _d;	    }	    if (p[n] <= threshold) {	        return p[n];	    }	    return -1;	}
public static boolean isAlphaSpace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false && cs.charAt(i) != ' ') {	            return false;	        }	    }	    return true;	}
static int compareParameterTypes(final Class<?>[] left, final Class<?>[] right, final Class<?>[] actual) {	    final float leftCost = getTotalTransformationCost(actual, left);	    final float rightCost = getTotalTransformationCost(actual, right);	    return leftCost < rightCost ? -1 : rightCost < leftCost ? 1 : 0;	}
public static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools) {	    if ((src.length == 0 && srcPos == 0) || 0 == nBools) {	        return dstInit;	    }	    if (nBools - 1 + dstPos >= 64) {	        throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 64");	    }	    long out = dstInit;	    int shift = 0;	    for (int i = 0; i < nBools; i++) {	        shift = i * 1 + dstPos;	        final long bits = (src[i + srcPos] ? 1L : 0) << shift;	        final long mask = 0x1L << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
private static boolean endsWith(final CharSequence str, final CharSequence suffix, final boolean ignoreCase) {	    if (str == null || suffix == null) {	        return str == null && suffix == null;	    }	    if (suffix.length() > str.length()) {	        return false;	    }	    final int strOffset = str.length() - suffix.length();	    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, suffix, 0, suffix.length());	}
@Override	public T get() throws ConcurrentException {	    try {	        return getFuture().get();	    } catch (final ExecutionException execex) {	        ConcurrentUtils.handleCause(execex);	        return null;	    } catch (final InterruptedException iex) {	        Thread.currentThread().interrupt();	        throw new ConcurrentException(iex);	    }	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public int size() {	    return size;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public static final String escapeHtml4(final String input) {	    return ESCAPE_HTML4.translate(input);	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public synchronized int getAvailablePermits() {	    return getLimit() - getAcquireCount();	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public int indexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex < 0 ? 0 : startIndex);	    if (matcher == null || startIndex >= size) {	        return -1;	    }	    final int len = size;	    final char[] buf = buffer;	    for (int i = startIndex; i < len; i++) {	        if (matcher.isMatch(buf, i, startIndex, len) > 0) {	            return i;	        }	    }	    return -1;	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
private static long getFragment(final Calendar calendar, final int fragment, final int unit) {	    if (calendar == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final long millisPerUnit = getMillisPerUnit(unit);	    long result = 0;	    switch(fragment) {	        case Calendar.YEAR:	            result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit;	            break;	        case Calendar.MONTH:	            result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit;	            break;	    }	    switch(fragment) {	        case Calendar.YEAR:	        case Calendar.MONTH:	        case Calendar.DAY_OF_YEAR:	        case Calendar.DATE:	            result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit;	        case Calendar.HOUR_OF_DAY:	            result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit;	        case Calendar.MINUTE:	            result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit;	        case Calendar.SECOND:	            result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit;	            break;	        case Calendar.MILLISECOND:	            break;	        default:	            throw new IllegalArgumentException("The fragment " + fragment + " is not supported");	    }	    return result;	}
public String getNullText() {	    return nullText;	}
public boolean isEmpty() {	    return size == 0;	}
protected String getArrayStart() {	    return arrayStart;	}
public static <V> StrLookup<V> mapLookup(final Map<String, V> map) {	    return new MapStrLookup<V>(map);	}
public String getNewLineText() {	    return newLine;	}
public static String capitalize(final String str) {	    int strLen;	    if (str == null || (strLen = str.length()) == 0) {	        return str;	    }	    char firstChar = str.charAt(0);	    if (Character.isTitleCase(firstChar)) {	        return str;	    }	    return new StringBuilder(strLen).append(Character.toTitleCase(firstChar)).append(str.substring(1)).toString();	}
public StrTokenizer setDelimiterString(final String delim) {	    return setDelimiterMatcher(StrMatcher.stringMatcher(delim));	}
public static String overlay(final String str, String overlay, int start, int end) {	    if (str == null) {	        return null;	    }	    if (overlay == null) {	        overlay = EMPTY;	    }	    final int len = str.length();	    if (start < 0) {	        start = 0;	    }	    if (start > len) {	        start = len;	    }	    if (end < 0) {	        end = 0;	    }	    if (end > len) {	        end = len;	    }	    if (start > end) {	        final int temp = start;	        start = end;	        end = temp;	    }	    return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString();	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public String getNullText() {	    return nullText;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public static String formatDuration(long durationMillis, final String format, final boolean padWithZeros) {	    final Token[] tokens = lexx(format);	    int days = 0;	    int hours = 0;	    int minutes = 0;	    int seconds = 0;	    int milliseconds = 0;	    if (Token.containsTokenWithValue(tokens, d)) {	        days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY);	        durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY);	    }	    if (Token.containsTokenWithValue(tokens, H)) {	        hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR);	        durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR);	    }	    if (Token.containsTokenWithValue(tokens, m)) {	        minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE);	        durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE);	    }	    if (Token.containsTokenWithValue(tokens, s)) {	        seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND);	        durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND);	    }	    if (Token.containsTokenWithValue(tokens, S)) {	        milliseconds = (int) durationMillis;	    }	    return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
public boolean isEmpty() {	    return size == 0;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static String overlay(final String str, String overlay, int start, int end) {	    if (str == null) {	        return null;	    }	    if (overlay == null) {	        overlay = EMPTY;	    }	    final int len = str.length();	    if (start < 0) {	        start = 0;	    }	    if (start > len) {	        start = len;	    }	    if (end < 0) {	        end = 0;	    }	    if (end > len) {	        end = len;	    }	    if (start > end) {	        final int temp = start;	        start = end;	        end = temp;	    }	    return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString();	}
public static char toChar(final String str, final char defaultValue) {	    if (StringUtils.isEmpty(str)) {	        return defaultValue;	    }	    return str.charAt(0);	}
public boolean isAppendStatics() {	    return this.appendStatics;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
@Override	public String next() {	    if (hasNext()) {	        return tokens[tokenPos++];	    }	    throw new NoSuchElementException();	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
public static float max(final float a, final float b, final float c) {	    return Math.max(Math.max(a, b), c);	}
public static String substringBetween(final String str, final String open, final String close) {	    if (str == null || open == null || close == null) {	        return null;	    }	    final int start = str.indexOf(open);	    if (start != INDEX_NOT_FOUND) {	        final int end = str.indexOf(close, start + open.length());	        if (end != INDEX_NOT_FOUND) {	            return str.substring(start + open.length(), end);	        }	    }	    return null;	}
public static Boolean[] nullToEmpty(final Boolean[] array) {	    if (array == null || array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    return array;	}
@Override	public List<Pair<String, Object>> getContextEntries() {	    return this.exceptionContext.getContextEntries();	}
public static void writeField(final Object target, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException {	    if (target == null) {	        throw new IllegalArgumentException("target object must not be null");	    }	    final Class<?> cls = target.getClass();	    final Field field = getField(cls, fieldName, forceAccess);	    if (field == null) {	        throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName);	    }	    writeField(field, target, value);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public int getNumerator() {	    return numerator;	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static String substringBeforeLast(final String str, final String separator) {	    if (isEmpty(str) || isEmpty(separator)) {	        return str;	    }	    final int pos = str.lastIndexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return str;	    }	    return str.substring(0, pos);	}
public int size() {	    return size;	}
public static String removeEnd(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.endsWith(remove)) {	        return str.substring(0, str.length() - remove.length());	    }	    return str;	}
private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass) {	    if (throwable == null || type == null) {	        return -1;	    }	    if (fromIndex < 0) {	        fromIndex = 0;	    }	    final Throwable[] throwables = ExceptionUtils.getThrowables(throwable);	    if (fromIndex >= throwables.length) {	        return -1;	    }	    if (subclass) {	        for (int i = fromIndex; i < throwables.length; i++) {	            if (type.isAssignableFrom(throwables[i].getClass())) {	                return i;	            }	        }	    } else {	        for (int i = fromIndex; i < throwables.length; i++) {	            if (type.equals(throwables[i].getClass())) {	                return i;	            }	        }	    }	    return -1;	}
public String getNewLineText() {	    return newLine;	}
public static String substringBefore(final String str, final String separator) {	    if (isEmpty(str) || separator == null) {	        return str;	    }	    if (separator.isEmpty()) {	        return EMPTY;	    }	    final int pos = str.indexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return str;	    }	    return str.substring(0, pos);	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
public static CharRange is(final char ch) {	    return new CharRange(ch, ch, false);	}
public StrBuilder appendSeparator(final char separator, final int loopIndex) {	    if (loopIndex > 0) {	        append(separator);	    }	    return this;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
@Override	public int length() {	    return size;	}
public static <E extends Enum<E>> EnumSet<E> processBitVector(final Class<E> enumClass, final long value) {	    checkBitVectorable(enumClass).getEnumConstants();	    return processBitVectors(enumClass, value);	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
@Override	public int length() {	    return size;	}
public static boolean isAsciiAlphaUpper(final char ch) {	    return ch >= 'A' && ch <= 'Z';	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
public static ConcurrentRuntimeException extractCauseUnchecked(final ExecutionException ex) {	    if (ex == null || ex.getCause() == null) {	        return null;	    }	    throwCause(ex);	    return new ConcurrentRuntimeException(ex.getMessage(), ex.getCause());	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
@Override	public boolean markSupported() {	    return true;	}
public static float min(final float a, final float b) {	    if (Float.isNaN(a)) {	        return b;	    } else if (Float.isNaN(b)) {	        return a;	    } else {	        return Math.min(a, b);	    }	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static Throwable[] getThrowables(final Throwable throwable) {	    final List<Throwable> list = getThrowableList(throwable);	    return list.toArray(new Throwable[list.size()]);	}
public boolean isEmptyTokenAsNull() {	    return this.emptyAsNull;	}
public static String substringBetween(final String str, final String open, final String close) {	    if (str == null || open == null || close == null) {	        return null;	    }	    final int start = str.indexOf(open);	    if (start != INDEX_NOT_FOUND) {	        final int end = str.indexOf(close, start + open.length());	        if (end != INDEX_NOT_FOUND) {	            return str.substring(start + open.length(), end);	        }	    }	    return null;	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
@Override	public boolean equals(final Object obj2) {	    if (obj2 instanceof Token) {	        final Token tok2 = (Token) obj2;	        if (this.value.getClass() != tok2.value.getClass()) {	            return false;	        }	        if (this.count != tok2.count) {	            return false;	        }	        if (this.value instanceof StringBuilder) {	            return this.value.toString().equals(tok2.value.toString());	        } else if (this.value instanceof Number) {	            return this.value.equals(tok2.value);	        } else {	            return this.value == tok2.value;	        }	    }	    return false;	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static boolean isEmpty(final CharSequence cs) {	    return cs == null || cs.length() == 0;	}
public static short[] removeElement(final short[] array, final short element) {	    final int index = indexOf(array, element);	    if (index == INDEX_NOT_FOUND) {	        return clone(array);	    }	    return remove(array, index);	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public static <T> Range<T> is(final T element, final Comparator<T> comparator) {	    return between(element, element, comparator);	}
public static String removeStart(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.startsWith(remove)) {	        return str.substring(remove.length());	    }	    return str;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public StrBuilder appendSeparator(final char separator, final int loopIndex) {	    if (loopIndex > 0) {	        append(separator);	    }	    return this;	}
@Override	public StringBuffer format(final Calendar calendar, final StringBuffer buf) {	    return applyRules(calendar, buf);	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public boolean isAppendStatics() {	    return this.appendStatics;	}
public HashCodeBuilder append(final short[] array) {	    if (array == null) {	        iTotal = iTotal * iConstant;	    } else {	        for (final short element : array) {	            append(element);	        }	    }	    return this;	}
public static float min(final float a, final float b) {	    if (Float.isNaN(a)) {	        return b;	    } else if (Float.isNaN(b)) {	        return a;	    } else {	        return Math.min(a, b);	    }	}
public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale) {	    return cache.getDateTimeInstance(dateStyle, timeStyle, timeZone, locale);	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public static final String unescapeJson(final String input) {	    return UNESCAPE_JSON.translate(input);	}
public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException {	    return parseDateWithLeniency(str, null, parsePatterns, false);	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public StrBuilder deleteAll(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, -1);	}
static void unregister(final Object lhs, final Object rhs) {	    Set<Pair<IDKey, IDKey>> registry = getRegistry();	    if (registry != null) {	        final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);	        registry.remove(pair);	        synchronized (EqualsBuilder.class) {	            registry = getRegistry();	            if (registry != null && registry.isEmpty()) {	                REGISTRY.remove();	            }	        }	    }	}
public static String[][] BASIC_ESCAPE() {	    return BASIC_ESCAPE.clone();	}
protected boolean isUseIdentityHashCode() {	    return useIdentityHashCode;	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
@Deprecated	public static String chomp(final String str, final String separator) {	    return removeEnd(str, separator);	}
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = Integer.MAX_VALUE;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.indexOf(str, search, 0);	        if (tmp == INDEX_NOT_FOUND) {	            continue;	        }	        if (tmp < ret) {	            ret = tmp;	        }	    }	    return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;	}
public static String formatDuration(long durationMillis, final String format, final boolean padWithZeros) {	    final Token[] tokens = lexx(format);	    int days = 0;	    int hours = 0;	    int minutes = 0;	    int seconds = 0;	    int milliseconds = 0;	    if (Token.containsTokenWithValue(tokens, d)) {	        days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY);	        durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY);	    }	    if (Token.containsTokenWithValue(tokens, H)) {	        hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR);	        durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR);	    }	    if (Token.containsTokenWithValue(tokens, m)) {	        minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE);	        durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE);	    }	    if (Token.containsTokenWithValue(tokens, s)) {	        seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND);	        durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND);	    }	    if (Token.containsTokenWithValue(tokens, S)) {	        milliseconds = (int) durationMillis;	    }	    return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
public String getNullText() {	    return nullText;	}
public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) {	    if (s == null || t == null) {	        throw new IllegalArgumentException("Strings must not be null");	    }	    if (threshold < 0) {	        throw new IllegalArgumentException("Threshold must not be negative");	    }	    int n = s.length();	    int m = t.length();	    if (n == 0) {	        return m <= threshold ? m : -1;	    } else if (m == 0) {	        return n <= threshold ? n : -1;	    }	    if (n > m) {	        final CharSequence tmp = s;	        s = t;	        t = tmp;	        n = m;	        m = t.length();	    }	    int[] p = new int[n + 1];	    int[] d = new int[n + 1];	    int[] _d;	    final int boundary = Math.min(n, threshold) + 1;	    for (int i = 0; i < boundary; i++) {	        p[i] = i;	    }	    Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);	    Arrays.fill(d, Integer.MAX_VALUE);	    for (int j = 1; j <= m; j++) {	        final char t_j = t.charAt(j - 1);	        d[0] = j;	        final int min = Math.max(1, j - threshold);	        final int max = Math.min(n, j + threshold);	        if (min > max) {	            return -1;	        }	        if (min > 1) {	            d[min - 1] = Integer.MAX_VALUE;	        }	        for (int i = min; i <= max; i++) {	            if (s.charAt(i - 1) == t_j) {	                d[i] = p[i - 1];	            } else {	                d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);	            }	        }	        _d = p;	        p = d;	        d = _d;	    }	    if (p[n] <= threshold) {	        return p[n];	    }	    return -1;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static StrMatcher doubleQuoteMatcher() {	    return DOUBLE_QUOTE_MATCHER;	}
public static <L, R> Pair<L, R> of(final L left, final R right) {	    return new ImmutablePair<L, R>(left, right);	}
public String getRawMessage() {	    return super.getMessage();	}
@Override	public float floatValue() {	    return (float) numerator / (float) denominator;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static <E extends Enum<E>> E getEnum(final Class<E> enumClass, final String enumName) {	    if (enumName == null) {	        return null;	    }	    try {	        return Enum.valueOf(enumClass, enumName);	    } catch (final IllegalArgumentException ex) {	        return null;	    }	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public static boolean containsAny(final CharSequence cs, final CharSequence searchChars) {	    if (searchChars == null) {	        return false;	    }	    return containsAny(cs, CharSequenceUtils.toCharArray(searchChars));	}
public static char toChar(final String str, final char defaultValue) {	    if (StringUtils.isEmpty(str)) {	        return defaultValue;	    }	    return str.charAt(0);	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public static int reflectionHashCode(final Object object, final String... excludeFields) {	    return reflectionHashCode(17, 37, object, false, null, excludeFields);	}
public static String stripAccents(final String input) {	    if (input == null) {	        return null;	    }	    final Pattern pattern = Pattern.compile("\\p{InCombiningDiacriticalMarks}+");	    final String decomposed = Normalizer.normalize(input, Normalizer.Form.NFD);	    return pattern.matcher(decomposed).replaceAll("");	}
public boolean contains(final T element) {	    if (element == null) {	        return false;	    }	    return comparator.compare(element, minimum) > -1 && comparator.compare(element, maximum) < 1;	}
public static String prependIfMissing(final String str, final CharSequence prefix, final CharSequence... prefixes) {	    return prependIfMissing(str, prefix, false, prefixes);	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
public int size() {	    return size;	}
public StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, 1);	}
public static Number createNumber(final String str) throws NumberFormatException {	    if (str == null) {	        return null;	    }	    if (StringUtils.isBlank(str)) {	        throw new NumberFormatException("A blank string is not a valid number");	    }	    final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" };	    int pfxLen = 0;	    for (final String pfx : hex_prefixes) {	        if (str.startsWith(pfx)) {	            pfxLen += pfx.length();	            break;	        }	    }	    if (pfxLen > 0) {	        final int hexDigits = str.length() - pfxLen;	        if (hexDigits > 16) {	            return createBigInteger(str);	        }	        if (hexDigits > 8) {	            return createLong(str);	        }	        return createInteger(str);	    }	    final char lastChar = str.charAt(str.length() - 1);	    String mant;	    String dec;	    String exp;	    final int decPos = str.indexOf('.');	    final int expPos = str.indexOf('e') + str.indexOf('E') + 1;	    int numDecimals = 0;	    if (decPos > -1) {	        if (expPos > -1) {	            if (expPos < decPos || expPos > str.length()) {	                throw new NumberFormatException(str + " is not a valid number.");	            }	            dec = str.substring(decPos + 1, expPos);	        } else {	            dec = str.substring(decPos + 1);	        }	        mant = str.substring(0, decPos);	        numDecimals = dec.length();	    } else {	        if (expPos > -1) {	            if (expPos > str.length()) {	                throw new NumberFormatException(str + " is not a valid number.");	            }	            mant = str.substring(0, expPos);	        } else {	            mant = str;	        }	        dec = null;	    }	    if (!Character.isDigit(lastChar) && lastChar != '.') {	        if (expPos > -1 && expPos < str.length() - 1) {	            exp = str.substring(expPos + 1, str.length() - 1);	        } else {	            exp = null;	        }	        final String numeric = str.substring(0, str.length() - 1);	        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);	        switch(lastChar) {	            case 'l':	            case 'L':	                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {	                    try {	                        return createLong(numeric);	                    } catch (final NumberFormatException nfe) {	                    }	                    return createBigInteger(numeric);	                }	                throw new NumberFormatException(str + " is not a valid number.");	            case 'f':	            case 'F':	                try {	                    final Float f = NumberUtils.createFloat(numeric);	                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {	                        return f;	                    }	                } catch (final NumberFormatException nfe) {	                }	            case 'd':	            case 'D':	                try {	                    final Double d = NumberUtils.createDouble(numeric);	                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {	                        return d;	                    }	                } catch (final NumberFormatException nfe) {	                }	                try {	                    return createBigDecimal(numeric);	                } catch (final NumberFormatException e) {	                }	            default:	                throw new NumberFormatException(str + " is not a valid number.");	        }	    }	    if (expPos > -1 && expPos < str.length() - 1) {	        exp = str.substring(expPos + 1, str.length());	    } else {	        exp = null;	    }	    if (dec == null && exp == null) {	        try {	            return createInteger(str);	        } catch (final NumberFormatException nfe) {	        }	        try {	            return createLong(str);	        } catch (final NumberFormatException nfe) {	        }	        return createBigInteger(str);	    }	    final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);	    try {	        if (numDecimals <= 7) {	            final Float f = createFloat(str);	            if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {	                return f;	            }	        }	    } catch (final NumberFormatException nfe) {	    }	    try {	        if (numDecimals <= 16) {	            final Double d = createDouble(str);	            if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {	                return d;	            }	        }	    } catch (final NumberFormatException nfe) {	    }	    return createBigDecimal(str);	}
public boolean isIgnoreEmptyTokens() {	    return ignoreEmptyTokens;	}
public static boolean[] removeElements(final boolean[] array, final boolean... values) {	    if (isEmpty(array) || isEmpty(values)) {	        return clone(array);	    }	    final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2);	    for (final boolean v : values) {	        final Boolean boxed = Boolean.valueOf(v);	        final MutableInt count = occurrences.get(boxed);	        if (count == null) {	            occurrences.put(boxed, new MutableInt(1));	        } else {	            count.increment();	        }	    }	    final BitSet toRemove = new BitSet();	    for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) {	        final Boolean v = e.getKey();	        int found = 0;	        for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {	            found = indexOf(array, v.booleanValue(), found);	            if (found < 0) {	                break;	            }	            toRemove.set(found++);	        }	    }	    return (boolean[]) removeAll(array, toRemove);	}
@Override	public T get() throws ConcurrentException {	    return getObject();	}
public synchronized void acquire() throws InterruptedException {	    if (isShutdown()) {	        throw new IllegalStateException("TimedSemaphore is shut down!");	    }	    if (task == null) {	        task = startTimer();	    }	    boolean canPass = false;	    do {	        canPass = getLimit() <= NO_LIMIT || acquireCount < getLimit();	        if (!canPass) {	            wait();	        } else {	            acquireCount++;	        }	    } while (!canPass);	}
public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) {	    if (array == null) {	        return null;	    }	    if (startIndexInclusive < 0) {	        startIndexInclusive = 0;	    }	    if (endIndexExclusive > array.length) {	        endIndexExclusive = array.length;	    }	    final int newSize = endIndexExclusive - startIndexInclusive;	    if (newSize <= 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] subarray = new boolean[newSize];	    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);	    return subarray;	}
public StrTokenizer setDelimiterMatcher(final StrMatcher delim) {	    if (delim == null) {	        this.delimMatcher = StrMatcher.noneMatcher();	    } else {	        this.delimMatcher = delim;	    }	    return this;	}
public String getNullText() {	    return nullText;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static <T> T initializeUnchecked(final ConcurrentInitializer<T> initializer) {	    try {	        return initialize(initializer);	    } catch (final ConcurrentException cex) {	        throw new ConcurrentRuntimeException(cex.getCause());	    }	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public int indexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex < 0 ? 0 : startIndex);	    if (matcher == null || startIndex >= size) {	        return -1;	    }	    final int len = size;	    final char[] buf = buffer;	    for (int i = startIndex; i < len; i++) {	        if (matcher.isMatch(buf, i, startIndex, len) > 0) {	            return i;	        }	    }	    return -1;	}
public boolean isEmpty() {	    return size == 0;	}
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] result = new boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        final Boolean b = array[i];	        result[i] = (b == null ? valueForNull : b.booleanValue());	    }	    return result;	}
public StrBuilder deleteAll(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, -1);	}
public boolean isEmpty() {	    return size == 0;	}
public static Date truncate(final Object date, final int field) {	    if (date == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (date instanceof Date) {	        return truncate((Date) date, field);	    } else if (date instanceof Calendar) {	        return truncate((Calendar) date, field).getTime();	    } else {	        throw new ClassCastException("Could not truncate " + date);	    }	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
@Override	public void flush() {	}
@Override	public void setValue(final Number value) {	    this.value = value.intValue();	}
public boolean isEmpty() {	    return size == 0;	}
public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException {	    return parseDateWithLeniency(str, locale, parsePatterns, true);	}
public int set(final int holder) {	    return holder | _mask;	}
public int size() {	    return size;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static UnicodeEscaper outsideOf(final int codepointLow, final int codepointHigh) {	    return new UnicodeEscaper(codepointLow, codepointHigh, false);	}
public static String center(String str, final int size, String padStr) {	    if (str == null || size <= 0) {	        return str;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    str = leftPad(str, strLen + pads / 2, padStr);	    str = rightPad(str, size, padStr);	    return str;	}
public static String lowerCase(final String str, final Locale locale) {	    if (str == null) {	        return null;	    }	    return str.toLowerCase(locale);	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static String replaceChars(final String str, final String searchChars, String replaceChars) {	    if (isEmpty(str) || isEmpty(searchChars)) {	        return str;	    }	    if (replaceChars == null) {	        replaceChars = EMPTY;	    }	    boolean modified = false;	    final int replaceCharsLength = replaceChars.length();	    final int strLength = str.length();	    final StringBuilder buf = new StringBuilder(strLength);	    for (int i = 0; i < strLength; i++) {	        final char ch = str.charAt(i);	        final int index = searchChars.indexOf(ch);	        if (index >= 0) {	            modified = true;	            if (index < replaceCharsLength) {	                buf.append(replaceChars.charAt(index));	            }	        } else {	            buf.append(ch);	        }	    }	    if (modified) {	        return buf.toString();	    }	    return str;	}
public static ConcurrentRuntimeException extractCauseUnchecked(final ExecutionException ex) {	    if (ex == null || ex.getCause() == null) {	        return null;	    }	    throwCause(ex);	    return new ConcurrentRuntimeException(ex.getMessage(), ex.getCause());	}
static Object removeAll(final Object array, final BitSet indices) {	    final int srcLength = ArrayUtils.getLength(array);	    final int removals = indices.cardinality();	    final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals);	    int srcIndex = 0;	    int destIndex = 0;	    int count;	    int set;	    while ((set = indices.nextSetBit(srcIndex)) != -1) {	        count = set - srcIndex;	        if (count > 0) {	            System.arraycopy(array, srcIndex, result, destIndex, count);	            destIndex += count;	        }	        srcIndex = indices.nextClearBit(set);	    }	    count = srcLength - srcIndex;	    if (count > 0) {	        System.arraycopy(array, srcIndex, result, destIndex, count);	    }	    return result;	}
public static String upperCase(final String str, final Locale locale) {	    if (str == null) {	        return null;	    }	    return str.toUpperCase(locale);	}
protected boolean isFieldSeparatorAtEnd() {	    return fieldSeparatorAtEnd;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public String getNewLineText() {	    return newLine;	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
@Override	public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) {	    return formatter.format(obj, toAppendTo, pos);	}
public static String removeStart(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.startsWith(remove)) {	        return str.substring(remove.length());	    }	    return str;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public static String trim(final String str) {	    return str == null ? null : str.trim();	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
@Override	public int compare(final Object obj1, final Object obj2) {	    return ((Comparable) obj1).compareTo(obj2);	}
public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width, final int precision, final char padChar, final CharSequence ellipsis) {	    Validate.isTrue(ellipsis == null || precision < 0 || ellipsis.length() <= precision, "Specified ellipsis '%1$s' exceeds precision of %2$s", ellipsis, Integer.valueOf(precision));	    final StringBuilder buf = new StringBuilder(seq);	    if (precision >= 0 && precision < seq.length()) {	        final CharSequence _ellipsis = ObjectUtils.defaultIfNull(ellipsis, StringUtils.EMPTY);	        buf.replace(precision - _ellipsis.length(), seq.length(), _ellipsis.toString());	    }	    final boolean leftJustify = (flags & LEFT_JUSTIFY) == LEFT_JUSTIFY;	    for (int i = buf.length(); i < width; i++) {	        buf.insert(leftJustify ? i : 0, padChar);	    }	    formatter.format(buf.toString());	    return formatter;	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
public void getChars(final int startIndex, final int endIndex, final char[] destination, final int destinationIndex) {	    if (startIndex < 0) {	        throw new StringIndexOutOfBoundsException(startIndex);	    }	    if (endIndex < 0 || endIndex > length()) {	        throw new StringIndexOutOfBoundsException(endIndex);	    }	    if (startIndex > endIndex) {	        throw new StringIndexOutOfBoundsException("end < start");	    }	    System.arraycopy(buffer, startIndex, destination, destinationIndex, endIndex - startIndex);	}
public static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex) {	    if (0 == nHex) {	        return dstInit;	    }	    if ((nHex - 1) * 4 + dstPos >= 32) {	        throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 32");	    }	    int out = dstInit;	    int shift = 0;	    for (int i = 0; i < nHex; i++) {	        shift = i * 4 + dstPos;	        final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift;	        final int mask = 0xf << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
public static boolean contains(final boolean[] array, final boolean valueToFind) {	    return indexOf(array, valueToFind) != INDEX_NOT_FOUND;	}
public boolean isEnableSubstitutionInVariables() {	    return enableSubstitutionInVariables;	}
public static String capitalize(final String str) {	    int strLen;	    if (str == null || (strLen = str.length()) == 0) {	        return str;	    }	    char firstChar = str.charAt(0);	    if (Character.isTitleCase(firstChar)) {	        return str;	    }	    return new StringBuilder(strLen).append(Character.toTitleCase(firstChar)).append(str.substring(1)).toString();	}
@Override	public int length() {	    return size;	}
protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    appendSummarySize(buffer, fieldName, array.length);	}
public HashCodeBuilder append(final short[] array) {	    if (array == null) {	        iTotal = iTotal * iConstant;	    } else {	        for (final short element : array) {	            append(element);	        }	    }	    return this;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public static String substringAfter(final String str, final String separator) {	    if (isEmpty(str)) {	        return str;	    }	    if (separator == null) {	        return EMPTY;	    }	    final int pos = str.indexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return EMPTY;	    }	    return str.substring(pos + separator.length());	}
public StrTokenizer setQuoteChar(final char quote) {	    return setQuoteMatcher(StrMatcher.charMatcher(quote));	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
@Override	public void close() {	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public int size() {	    return size;	}
@Override	public int length() {	    return size;	}
public boolean isAfter(final T element) {	    if (element == null) {	        return false;	    }	    return comparator.compare(element, minimum) < 0;	}
public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width, final int precision, final char padChar, final CharSequence ellipsis) {	    Validate.isTrue(ellipsis == null || precision < 0 || ellipsis.length() <= precision, "Specified ellipsis '%1$s' exceeds precision of %2$s", ellipsis, Integer.valueOf(precision));	    final StringBuilder buf = new StringBuilder(seq);	    if (precision >= 0 && precision < seq.length()) {	        final CharSequence _ellipsis = ObjectUtils.defaultIfNull(ellipsis, StringUtils.EMPTY);	        buf.replace(precision - _ellipsis.length(), seq.length(), _ellipsis.toString());	    }	    final boolean leftJustify = (flags & LEFT_JUSTIFY) == LEFT_JUSTIFY;	    for (int i = buf.length(); i < width; i++) {	        buf.insert(leftJustify ? i : 0, padChar);	    }	    formatter.format(buf.toString());	    return formatter;	}
public int getNumerator() {	    return numerator;	}
public synchronized boolean start() {	    if (!isStarted()) {	        ExecutorService tempExec;	        executor = getExternalExecutor();	        if (executor == null) {	            executor = tempExec = createExecutor();	        } else {	            tempExec = null;	        }	        future = executor.submit(createTask(tempExec));	        return true;	    }	    return false;	}
@Override	public int nextIndex() {	    return tokenPos;	}
public static boolean containsWhitespace(final CharSequence seq) {	    if (isEmpty(seq)) {	        return false;	    }	    final int strLen = seq.length();	    for (int i = 0; i < strLen; i++) {	        if (Character.isWhitespace(seq.charAt(i))) {	            return true;	        }	    }	    return false;	}
static boolean isRegistered(final Object lhs, final Object rhs) {	    final Set<Pair<IDKey, IDKey>> registry = getRegistry();	    final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);	    final Pair<IDKey, IDKey> swappedPair = Pair.of(pair.getLeft(), pair.getRight());	    return registry != null && (registry.contains(pair) || registry.contains(swappedPair));	}
public static <T> T invokeExactConstructor(final Class<T> cls, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {	    if (args == null) {	        args = ArrayUtils.EMPTY_OBJECT_ARRAY;	    }	    if (parameterTypes == null) {	        parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;	    }	    final Constructor<T> ctor = getAccessibleConstructor(cls, parameterTypes);	    if (ctor == null) {	        throw new NoSuchMethodException("No such accessible constructor on object: " + cls.getName());	    }	    return ctor.newInstance(args);	}
public static String overlay(final String str, String overlay, int start, int end) {	    if (str == null) {	        return null;	    }	    if (overlay == null) {	        overlay = EMPTY;	    }	    final int len = str.length();	    if (start < 0) {	        start = 0;	    }	    if (start > len) {	        start = len;	    }	    if (end < 0) {	        end = 0;	    }	    if (end > len) {	        end = len;	    }	    if (start > end) {	        final int temp = start;	        start = end;	        end = temp;	    }	    return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString();	}
public String getNewLineText() {	    return newLine;	}
public static String appendIfMissing(final String str, final CharSequence suffix, final CharSequence... suffixes) {	    return appendIfMissing(str, suffix, false, suffixes);	}
public String getNewLineText() {	    return newLine;	}
protected abstract T initialize() throws Exception;
protected String getSummaryObjectStartText() {	    return summaryObjectStartText;	}
public StrBuilder deleteCharAt(final int index) {	    if (index < 0 || index >= size) {	        throw new StringIndexOutOfBoundsException(index);	    }	    deleteImpl(index, index + 1, 1);	    return this;	}
protected String getArraySeparator() {	    return arraySeparator;	}
public static CharRange is(final char ch) {	    return new CharRange(ch, ch, false);	}
@Override	public int compare(final Object obj1, final Object obj2) {	    return ((Comparable) obj1).compareTo(obj2);	}
private static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns) {	    if (!isAssignable(cls, toClass)) {	        return null;	    }	    if (cls.isPrimitive()) {	        if (toClass.isPrimitive()) {	            return new HashMap<TypeVariable<?>, Type>();	        }	        cls = ClassUtils.primitiveToWrapper(cls);	    }	    final HashMap<TypeVariable<?>, Type> typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>() : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);	    if (toClass.equals(cls)) {	        return typeVarAssigns;	    }	    return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns);	}
public int size() {	    return size;	}
@Override	public int length() {	    return size;	}
protected String getSizeStartText() {	    return sizeStartText;	}
@Override	public TimeZone getTimeZone() {	    return timeZone;	}
public StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, 1);	}
protected void appendFieldEnd(final StringBuffer buffer, final String fieldName) {	    appendFieldSeparator(buffer);	}
public boolean isEquals() {	    return this.isEquals;	}
public static <E extends Enum<E>> E getEnum(final Class<E> enumClass, final String enumName) {	    if (enumName == null) {	        return null;	    }	    try {	        return Enum.valueOf(enumClass, enumName);	    } catch (final IllegalArgumentException ex) {	        return null;	    }	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
@Override	public TimeZone getTimeZone() {	    return timeZone;	}
public abstract L getLeft();
public boolean isIgnoreEmptyTokens() {	    return ignoreEmptyTokens;	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass) {	    if (throwable == null || type == null) {	        return -1;	    }	    if (fromIndex < 0) {	        fromIndex = 0;	    }	    final Throwable[] throwables = ExceptionUtils.getThrowables(throwable);	    if (fromIndex >= throwables.length) {	        return -1;	    }	    if (subclass) {	        for (int i = fromIndex; i < throwables.length; i++) {	            if (type.isAssignableFrom(throwables[i].getClass())) {	                return i;	            }	        }	    } else {	        for (int i = fromIndex; i < throwables.length; i++) {	            if (type.equals(throwables[i].getClass())) {	                return i;	            }	        }	    }	    return -1;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static String center(String str, final int size, String padStr) {	    if (str == null || size <= 0) {	        return str;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    str = leftPad(str, strLen + pads / 2, padStr);	    str = rightPad(str, size, padStr);	    return str;	}
public static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) {	    if (0 == nHexs) {	        return dstInit;	    }	    if ((nHexs - 1) * 4 + srcPos >= 32) {	        throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 32");	    }	    final StringBuilder sb = new StringBuilder(dstInit);	    int shift = 0;	    int append = sb.length();	    for (int i = 0; i < nHexs; i++) {	        shift = i * 4 + srcPos;	        final int bits = 0xF & (src >> shift);	        if (dstPos + i == append) {	            ++append;	            sb.append(intToHexDigit(bits));	        } else {	            sb.setCharAt(dstPos + i, intToHexDigit(bits));	        }	    }	    return sb.toString();	}
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = Integer.MAX_VALUE;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.indexOf(str, search, 0);	        if (tmp == INDEX_NOT_FOUND) {	            continue;	        }	        if (tmp < ret) {	            ret = tmp;	        }	    }	    return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;	}
public static String leftPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return leftPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return padStr.concat(str);	    } else if (pads < padLen) {	        return padStr.substring(0, pads).concat(str);	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return new String(padding).concat(str);	    }	}
@Override	public void flush() {	}
public String getNullText() {	    return nullText;	}
public String toProperString() {	    if (toProperString == null) {	        if (numerator == 0) {	            toProperString = "0";	        } else if (numerator == denominator) {	            toProperString = "1";	        } else if (numerator == -1 * denominator) {	            toProperString = "-1";	        } else if ((numerator > 0 ? -numerator : numerator) < -denominator) {	            final int properNumerator = getProperNumerator();	            if (properNumerator == 0) {	                toProperString = Integer.toString(getProperWhole());	            } else {	                toProperString = new StringBuilder(32).append(getProperWhole()).append(' ').append(properNumerator).append('/').append(getDenominator()).toString();	            }	        } else {	            toProperString = new StringBuilder(32).append(getNumerator()).append('/').append(getDenominator()).toString();	        }	    }	    return toProperString;	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public String getNullText() {	    return nullText;	}
protected String getArrayStart() {	    return arrayStart;	}
public static String[] substringsBetween(final String str, final String open, final String close) {	    if (str == null || isEmpty(open) || isEmpty(close)) {	        return null;	    }	    final int strLen = str.length();	    if (strLen == 0) {	        return ArrayUtils.EMPTY_STRING_ARRAY;	    }	    final int closeLen = close.length();	    final int openLen = open.length();	    final List<String> list = new ArrayList<String>();	    int pos = 0;	    while (pos < strLen - closeLen) {	        int start = str.indexOf(open, pos);	        if (start < 0) {	            break;	        }	        start += openLen;	        final int end = str.indexOf(close, start);	        if (end < 0) {	            break;	        }	        list.add(str.substring(start, end));	        pos = end + closeLen;	    }	    if (list.isEmpty()) {	        return null;	    }	    return list.toArray(new String[list.size()]);	}
protected boolean isUseShortClassName() {	    return useShortClassName;	}
public static boolean isAllUpperCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isUpperCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
protected String getSummaryObjectEndText() {	    return summaryObjectEndText;	}
@Override	public T get() throws ConcurrentException {	    try {	        return getFuture().get();	    } catch (final ExecutionException execex) {	        ConcurrentUtils.handleCause(execex);	        return null;	    } catch (final InterruptedException iex) {	        Thread.currentThread().interrupt();	        throw new ConcurrentException(iex);	    }	}
@Override	public boolean equals(final Object other) {	    if (!(other instanceof IDKey)) {	        return false;	    }	    final IDKey idKey = (IDKey) other;	    if (id != idKey.id) {	        return false;	    }	    return value == idKey.value;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public static boolean isEmpty(final boolean[] array) {	    return array == null || array.length == 0;	}
private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) {	    if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {	        return text;	    }	    if (timeToLive < 0) {	        throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another");	    }	    final int searchLength = searchList.length;	    final int replacementLength = replacementList.length;	    if (searchLength != replacementLength) {	        throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength);	    }	    final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];	    int textIndex = -1;	    int replaceIndex = -1;	    int tempIndex = -1;	    for (int i = 0; i < searchLength; i++) {	        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {	            continue;	        }	        tempIndex = text.indexOf(searchList[i]);	        if (tempIndex == -1) {	            noMoreMatchesForReplIndex[i] = true;	        } else {	            if (textIndex == -1 || tempIndex < textIndex) {	                textIndex = tempIndex;	                replaceIndex = i;	            }	        }	    }	    if (textIndex == -1) {	        return text;	    }	    int start = 0;	    int increase = 0;	    for (int i = 0; i < searchList.length; i++) {	        if (searchList[i] == null || replacementList[i] == null) {	            continue;	        }	        final int greater = replacementList[i].length() - searchList[i].length();	        if (greater > 0) {	            increase += 3 * greater;	        }	    }	    increase = Math.min(increase, text.length() / 5);	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (textIndex != -1) {	        for (int i = start; i < textIndex; i++) {	            buf.append(text.charAt(i));	        }	        buf.append(replacementList[replaceIndex]);	        start = textIndex + searchList[replaceIndex].length();	        textIndex = -1;	        replaceIndex = -1;	        tempIndex = -1;	        for (int i = 0; i < searchLength; i++) {	            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {	                continue;	            }	            tempIndex = text.indexOf(searchList[i], start);	            if (tempIndex == -1) {	                noMoreMatchesForReplIndex[i] = true;	            } else {	                if (textIndex == -1 || tempIndex < textIndex) {	                    textIndex = tempIndex;	                    replaceIndex = i;	                }	            }	        }	    }	    final int textLength = text.length();	    for (int i = start; i < textLength; i++) {	        buf.append(text.charAt(i));	    }	    final String result = buf.toString();	    if (!repeat) {	        return result;	    }	    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);	}
@Override	public T get(final long timeout, final TimeUnit unit) {	    return value;	}
protected String getSizeStartText() {	    return sizeStartText;	}
public StrBuilder appendSeparator(final char separator, final int loopIndex) {	    if (loopIndex > 0) {	        append(separator);	    }	    return this;	}
static Object removeAll(final Object array, final BitSet indices) {	    final int srcLength = ArrayUtils.getLength(array);	    final int removals = indices.cardinality();	    final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals);	    int srcIndex = 0;	    int destIndex = 0;	    int count;	    int set;	    while ((set = indices.nextSetBit(srcIndex)) != -1) {	        count = set - srcIndex;	        if (count > 0) {	            System.arraycopy(array, srcIndex, result, destIndex, count);	            destIndex += count;	        }	        srcIndex = indices.nextClearBit(set);	    }	    count = srcLength - srcIndex;	    if (count > 0) {	        System.arraycopy(array, srcIndex, result, destIndex, count);	    }	    return result;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static boolean isAscii(final char ch) {	    return ch < 128;	}
public static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools) {	    if ((src.length == 0 && srcPos == 0) || 0 == nBools) {	        return dstInit;	    }	    if (nBools - 1 + dstPos >= 32) {	        throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 32");	    }	    int out = dstInit;	    int shift = 0;	    for (int i = 0; i < nBools; i++) {	        shift = i * 1 + dstPos;	        final int bits = (src[i + srcPos] ? 1 : 0) << shift;	        final int mask = 0x1 << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return new boolean[] { false, false, false, false };	        case '1':	            return new boolean[] { false, false, false, true };	        case '2':	            return new boolean[] { false, false, true, false };	        case '3':	            return new boolean[] { false, false, true, true };	        case '4':	            return new boolean[] { false, true, false, false };	        case '5':	            return new boolean[] { false, true, false, true };	        case '6':	            return new boolean[] { false, true, true, false };	        case '7':	            return new boolean[] { false, true, true, true };	        case '8':	            return new boolean[] { true, false, false, false };	        case '9':	            return new boolean[] { true, false, false, true };	        case 'a':	        case 'A':	            return new boolean[] { true, false, true, false };	        case 'b':	        case 'B':	            return new boolean[] { true, false, true, true };	        case 'c':	        case 'C':	            return new boolean[] { true, true, false, false };	        case 'd':	        case 'D':	            return new boolean[] { true, true, false, true };	        case 'e':	        case 'E':	            return new boolean[] { true, true, true, false };	        case 'f':	        case 'F':	            return new boolean[] { true, true, true, true };	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
@Override	public Date parse(final String source, final ParsePosition pos) {	    final int offset = pos.getIndex();	    final Matcher matcher = parsePattern.matcher(source.substring(offset));	    if (!matcher.lookingAt()) {	        return null;	    }	    final Calendar cal = Calendar.getInstance(timeZone, locale);	    cal.clear();	    for (int i = 0; i < strategies.length; ) {	        final Strategy strategy = strategies[i++];	        strategy.setCalendar(this, cal, matcher.group(i));	    }	    pos.setIndex(offset + matcher.end());	    return cal.getTime();	}
public static boolean isAsciiAlpha(final char ch) {	    return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
@Override	public int length() {	    return size;	}
public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale) {	    return cache.getInstance(pattern, timeZone, locale);	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static boolean isNumeric(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isDigit(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
static Set<Pair<IDKey, IDKey>> getRegistry() {	    return REGISTRY.get();	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public int lastIndexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex >= size ? size - 1 : startIndex);	    if (matcher == null || startIndex < 0) {	        return -1;	    }	    final char[] buf = buffer;	    final int endIndex = startIndex + 1;	    for (int i = startIndex; i >= 0; i--) {	        if (matcher.isMatch(buf, i, 0, endIndex) > 0) {	            return i;	        }	    }	    return -1;	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
@Override	public String getPattern() {	    return mPattern;	}
@Override	public TimeZone getTimeZone() {	    return mTimeZone;	}
public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) {	    final Token[] tokens = lexx(format);	    final Calendar start = Calendar.getInstance(timezone);	    start.setTime(new Date(startMillis));	    final Calendar end = Calendar.getInstance(timezone);	    end.setTime(new Date(endMillis));	    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);	    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);	    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);	    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);	    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);	    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);	    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);	    while (milliseconds < 0) {	        milliseconds += 1000;	        seconds -= 1;	    }	    while (seconds < 0) {	        seconds += 60;	        minutes -= 1;	    }	    while (minutes < 0) {	        minutes += 60;	        hours -= 1;	    }	    while (hours < 0) {	        hours += 24;	        days -= 1;	    }	    if (Token.containsTokenWithValue(tokens, M)) {	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	        while (months < 0) {	            months += 12;	            years -= 1;	        }	        if (!Token.containsTokenWithValue(tokens, y) && years != 0) {	            while (years != 0) {	                months += 12 * years;	                years = 0;	            }	        }	    } else {	        if (!Token.containsTokenWithValue(tokens, y)) {	            int target = end.get(Calendar.YEAR);	            if (months < 0) {	                target -= 1;	            }	            while (start.get(Calendar.YEAR) != target) {	                days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);	                if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) {	                    days += 1;	                }	                start.add(Calendar.YEAR, 1);	                days += start.get(Calendar.DAY_OF_YEAR);	            }	            years = 0;	        }	        while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            start.add(Calendar.MONTH, 1);	        }	        months = 0;	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	    }	    if (!Token.containsTokenWithValue(tokens, d)) {	        hours += 24 * days;	        days = 0;	    }	    if (!Token.containsTokenWithValue(tokens, H)) {	        minutes += 60 * hours;	        hours = 0;	    }	    if (!Token.containsTokenWithValue(tokens, m)) {	        seconds += 60 * minutes;	        minutes = 0;	    }	    if (!Token.containsTokenWithValue(tokens, s)) {	        milliseconds += 1000 * seconds;	        seconds = 0;	    }	    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
@Override	public int hashCode() {	    return value ? Boolean.TRUE.hashCode() : Boolean.FALSE.hashCode();	}
public Fraction negate() {	    if (numerator == Integer.MIN_VALUE) {	        throw new ArithmeticException("overflow: too large to negate");	    }	    return new Fraction(-numerator, denominator);	}
public String getNullText() {	    return nullText;	}
public static Long createLong(final String str) {	    if (str == null) {	        return null;	    }	    return Long.decode(str);	}
public int getDenominator() {	    return denominator;	}
public void stop() {	    if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {	        throw new IllegalStateException("Stopwatch is not running. ");	    }	    if (this.runningState == STATE_RUNNING) {	        this.stopTime = System.nanoTime();	    }	    this.runningState = STATE_STOPPED;	}
private static boolean endsWith(final CharSequence str, final CharSequence suffix, final boolean ignoreCase) {	    if (str == null || suffix == null) {	        return str == null && suffix == null;	    }	    if (suffix.length() > str.length()) {	        return false;	    }	    final int strOffset = str.length() - suffix.length();	    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, suffix, 0, suffix.length());	}
public static float min(final float a, final float b, final float c) {	    return Math.min(Math.min(a, b), c);	}
public String getNullText() {	    return nullText;	}
public static void reverse(final boolean[] array) {	    if (array == null) {	        return;	    }	    int i = 0;	    int j = array.length - 1;	    boolean tmp;	    while (j > i) {	        tmp = array[j];	        array[j] = array[i];	        array[i] = tmp;	        j--;	        i++;	    }	}
public static String substringAfter(final String str, final String separator) {	    if (isEmpty(str)) {	        return str;	    }	    if (separator == null) {	        return EMPTY;	    }	    final int pos = str.indexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return EMPTY;	    }	    return str.substring(pos + separator.length());	}
public static String right(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(str.length() - len);	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
static boolean regionMatches(final CharSequence cs, final boolean ignoreCase, final int thisStart, final CharSequence substring, final int start, final int length) {	    if (cs instanceof String && substring instanceof String) {	        return ((String) cs).regionMatches(ignoreCase, thisStart, (String) substring, start, length);	    } else {	        int index1 = thisStart;	        int index2 = start;	        int tmpLen = length;	        while (tmpLen-- > 0) {	            char c1 = cs.charAt(index1++);	            char c2 = substring.charAt(index2++);	            if (c1 == c2) {	                continue;	            }	            if (!ignoreCase) {	                return false;	            }	            if (Character.toUpperCase(c1) != Character.toUpperCase(c2) && Character.toLowerCase(c1) != Character.toLowerCase(c2)) {	                return false;	            }	        }	        return true;	    }	}
public static String strip(String str, final String stripChars) {	    if (isEmpty(str)) {	        return str;	    }	    str = stripStart(str, stripChars);	    return stripEnd(str, stripChars);	}
public static String reverse(final String str) {	    if (str == null) {	        return null;	    }	    return new StringBuilder(str).reverse().toString();	}
public static String leftPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return leftPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return padStr.concat(str);	    } else if (pads < padLen) {	        return padStr.substring(0, pads).concat(str);	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return new String(padding).concat(str);	    }	}
@Override	public Integer build() {	    return Integer.valueOf(toHashCode());	}
public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException {	    return parseDateWithLeniency(str, locale, parsePatterns, true);	}
public StringBuffer toStringBuffer() {	    return new StringBuffer(size).append(buffer, 0, size);	}
public static <T> Range<T> is(final T element, final Comparator<T> comparator) {	    return between(element, element, comparator);	}
public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException {	    return parseDateWithLeniency(str, locale, parsePatterns, true);	}
protected boolean isDefaultFullDetail() {	    return defaultFullDetail;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
protected boolean isUseShortClassName() {	    return useShortClassName;	}
public static String replaceChars(final String str, final String searchChars, String replaceChars) {	    if (isEmpty(str) || isEmpty(searchChars)) {	        return str;	    }	    if (replaceChars == null) {	        replaceChars = EMPTY;	    }	    boolean modified = false;	    final int replaceCharsLength = replaceChars.length();	    final int strLength = str.length();	    final StringBuilder buf = new StringBuilder(strLength);	    for (int i = 0; i < strLength; i++) {	        final char ch = str.charAt(i);	        final int index = searchChars.indexOf(ch);	        if (index >= 0) {	            modified = true;	            if (index < replaceCharsLength) {	                buf.append(replaceChars.charAt(index));	            }	        } else {	            buf.append(ch);	        }	    }	    if (modified) {	        return buf.toString();	    }	    return str;	}
public boolean isEmpty() {	    return size == 0;	}
public int toComparison() {	    return comparison;	}
public final synchronized int getLimit() {	    return limit;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static CharRange is(final char ch) {	    return new CharRange(ch, ch, false);	}
public static String prependIfMissing(final String str, final CharSequence prefix, final CharSequence... prefixes) {	    return prependIfMissing(str, prefix, false, prefixes);	}
public static int toIntValue(final Character ch, final int defaultValue) {	    if (ch == null) {	        return defaultValue;	    }	    return toIntValue(ch.charValue(), defaultValue);	}
@Override	public String next() {	    if (hasNext()) {	        return tokens[tokenPos++];	    }	    throw new NoSuchElementException();	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static String removeStart(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.startsWith(remove)) {	        return str.substring(remove.length());	    }	    return str;	}
public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width, final int precision, final char padChar, final CharSequence ellipsis) {	    Validate.isTrue(ellipsis == null || precision < 0 || ellipsis.length() <= precision, "Specified ellipsis '%1$s' exceeds precision of %2$s", ellipsis, Integer.valueOf(precision));	    final StringBuilder buf = new StringBuilder(seq);	    if (precision >= 0 && precision < seq.length()) {	        final CharSequence _ellipsis = ObjectUtils.defaultIfNull(ellipsis, StringUtils.EMPTY);	        buf.replace(precision - _ellipsis.length(), seq.length(), _ellipsis.toString());	    }	    final boolean leftJustify = (flags & LEFT_JUSTIFY) == LEFT_JUSTIFY;	    for (int i = buf.length(); i < width; i++) {	        buf.insert(leftJustify ? i : 0, padChar);	    }	    formatter.format(buf.toString());	    return formatter;	}
public static boolean isBlank(final CharSequence cs) {	    int strLen;	    if (cs == null || (strLen = cs.length()) == 0) {	        return true;	    }	    for (int i = 0; i < strLen; i++) {	        if (Character.isWhitespace(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public String getNewLineText() {	    return newLine;	}
public static String overlay(final String str, String overlay, int start, int end) {	    if (str == null) {	        return null;	    }	    if (overlay == null) {	        overlay = EMPTY;	    }	    final int len = str.length();	    if (start < 0) {	        start = 0;	    }	    if (start > len) {	        start = len;	    }	    if (end < 0) {	        end = 0;	    }	    if (end > len) {	        end = len;	    }	    if (start > end) {	        final int temp = start;	        start = end;	        end = temp;	    }	    return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString();	}
protected String getSummaryObjectStartText() {	    return summaryObjectStartText;	}
protected void setFieldSeparator(String fieldSeparator) {	    if (fieldSeparator == null) {	        fieldSeparator = "";	    }	    this.fieldSeparator = fieldSeparator;	}
public boolean contains(final StrMatcher matcher) {	    return indexOf(matcher, 0) >= 0;	}
public static Type[] normalizeUpperBounds(final Type[] bounds) {	    if (bounds.length < 2) {	        return bounds;	    }	    final Set<Type> types = new HashSet<Type>(bounds.length);	    for (final Type type1 : bounds) {	        boolean subtypeFound = false;	        for (final Type type2 : bounds) {	            if (type1 != type2 && isAssignable(type2, type1, null)) {	                subtypeFound = true;	                break;	            }	        }	        if (!subtypeFound) {	            types.add(type1);	        }	    }	    return types.toArray(new Type[types.size()]);	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
@Override	public int length() {	    return size;	}
public String getNewLineText() {	    return newLine;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public StringBuilder toStringBuilder() {	    return new StringBuilder(size).append(buffer, 0, size);	}
private static boolean isAssignable(final Type type, final TypeVariable<?> toTypeVariable, final Map<TypeVariable<?>, Type> typeVarAssigns) {	    if (type == null) {	        return true;	    }	    if (toTypeVariable == null) {	        return false;	    }	    if (toTypeVariable.equals(type)) {	        return true;	    }	    if (type instanceof TypeVariable<?>) {	        final Type[] bounds = getImplicitBounds((TypeVariable<?>) type);	        for (final Type bound : bounds) {	            if (isAssignable(bound, toTypeVariable, typeVarAssigns)) {	                return true;	            }	        }	    }	    if (type instanceof Class<?> || type instanceof ParameterizedType || type instanceof GenericArrayType || type instanceof WildcardType) {	        return false;	    }	    throw new IllegalStateException("found an unhandled type: " + type);	}
public static StrMatcher stringMatcher(final String str) {	    if (StringUtils.isEmpty(str)) {	        return NONE_MATCHER;	    }	    return new StringMatcher(str);	}
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) {	    return new Range<T>(fromInclusive, toInclusive, comparator);	}
public static <L, R> Pair<L, R> of(final L left, final R right) {	    return new ImmutablePair<L, R>(left, right);	}
public static String stripToNull(String str) {	    if (str == null) {	        return null;	    }	    str = strip(str, null);	    return str.isEmpty() ? null : str;	}
public String toString(final String format) {	    return String.format(format, getLeft(), getRight());	}
public StrBuilder deleteCharAt(final int index) {	    if (index < 0 || index >= size) {	        throw new StringIndexOutOfBoundsException(index);	    }	    deleteImpl(index, index + 1, 1);	    return this;	}
public static String stripToNull(String str) {	    if (str == null) {	        return null;	    }	    str = strip(str, null);	    return str.isEmpty() ? null : str;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static Fraction getReducedFraction(int numerator, int denominator) {	    if (denominator == 0) {	        throw new ArithmeticException("The denominator must not be zero");	    }	    if (numerator == 0) {	        return ZERO;	    }	    if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) {	        numerator /= 2;	        denominator /= 2;	    }	    if (denominator < 0) {	        if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {	            throw new ArithmeticException("overflow: can't negate");	        }	        numerator = -numerator;	        denominator = -denominator;	    }	    final int gcd = greatestCommonDivisor(numerator, denominator);	    numerator /= gcd;	    denominator /= gcd;	    return new Fraction(numerator, denominator);	}
public String getNewLineText() {	    return newLine;	}
public boolean isEmpty() {	    return size == 0;	}
protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array) {	    buffer.append(arrayStart);	    final int length = Array.getLength(array);	    for (int i = 0; i < length; i++) {	        final Object item = Array.get(array, i);	        if (i > 0) {	            buffer.append(arraySeparator);	        }	        if (item == null) {	            appendNullText(buffer, fieldName);	        } else {	            appendInternal(buffer, fieldName, item, arrayContentDetail);	        }	    }	    buffer.append(arrayEnd);	}
public static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts) {	    if ((src.length == 0 && srcPos == 0) || 0 == nShorts) {	        return dstInit;	    }	    if ((nShorts - 1) * 16 + dstPos >= 32) {	        throw new IllegalArgumentException("(nShorts-1)*16+dstPos is greather or equal to than 32");	    }	    int out = dstInit;	    int shift = 0;	    for (int i = 0; i < nShorts; i++) {	        shift = i * 16 + dstPos;	        final int bits = (0xffff & src[i + srcPos]) << shift;	        final int mask = 0xffff << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {	    if (array == null) {	        if (index != 0) {	            throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0");	        }	        final Object joinedArray = Array.newInstance(clss, 1);	        Array.set(joinedArray, 0, element);	        return joinedArray;	    }	    final int length = Array.getLength(array);	    if (index > length || index < 0) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(clss, length + 1);	    System.arraycopy(array, 0, result, 0, index);	    Array.set(result, index, element);	    if (index < length) {	        System.arraycopy(array, index, result, index + 1, length - index);	    }	    return result;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static String prependIfMissing(final String str, final CharSequence prefix, final CharSequence... prefixes) {	    return prependIfMissing(str, prefix, false, prefixes);	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public static float max(final float a, final float b) {	    if (Float.isNaN(a)) {	        return b;	    } else if (Float.isNaN(b)) {	        return a;	    } else {	        return Math.max(a, b);	    }	}
@Override	public Set<String> getContextLabels() {	    final Set<String> labels = new HashSet<String>();	    for (final Pair<String, Object> pair : contextValues) {	        labels.add(pair.getKey());	    }	    return labels;	}
@Override	public int intValue() {	    return value;	}
public void addInitializer(final String name, final BackgroundInitializer<?> init) {	    if (name == null) {	        throw new IllegalArgumentException("Name of child initializer must not be null!");	    }	    if (init == null) {	        throw new IllegalArgumentException("Child initializer must not be null!");	    }	    synchronized (this) {	        if (isStarted()) {	            throw new IllegalStateException("addInitializer() must not be called after start()!");	        }	        childInitializers.put(name, init);	    }	}
public StrBuilder setLength(final int length) {	    if (length < 0) {	        throw new StringIndexOutOfBoundsException(length);	    }	    if (length < size) {	        size = length;	    } else if (length > size) {	        ensureCapacity(length);	        final int oldEnd = size;	        final int newEnd = length;	        size = length;	        for (int i = oldEnd; i < newEnd; i++) {	            buffer[i] = '\0';	        }	    }	    return this;	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] result = new boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        final Boolean b = array[i];	        result[i] = (b == null ? valueForNull : b.booleanValue());	    }	    return result;	}
@Override	public boolean equals(final Object obj) {	    if (obj == this) {	        return true;	    }	    if (obj instanceof Triple<?, ?, ?>) {	        final Triple<?, ?, ?> other = (Triple<?, ?, ?>) obj;	        return ObjectUtils.equals(getLeft(), other.getLeft()) && ObjectUtils.equals(getMiddle(), other.getMiddle()) && ObjectUtils.equals(getRight(), other.getRight());	    }	    return false;	}
public static Boolean or(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
public int size() {	    return size;	}
public static void validState(final boolean expression, final String message, final Object... values) {	    if (expression == false) {	        throw new IllegalStateException(String.format(message, values));	    }	}
@Override	public boolean cancel(final boolean mayInterruptIfRunning) {	    return false;	}
public static int indexOfDifference(final CharSequence... css) {	    if (css == null || css.length <= 1) {	        return INDEX_NOT_FOUND;	    }	    boolean anyStringNull = false;	    boolean allStringsNull = true;	    final int arrayLen = css.length;	    int shortestStrLen = Integer.MAX_VALUE;	    int longestStrLen = 0;	    for (int i = 0; i < arrayLen; i++) {	        if (css[i] == null) {	            anyStringNull = true;	            shortestStrLen = 0;	        } else {	            allStringsNull = false;	            shortestStrLen = Math.min(css[i].length(), shortestStrLen);	            longestStrLen = Math.max(css[i].length(), longestStrLen);	        }	    }	    if (allStringsNull || longestStrLen == 0 && !anyStringNull) {	        return INDEX_NOT_FOUND;	    }	    if (shortestStrLen == 0) {	        return 0;	    }	    int firstDiff = -1;	    for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {	        final char comparisonChar = css[0].charAt(stringPos);	        for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {	            if (css[arrayPos].charAt(stringPos) != comparisonChar) {	                firstDiff = stringPos;	                break;	            }	        }	        if (firstDiff != -1) {	            break;	        }	    }	    if (firstDiff == -1 && shortestStrLen != longestStrLen) {	        return shortestStrLen;	    }	    return firstDiff;	}
public static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex) {	    if (0 == nHex) {	        return dstInit;	    }	    if ((nHex - 1) * 4 + dstPos >= 64) {	        throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 64");	    }	    long out = dstInit;	    int shift = 0;	    for (int i = 0; i < nHex; i++) {	        shift = i * 4 + dstPos;	        final long bits = (0xfL & hexDigitToInt(src.charAt(i + srcPos))) << shift;	        final long mask = 0xfL << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
public int capacity() {	    return buffer.length;	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
protected int getTaskCount() {	    return 1;	}
protected String getFieldSeparator() {	    return fieldSeparator;	}
public static boolean isNumeric(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isDigit(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException {	    return charsetName == null ? new String(bytes) : new String(bytes, charsetName);	}
public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) {	    if (src.length > 8) {	        throw new IllegalArgumentException("src.length>8: src.length=" + src.length);	    }	    if (src.length - srcPos < 4) {	        throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos);	    }	    if (src[srcPos + 3]) {	        if (src[srcPos + 2]) {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return '7';	                }	            } else {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return '3';	                }	            }	        } else {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return '5';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '1';	                }	            }	        }	    } else {	        if (src[srcPos + 2]) {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'e';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return 'a';	                } else {	                    return '2';	                }	            }	        } else {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'c';	                } else {	                    return '4';	                }	            } else {	                if (src[srcPos]) {	                    return '8';	                } else {	                    return '0';	                }	            }	        }	    }	}
public static String rightPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return rightPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return str.concat(padStr);	    } else if (pads < padLen) {	        return str.concat(padStr.substring(0, pads));	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return str.concat(new String(padding));	    }	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess) {	    if (cls == null) {	        throw new IllegalArgumentException("The class must not be null");	    }	    if (fieldName == null) {	        throw new IllegalArgumentException("The field name must not be null");	    }	    try {	        final Field field = cls.getDeclaredField(fieldName);	        if (!MemberUtils.isAccessible(field)) {	            if (forceAccess) {	                field.setAccessible(true);	            } else {	                return null;	            }	        }	        return field;	    } catch (final NoSuchFieldException e) {	    }	    return null;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex) {	    if (0 == nHex) {	        return dstInit;	    }	    if ((nHex - 1) * 4 + dstPos >= 16) {	        throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 16");	    }	    short out = dstInit;	    int shift = 0;	    for (int i = 0; i < nHex; i++) {	        shift = i * 4 + dstPos;	        final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift;	        final int mask = 0xf << shift;	        out = (short) ((out & ~mask) | bits);	    }	    return out;	}
public int size() {	    return size;	}
public StrBuilder clear() {	    size = 0;	    return this;	}
public static String removePattern(final String source, final String regex) {	    return replacePattern(source, regex, StringUtils.EMPTY);	}
public static String defaultString(final String str, final String defaultStr) {	    return str == null ? defaultStr : str;	}
public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) {	    String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'");	    if (suppressLeadingZeroElements) {	        duration = " " + duration;	        String tmp = StringUtils.replaceOnce(duration, " 0 days", "");	        if (tmp.length() != duration.length()) {	            duration = tmp;	            tmp = StringUtils.replaceOnce(duration, " 0 hours", "");	            if (tmp.length() != duration.length()) {	                duration = tmp;	                tmp = StringUtils.replaceOnce(duration, " 0 minutes", "");	                duration = tmp;	                if (tmp.length() != duration.length()) {	                    duration = StringUtils.replaceOnce(tmp, " 0 seconds", "");	                }	            }	        }	        if (duration.length() != 0) {	            duration = duration.substring(1);	        }	    }	    if (suppressTrailingZeroElements) {	        String tmp = StringUtils.replaceOnce(duration, " 0 seconds", "");	        if (tmp.length() != duration.length()) {	            duration = tmp;	            tmp = StringUtils.replaceOnce(duration, " 0 minutes", "");	            if (tmp.length() != duration.length()) {	                duration = tmp;	                tmp = StringUtils.replaceOnce(duration, " 0 hours", "");	                if (tmp.length() != duration.length()) {	                    duration = StringUtils.replaceOnce(tmp, " 0 days", "");	                }	            }	        }	    }	    duration = " " + duration;	    duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second");	    duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute");	    duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour");	    duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day");	    return duration.trim();	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static boolean[] removeElements(final boolean[] array, final boolean... values) {	    if (isEmpty(array) || isEmpty(values)) {	        return clone(array);	    }	    final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2);	    for (final boolean v : values) {	        final Boolean boxed = Boolean.valueOf(v);	        final MutableInt count = occurrences.get(boxed);	        if (count == null) {	            occurrences.put(boxed, new MutableInt(1));	        } else {	            count.increment();	        }	    }	    final BitSet toRemove = new BitSet();	    for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) {	        final Boolean v = e.getKey();	        int found = 0;	        for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {	            found = indexOf(array, v.booleanValue(), found);	            if (found < 0) {	                break;	            }	            toRemove.set(found++);	        }	    }	    return (boolean[]) removeAll(array, toRemove);	}
public String getNewLineText() {	    return newLine;	}
public static <T extends CharSequence> T notEmpty(final T chars) {	    return notEmpty(chars, DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
public static boolean isNotEmpty(final boolean[] array) {	    return (array != null && array.length != 0);	}
@Override	public TimeZone getTimeZone() {	    return mTimeZone;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
@Override	public String toString() {	    return String.valueOf(value);	}
public static <T> T defaultIfNull(final T object, final T defaultValue) {	    return object != null ? object : defaultValue;	}
public int toComparison() {	    return comparison;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
@Override	public Locale getLocale() {	    return printer.getLocale();	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
@Override	public String getArraySeparator() {	    return super.getArraySeparator();	}
public static String formatDurationHMS(final long durationMillis) {	    return formatDuration(durationMillis, "H:mm:ss.SSS");	}
public String getNewLineText() {	    return newLine;	}
public static boolean isAlpha(final CharSequence cs) {	    if (cs == null || cs.length() == 0) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLetter(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {	    if (array == null) {	        if (index != 0) {	            throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0");	        }	        final Object joinedArray = Array.newInstance(clss, 1);	        Array.set(joinedArray, 0, element);	        return joinedArray;	    }	    final int length = Array.getLength(array);	    if (index > length || index < 0) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(clss, length + 1);	    System.arraycopy(array, 0, result, 0, index);	    Array.set(result, index, element);	    if (index < length) {	        System.arraycopy(array, index, result, index + 1, length - index);	    }	    return result;	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static Method getPublicMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) throws SecurityException, NoSuchMethodException {	    final Method declaredMethod = cls.getMethod(methodName, parameterTypes);	    if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) {	        return declaredMethod;	    }	    final List<Class<?>> candidateClasses = new ArrayList<Class<?>>();	    candidateClasses.addAll(getAllInterfaces(cls));	    candidateClasses.addAll(getAllSuperclasses(cls));	    for (final Class<?> candidateClass : candidateClasses) {	        if (!Modifier.isPublic(candidateClass.getModifiers())) {	            continue;	        }	        Method candidateMethod;	        try {	            candidateMethod = candidateClass.getMethod(methodName, parameterTypes);	        } catch (final NoSuchMethodException ex) {	            continue;	        }	        if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) {	            return candidateMethod;	        }	    }	    throw new NoSuchMethodException("Can't find a public method for " + methodName + " " + ArrayUtils.toString(parameterTypes));	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
@Override	public String getFormattedExceptionMessage(final String baseMessage) {	    final StringBuilder buffer = new StringBuilder(256);	    if (baseMessage != null) {	        buffer.append(baseMessage);	    }	    if (contextValues.size() > 0) {	        if (buffer.length() > 0) {	            buffer.append('\n');	        }	        buffer.append("Exception Context:\n");	        int i = 0;	        for (final Pair<String, Object> pair : contextValues) {	            buffer.append("\t[");	            buffer.append(++i);	            buffer.append(':');	            buffer.append(pair.getKey());	            buffer.append("=");	            final Object value = pair.getValue();	            if (value == null) {	                buffer.append("null");	            } else {	                String valueStr;	                try {	                    valueStr = value.toString();	                } catch (final Exception e) {	                    valueStr = "Exception thrown on toString(): " + ExceptionUtils.getStackTrace(e);	                }	                buffer.append(valueStr);	            }	            buffer.append("]\n");	        }	        buffer.append("---------------------------------");	    }	    return buffer.toString();	}
public StringBuilder toStringBuilder() {	    return new StringBuilder(size).append(buffer, 0, size);	}
public static ConcurrentException extractCause(final ExecutionException ex) {	    if (ex == null || ex.getCause() == null) {	        return null;	    }	    throwCause(ex);	    return new ConcurrentException(ex.getMessage(), ex.getCause());	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
protected boolean isDefaultFullDetail() {	    return defaultFullDetail;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public static <T> T initialize(final ConcurrentInitializer<T> initializer) throws ConcurrentException {	    return initializer != null ? initializer.get() : null;	}
protected String getArraySeparator() {	    return arraySeparator;	}
public int capacity() {	    return buffer.length;	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public StrBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar) {	    return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);	}
public void add(final Number operand) {	    this.value += operand.longValue();	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public boolean contains(final StrMatcher matcher) {	    return indexOf(matcher, 0) >= 0;	}
public static float min(final float a, final float b, final float c) {	    return Math.min(Math.min(a, b), c);	}
public static int reflectionHashCode(final Object object, final String... excludeFields) {	    return reflectionHashCode(17, 37, object, false, null, excludeFields);	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public static <T> T CONST(final T v) {	    return v;	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public int capacity() {	    return buffer.length;	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public HashCodeBuilder append(final short[] array) {	    if (array == null) {	        iTotal = iTotal * iConstant;	    } else {	        for (final short element : array) {	            append(element);	        }	    }	    return this;	}
public void reset() {	    this.isEquals = true;	}
public static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes) {	    if ((src.length == 0 && srcPos == 0) || 0 == nBytes) {	        return dstInit;	    }	    if ((nBytes - 1) * 8 + dstPos >= 32) {	        throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 32");	    }	    int out = dstInit;	    int shift = 0;	    for (int i = 0; i < nBytes; i++) {	        shift = i * 8 + dstPos;	        final int bits = (0xff & src[i + srcPos]) << shift;	        final int mask = 0xff << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
@Override	public double doubleValue() {	    return (double) numerator / (double) denominator;	}
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {	    if (array == null) {	        if (index != 0) {	            throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0");	        }	        final Object joinedArray = Array.newInstance(clss, 1);	        Array.set(joinedArray, 0, element);	        return joinedArray;	    }	    final int length = Array.getLength(array);	    if (index > length || index < 0) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(clss, length + 1);	    System.arraycopy(array, 0, result, 0, index);	    Array.set(result, index, element);	    if (index < length) {	        System.arraycopy(array, index, result, index + 1, length - index);	    }	    return result;	}
public static String difference(final String str1, final String str2) {	    if (str1 == null) {	        return str2;	    }	    if (str2 == null) {	        return str1;	    }	    final int at = indexOfDifference(str1, str2);	    if (at == INDEX_NOT_FOUND) {	        return EMPTY;	    }	    return str2.substring(at);	}
@Override	public int compareTo(final MutableLong other) {	    final long anotherVal = other.value;	    return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1);	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
public StrBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar) {	    return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);	}
public static String formatDuration(long durationMillis, final String format, final boolean padWithZeros) {	    final Token[] tokens = lexx(format);	    int days = 0;	    int hours = 0;	    int minutes = 0;	    int seconds = 0;	    int milliseconds = 0;	    if (Token.containsTokenWithValue(tokens, d)) {	        days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY);	        durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY);	    }	    if (Token.containsTokenWithValue(tokens, H)) {	        hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR);	        durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR);	    }	    if (Token.containsTokenWithValue(tokens, m)) {	        minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE);	        durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE);	    }	    if (Token.containsTokenWithValue(tokens, s)) {	        seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND);	        durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND);	    }	    if (Token.containsTokenWithValue(tokens, S)) {	        milliseconds = (int) durationMillis;	    }	    return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
public StrBuilder appendAll(final Iterator<?> it) {	    if (it != null) {	        while (it.hasNext()) {	            append(it.next());	        }	    }	    return this;	}
public int size() {	    checkTokenized();	    return tokens.length;	}
public static String join(final Iterable<?> iterable, final String separator) {	    if (iterable == null) {	        return null;	    }	    return join(iterable.iterator(), separator);	}
public static String removeStart(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.startsWith(remove)) {	        return str.substring(remove.length());	    }	    return str;	}
public static List<Locale> languagesByCountry(final String countryCode) {	    if (countryCode == null) {	        return Collections.emptyList();	    }	    List<Locale> langs = cLanguagesByCountry.get(countryCode);	    if (langs == null) {	        langs = new ArrayList<Locale>();	        final List<Locale> locales = availableLocaleList();	        for (int i = 0; i < locales.size(); i++) {	            final Locale locale = locales.get(i);	            if (countryCode.equals(locale.getCountry()) && locale.getVariant().isEmpty()) {	                langs.add(locale);	            }	        }	        langs = Collections.unmodifiableList(langs);	        cLanguagesByCountry.putIfAbsent(countryCode, langs);	        langs = cLanguagesByCountry.get(countryCode);	    }	    return langs;	}
protected void setContentEnd(String contentEnd) {	    if (contentEnd == null) {	        contentEnd = "";	    }	    this.contentEnd = contentEnd;	}
protected String getArrayEnd() {	    return arrayEnd;	}
public static String abbreviate(final String str, int offset, final int maxWidth) {	    if (str == null) {	        return null;	    }	    if (maxWidth < 4) {	        throw new IllegalArgumentException("Minimum abbreviation width is 4");	    }	    if (str.length() <= maxWidth) {	        return str;	    }	    if (offset > str.length()) {	        offset = str.length();	    }	    if (str.length() - offset < maxWidth - 3) {	        offset = str.length() - (maxWidth - 3);	    }	    final String abrevMarker = "...";	    if (offset <= 4) {	        return str.substring(0, maxWidth - 3) + abrevMarker;	    }	    if (maxWidth < 7) {	        throw new IllegalArgumentException("Minimum abbreviation width with offset is 7");	    }	    if (offset + maxWidth - 3 < str.length()) {	        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);	    }	    return abrevMarker + str.substring(str.length() - (maxWidth - 3));	}
public int capacity() {	    return buffer.length;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static boolean containsIgnoreCase(final CharSequence str, final CharSequence searchStr) {	    if (str == null || searchStr == null) {	        return false;	    }	    final int len = searchStr.length();	    final int max = str.length() - len;	    for (int i = 0; i <= max; i++) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, len)) {	            return true;	        }	    }	    return false;	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {	    if (str == null || searchStr == null) {	        return INDEX_NOT_FOUND;	    }	    if (startPos > str.length() - searchStr.length()) {	        startPos = str.length() - searchStr.length();	    }	    if (startPos < 0) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return startPos;	    }	    for (int i = startPos; i >= 0; i--) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
public static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {	    if (str == null || searchStr == null) {	        return INDEX_NOT_FOUND;	    }	    if (startPos < 0) {	        startPos = 0;	    }	    final int endLimit = str.length() - searchStr.length() + 1;	    if (startPos > endLimit) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return startPos;	    }	    for (int i = startPos; i < endLimit; i++) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public boolean isEmpty() {	    return size == 0;	}
public String toString(final String format) {	    return String.format(format, getLeft(), getMiddle(), getRight());	}
public ReflectionToStringBuilder setExcludeFieldNames(final String... excludeFieldNamesParam) {	    if (excludeFieldNamesParam == null) {	        this.excludeFieldNames = null;	    } else {	        this.excludeFieldNames = toNoNullStringArray(excludeFieldNamesParam);	        Arrays.sort(this.excludeFieldNames);	    }	    return this;	}
public static Boolean[] nullToEmpty(final Boolean[] array) {	    if (array == null || array.length == 0) {	        return EMPTY_BOOLEAN_OBJECT_ARRAY;	    }	    return array;	}
public static String capitalizeFully(String str, final char... delimiters) {	    final int delimLen = delimiters == null ? -1 : delimiters.length;	    if (StringUtils.isEmpty(str) || delimLen == 0) {	        return str;	    }	    str = str.toLowerCase();	    return capitalize(str, delimiters);	}
@Override	public int nextIndex() {	    return tokenPos;	}
public static int indexOfDifference(final CharSequence... css) {	    if (css == null || css.length <= 1) {	        return INDEX_NOT_FOUND;	    }	    boolean anyStringNull = false;	    boolean allStringsNull = true;	    final int arrayLen = css.length;	    int shortestStrLen = Integer.MAX_VALUE;	    int longestStrLen = 0;	    for (int i = 0; i < arrayLen; i++) {	        if (css[i] == null) {	            anyStringNull = true;	            shortestStrLen = 0;	        } else {	            allStringsNull = false;	            shortestStrLen = Math.min(css[i].length(), shortestStrLen);	            longestStrLen = Math.max(css[i].length(), longestStrLen);	        }	    }	    if (allStringsNull || longestStrLen == 0 && !anyStringNull) {	        return INDEX_NOT_FOUND;	    }	    if (shortestStrLen == 0) {	        return 0;	    }	    int firstDiff = -1;	    for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {	        final char comparisonChar = css[0].charAt(stringPos);	        for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {	            if (css[arrayPos].charAt(stringPos) != comparisonChar) {	                firstDiff = stringPos;	                break;	            }	        }	        if (firstDiff != -1) {	            break;	        }	    }	    if (firstDiff == -1 && shortestStrLen != longestStrLen) {	        return shortestStrLen;	    }	    return firstDiff;	}
@Override	public void setFormat(final int formatElementIndex, final Format newFormat) {	    throw new UnsupportedOperationException();	}
@Deprecated	public static String chomp(final String str, final String separator) {	    return removeEnd(str, separator);	}
public static String difference(final String str1, final String str2) {	    if (str1 == null) {	        return str2;	    }	    if (str2 == null) {	        return str1;	    }	    final int at = indexOfDifference(str1, str2);	    if (at == INDEX_NOT_FOUND) {	        return EMPTY;	    }	    return str2.substring(at);	}
protected void setEquals(final boolean isEquals) {	    this.isEquals = isEquals;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public boolean isEquals() {	    return this.isEquals;	}
public static Class<?> getClass(final String className, final boolean initialize) throws ClassNotFoundException {	    final ClassLoader contextCL = Thread.currentThread().getContextClassLoader();	    final ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL;	    return getClass(loader, className, initialize);	}
public static <T extends Iterable<?>> T noNullElements(final T iterable) {	    return noNullElements(iterable, DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE);	}
public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale) {	    return cache.getInstance(pattern, timeZone, locale);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public StrTokenizer setIgnoredChar(final char ignored) {	    return setIgnoredMatcher(StrMatcher.charMatcher(ignored));	}
@Override	public Date parse(final String source, final ParsePosition pos) {	    final int offset = pos.getIndex();	    final Matcher matcher = parsePattern.matcher(source.substring(offset));	    if (!matcher.lookingAt()) {	        return null;	    }	    final Calendar cal = Calendar.getInstance(timeZone, locale);	    cal.clear();	    for (int i = 0; i < strategies.length; ) {	        final Strategy strategy = strategies[i++];	        strategy.setCalendar(this, cal, matcher.group(i));	    }	    pos.setIndex(offset + matcher.end());	    return cal.getTime();	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static NumericEntityEscaper between(final int codepointLow, final int codepointHigh) {	    return new NumericEntityEscaper(codepointLow, codepointHigh, true);	}
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException {	    return charsetName == null ? new String(bytes) : new String(bytes, charsetName);	}
public String getNullText() {	    return nullText;	}
public static String center(String str, final int size, String padStr) {	    if (str == null || size <= 0) {	        return str;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    str = leftPad(str, strLen + pads / 2, padStr);	    str = rightPad(str, size, padStr);	    return str;	}
public static String toString(final boolean bool, final String trueString, final String falseString) {	    return bool ? trueString : falseString;	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
protected boolean isFieldSeparatorAtEnd() {	    return fieldSeparatorAtEnd;	}
@Override	protected String toUtf16Escape(final int codepoint) {	    final char[] surrogatePair = Character.toChars(codepoint);	    return "\\u" + hex(surrogatePair[0]) + "\\u" + hex(surrogatePair[1]);	}
public boolean isEmpty() {	    return size == 0;	}
public String previousToken() {	    if (hasPrevious()) {	        return tokens[--tokenPos];	    }	    return null;	}
public static boolean isAllLowerCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLowerCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static boolean equalsIgnoreCase(final CharSequence str1, final CharSequence str2) {	    if (str1 == null || str2 == null) {	        return str1 == str2;	    } else if (str1 == str2) {	        return true;	    } else if (str1.length() != str2.length()) {	        return false;	    } else {	        return CharSequenceUtils.regionMatches(str1, true, 0, str2, 0, str1.length());	    }	}
public static String repeat(final char ch, final int repeat) {	    final char[] buf = new char[repeat];	    for (int i = repeat - 1; i >= 0; i--) {	        buf[i] = ch;	    }	    return new String(buf);	}
public static boolean isAsciiAlphanumeric(final char ch) {	    return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9');	}
public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) {	    if (toClass == null) {	        return false;	    }	    if (cls == null) {	        return !toClass.isPrimitive();	    }	    if (autoboxing) {	        if (cls.isPrimitive() && !toClass.isPrimitive()) {	            cls = primitiveToWrapper(cls);	            if (cls == null) {	                return false;	            }	        }	        if (toClass.isPrimitive() && !cls.isPrimitive()) {	            cls = wrapperToPrimitive(cls);	            if (cls == null) {	                return false;	            }	        }	    }	    if (cls.equals(toClass)) {	        return true;	    }	    if (cls.isPrimitive()) {	        if (toClass.isPrimitive() == false) {	            return false;	        }	        if (Integer.TYPE.equals(cls)) {	            return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Long.TYPE.equals(cls)) {	            return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Boolean.TYPE.equals(cls)) {	            return false;	        }	        if (Double.TYPE.equals(cls)) {	            return false;	        }	        if (Float.TYPE.equals(cls)) {	            return Double.TYPE.equals(toClass);	        }	        if (Character.TYPE.equals(cls)) {	            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Short.TYPE.equals(cls)) {	            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        if (Byte.TYPE.equals(cls)) {	            return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);	        }	        return false;	    }	    return toClass.isAssignableFrom(cls);	}
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {	    final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);	    return df.format(calendar);	}
public String getNullText() {	    return nullText;	}
public static String prependIfMissing(final String str, final CharSequence prefix, final CharSequence... prefixes) {	    return prependIfMissing(str, prefix, false, prefixes);	}
@Override	public T get() throws ConcurrentException {	    try {	        return getFuture().get();	    } catch (final ExecutionException execex) {	        ConcurrentUtils.handleCause(execex);	        return null;	    } catch (final InterruptedException iex) {	        Thread.currentThread().interrupt();	        throw new ConcurrentException(iex);	    }	}
@Override	public int read(final char[] b, final int off, int len) {	    if (off < 0 || len < 0 || off > b.length || (off + len) > b.length || (off + len) < 0) {	        throw new IndexOutOfBoundsException();	    }	    if (len == 0) {	        return 0;	    }	    if (pos >= StrBuilder.this.size()) {	        return -1;	    }	    if (pos + len > size()) {	        len = StrBuilder.this.size() - pos;	    }	    StrBuilder.this.getChars(pos, pos + len, b, off);	    pos += len;	    return len;	}
public static Number createNumber(final String str) throws NumberFormatException {	    if (str == null) {	        return null;	    }	    if (StringUtils.isBlank(str)) {	        throw new NumberFormatException("A blank string is not a valid number");	    }	    final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" };	    int pfxLen = 0;	    for (final String pfx : hex_prefixes) {	        if (str.startsWith(pfx)) {	            pfxLen += pfx.length();	            break;	        }	    }	    if (pfxLen > 0) {	        final int hexDigits = str.length() - pfxLen;	        if (hexDigits > 16) {	            return createBigInteger(str);	        }	        if (hexDigits > 8) {	            return createLong(str);	        }	        return createInteger(str);	    }	    final char lastChar = str.charAt(str.length() - 1);	    String mant;	    String dec;	    String exp;	    final int decPos = str.indexOf('.');	    final int expPos = str.indexOf('e') + str.indexOf('E') + 1;	    int numDecimals = 0;	    if (decPos > -1) {	        if (expPos > -1) {	            if (expPos < decPos || expPos > str.length()) {	                throw new NumberFormatException(str + " is not a valid number.");	            }	            dec = str.substring(decPos + 1, expPos);	        } else {	            dec = str.substring(decPos + 1);	        }	        mant = str.substring(0, decPos);	        numDecimals = dec.length();	    } else {	        if (expPos > -1) {	            if (expPos > str.length()) {	                throw new NumberFormatException(str + " is not a valid number.");	            }	            mant = str.substring(0, expPos);	        } else {	            mant = str;	        }	        dec = null;	    }	    if (!Character.isDigit(lastChar) && lastChar != '.') {	        if (expPos > -1 && expPos < str.length() - 1) {	            exp = str.substring(expPos + 1, str.length() - 1);	        } else {	            exp = null;	        }	        final String numeric = str.substring(0, str.length() - 1);	        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);	        switch(lastChar) {	            case 'l':	            case 'L':	                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {	                    try {	                        return createLong(numeric);	                    } catch (final NumberFormatException nfe) {	                    }	                    return createBigInteger(numeric);	                }	                throw new NumberFormatException(str + " is not a valid number.");	            case 'f':	            case 'F':	                try {	                    final Float f = NumberUtils.createFloat(numeric);	                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {	                        return f;	                    }	                } catch (final NumberFormatException nfe) {	                }	            case 'd':	            case 'D':	                try {	                    final Double d = NumberUtils.createDouble(numeric);	                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {	                        return d;	                    }	                } catch (final NumberFormatException nfe) {	                }	                try {	                    return createBigDecimal(numeric);	                } catch (final NumberFormatException e) {	                }	            default:	                throw new NumberFormatException(str + " is not a valid number.");	        }	    }	    if (expPos > -1 && expPos < str.length() - 1) {	        exp = str.substring(expPos + 1, str.length());	    } else {	        exp = null;	    }	    if (dec == null && exp == null) {	        try {	            return createInteger(str);	        } catch (final NumberFormatException nfe) {	        }	        try {	            return createLong(str);	        } catch (final NumberFormatException nfe) {	        }	        return createBigInteger(str);	    }	    final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);	    try {	        if (numDecimals <= 7) {	            final Float f = createFloat(str);	            if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {	                return f;	            }	        }	    } catch (final NumberFormatException nfe) {	    }	    try {	        if (numDecimals <= 16) {	            final Double d = createDouble(str);	            if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {	                return d;	            }	        }	    } catch (final NumberFormatException nfe) {	    }	    return createBigDecimal(str);	}
public static <L, R> MutablePair<L, R> of(final L left, final R right) {	    return new MutablePair<L, R>(left, right);	}
public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) {	    final Token[] tokens = lexx(format);	    final Calendar start = Calendar.getInstance(timezone);	    start.setTime(new Date(startMillis));	    final Calendar end = Calendar.getInstance(timezone);	    end.setTime(new Date(endMillis));	    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);	    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);	    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);	    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);	    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);	    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);	    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);	    while (milliseconds < 0) {	        milliseconds += 1000;	        seconds -= 1;	    }	    while (seconds < 0) {	        seconds += 60;	        minutes -= 1;	    }	    while (minutes < 0) {	        minutes += 60;	        hours -= 1;	    }	    while (hours < 0) {	        hours += 24;	        days -= 1;	    }	    if (Token.containsTokenWithValue(tokens, M)) {	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	        while (months < 0) {	            months += 12;	            years -= 1;	        }	        if (!Token.containsTokenWithValue(tokens, y) && years != 0) {	            while (years != 0) {	                months += 12 * years;	                years = 0;	            }	        }	    } else {	        if (!Token.containsTokenWithValue(tokens, y)) {	            int target = end.get(Calendar.YEAR);	            if (months < 0) {	                target -= 1;	            }	            while (start.get(Calendar.YEAR) != target) {	                days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);	                if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) {	                    days += 1;	                }	                start.add(Calendar.YEAR, 1);	                days += start.get(Calendar.DAY_OF_YEAR);	            }	            years = 0;	        }	        while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            start.add(Calendar.MONTH, 1);	        }	        months = 0;	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	    }	    if (!Token.containsTokenWithValue(tokens, d)) {	        hours += 24 * days;	        days = 0;	    }	    if (!Token.containsTokenWithValue(tokens, H)) {	        minutes += 60 * hours;	        hours = 0;	    }	    if (!Token.containsTokenWithValue(tokens, m)) {	        seconds += 60 * minutes;	        minutes = 0;	    }	    if (!Token.containsTokenWithValue(tokens, s)) {	        milliseconds += 1000 * seconds;	        seconds = 0;	    }	    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width, final int precision, final char padChar, final CharSequence ellipsis) {	    Validate.isTrue(ellipsis == null || precision < 0 || ellipsis.length() <= precision, "Specified ellipsis '%1$s' exceeds precision of %2$s", ellipsis, Integer.valueOf(precision));	    final StringBuilder buf = new StringBuilder(seq);	    if (precision >= 0 && precision < seq.length()) {	        final CharSequence _ellipsis = ObjectUtils.defaultIfNull(ellipsis, StringUtils.EMPTY);	        buf.replace(precision - _ellipsis.length(), seq.length(), _ellipsis.toString());	    }	    final boolean leftJustify = (flags & LEFT_JUSTIFY) == LEFT_JUSTIFY;	    for (int i = buf.length(); i < width; i++) {	        buf.insert(leftJustify ? i : 0, padChar);	    }	    formatter.format(buf.toString());	    return formatter;	}
public HashCodeBuilder append(final short[] array) {	    if (array == null) {	        iTotal = iTotal * iConstant;	    } else {	        for (final short element : array) {	            append(element);	        }	    }	    return this;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public void suspend() {	    if (this.runningState != STATE_RUNNING) {	        throw new IllegalStateException("Stopwatch must be running to suspend. ");	    }	    this.stopTime = System.nanoTime();	    this.runningState = STATE_SUSPENDED;	}
public byte setByte(final byte holder) {	    return (byte) set(holder);	}
protected boolean isUseFieldNames() {	    return useFieldNames;	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
public String getNewLineText() {	    return newLine;	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale) {	    return cache.getTimeInstance(style, timeZone, locale);	}
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) {	    if (lhs == rhs) {	        return true;	    }	    if (lhs == null || rhs == null) {	        return false;	    }	    final Class<?> lhsClass = lhs.getClass();	    final Class<?> rhsClass = rhs.getClass();	    Class<?> testClass;	    if (lhsClass.isInstance(rhs)) {	        testClass = lhsClass;	        if (!rhsClass.isInstance(lhs)) {	            testClass = rhsClass;	        }	    } else if (rhsClass.isInstance(lhs)) {	        testClass = rhsClass;	        if (!lhsClass.isInstance(rhs)) {	            testClass = lhsClass;	        }	    } else {	        return false;	    }	    final EqualsBuilder equalsBuilder = new EqualsBuilder();	    try {	        reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {	            testClass = testClass.getSuperclass();	            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);	        }	    } catch (final IllegalArgumentException e) {	        return false;	    }	    return equalsBuilder.isEquals();	}
public static <T> T clone(final T obj) {	    if (obj instanceof Cloneable) {	        final Object result;	        if (obj.getClass().isArray()) {	            final Class<?> componentType = obj.getClass().getComponentType();	            if (!componentType.isPrimitive()) {	                result = ((Object[]) obj).clone();	            } else {	                int length = Array.getLength(obj);	                result = Array.newInstance(componentType, length);	                while (length-- > 0) {	                    Array.set(result, length, Array.get(obj, length));	                }	            }	        } else {	            try {	                final Method clone = obj.getClass().getMethod("clone");	                result = clone.invoke(obj);	            } catch (final NoSuchMethodException e) {	                throw new CloneFailedException("Cloneable type " + obj.getClass().getName() + " has no clone method", e);	            } catch (final IllegalAccessException e) {	                throw new CloneFailedException("Cannot clone Cloneable type " + obj.getClass().getName(), e);	            } catch (final InvocationTargetException e) {	                throw new CloneFailedException("Exception cloning Cloneable type " + obj.getClass().getName(), e.getCause());	            }	        }	        @SuppressWarnings("unchecked")	        final T checked = (T) result;	        return checked;	    }	    return null;	}
public Class<?> getUpToClass() {	    return this.upToClass;	}
public static StrTokenizer getCSVInstance(final char[] input) {	    final StrTokenizer tok = getCSVClone();	    tok.reset(input);	    return tok;	}
public static String remove(final String str, final char remove) {	    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {	        return str;	    }	    final char[] chars = str.toCharArray();	    int pos = 0;	    for (int i = 0; i < chars.length; i++) {	        if (chars[i] != remove) {	            chars[pos++] = chars[i];	        }	    }	    return new String(chars, 0, pos);	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public HashCodeBuilder append(final short[] array) {	    if (array == null) {	        iTotal = iTotal * iConstant;	    } else {	        for (final short element : array) {	            append(element);	        }	    }	    return this;	}
public boolean isEquals() {	    return this.isEquals;	}
public static boolean isInstance(final Object value, final Type type) {	    if (type == null) {	        return false;	    }	    return value == null ? !(type instanceof Class<?>) || !((Class<?>) type).isPrimitive() : isAssignable(value.getClass(), type, null);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public StrBuilder replaceAll(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, -1);	}
public static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools) {	    if ((src.length == 0 && srcPos == 0) || 0 == nBools) {	        return dstInit;	    }	    if (nBools - 1 + dstPos >= 16) {	        throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 16");	    }	    short out = dstInit;	    int shift = 0;	    for (int i = 0; i < nBools; i++) {	        shift = i * 1 + dstPos;	        final int bits = (src[i + srcPos] ? 1 : 0) << shift;	        final int mask = 0x1 << shift;	        out = (short) ((out & ~mask) | bits);	    }	    return out;	}
public static String rightPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return rightPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return str.concat(padStr);	    } else if (pads < padLen) {	        return str.concat(padStr.substring(0, pads));	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return str.concat(new String(padding));	    }	}
int getCount() {	    return count;	}
@Override	public boolean equals(final Object obj) {	    if (obj == this) {	        return true;	    } else if (obj == null || obj.getClass() != getClass()) {	        return false;	    } else {	        @SuppressWarnings("unchecked")	        final Range<T> range = (Range<T>) obj;	        return minimum.equals(range.minimum) && maximum.equals(range.maximum);	    }	}
public static void writeDeclaredField(final Object target, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException {	    if (target == null) {	        throw new IllegalArgumentException("target object must not be null");	    }	    final Class<?> cls = target.getClass();	    final Field field = getDeclaredField(cls, fieldName, forceAccess);	    if (field == null) {	        throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName);	    }	    writeField(field, target, value);	}
public static String capitalize(final String str) {	    int strLen;	    if (str == null || (strLen = str.length()) == 0) {	        return str;	    }	    char firstChar = str.charAt(0);	    if (Character.isTitleCase(firstChar)) {	        return str;	    }	    return new StringBuilder(strLen).append(Character.toTitleCase(firstChar)).append(str.substring(1)).toString();	}
public static boolean[] hexDigitToBinary(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return new boolean[] { false, false, false, false };	        case '1':	            return new boolean[] { true, false, false, false };	        case '2':	            return new boolean[] { false, true, false, false };	        case '3':	            return new boolean[] { true, true, false, false };	        case '4':	            return new boolean[] { false, false, true, false };	        case '5':	            return new boolean[] { true, false, true, false };	        case '6':	            return new boolean[] { false, true, true, false };	        case '7':	            return new boolean[] { true, true, true, false };	        case '8':	            return new boolean[] { false, false, false, true };	        case '9':	            return new boolean[] { true, false, false, true };	        case 'a':	        case 'A':	            return new boolean[] { false, true, false, true };	        case 'b':	        case 'B':	            return new boolean[] { true, true, false, true };	        case 'c':	        case 'C':	            return new boolean[] { false, false, true, true };	        case 'd':	        case 'D':	            return new boolean[] { true, false, true, true };	        case 'e':	        case 'E':	            return new boolean[] { false, true, true, true };	        case 'f':	        case 'F':	            return new boolean[] { true, true, true, true };	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public static boolean isWhitespace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isWhitespace(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public int capacity() {	    return buffer.length;	}
public static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts) {	    if ((src.length == 0 && srcPos == 0) || 0 == nShorts) {	        return dstInit;	    }	    if ((nShorts - 1) * 16 + dstPos >= 64) {	        throw new IllegalArgumentException("(nShorts-1)*16+dstPos is greather or equal to than 64");	    }	    long out = dstInit;	    int shift = 0;	    for (int i = 0; i < nShorts; i++) {	        shift = i * 16 + dstPos;	        final long bits = (0xffffL & src[i + srcPos]) << shift;	        final long mask = 0xffffL << shift;	        out = (out & ~mask) | bits;	    }	    return out;	}
public static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    final int beSrcPos = src.length - 1 - srcPos;	    final int srcLen = Math.min(4, beSrcPos + 1);	    final boolean[] paddedSrc = new boolean[4];	    System.arraycopy(src, beSrcPos + 1 - srcLen, paddedSrc, 4 - srcLen, srcLen);	    src = paddedSrc;	    srcPos = 0;	    if (src[srcPos]) {	        if (src.length > srcPos + 1 && src[srcPos + 1]) {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 1 && src[srcPos + 1]) {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 2 && src[srcPos + 2]) {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src.length > srcPos + 3 && src[srcPos + 3]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public boolean isEmptyTokenAsNull() {	    return this.emptyAsNull;	}
public boolean contains(final StrMatcher matcher) {	    return indexOf(matcher, 0) >= 0;	}
protected String getArraySeparator() {	    return arraySeparator;	}
public static int hexDigitMsb0ToInt(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return 0x0;	        case '1':	            return 0x8;	        case '2':	            return 0x4;	        case '3':	            return 0xC;	        case '4':	            return 0x2;	        case '5':	            return 0xA;	        case '6':	            return 0x6;	        case '7':	            return 0xE;	        case '8':	            return 0x1;	        case '9':	            return 0x9;	        case 'a':	        case 'A':	            return 0x5;	        case 'b':	        case 'B':	            return 0xD;	        case 'c':	        case 'C':	            return 0x3;	        case 'd':	        case 'D':	            return 0xB;	        case 'e':	        case 'E':	            return 0x7;	        case 'f':	        case 'F':	            return 0xF;	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public char[] toCharArray(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len == 0) {	        return ArrayUtils.EMPTY_CHAR_ARRAY;	    }	    final char[] chars = new char[len];	    System.arraycopy(buffer, startIndex, chars, 0, len);	    return chars;	}
public static <T> EventListenerSupport<T> create(final Class<T> listenerInterface) {	    return new EventListenerSupport<T>(listenerInterface);	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
public static boolean isNumber(final String str) {	    if (StringUtils.isEmpty(str)) {	        return false;	    }	    final char[] chars = str.toCharArray();	    int sz = chars.length;	    boolean hasExp = false;	    boolean hasDecPoint = false;	    boolean allowSigns = false;	    boolean foundDigit = false;	    final int start = (chars[0] == '-') ? 1 : 0;	    if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') {	        int i = start + 2;	        if (i == sz) {	            return false;	        }	        for (; i < chars.length; i++) {	            if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) {	                return false;	            }	        }	        return true;	    }	    sz--;	    int i = start;	    while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {	        if (chars[i] >= '0' && chars[i] <= '9') {	            foundDigit = true;	            allowSigns = false;	        } else if (chars[i] == '.') {	            if (hasDecPoint || hasExp) {	                return false;	            }	            hasDecPoint = true;	        } else if (chars[i] == 'e' || chars[i] == 'E') {	            if (hasExp) {	                return false;	            }	            if (!foundDigit) {	                return false;	            }	            hasExp = true;	            allowSigns = true;	        } else if (chars[i] == '+' || chars[i] == '-') {	            if (!allowSigns) {	                return false;	            }	            allowSigns = false;	            foundDigit = false;	        } else {	            return false;	        }	        i++;	    }	    if (i < chars.length) {	        if (chars[i] >= '0' && chars[i] <= '9') {	            return true;	        }	        if (chars[i] == 'e' || chars[i] == 'E') {	            return false;	        }	        if (chars[i] == '.') {	            if (hasDecPoint || hasExp) {	                return false;	            }	            return foundDigit;	        }	        if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) {	            return foundDigit;	        }	        if (chars[i] == 'l' || chars[i] == 'L') {	            return foundDigit && !hasExp && !hasDecPoint;	        }	        return false;	    }	    return !allowSigns && foundDigit;	}
public static String removeEnd(final String str, final String remove) {	    if (isEmpty(str) || isEmpty(remove)) {	        return str;	    }	    if (str.endsWith(remove)) {	        return str.substring(0, str.length() - remove.length());	    }	    return str;	}
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {	    if (array == null) {	        if (index != 0) {	            throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0");	        }	        final Object joinedArray = Array.newInstance(clss, 1);	        Array.set(joinedArray, 0, element);	        return joinedArray;	    }	    final int length = Array.getLength(array);	    if (index > length || index < 0) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(clss, length + 1);	    System.arraycopy(array, 0, result, 0, index);	    Array.set(result, index, element);	    if (index < length) {	        System.arraycopy(array, index, result, index + 1, length - index);	    }	    return result;	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale) {	    return cache.getTimeInstance(style, timeZone, locale);	}
public boolean isNaturalOrdering() {	    return comparator == ComparableComparator.INSTANCE;	}
public boolean isIgnoreEmptyTokens() {	    return ignoreEmptyTokens;	}
public static String[] substringsBetween(final String str, final String open, final String close) {	    if (str == null || isEmpty(open) || isEmpty(close)) {	        return null;	    }	    final int strLen = str.length();	    if (strLen == 0) {	        return ArrayUtils.EMPTY_STRING_ARRAY;	    }	    final int closeLen = close.length();	    final int openLen = open.length();	    final List<String> list = new ArrayList<String>();	    int pos = 0;	    while (pos < strLen - closeLen) {	        int start = str.indexOf(open, pos);	        if (start < 0) {	            break;	        }	        start += openLen;	        final int end = str.indexOf(close, start);	        if (end < 0) {	            break;	        }	        list.add(str.substring(start, end));	        pos = end + closeLen;	    }	    if (list.isEmpty()) {	        return null;	    }	    return list.toArray(new String[list.size()]);	}
@Override	public int length() {	    return size;	}
@Override	public String next() {	    if (hasNext()) {	        return tokens[tokenPos++];	    }	    throw new NoSuchElementException();	}
public StrBuilder deleteCharAt(final int index) {	    if (index < 0 || index >= size) {	        throw new StringIndexOutOfBoundsException(index);	    }	    deleteImpl(index, index + 1, 1);	    return this;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static String formatUTC(final Date date, final String pattern, final Locale locale) {	    return format(date, pattern, UTC_TIME_ZONE, locale);	}
public String replace(final Object source) {	    if (source == null) {	        return null;	    }	    final StrBuilder buf = new StrBuilder().append(source);	    substitute(buf, 0, buf.length());	    return buf.toString();	}
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return new boolean[] { false, false, false, false };	        case '1':	            return new boolean[] { false, false, false, true };	        case '2':	            return new boolean[] { false, false, true, false };	        case '3':	            return new boolean[] { false, false, true, true };	        case '4':	            return new boolean[] { false, true, false, false };	        case '5':	            return new boolean[] { false, true, false, true };	        case '6':	            return new boolean[] { false, true, true, false };	        case '7':	            return new boolean[] { false, true, true, true };	        case '8':	            return new boolean[] { true, false, false, false };	        case '9':	            return new boolean[] { true, false, false, true };	        case 'a':	        case 'A':	            return new boolean[] { true, false, true, false };	        case 'b':	        case 'B':	            return new boolean[] { true, false, true, true };	        case 'c':	        case 'C':	            return new boolean[] { true, true, false, false };	        case 'd':	        case 'D':	            return new boolean[] { true, true, false, true };	        case 'e':	        case 'E':	            return new boolean[] { true, true, true, false };	        case 'f':	        case 'F':	            return new boolean[] { true, true, true, true };	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public static float max(final float a, final float b, final float c) {	    return Math.max(Math.max(a, b), c);	}
public static String toString(final Object obj, final String nullStr) {	    return obj == null ? nullStr : obj.toString();	}
@Override	public T get(final long timeout, final TimeUnit unit) {	    return value;	}
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = Integer.MAX_VALUE;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.indexOf(str, search, 0);	        if (tmp == INDEX_NOT_FOUND) {	            continue;	        }	        if (tmp < ret) {	            ret = tmp;	        }	    }	    return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;	}
@Override	public int length() {	    return size;	}
public static <T> Range<T> is(final T element, final Comparator<T> comparator) {	    return between(element, element, comparator);	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public void add(final Number operand) {	    this.value += operand.doubleValue();	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public StrTokenizer setEmptyTokenAsNull(final boolean emptyAsNull) {	    this.emptyAsNull = emptyAsNull;	    return this;	}
public static <T> T mode(final T... items) {	    if (ArrayUtils.isNotEmpty(items)) {	        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(items.length);	        for (final T t : items) {	            final MutableInt count = occurrences.get(t);	            if (count == null) {	                occurrences.put(t, new MutableInt(1));	            } else {	                count.increment();	            }	        }	        T result = null;	        int max = 0;	        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {	            final int cmp = e.getValue().intValue();	            if (cmp == max) {	                result = null;	            } else if (cmp > max) {	                max = cmp;	                result = e.getKey();	            }	        }	        return result;	    }	    return null;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
@Override	public int hashCode() {	    return toHashCode();	}
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = Integer.MAX_VALUE;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.indexOf(str, search, 0);	        if (tmp == INDEX_NOT_FOUND) {	            continue;	        }	        if (tmp < ret) {	            ret = tmp;	        }	    }	    return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;	}
@Override	public int length() {	    return size;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public int capacity() {	    return buffer.length;	}
public static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) {	    if (0 == nHexs) {	        return dstInit;	    }	    if ((nHexs - 1) * 4 + srcPos >= 8) {	        throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 8");	    }	    final StringBuilder sb = new StringBuilder(dstInit);	    int shift = 0;	    int append = sb.length();	    for (int i = 0; i < nHexs; i++) {	        shift = i * 4 + srcPos;	        final int bits = 0xF & (src >> shift);	        if (dstPos + i == append) {	            ++append;	            sb.append(intToHexDigit(bits));	        } else {	            sb.setCharAt(dstPos + i, intToHexDigit(bits));	        }	    }	    return sb.toString();	}
public static String replaceEachRepeatedly(final String text, final String[] searchList, final String[] replacementList) {	    final int timeToLive = searchList == null ? 0 : searchList.length;	    return replaceEach(text, searchList, replacementList, true, timeToLive);	}
public static String substringAfter(final String str, final String separator) {	    if (isEmpty(str)) {	        return str;	    }	    if (separator == null) {	        return EMPTY;	    }	    final int pos = str.indexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return EMPTY;	    }	    return str.substring(pos + separator.length());	}
public boolean isAppendTransients() {	    return this.appendTransients;	}
public boolean isEmptyTokenAsNull() {	    return this.emptyAsNull;	}
public static CharRange isNotIn(final char start, final char end) {	    return new CharRange(start, end, true);	}
@Override	public TimeZone getTimeZone() {	    return printer.getTimeZone();	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public int size() {	    return size;	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
protected String getSizeEndText() {	    return sizeEndText;	}
public static int reflectionHashCode(final Object object, final String... excludeFields) {	    return reflectionHashCode(17, 37, object, false, null, excludeFields);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static <L, R> ImmutablePair<L, R> of(final L left, final R right) {	    return new ImmutablePair<L, R>(left, right);	}
@Override	public int length() {	    return size;	}
public static boolean isNotEmpty(final boolean[] array) {	    return (array != null && array.length != 0);	}
public StrTokenizer setQuoteChar(final char quote) {	    return setQuoteMatcher(StrMatcher.charMatcher(quote));	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public static Boolean negate(final Boolean bool) {	    if (bool == null) {	        return null;	    }	    return bool.booleanValue() ? Boolean.FALSE : Boolean.TRUE;	}
static List<String> getStackFrameList(final Throwable t) {	    final String stackTrace = getStackTrace(t);	    final String linebreak = SystemUtils.LINE_SEPARATOR;	    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);	    final List<String> list = new ArrayList<String>();	    boolean traceStarted = false;	    while (frames.hasMoreTokens()) {	        final String token = frames.nextToken();	        final int at = token.indexOf("at");	        if (at != -1 && token.substring(0, at).trim().isEmpty()) {	            traceStarted = true;	            list.add(token);	        } else if (traceStarted) {	            break;	        }	    }	    return list;	}
public synchronized int getAcquireCount() {	    return acquireCount;	}
public boolean isEmptyTokenAsNull() {	    return this.emptyAsNull;	}
public static String rightPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return rightPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return str.concat(padStr);	    } else if (pads < padLen) {	        return str.concat(padStr.substring(0, pads));	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return str.concat(new String(padding));	    }	}
public static final String escapeXml(final String input) {	    return ESCAPE_XML.translate(input);	}
protected void appendFieldSeparator(final StringBuffer buffer) {	    buffer.append(fieldSeparator);	}
public static Object invokeMethod(final Object object, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {	    if (parameterTypes == null) {	        parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;	    }	    if (args == null) {	        args = ArrayUtils.EMPTY_OBJECT_ARRAY;	    }	    final Method method = getMatchingAccessibleMethod(object.getClass(), methodName, parameterTypes);	    if (method == null) {	        throw new NoSuchMethodException("No such accessible method: " + methodName + "() on object: " + object.getClass().getName());	    }	    return method.invoke(object, args);	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) {	    if (0 == nHexs) {	        return dstInit;	    }	    if ((nHexs - 1) * 4 + srcPos >= 32) {	        throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 32");	    }	    final StringBuilder sb = new StringBuilder(dstInit);	    int shift = 0;	    int append = sb.length();	    for (int i = 0; i < nHexs; i++) {	        shift = i * 4 + srcPos;	        final int bits = 0xF & (src >> shift);	        if (dstPos + i == append) {	            ++append;	            sb.append(intToHexDigit(bits));	        } else {	            sb.setCharAt(dstPos + i, intToHexDigit(bits));	        }	    }	    return sb.toString();	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public static boolean containsOnly(final CharSequence cs, final String validChars) {	    if (cs == null || validChars == null) {	        return false;	    }	    return containsOnly(cs, validChars.toCharArray());	}
public static boolean isAllLowerCase(final CharSequence cs) {	    if (cs == null || isEmpty(cs)) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isLowerCase(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static Boolean or(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
@Override	public String toString() {	    if (this.getObject() == null) {	        return this.getStyle().getNullText();	    }	    Class<?> clazz = this.getObject().getClass();	    this.appendFieldsIn(clazz);	    while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {	        clazz = clazz.getSuperclass();	        this.appendFieldsIn(clazz);	    }	    return super.toString();	}
public static String toString(final Formattable formattable) {	    return String.format(SIMPLEST_FORMAT, formattable);	}
public StrTokenizer setIgnoredChar(final char ignored) {	    return setIgnoredMatcher(StrMatcher.charMatcher(ignored));	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static char binaryToHexDigit(final boolean[] src, final int srcPos) {	    if (src.length == 0) {	        throw new IllegalArgumentException("Cannot convert an empty array.");	    }	    if (src.length > srcPos + 3 && src[srcPos + 3]) {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return 'e';	                }	            } else {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return 'c';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return 'a';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '8';	                }	            }	        }	    } else {	        if (src.length > srcPos + 2 && src[srcPos + 2]) {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '7';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return '5';	                } else {	                    return '4';	                }	            }	        } else {	            if (src.length > srcPos + 1 && src[srcPos + 1]) {	                if (src[srcPos]) {	                    return '3';	                } else {	                    return '2';	                }	            } else {	                if (src[srcPos]) {	                    return '1';	                } else {	                    return '0';	                }	            }	        }	    }	}
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {	    if (array == null) {	        if (index != 0) {	            throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0");	        }	        final Object joinedArray = Array.newInstance(clss, 1);	        Array.set(joinedArray, 0, element);	        return joinedArray;	    }	    final int length = Array.getLength(array);	    if (index > length || index < 0) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(clss, length + 1);	    System.arraycopy(array, 0, result, 0, index);	    Array.set(result, index, element);	    if (index < length) {	        System.arraycopy(array, index, result, index + 1, length - index);	    }	    return result;	}
protected String getArrayEnd() {	    return arrayEnd;	}
protected boolean isFieldSeparatorAtEnd() {	    return fieldSeparatorAtEnd;	}
@Override	public Date parse(final String source, final ParsePosition pos) {	    final int offset = pos.getIndex();	    final Matcher matcher = parsePattern.matcher(source.substring(offset));	    if (!matcher.lookingAt()) {	        return null;	    }	    final Calendar cal = Calendar.getInstance(timeZone, locale);	    cal.clear();	    for (int i = 0; i < strategies.length; ) {	        final Strategy strategy = strategies[i++];	        strategy.setCalendar(this, cal, matcher.group(i));	    }	    pos.setIndex(offset + matcher.end());	    return cal.getTime();	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
public static String lowerCase(final String str, final Locale locale) {	    if (str == null) {	        return null;	    }	    return str.toLowerCase(locale);	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public int capacity() {	    return buffer.length;	}
public long getPeriod() {	    return period;	}
public String getNullText() {	    return nullText;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {	    appendFieldStart(buffer, fieldName);	    if (array == null) {	        appendNullText(buffer, fieldName);	    } else if (isFullDetail(fullDetail)) {	        appendDetail(buffer, fieldName, array);	    } else {	        appendSummary(buffer, fieldName, array);	    }	    appendFieldEnd(buffer, fieldName);	}
@Override	public String toString() {	    return new String(buffer, 0, size);	}
public int getDenominator() {	    return denominator;	}
@Override	public int translate(final CharSequence input, final int index, final Writer out) throws IOException {	    final int seqEnd = input.length();	    if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') {	        int start = index + 2;	        boolean isHex = false;	        final char firstChar = input.charAt(start);	        if (firstChar == 'x' || firstChar == 'X') {	            start++;	            isHex = true;	            if (start == seqEnd) {	                return 0;	            }	        }	        int end = start;	        while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) {	            end++;	        }	        final boolean semiNext = end != seqEnd && input.charAt(end) == ';';	        if (!semiNext) {	            if (isSet(OPTION.semiColonRequired)) {	                return 0;	            } else if (isSet(OPTION.errorIfNoSemiColon)) {	                throw new IllegalArgumentException("Semi-colon required at end of numeric entity");	            }	        }	        int entityValue;	        try {	            if (isHex) {	                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);	            } else {	                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);	            }	        } catch (final NumberFormatException nfe) {	            return 0;	        }	        if (entityValue > 0xFFFF) {	            final char[] chrs = Character.toChars(entityValue);	            out.write(chrs[0]);	            out.write(chrs[1]);	        } else {	            out.write(entityValue);	        }	        return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0);	    }	    return 0;	}
public static final String unescapeHtml3(final String input) {	    return UNESCAPE_HTML3.translate(input);	}
protected String getContentStart() {	    return contentStart;	}
protected String getSizeEndText() {	    return sizeEndText;	}
protected int getTaskCount() {	    return 1;	}
public String getNewLineText() {	    return newLine;	}
@Override	public String previous() {	    if (hasPrevious()) {	        return tokens[--tokenPos];	    }	    throw new NoSuchElementException();	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
@Override	public String toString() {	    return "FastDateFormat[" + printer.getPattern() + "," + printer.getLocale() + "," + printer.getTimeZone().getID() + "]";	}
public String getNullText() {	    return nullText;	}
public boolean isEmpty() {	    return size == 0;	}
public static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools) {	    if ((src.length == 0 && srcPos == 0) || 0 == nBools) {	        return dstInit;	    }	    if (nBools - 1 + dstPos >= 8) {	        throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 8");	    }	    byte out = dstInit;	    int shift = 0;	    for (int i = 0; i < nBools; i++) {	        shift = i * 1 + dstPos;	        final int bits = (src[i + srcPos] ? 1 : 0) << shift;	        final int mask = 0x1 << shift;	        out = (byte) ((out & ~mask) | bits);	    }	    return out;	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public static String formatDuration(long durationMillis, final String format, final boolean padWithZeros) {	    final Token[] tokens = lexx(format);	    int days = 0;	    int hours = 0;	    int minutes = 0;	    int seconds = 0;	    int milliseconds = 0;	    if (Token.containsTokenWithValue(tokens, d)) {	        days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY);	        durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY);	    }	    if (Token.containsTokenWithValue(tokens, H)) {	        hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR);	        durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR);	    }	    if (Token.containsTokenWithValue(tokens, m)) {	        minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE);	        durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE);	    }	    if (Token.containsTokenWithValue(tokens, s)) {	        seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND);	        durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND);	    }	    if (Token.containsTokenWithValue(tokens, S)) {	        milliseconds = (int) durationMillis;	    }	    return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
public static String formatDuration(long durationMillis, final String format, final boolean padWithZeros) {	    final Token[] tokens = lexx(format);	    int days = 0;	    int hours = 0;	    int minutes = 0;	    int seconds = 0;	    int milliseconds = 0;	    if (Token.containsTokenWithValue(tokens, d)) {	        days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY);	        durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY);	    }	    if (Token.containsTokenWithValue(tokens, H)) {	        hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR);	        durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR);	    }	    if (Token.containsTokenWithValue(tokens, m)) {	        minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE);	        durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE);	    }	    if (Token.containsTokenWithValue(tokens, s)) {	        seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND);	        durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND);	    }	    if (Token.containsTokenWithValue(tokens, S)) {	        milliseconds = (int) durationMillis;	    }	    return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
public static String leftPad(final String str, final int size, String padStr) {	    if (str == null) {	        return null;	    }	    if (isEmpty(padStr)) {	        padStr = SPACE;	    }	    final int padLen = padStr.length();	    final int strLen = str.length();	    final int pads = size - strLen;	    if (pads <= 0) {	        return str;	    }	    if (padLen == 1 && pads <= PAD_LIMIT) {	        return leftPad(str, size, padStr.charAt(0));	    }	    if (pads == padLen) {	        return padStr.concat(str);	    } else if (pads < padLen) {	        return padStr.substring(0, pads).concat(str);	    } else {	        final char[] padding = new char[pads];	        final char[] padChars = padStr.toCharArray();	        for (int i = 0; i < pads; i++) {	            padding[i] = padChars[i % padLen];	        }	        return new String(padding).concat(str);	    }	}
public String[] getExcludeFieldNames() {	    return this.excludeFieldNames.clone();	}
protected boolean isArrayContentDetail() {	    return arrayContentDetail;	}
protected boolean isUseShortClassName() {	    return useShortClassName;	}
public static String defaultString(final String str, final String defaultStr) {	    return str == null ? defaultStr : str;	}
public StrBuilder reverse() {	    if (size == 0) {	        return this;	    }	    final int half = size / 2;	    final char[] buf = buffer;	    for (int leftIdx = 0, rightIdx = size - 1; leftIdx < half; leftIdx++, rightIdx--) {	        final char swap = buf[leftIdx];	        buf[leftIdx] = buf[rightIdx];	        buf[rightIdx] = swap;	    }	    return this;	}
public StrBuilder deleteAll(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, -1);	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public int capacity() {	    return buffer.length;	}
public int capacity() {	    return buffer.length;	}
public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {	    if (str == null || searchStr == null) {	        return INDEX_NOT_FOUND;	    }	    if (startPos > str.length() - searchStr.length()) {	        startPos = str.length() - searchStr.length();	    }	    if (startPos < 0) {	        return INDEX_NOT_FOUND;	    }	    if (searchStr.length() == 0) {	        return startPos;	    }	    for (int i = startPos; i >= 0; i--) {	        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
@Override	public String next() {	    if (hasNext()) {	        return tokens[tokenPos++];	    }	    throw new NoSuchElementException();	}
public boolean isEmpty() {	    return size == 0;	}
protected String getArrayEnd() {	    return arrayEnd;	}
public static <T> T invokeConstructor(final Class<T> cls, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {	    if (parameterTypes == null) {	        parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;	    }	    if (args == null) {	        args = ArrayUtils.EMPTY_OBJECT_ARRAY;	    }	    final Constructor<T> ctor = getMatchingAccessibleConstructor(cls, parameterTypes);	    if (ctor == null) {	        throw new NoSuchMethodException("No such accessible constructor on object: " + cls.getName());	    }	    return ctor.newInstance(args);	}
static Object removeAll(final Object array, final BitSet indices) {	    final int srcLength = ArrayUtils.getLength(array);	    final int removals = indices.cardinality();	    final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals);	    int srcIndex = 0;	    int destIndex = 0;	    int count;	    int set;	    while ((set = indices.nextSetBit(srcIndex)) != -1) {	        count = set - srcIndex;	        if (count > 0) {	            System.arraycopy(array, srcIndex, result, destIndex, count);	            destIndex += count;	        }	        srcIndex = indices.nextClearBit(set);	    }	    count = srcLength - srcIndex;	    if (count > 0) {	        System.arraycopy(array, srcIndex, result, destIndex, count);	    }	    return result;	}
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException {	    return charsetName == null ? new String(bytes) : new String(bytes, charsetName);	}
public static String abbreviate(final String str, int offset, final int maxWidth) {	    if (str == null) {	        return null;	    }	    if (maxWidth < 4) {	        throw new IllegalArgumentException("Minimum abbreviation width is 4");	    }	    if (str.length() <= maxWidth) {	        return str;	    }	    if (offset > str.length()) {	        offset = str.length();	    }	    if (str.length() - offset < maxWidth - 3) {	        offset = str.length() - (maxWidth - 3);	    }	    final String abrevMarker = "...";	    if (offset <= 4) {	        return str.substring(0, maxWidth - 3) + abrevMarker;	    }	    if (maxWidth < 7) {	        throw new IllegalArgumentException("Minimum abbreviation width with offset is 7");	    }	    if (offset + maxWidth - 3 < str.length()) {	        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);	    }	    return abrevMarker + str.substring(str.length() - (maxWidth - 3));	}
public static char intToHexDigit(final int nibble) {	    final char c = Character.forDigit(nibble, 16);	    if (c == Character.MIN_VALUE) {	        throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble);	    }	    return c;	}
@Override	public int intValue() {	    return numerator / denominator;	}
public boolean isNegated() {	    return negated;	}
public Object getResultObject(final String name) {	    checkName(name);	    return resultObjects.get(name);	}
@Override	public Integer build() {	    return Integer.valueOf(toComparison());	}
public static boolean[] hexDigitToBinary(final char hexDigit) {	    switch(hexDigit) {	        case '0':	            return new boolean[] { false, false, false, false };	        case '1':	            return new boolean[] { true, false, false, false };	        case '2':	            return new boolean[] { false, true, false, false };	        case '3':	            return new boolean[] { true, true, false, false };	        case '4':	            return new boolean[] { false, false, true, false };	        case '5':	            return new boolean[] { true, false, true, false };	        case '6':	            return new boolean[] { false, true, true, false };	        case '7':	            return new boolean[] { true, true, true, false };	        case '8':	            return new boolean[] { false, false, false, true };	        case '9':	            return new boolean[] { true, false, false, true };	        case 'a':	        case 'A':	            return new boolean[] { false, true, false, true };	        case 'b':	        case 'B':	            return new boolean[] { true, true, false, true };	        case 'c':	        case 'C':	            return new boolean[] { false, false, true, true };	        case 'd':	        case 'D':	            return new boolean[] { true, false, true, true };	        case 'e':	        case 'E':	            return new boolean[] { false, true, true, true };	        case 'f':	        case 'F':	            return new boolean[] { true, true, true, true };	        default:	            throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit");	    }	}
public static String abbreviate(final String str, int offset, final int maxWidth) {	    if (str == null) {	        return null;	    }	    if (maxWidth < 4) {	        throw new IllegalArgumentException("Minimum abbreviation width is 4");	    }	    if (str.length() <= maxWidth) {	        return str;	    }	    if (offset > str.length()) {	        offset = str.length();	    }	    if (str.length() - offset < maxWidth - 3) {	        offset = str.length() - (maxWidth - 3);	    }	    final String abrevMarker = "...";	    if (offset <= 4) {	        return str.substring(0, maxWidth - 3) + abrevMarker;	    }	    if (maxWidth < 7) {	        throw new IllegalArgumentException("Minimum abbreviation width with offset is 7");	    }	    if (offset + maxWidth - 3 < str.length()) {	        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);	    }	    return abrevMarker + str.substring(str.length() - (maxWidth - 3));	}
public void add(final Number operand) {	    this.value += operand.intValue();	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
@Override	protected List<String> tokenize(final char[] chars, final int offset, final int count) {	    if (chars == null) {	        return super.tokenize(StrBuilder.this.buffer, 0, StrBuilder.this.size());	    }	    return super.tokenize(chars, offset, count);	}
public synchronized boolean start() {	    if (!isStarted()) {	        ExecutorService tempExec;	        executor = getExternalExecutor();	        if (executor == null) {	            executor = tempExec = createExecutor();	        } else {	            tempExec = null;	        }	        future = executor.submit(createTask(tempExec));	        return true;	    }	    return false;	}
public static String right(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(str.length() - len);	}
public static short[] removeElement(final short[] array, final short element) {	    final int index = indexOf(array, element);	    if (index == INDEX_NOT_FOUND) {	        return clone(array);	    }	    return remove(array, index);	}
public StrBuilder setNewLineText(final String newLine) {	    this.newLine = newLine;	    return this;	}
public static Boolean and(final Boolean... array) {	    if (array == null) {	        throw new IllegalArgumentException("The Array must not be null");	    }	    if (array.length == 0) {	        throw new IllegalArgumentException("Array is empty");	    }	    try {	        final boolean[] primitive = ArrayUtils.toPrimitive(array);	        return and(primitive) ? Boolean.TRUE : Boolean.FALSE;	    } catch (final NullPointerException ex) {	        throw new IllegalArgumentException("The array must not contain any null elements");	    }	}
public static float min(final float a, final float b, final float c) {	    return Math.min(Math.min(a, b), c);	}
@Override	public boolean isCancelled() {	    return false;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
public static int hashCodeMulti(final Object... objects) {	    int hash = 1;	    if (objects != null) {	        for (final Object object : objects) {	            hash = hash * 31 + ObjectUtils.hashCode(object);	        }	    }	    return hash;	}
private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase) {	    if (str == null || prefix == null) {	        return str == null && prefix == null;	    }	    if (prefix.length() > str.length()) {	        return false;	    }	    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());	}
public static Fraction getFraction(String str) {	    if (str == null) {	        throw new IllegalArgumentException("The string must not be null");	    }	    int pos = str.indexOf('.');	    if (pos >= 0) {	        return getFraction(Double.parseDouble(str));	    }	    pos = str.indexOf(' ');	    if (pos > 0) {	        final int whole = Integer.parseInt(str.substring(0, pos));	        str = str.substring(pos + 1);	        pos = str.indexOf('/');	        if (pos < 0) {	            throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z");	        } else {	            final int numer = Integer.parseInt(str.substring(0, pos));	            final int denom = Integer.parseInt(str.substring(pos + 1));	            return getFraction(whole, numer, denom);	        }	    }	    pos = str.indexOf('/');	    if (pos < 0) {	        return getFraction(Integer.parseInt(str), 1);	    } else {	        final int numer = Integer.parseInt(str.substring(0, pos));	        final int denom = Integer.parseInt(str.substring(pos + 1));	        return getFraction(numer, denom);	    }	}
public String getNullText() {	    return nullText;	}
@Override	public int compareTo(final MutableDouble other) {	    final double anotherVal = other.value;	    return Double.compare(value, anotherVal);	}
@Override	public boolean equals(final Object obj) {	    if (obj == this) {	        return true;	    }	    if (obj instanceof Fraction == false) {	        return false;	    }	    final Fraction other = (Fraction) obj;	    return getNumerator() == other.getNumerator() && getDenominator() == other.getDenominator();	}
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {	    if (array == null) {	        if (index != 0) {	            throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0");	        }	        final Object joinedArray = Array.newInstance(clss, 1);	        Array.set(joinedArray, 0, element);	        return joinedArray;	    }	    final int length = Array.getLength(array);	    if (index > length || index < 0) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(clss, length + 1);	    System.arraycopy(array, 0, result, 0, index);	    Array.set(result, index, element);	    if (index < length) {	        System.arraycopy(array, index, result, index + 1, length - index);	    }	    return result;	}
@Override	public T get() throws ConcurrentException {	    try {	        return getFuture().get();	    } catch (final ExecutionException execex) {	        ConcurrentUtils.handleCause(execex);	        return null;	    } catch (final InterruptedException iex) {	        Thread.currentThread().interrupt();	        throw new ConcurrentException(iex);	    }	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static boolean isNumericSpace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isDigit(cs.charAt(i)) == false && cs.charAt(i) != ' ') {	            return false;	        }	    }	    return true;	}
public String getNewLineText() {	    return newLine;	}
protected String getArraySeparator() {	    return arraySeparator;	}
public boolean isEmpty() {	    return size == 0;	}
@Override	public String toString() {	    if (this.getObject() == null) {	        this.getStringBuffer().append(this.getStyle().getNullText());	    } else {	        style.appendEnd(this.getStringBuffer(), this.getObject());	    }	    return this.getStringBuffer().toString();	}
public static String[] split(final String str, final String separatorChars, final int max) {	    return splitWorker(str, separatorChars, max, false);	}
public StrBuilder replaceAll(final StrMatcher matcher, final String replaceStr) {	    return replace(matcher, replaceStr, 0, size, -1);	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
public boolean isEmpty() {	    return size == 0;	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
public static <T extends CharSequence> T defaultIfBlank(final T str, final T defaultStr) {	    return StringUtils.isBlank(str) ? defaultStr : str;	}
@Override	public Integer build() {	    return Integer.valueOf(toHashCode());	}
public boolean isEmpty() {	    return size == 0;	}
@Override	public void setFieldSeparator(final String fieldSeparator) {	    super.setFieldSeparator(fieldSeparator);	}
public char getEscapeChar() {	    return this.escapeChar;	}
public static <T> Range<T> is(final T element, final Comparator<T> comparator) {	    return between(element, element, comparator);	}
protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array) {	    appendSummarySize(buffer, fieldName, array.length);	}
public static float max(final float a, final float b) {	    if (Float.isNaN(a)) {	        return b;	    } else if (Float.isNaN(b)) {	        return a;	    } else {	        return Math.max(a, b);	    }	}
public static String mid(final String str, int pos, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0 || pos > str.length()) {	        return EMPTY;	    }	    if (pos < 0) {	        pos = 0;	    }	    if (str.length() <= pos + len) {	        return str.substring(pos);	    }	    return str.substring(pos, pos + len);	}
public static boolean isSameInstant(final Calendar cal1, final Calendar cal2) {	    if (cal1 == null || cal2 == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    return cal1.getTime().getTime() == cal2.getTime().getTime();	}
protected String getArrayStart() {	    return arrayStart;	}
@Override	public Boolean build() {	    return Boolean.valueOf(isEquals());	}
@Override	public int length() {	    return size;	}
public static String left(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(0, len);	}
public static boolean startsWithAny(final CharSequence string, final CharSequence... searchStrings) {	    if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {	        return false;	    }	    for (final CharSequence searchString : searchStrings) {	        if (StringUtils.startsWith(string, searchString)) {	            return true;	        }	    }	    return false;	}
public static String stripStart(final String str, final String stripChars) {	    int strLen;	    if (str == null || (strLen = str.length()) == 0) {	        return str;	    }	    int start = 0;	    if (stripChars == null) {	        while (start != strLen && Character.isWhitespace(str.charAt(start))) {	            start++;	        }	    } else if (stripChars.isEmpty()) {	        return str;	    } else {	        while (start != strLen && stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND) {	            start++;	        }	    }	    return str.substring(start);	}
public static Date addHours(final Date date, final int amount) {	    return add(date, Calendar.HOUR_OF_DAY, amount);	}
@Override	public int length() {	    return size;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
@Override	public int intValue() {	    return (int) value;	}
public HashCodeBuilder appendSuper(final int superHashCode) {	    iTotal = iTotal * iConstant + superHashCode;	    return this;	}
@Override	public long longValue() {	    return (long) value;	}
@Override	public String toString() {	    if (this.getObject() == null) {	        return this.getStyle().getNullText();	    }	    Class<?> clazz = this.getObject().getClass();	    this.appendFieldsIn(clazz);	    while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {	        clazz = clazz.getSuperclass();	        this.appendFieldsIn(clazz);	    }	    return super.toString();	}
public static boolean isSupported(final String name) {	    if (name == null) {	        return false;	    }	    try {	        return Charset.isSupported(name);	    } catch (final IllegalCharsetNameException ex) {	        return false;	    }	}
@Override	public float floatValue() {	    return (float) numerator / (float) denominator;	}
private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) {	    if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {	        return text;	    }	    if (timeToLive < 0) {	        throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another");	    }	    final int searchLength = searchList.length;	    final int replacementLength = replacementList.length;	    if (searchLength != replacementLength) {	        throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength);	    }	    final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];	    int textIndex = -1;	    int replaceIndex = -1;	    int tempIndex = -1;	    for (int i = 0; i < searchLength; i++) {	        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {	            continue;	        }	        tempIndex = text.indexOf(searchList[i]);	        if (tempIndex == -1) {	            noMoreMatchesForReplIndex[i] = true;	        } else {	            if (textIndex == -1 || tempIndex < textIndex) {	                textIndex = tempIndex;	                replaceIndex = i;	            }	        }	    }	    if (textIndex == -1) {	        return text;	    }	    int start = 0;	    int increase = 0;	    for (int i = 0; i < searchList.length; i++) {	        if (searchList[i] == null || replacementList[i] == null) {	            continue;	        }	        final int greater = replacementList[i].length() - searchList[i].length();	        if (greater > 0) {	            increase += 3 * greater;	        }	    }	    increase = Math.min(increase, text.length() / 5);	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (textIndex != -1) {	        for (int i = start; i < textIndex; i++) {	            buf.append(text.charAt(i));	        }	        buf.append(replacementList[replaceIndex]);	        start = textIndex + searchList[replaceIndex].length();	        textIndex = -1;	        replaceIndex = -1;	        tempIndex = -1;	        for (int i = 0; i < searchLength; i++) {	            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {	                continue;	            }	            tempIndex = text.indexOf(searchList[i], start);	            if (tempIndex == -1) {	                noMoreMatchesForReplIndex[i] = true;	            } else {	                if (textIndex == -1 || tempIndex < textIndex) {	                    textIndex = tempIndex;	                    replaceIndex = i;	                }	            }	        }	    }	    final int textLength = text.length();	    for (int i = start; i < textLength; i++) {	        buf.append(text.charAt(i));	    }	    final String result = buf.toString();	    if (!repeat) {	        return result;	    }	    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public static Iterator<?> iterator(final Object focus, final int rangeStyle) {	    if (focus == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    if (focus instanceof Date) {	        return iterator((Date) focus, rangeStyle);	    } else if (focus instanceof Calendar) {	        return iterator((Calendar) focus, rangeStyle);	    } else {	        throw new ClassCastException("Could not iterate based on " + focus);	    }	}
public int size() {	    return size;	}
public static String reverse(final String str) {	    if (str == null) {	        return null;	    }	    return new StringBuilder(str).reverse().toString();	}
public int set(final int holder) {	    return holder | _mask;	}
protected boolean isArrayContentDetail() {	    return arrayContentDetail;	}
public static boolean startsWithAny(final CharSequence string, final CharSequence... searchStrings) {	    if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {	        return false;	    }	    for (final CharSequence searchString : searchStrings) {	        if (StringUtils.startsWith(string, searchString)) {	            return true;	        }	    }	    return false;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public int capacity() {	    return buffer.length;	}
public static <T extends CharSequence> T validIndex(final T chars, final int index) {	    return validIndex(chars, index, DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE, Integer.valueOf(index));	}
public static StrMatcher commaMatcher() {	    return COMMA_MATCHER;	}
public int getRawValue(final int holder) {	    return holder & _mask;	}
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = Integer.MAX_VALUE;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.indexOf(str, search, 0);	        if (tmp == INDEX_NOT_FOUND) {	            continue;	        }	        if (tmp < ret) {	            ret = tmp;	        }	    }	    return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;	}
public static float max(final float a, final float b) {	    if (Float.isNaN(a)) {	        return b;	    } else if (Float.isNaN(b)) {	        return a;	    } else {	        return Math.max(a, b);	    }	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public int capacity() {	    return buffer.length;	}
public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) {	    if (s == null || t == null) {	        throw new IllegalArgumentException("Strings must not be null");	    }	    if (threshold < 0) {	        throw new IllegalArgumentException("Threshold must not be negative");	    }	    int n = s.length();	    int m = t.length();	    if (n == 0) {	        return m <= threshold ? m : -1;	    } else if (m == 0) {	        return n <= threshold ? n : -1;	    }	    if (n > m) {	        final CharSequence tmp = s;	        s = t;	        t = tmp;	        n = m;	        m = t.length();	    }	    int[] p = new int[n + 1];	    int[] d = new int[n + 1];	    int[] _d;	    final int boundary = Math.min(n, threshold) + 1;	    for (int i = 0; i < boundary; i++) {	        p[i] = i;	    }	    Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);	    Arrays.fill(d, Integer.MAX_VALUE);	    for (int j = 1; j <= m; j++) {	        final char t_j = t.charAt(j - 1);	        d[0] = j;	        final int min = Math.max(1, j - threshold);	        final int max = Math.min(n, j + threshold);	        if (min > max) {	            return -1;	        }	        if (min > 1) {	            d[min - 1] = Integer.MAX_VALUE;	        }	        for (int i = min; i <= max; i++) {	            if (s.charAt(i - 1) == t_j) {	                d[i] = p[i - 1];	            } else {	                d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);	            }	        }	        _d = p;	        p = d;	        d = _d;	    }	    if (p[n] <= threshold) {	        return p[n];	    }	    return -1;	}
public static String replace(final String text, final String searchString, final String replacement, int max) {	    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {	        return text;	    }	    int start = 0;	    int end = text.indexOf(searchString, start);	    if (end == INDEX_NOT_FOUND) {	        return text;	    }	    final int replLength = searchString.length();	    int increase = replacement.length() - replLength;	    increase = increase < 0 ? 0 : increase;	    increase *= max < 0 ? 16 : max > 64 ? 64 : max;	    final StringBuilder buf = new StringBuilder(text.length() + increase);	    while (end != INDEX_NOT_FOUND) {	        buf.append(text.substring(start, end)).append(replacement);	        start = end + replLength;	        if (--max == 0) {	            break;	        }	        end = text.indexOf(searchString, start);	    }	    buf.append(text.substring(start));	    return buf.toString();	}
@Override	public Integer build() {	    return Integer.valueOf(toHashCode());	}
public abstract boolean translate(int codepoint, Writer out) throws IOException;
public static String[] stripAll(final String[] strs, final String stripChars) {	    int strsLen;	    if (strs == null || (strsLen = strs.length) == 0) {	        return strs;	    }	    final String[] newArr = new String[strsLen];	    for (int i = 0; i < strsLen; i++) {	        newArr[i] = strip(strs[i], stripChars);	    }	    return newArr;	}
public StrBuilder appendln(final double value) {	    return append(value).appendNewLine();	}
public static void reverse(final boolean[] array) {	    if (array == null) {	        return;	    }	    int i = 0;	    int j = array.length - 1;	    boolean tmp;	    while (j > i) {	        tmp = array[j];	        array[j] = array[i];	        array[i] = tmp;	        j--;	        i++;	    }	}
@Override	public boolean ready() {	    return pos < StrBuilder.this.size();	}
public int capacity() {	    return buffer.length;	}
public int getDenominator() {	    return denominator;	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public char getEnd() {	    return this.end;	}
public String getNewLineText() {	    return newLine;	}
public static short[] removeElement(final short[] array, final short element) {	    final int index = indexOf(array, element);	    if (index == INDEX_NOT_FOUND) {	        return clone(array);	    }	    return remove(array, index);	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
public static String capitalize(final String str, final char... delimiters) {	    final int delimLen = delimiters == null ? -1 : delimiters.length;	    if (StringUtils.isEmpty(str) || delimLen == 0) {	        return str;	    }	    final char[] buffer = str.toCharArray();	    boolean capitalizeNext = true;	    for (int i = 0; i < buffer.length; i++) {	        final char ch = buffer[i];	        if (isDelimiter(ch, delimiters)) {	            capitalizeNext = true;	        } else if (capitalizeNext) {	            buffer[i] = Character.toTitleCase(ch);	            capitalizeNext = false;	        }	    }	    return new String(buffer);	}
public Builder uncaughtExceptionHandler(final Thread.UncaughtExceptionHandler handler) {	    if (handler == null) {	        throw new NullPointerException("Uncaught exception handler must not be null!");	    }	    exceptionHandler = handler;	    return this;	}
@Override	public float floatValue() {	    return value;	}
@Override	public String previous() {	    if (hasPrevious()) {	        return tokens[--tokenPos];	    }	    throw new NoSuchElementException();	}
protected boolean isUseClassName() {	    return useClassName;	}
public static int reflectionHashCode(final Object object, final String... excludeFields) {	    return reflectionHashCode(17, 37, object, false, null, excludeFields);	}
public static boolean[] removeElements(final boolean[] array, final boolean... values) {	    if (isEmpty(array) || isEmpty(values)) {	        return clone(array);	    }	    final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2);	    for (final boolean v : values) {	        final Boolean boxed = Boolean.valueOf(v);	        final MutableInt count = occurrences.get(boxed);	        if (count == null) {	            occurrences.put(boxed, new MutableInt(1));	        } else {	            count.increment();	        }	    }	    final BitSet toRemove = new BitSet();	    for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) {	        final Boolean v = e.getKey();	        int found = 0;	        for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {	            found = indexOf(array, v.booleanValue(), found);	            if (found < 0) {	                break;	            }	            toRemove.set(found++);	        }	    }	    return (boolean[]) removeAll(array, toRemove);	}
public StrBuilder append(final double value) {	    return append(String.valueOf(value));	}
public static String substringBetween(final String str, final String open, final String close) {	    if (str == null || open == null || close == null) {	        return null;	    }	    final int start = str.indexOf(open);	    if (start != INDEX_NOT_FOUND) {	        final int end = str.indexOf(close, start + open.length());	        if (end != INDEX_NOT_FOUND) {	            return str.substring(start + open.length(), end);	        }	    }	    return null;	}
public static <T extends Iterable<?>> T noNullElements(final T iterable) {	    return noNullElements(iterable, DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE);	}
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException {	    return charsetName == null ? new String(bytes) : new String(bytes, charsetName);	}
public String toProperString() {	    if (toProperString == null) {	        if (numerator == 0) {	            toProperString = "0";	        } else if (numerator == denominator) {	            toProperString = "1";	        } else if (numerator == -1 * denominator) {	            toProperString = "-1";	        } else if ((numerator > 0 ? -numerator : numerator) < -denominator) {	            final int properNumerator = getProperNumerator();	            if (properNumerator == 0) {	                toProperString = Integer.toString(getProperWhole());	            } else {	                toProperString = new StringBuilder(32).append(getProperWhole()).append(' ').append(properNumerator).append('/').append(getDenominator()).toString();	            }	        } else {	            toProperString = new StringBuilder(32).append(getNumerator()).append('/').append(getDenominator()).toString();	        }	    }	    return toProperString;	}
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (comparison != 0) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null) {	        comparison = -1;	        return this;	    }	    if (rhs == null) {	        comparison = +1;	        return this;	    }	    if (lhs.length != rhs.length) {	        comparison = (lhs.length < rhs.length) ? -1 : +1;	        return this;	    }	    for (int i = 0; i < lhs.length && comparison == 0; i++) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
protected boolean isArrayContentDetail() {	    return arrayContentDetail;	}
public StrBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar) {	    return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);	}
public int capacity() {	    return buffer.length;	}
public static int indexOfDifference(final CharSequence... css) {	    if (css == null || css.length <= 1) {	        return INDEX_NOT_FOUND;	    }	    boolean anyStringNull = false;	    boolean allStringsNull = true;	    final int arrayLen = css.length;	    int shortestStrLen = Integer.MAX_VALUE;	    int longestStrLen = 0;	    for (int i = 0; i < arrayLen; i++) {	        if (css[i] == null) {	            anyStringNull = true;	            shortestStrLen = 0;	        } else {	            allStringsNull = false;	            shortestStrLen = Math.min(css[i].length(), shortestStrLen);	            longestStrLen = Math.max(css[i].length(), longestStrLen);	        }	    }	    if (allStringsNull || longestStrLen == 0 && !anyStringNull) {	        return INDEX_NOT_FOUND;	    }	    if (shortestStrLen == 0) {	        return 0;	    }	    int firstDiff = -1;	    for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {	        final char comparisonChar = css[0].charAt(stringPos);	        for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {	            if (css[arrayPos].charAt(stringPos) != comparisonChar) {	                firstDiff = stringPos;	                break;	            }	        }	        if (firstDiff != -1) {	            break;	        }	    }	    if (firstDiff == -1 && shortestStrLen != longestStrLen) {	        return shortestStrLen;	    }	    return firstDiff;	}
protected boolean isUseFieldNames() {	    return useFieldNames;	}
public int indexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex < 0 ? 0 : startIndex);	    if (matcher == null || startIndex >= size) {	        return -1;	    }	    final int len = size;	    final char[] buf = buffer;	    for (int i = startIndex; i < len; i++) {	        if (matcher.isMatch(buf, i, startIndex, len) > 0) {	            return i;	        }	    }	    return -1;	}
public static StrTokenizer getTSVInstance(final char[] input) {	    final StrTokenizer tok = getTSVClone();	    tok.reset(input);	    return tok;	}
private static Object remove(final Object array, final int index) {	    final int length = getLength(array);	    if (index < 0 || index >= length) {	        throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length);	    }	    final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);	    System.arraycopy(array, 0, result, 0, index);	    if (index < length - 1) {	        System.arraycopy(array, index + 1, result, index, length - index - 1);	    }	    return result;	}
public static String right(final String str, final int len) {	    if (str == null) {	        return null;	    }	    if (len < 0) {	        return EMPTY;	    }	    if (str.length() <= len) {	        return str;	    }	    return str.substring(str.length() - len);	}
public synchronized double getAverageCallsPerPeriod() {	    return periodCount == 0 ? 0 : (double) totalAcquireCount / (double) periodCount;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static boolean toBoolean(final String str, final String trueString, final String falseString) {	    if (str == trueString) {	        return true;	    } else if (str == falseString) {	        return false;	    } else if (str != null) {	        if (str.equals(trueString)) {	            return true;	        } else if (str.equals(falseString)) {	            return false;	        }	    }	    throw new IllegalArgumentException("The String did not match either specified value");	}
public int size() {	    return size;	}
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);	}
public HashCodeBuilder append(final short[] array) {	    if (array == null) {	        iTotal = iTotal * iConstant;	    } else {	        for (final short element : array) {	            append(element);	        }	    }	    return this;	}
public String getNullText() {	    return nullText;	}
public final void translate(final CharSequence input, final Writer out) throws IOException {	    if (out == null) {	        throw new IllegalArgumentException("The Writer must not be null");	    }	    if (input == null) {	        return;	    }	    int pos = 0;	    final int len = input.length();	    while (pos < len) {	        final int consumed = translate(input, pos, out);	        if (consumed == 0) {	            final char[] c = Character.toChars(Character.codePointAt(input, pos));	            out.write(c);	            pos += c.length;	            continue;	        }	        for (int pt = 0; pt < consumed; pt++) {	            pos += Character.charCount(Character.codePointAt(input, pt));	        }	    }	}
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] result = new boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        final Boolean b = array[i];	        result[i] = (b == null ? valueForNull : b.booleanValue());	    }	    return result;	}
public boolean isEmpty() {	    return size == 0;	}
@Override	public StringBuffer format(final Calendar calendar, final StringBuffer buf) {	    return printer.format(calendar, buf);	}
public StrBuilder appendSeparator(final char separator, final int loopIndex) {	    if (loopIndex > 0) {	        append(separator);	    }	    return this;	}
public static boolean isNumber(final String str) {	    if (StringUtils.isEmpty(str)) {	        return false;	    }	    final char[] chars = str.toCharArray();	    int sz = chars.length;	    boolean hasExp = false;	    boolean hasDecPoint = false;	    boolean allowSigns = false;	    boolean foundDigit = false;	    final int start = (chars[0] == '-') ? 1 : 0;	    if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') {	        int i = start + 2;	        if (i == sz) {	            return false;	        }	        for (; i < chars.length; i++) {	            if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) {	                return false;	            }	        }	        return true;	    }	    sz--;	    int i = start;	    while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {	        if (chars[i] >= '0' && chars[i] <= '9') {	            foundDigit = true;	            allowSigns = false;	        } else if (chars[i] == '.') {	            if (hasDecPoint || hasExp) {	                return false;	            }	            hasDecPoint = true;	        } else if (chars[i] == 'e' || chars[i] == 'E') {	            if (hasExp) {	                return false;	            }	            if (!foundDigit) {	                return false;	            }	            hasExp = true;	            allowSigns = true;	        } else if (chars[i] == '+' || chars[i] == '-') {	            if (!allowSigns) {	                return false;	            }	            allowSigns = false;	            foundDigit = false;	        } else {	            return false;	        }	        i++;	    }	    if (i < chars.length) {	        if (chars[i] >= '0' && chars[i] <= '9') {	            return true;	        }	        if (chars[i] == 'e' || chars[i] == 'E') {	            return false;	        }	        if (chars[i] == '.') {	            if (hasDecPoint || hasExp) {	                return false;	            }	            return foundDigit;	        }	        if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) {	            return foundDigit;	        }	        if (chars[i] == 'l' || chars[i] == 'L') {	            return foundDigit && !hasExp && !hasDecPoint;	        }	        return false;	    }	    return !allowSigns && foundDigit;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {	    if (str == null || searchStrs == null) {	        return INDEX_NOT_FOUND;	    }	    final int sz = searchStrs.length;	    int ret = Integer.MAX_VALUE;	    int tmp = 0;	    for (int i = 0; i < sz; i++) {	        final CharSequence search = searchStrs[i];	        if (search == null) {	            continue;	        }	        tmp = CharSequenceUtils.indexOf(str, search, 0);	        if (tmp == INDEX_NOT_FOUND) {	            continue;	        }	        if (tmp < ret) {	            ret = tmp;	        }	    }	    return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;	}
public String getNullText() {	    return nullText;	}
public static float max(final float a, final float b, final float c) {	    return Math.max(Math.max(a, b), c);	}
public static <T extends CharSequence> T defaultIfBlank(final T str, final T defaultStr) {	    return StringUtils.isBlank(str) ? defaultStr : str;	}
synchronized void endOfPeriod() {	    lastCallsPerPeriod = acquireCount;	    totalAcquireCount += acquireCount;	    periodCount++;	    acquireCount = 0;	    notifyAll();	}
@Override	public boolean ready() {	    return pos < StrBuilder.this.size();	}
public int size() {	    return size;	}
public int lastIndexOf(final StrMatcher matcher, int startIndex) {	    startIndex = (startIndex >= size ? size - 1 : startIndex);	    if (matcher == null || startIndex < 0) {	        return -1;	    }	    final char[] buf = buffer;	    final int endIndex = startIndex + 1;	    for (int i = startIndex; i >= 0; i--) {	        if (matcher.isMatch(buf, i, 0, endIndex) > 0) {	            return i;	        }	    }	    return -1;	}
public String getNewLineText() {	    return newLine;	}
public StrBuilder deleteAll(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, -1);	}
@Override	public boolean equals(final Object obj) {	    if (obj instanceof StrBuilder) {	        return equals((StrBuilder) obj);	    }	    return false;	}
public StrBuilder deleteAll(final StrMatcher matcher) {	    return replace(matcher, null, 0, size, -1);	}
public static String trim(final String str) {	    return str == null ? null : str.trim();	}
public HashCodeBuilder append(final short[] array) {	    if (array == null) {	        iTotal = iTotal * iConstant;	    } else {	        for (final short element : array) {	            append(element);	        }	    }	    return this;	}
public boolean isEmpty() {	    return size == 0;	}
public boolean isEquals() {	    return this.isEquals;	}
public String getNewLineText() {	    return newLine;	}
public static String substringAfter(final String str, final String separator) {	    if (isEmpty(str)) {	        return str;	    }	    if (separator == null) {	        return EMPTY;	    }	    final int pos = str.indexOf(separator);	    if (pos == INDEX_NOT_FOUND) {	        return EMPTY;	    }	    return str.substring(pos + separator.length());	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public static StrTokenizer getCSVInstance(final char[] input) {	    final StrTokenizer tok = getCSVClone();	    tok.reset(input);	    return tok;	}
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) {	    if (str == null) {	        if (trueString == null) {	            return Boolean.TRUE;	        }	        if (falseString == null) {	            return Boolean.FALSE;	        }	        if (nullString == null) {	            return null;	        }	    } else if (str.equals(trueString)) {	        return Boolean.TRUE;	    } else if (str.equals(falseString)) {	        return Boolean.FALSE;	    } else if (str.equals(nullString)) {	        return null;	    }	    throw new IllegalArgumentException("The String did not match any specified value");	}
public static String formatUTC(final Date date, final String pattern, final Locale locale) {	    return format(date, pattern, UTC_TIME_ZONE, locale);	}
public static String keep(final String str, final String... set) {	    if (str == null) {	        return null;	    }	    if (str.isEmpty() || deepEmpty(set)) {	        return StringUtils.EMPTY;	    }	    return modify(str, set, true);	}
public static <K, V> V putIfAbsent(final ConcurrentMap<K, V> map, final K key, final V value) {	    if (map == null) {	        return null;	    }	    final V result = map.putIfAbsent(key, value);	    return result != null ? result : value;	}
public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) {	    if (src.length > 8) {	        throw new IllegalArgumentException("src.length>8: src.length=" + src.length);	    }	    if (src.length - srcPos < 4) {	        throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos);	    }	    if (src[srcPos + 3]) {	        if (src[srcPos + 2]) {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'f';	                } else {	                    return '7';	                }	            } else {	                if (src[srcPos]) {	                    return 'b';	                } else {	                    return '3';	                }	            }	        } else {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'd';	                } else {	                    return '5';	                }	            } else {	                if (src[srcPos]) {	                    return '9';	                } else {	                    return '1';	                }	            }	        }	    } else {	        if (src[srcPos + 2]) {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'e';	                } else {	                    return '6';	                }	            } else {	                if (src[srcPos]) {	                    return 'a';	                } else {	                    return '2';	                }	            }	        } else {	            if (src[srcPos + 1]) {	                if (src[srcPos]) {	                    return 'c';	                } else {	                    return '4';	                }	            } else {	                if (src[srcPos]) {	                    return '8';	                } else {	                    return '0';	                }	            }	        }	    }	}
public static String substring(final String str, int start, int end) {	    if (str == null) {	        return null;	    }	    if (end < 0) {	        end = str.length() + end;	    }	    if (start < 0) {	        start = str.length() + start;	    }	    if (end > str.length()) {	        end = str.length();	    }	    if (start > end) {	        return EMPTY;	    }	    if (start < 0) {	        start = 0;	    }	    if (end < 0) {	        end = 0;	    }	    return str.substring(start, end);	}
public static boolean isWhitespace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isWhitespace(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
private static long getFragment(final Calendar calendar, final int fragment, final int unit) {	    if (calendar == null) {	        throw new IllegalArgumentException("The date must not be null");	    }	    final long millisPerUnit = getMillisPerUnit(unit);	    long result = 0;	    switch(fragment) {	        case Calendar.YEAR:	            result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit;	            break;	        case Calendar.MONTH:	            result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit;	            break;	    }	    switch(fragment) {	        case Calendar.YEAR:	        case Calendar.MONTH:	        case Calendar.DAY_OF_YEAR:	        case Calendar.DATE:	            result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit;	        case Calendar.HOUR_OF_DAY:	            result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit;	        case Calendar.MINUTE:	            result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit;	        case Calendar.SECOND:	            result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit;	            break;	        case Calendar.MILLISECOND:	            break;	        default:	            throw new IllegalArgumentException("The fragment " + fragment + " is not supported");	    }	    return result;	}
public static <T extends CharSequence> T notEmpty(final T chars) {	    return notEmpty(chars, DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE);	}
public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {	    endIndex = validateRange(startIndex, endIndex);	    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);	}
public StrBuilder insert(final int index, final double value) {	    return insert(index, String.valueOf(value));	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) {	    String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'");	    if (suppressLeadingZeroElements) {	        duration = " " + duration;	        String tmp = StringUtils.replaceOnce(duration, " 0 days", "");	        if (tmp.length() != duration.length()) {	            duration = tmp;	            tmp = StringUtils.replaceOnce(duration, " 0 hours", "");	            if (tmp.length() != duration.length()) {	                duration = tmp;	                tmp = StringUtils.replaceOnce(duration, " 0 minutes", "");	                duration = tmp;	                if (tmp.length() != duration.length()) {	                    duration = StringUtils.replaceOnce(tmp, " 0 seconds", "");	                }	            }	        }	        if (duration.length() != 0) {	            duration = duration.substring(1);	        }	    }	    if (suppressTrailingZeroElements) {	        String tmp = StringUtils.replaceOnce(duration, " 0 seconds", "");	        if (tmp.length() != duration.length()) {	            duration = tmp;	            tmp = StringUtils.replaceOnce(duration, " 0 minutes", "");	            if (tmp.length() != duration.length()) {	                duration = tmp;	                tmp = StringUtils.replaceOnce(duration, " 0 hours", "");	                if (tmp.length() != duration.length()) {	                    duration = StringUtils.replaceOnce(tmp, " 0 days", "");	                }	            }	        }	    }	    duration = " " + duration;	    duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second");	    duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute");	    duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour");	    duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day");	    return duration.trim();	}
public byte setByteBoolean(final byte holder, final boolean flag) {	    return flag ? setByte(holder) : clearByte(holder);	}
public String getNullText() {	    return nullText;	}
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {	    if (seq == null || searchSeq == null) {	        return INDEX_NOT_FOUND;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);	}
public String getNullText() {	    return nullText;	}
@Override	public int length() {	    return size;	}
public static String formatPeriodISO(final long startMillis, final long endMillis) {	    return formatPeriod(startMillis, endMillis, ISO_EXTENDED_FORMAT_PATTERN, false, TimeZone.getDefault());	}
public StrBuilder deleteCharAt(final int index) {	    if (index < 0 || index >= size) {	        throw new StringIndexOutOfBoundsException(index);	    }	    deleteImpl(index, index + 1, 1);	    return this;	}
protected boolean isUseClassName() {	    return useClassName;	}
public char getEnd() {	    return this.end;	}
public String toString(final String format) {	    return String.format(format, getLeft(), getRight());	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static boolean isWhitespace(final CharSequence cs) {	    if (cs == null) {	        return false;	    }	    final int sz = cs.length();	    for (int i = 0; i < sz; i++) {	        if (Character.isWhitespace(cs.charAt(i)) == false) {	            return false;	        }	    }	    return true;	}
public static boolean isAsciiPrintable(final char ch) {	    return ch >= 32 && ch < 127;	}
public char getStart() {	    return this.start;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) {	    return new Range<T>(fromInclusive, toInclusive, comparator);	}
public int getNumerator() {	    return numerator;	}
public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale) {	    return cache.getDateInstance(style, timeZone, locale);	}
protected String getSizeEndText() {	    return sizeEndText;	}
public boolean isEmpty() {	    return size == 0;	}
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {	    if (array == null) {	        return null;	    } else if (array.length == 0) {	        return EMPTY_BOOLEAN_ARRAY;	    }	    final boolean[] result = new boolean[array.length];	    for (int i = 0; i < array.length; i++) {	        final Boolean b = array[i];	        result[i] = (b == null ? valueForNull : b.booleanValue());	    }	    return result;	}
@Override	public TimeZone getTimeZone() {	    return mTimeZone;	}
public static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex) {	    if (0 == nHex) {	        return dstInit;	    }	    if ((nHex - 1) * 4 + dstPos >= 16) {	        throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 16");	    }	    short out = dstInit;	    int shift = 0;	    for (int i = 0; i < nHex; i++) {	        shift = i * 4 + dstPos;	        final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift;	        final int mask = 0xf << shift;	        out = (short) ((out & ~mask) | bits);	    }	    return out;	}
public StrBuilder delete(final int startIndex, int endIndex) {	    endIndex = validateRange(startIndex, endIndex);	    final int len = endIndex - startIndex;	    if (len > 0) {	        deleteImpl(startIndex, endIndex, len);	    }	    return this;	}
public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) {	    final Token[] tokens = lexx(format);	    final Calendar start = Calendar.getInstance(timezone);	    start.setTime(new Date(startMillis));	    final Calendar end = Calendar.getInstance(timezone);	    end.setTime(new Date(endMillis));	    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);	    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);	    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);	    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);	    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);	    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);	    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);	    while (milliseconds < 0) {	        milliseconds += 1000;	        seconds -= 1;	    }	    while (seconds < 0) {	        seconds += 60;	        minutes -= 1;	    }	    while (minutes < 0) {	        minutes += 60;	        hours -= 1;	    }	    while (hours < 0) {	        hours += 24;	        days -= 1;	    }	    if (Token.containsTokenWithValue(tokens, M)) {	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	        while (months < 0) {	            months += 12;	            years -= 1;	        }	        if (!Token.containsTokenWithValue(tokens, y) && years != 0) {	            while (years != 0) {	                months += 12 * years;	                years = 0;	            }	        }	    } else {	        if (!Token.containsTokenWithValue(tokens, y)) {	            int target = end.get(Calendar.YEAR);	            if (months < 0) {	                target -= 1;	            }	            while (start.get(Calendar.YEAR) != target) {	                days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);	                if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) {	                    days += 1;	                }	                start.add(Calendar.YEAR, 1);	                days += start.get(Calendar.DAY_OF_YEAR);	            }	            years = 0;	        }	        while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            start.add(Calendar.MONTH, 1);	        }	        months = 0;	        while (days < 0) {	            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);	            months -= 1;	            start.add(Calendar.MONTH, 1);	        }	    }	    if (!Token.containsTokenWithValue(tokens, d)) {	        hours += 24 * days;	        days = 0;	    }	    if (!Token.containsTokenWithValue(tokens, H)) {	        minutes += 60 * hours;	        hours = 0;	    }	    if (!Token.containsTokenWithValue(tokens, m)) {	        seconds += 60 * minutes;	        minutes = 0;	    }	    if (!Token.containsTokenWithValue(tokens, s)) {	        milliseconds += 1000 * seconds;	        seconds = 0;	    }	    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);	}
@Override	public int length() {	    return size;	}
public StrTokenizer setIgnoredMatcher(final StrMatcher ignored) {	    if (ignored != null) {	        this.ignoredMatcher = ignored;	    }	    return this;	}
@Override	public void set(final String obj) {	    throw new UnsupportedOperationException("set() is unsupported");	}
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {	    if (isEquals == false) {	        return this;	    }	    if (lhs == rhs) {	        return this;	    }	    if (lhs == null || rhs == null) {	        this.setEquals(false);	        return this;	    }	    if (lhs.length != rhs.length) {	        this.setEquals(false);	        return this;	    }	    for (int i = 0; i < lhs.length && isEquals; ++i) {	        append(lhs[i], rhs[i]);	    }	    return this;	}
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {	    if (seq == null || searchSeq == null) {	        return false;	    }	    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;	}
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {	    if (cs1 == cs2) {	        return true;	    }	    if (cs1 == null || cs2 == null) {	        return false;	    }	    if (cs1 instanceof String && cs2 instanceof String) {	        return cs1.equals(cs2);	    }	    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));	}
public void appendEnd(final StringBuffer buffer, final Object object) {	    if (this.fieldSeparatorAtEnd == false) {	        removeLastFieldSeparator(buffer);	    }	    appendContentEnd(buffer);	    unregister(object);	}
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        startIndex = 0;	    }	    for (int i = startIndex; i < array.length; i++) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
public static boolean isEmpty(final CharSequence cs) {	    return cs == null || cs.length() == 0;	}
public static String[] splitByWholeSeparatorPreserveAllTokens(final String str, final String separator, final int max) {	    return splitByWholeSeparatorWorker(str, separator, max, true);	}
public boolean isIgnoreEmptyTokens() {	    return ignoreEmptyTokens;	}
@Override	public void setFormat(final int formatElementIndex, final Format newFormat) {	    throw new UnsupportedOperationException();	}
public static String lowerCase(final String str, final Locale locale) {	    if (str == null) {	        return null;	    }	    return str.toLowerCase(locale);	}
protected boolean isDefaultFullDetail() {	    return defaultFullDetail;	}
public static int length(final CharSequence cs) {	    return cs == null ? 0 : cs.length();	}
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {	    if (ArrayUtils.isEmpty(array)) {	        return INDEX_NOT_FOUND;	    }	    if (startIndex < 0) {	        return INDEX_NOT_FOUND;	    } else if (startIndex >= array.length) {	        startIndex = array.length - 1;	    }	    for (int i = startIndex; i >= 0; i--) {	        if (valueToFind == array[i]) {	            return i;	        }	    }	    return INDEX_NOT_FOUND;	}
@Override	public TimeZone getTimeZone() {	    return printer.getTimeZone();	}
public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer) {	    if (throwable == null) {	        return;	    }	    if (writer == null) {	        throw new IllegalArgumentException("The PrintWriter must not be null");	    }	    final String[] trace = getRootCauseStackTrace(throwable);	    for (final String element : trace) {	        writer.println(element);	    }	    writer.flush();	}
