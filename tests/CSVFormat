public List<CSVRecord> getRecords() throws IOException {	    List<CSVRecord> records = new ArrayList<CSVRecord>();	    CSVRecord rec;	    while ((rec = getRecord()) != null) {	        records.add(rec);	    }	    return records;	}
CSVRecord getRecord() throws IOException {	    CSVRecord result = new CSVRecord(null, headerMapping);	    record.clear();	    do {	        reusableToken.reset();	        lexer.nextToken(reusableToken);	        switch(reusableToken.type) {	            case TOKEN:	                record.add(reusableToken.content.toString());	                break;	            case EORECORD:	                record.add(reusableToken.content.toString());	                break;	            case EOF:	                if (reusableToken.isReady) {	                    record.add(reusableToken.content.toString());	                } else {	                    result = null;	                }	                break;	            case INVALID:	                throw new IOException("(line " + getLineNumber() + ") invalid parse sequence");	        }	    } while (reusableToken.type == TOKEN);	    if (!record.isEmpty()) {	        result = new CSVRecord(record.toArray(new String[record.size()]), headerMapping);	    }	    return result;	}
private Map<String, Integer> initializeHeader(CSVFormat format) throws IOException {	    Map<String, Integer> hdrMap = null;	    if (format.getHeader() != null) {	        hdrMap = new HashMap<String, Integer>();	        String[] header = null;	        if (format.getHeader().length == 0) {	            CSVRecord rec = getRecord();	            if (rec != null) {	                header = rec.values();	            }	        } else {	            header = format.getHeader();	        }	        if (header != null) {	            for (int i = 0; i < header.length; i++) {	                hdrMap.put(header[i], Integer.valueOf(i));	            }	        }	    }	    return hdrMap;	}
public boolean hasNext() {	    if (current == null) {	        current = getNextRecord();	    }	    return current != null;	}
public CSVRecord next() {	    CSVRecord next = current;	    current = null;	    if (next == null) {	        next = getNextRecord();	        if (next == null) {	            throw new NoSuchElementException("No more CSV records available");	        }	    }	    return next;	}
private CSVRecord getNextRecord() {	    try {	        return getRecord();	    } catch (IOException e) {	        throw new RuntimeException(e);	    }	}
public void remove() {	    throw new UnsupportedOperationException();	}
public Iterator<CSVRecord> iterator() {	    return new Iterator<CSVRecord>() {		        private CSVRecord current;		        public boolean hasNext() {	            if (current == null) {	                current = getNextRecord();	            }	            return current != null;	        }		        public CSVRecord next() {	            CSVRecord next = current;	            current = null;	            if (next == null) {	                next = getNextRecord();	                if (next == null) {	                    throw new NoSuchElementException("No more CSV records available");	                }	            }	            return next;	        }		        private CSVRecord getNextRecord() {	            try {	                return getRecord();	            } catch (IOException e) {	                throw new RuntimeException(e);	            }	        }		        public void remove() {	            throw new UnsupportedOperationException();	        }	    };	}
public int getLineNumber() {	    return lexer.getLineNumber();	}
public String get(int i) {	    return values[i];	}
public String get(String name) {	    if (mapping == null) {	        throw new IllegalStateException("No header was specified, the record values can't be accessed by name");	    }	    Integer index = mapping.get(name);	    return index != null ? values[index.intValue()] : null;	}
public Iterator<String> iterator() {	    return Arrays.asList(values).iterator();	}
String[] values() {	    return values;	}
public int size() {	    return values.length;	}
@Override	public String toString() {	    return Arrays.toString(values);	}
private static boolean isLineBreak(char c) {	    return c == '\n' || c == '\r';	}
void validate() throws IllegalArgumentException {	    if (delimiter == encapsulator) {	        throw new IllegalArgumentException("The encapsulator character and the delimiter cannot be the same (\"" + encapsulator + "\")");	    }	    if (delimiter == escape) {	        throw new IllegalArgumentException("The escape character and the delimiter cannot be the same (\"" + escape + "\")");	    }	    if (delimiter == commentStart) {	        throw new IllegalArgumentException("The comment start character and the delimiter cannot be the same (\"" + commentStart + "\")");	    }	    if (encapsulator != DISABLED && encapsulator == commentStart) {	        throw new IllegalArgumentException("The comment start character and the encapsulator cannot be the same (\"" + commentStart + "\")");	    }	    if (escape != DISABLED && escape == commentStart) {	        throw new IllegalArgumentException("The comment start and the escape character cannot be the same (\"" + commentStart + "\")");	    }	}
public char getDelimiter() {	    return delimiter;	}
public CSVFormat withDelimiter(char delimiter) {	    if (isLineBreak(delimiter)) {	        throw new IllegalArgumentException("The delimiter cannot be a line break");	    }	    return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);	}
public char getEncapsulator() {	    return encapsulator;	}
public CSVFormat withEncapsulator(char encapsulator) {	    if (isLineBreak(encapsulator)) {	        throw new IllegalArgumentException("The encapsulator cannot be a line break");	    }	    return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);	}
boolean isEncapsulating() {	    return this.encapsulator != DISABLED;	}
public char getCommentStart() {	    return commentStart;	}
public CSVFormat withCommentStart(char commentStart) {	    if (isLineBreak(commentStart)) {	        throw new IllegalArgumentException("The comment start character cannot be a line break");	    }	    return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);	}
public boolean isCommentingEnabled() {	    return this.commentStart != DISABLED;	}
public char getEscape() {	    return escape;	}
public CSVFormat withEscape(char escape) {	    if (isLineBreak(escape)) {	        throw new IllegalArgumentException("The escape character cannot be a line break");	    }	    return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);	}
boolean isEscaping() {	    return this.escape != DISABLED;	}
public boolean isSurroundingSpacesIgnored() {	    return surroundingSpacesIgnored;	}
public CSVFormat withSurroundingSpacesIgnored(boolean surroundingSpacesIgnored) {	    return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);	}
public boolean isEmptyLinesIgnored() {	    return emptyLinesIgnored;	}
public CSVFormat withEmptyLinesIgnored(boolean emptyLinesIgnored) {	    return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);	}
public String getLineSeparator() {	    return lineSeparator;	}
public CSVFormat withLineSeparator(String lineSeparator) {	    return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);	}
String[] getHeader() {	    return header;	}
public CSVFormat withHeader(String... header) {	    return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);	}
public Iterable<CSVRecord> parse(Reader in) throws IOException {	    return new CSVParser(in, this);	}
public String format(String... values) {	    StringWriter out = new StringWriter();	    try {	        new CSVPrinter(out, this).println(values);	    } catch (IOException e) {	    }	    return out.toString().trim();	}
@Override	public String toString() {	    StringBuilder sb = new StringBuilder();	    sb.append("Delimiter=<").append(delimiter).append('>');	    if (isEscaping()) {	        sb.append(' ');	        sb.append("Escape=<").append(escape).append('>');	    }	    if (isEncapsulating()) {	        sb.append(' ');	        sb.append("Encapsulator=<").append(encapsulator).append('>');	    }	    if (isCommentingEnabled()) {	        sb.append(' ');	        sb.append("CommentStart=<").append(commentStart).append('>');	    }	    if (isEmptyLinesIgnored()) {	        sb.append(" EmptyLines:ignored");	    }	    if (isSurroundingSpacesIgnored()) {	        sb.append(" SurroundingSpaces:ignored");	    }	    return sb.toString();	}
int getLineNumber() {	    return in.getLineNumber();	}
int readEscape(int c) throws IOException {	    c = in.read();	    switch(c) {	        case 'r':	            return '\r';	        case 'n':	            return '\n';	        case 't':	            return '\t';	        case 'b':	            return '\b';	        case 'f':	            return '\f';	        default:	            return c;	    }	}
void trimTrailingSpaces(StringBuilder buffer) {	    int length = buffer.length();	    while (length > 0 && Character.isWhitespace(buffer.charAt(length - 1))) {	        length = length - 1;	    }	    if (length != buffer.length()) {	        buffer.setLength(length);	    }	}
boolean isWhitespace(int c) {	    return (c != format.getDelimiter()) && Character.isWhitespace((char) c);	}
boolean isEndOfLine(int c) throws IOException {	    if (c == '\r' && in.lookAhead() == '\n') {	        c = in.read();	    }	    return (c == '\n' || c == '\r');	}
boolean isEndOfFile(int c) {	    return c == ExtendedBufferedReader.END_OF_STREAM;	}
abstract Token nextToken(Token reusableToken) throws IOException;
boolean isDelimiter(int c) {	    return c == delimiter;	}
boolean isEscape(int c) {	    return isEscaping && c == escape;	}
boolean isEncapsulator(int c) {	    return isEncapsulating && c == encapsulator;	}
boolean isCommentStart(int c) {	    return isCommentEnabled && c == commmentStart;	}
public void println() throws IOException {	    out.append(format.getLineSeparator());	    newLine = true;	}
public void flush() throws IOException {	    if (out instanceof Flushable) {	        ((Flushable) out).flush();	    }	}
public void println(String... values) throws IOException {	    for (String value : values) {	        print(value);	    }	    println();	}
public void printComment(String comment) throws IOException {	    if (!format.isCommentingEnabled()) {	        return;	    }	    if (!newLine) {	        println();	    }	    out.append(format.getCommentStart());	    out.append(' ');	    for (int i = 0; i < comment.length(); i++) {	        char c = comment.charAt(i);	        switch(c) {	            case '\r':	                if (i + 1 < comment.length() && comment.charAt(i + 1) == '\n') {	                    i++;	                }	            case '\n':	                println();	                out.append(format.getCommentStart());	                out.append(' ');	                break;	            default:	                out.append(c);	                break;	        }	    }	    println();	}
private void print(CharSequence value, int offset, int len) throws IOException {	    if (format.isEncapsulating()) {	        printAndEncapsulate(value, offset, len);	    } else if (format.isEscaping()) {	        printAndEscape(value, offset, len);	    } else {	        printSep();	        out.append(value, offset, offset + len);	    }	}
void printSep() throws IOException {	    if (newLine) {	        newLine = false;	    } else {	        out.append(format.getDelimiter());	    }	}
void printAndEscape(CharSequence value, int offset, int len) throws IOException {	    int start = offset;	    int pos = offset;	    int end = offset + len;	    printSep();	    char delim = format.getDelimiter();	    char escape = format.getEscape();	    while (pos < end) {	        char c = value.charAt(pos);	        if (c == '\r' || c == '\n' || c == delim || c == escape) {	            if (pos > start) {	                out.append(value, start, pos);	            }	            if (c == '\n') {	                c = 'n';	            } else if (c == '\r') {	                c = 'r';	            }	            out.append(escape);	            out.append(c);	            start = pos + 1;	        }	        pos++;	    }	    if (pos > start) {	        out.append(value, start, pos);	    }	}
void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {	    boolean first = newLine;	    boolean quote = false;	    int start = offset;	    int pos = offset;	    int end = offset + len;	    printSep();	    char delim = format.getDelimiter();	    char encapsulator = format.getEncapsulator();	    if (len <= 0) {	        if (first) {	            quote = true;	        }	    } else {	        char c = value.charAt(pos);	        if (first && (c < '0' || (c > '9' && c < 'A') || (c > 'Z' && c < 'a') || (c > 'z'))) {	            quote = true;	        } else if (c <= '#') {	            quote = true;	        } else {	            while (pos < end) {	                c = value.charAt(pos);	                if (c == '\n' || c == '\r' || c == encapsulator || c == delim) {	                    quote = true;	                    break;	                }	                pos++;	            }	            if (!quote) {	                pos = end - 1;	                c = value.charAt(pos);	                if (c <= ' ') {	                    quote = true;	                }	            }	        }	    }	    if (!quote) {	        out.append(value, start, end);	        return;	    }	    out.append(encapsulator);	    while (pos < end) {	        char c = value.charAt(pos);	        if (c == encapsulator) {	            out.append(value, start, pos + 1);	            start = pos;	        }	        pos++;	    }	    out.append(value, start, pos);	    out.append(encapsulator);	}
public void print(String value, boolean checkForEscape) throws IOException {	    if (value == null) {	        value = "";	    }	    if (!checkForEscape) {	        printSep();	        out.append(value);	    } else {	        print(value, 0, value.length());	    }	}
public void print(String value) throws IOException {	    print(value, true);	}
Token reset() {	    content.setLength(0);	    type = INVALID;	    isReady = false;	    return this;	}
@Override	public int read() throws IOException {	    int current = super.read();	    if (current == '\n') {	        lineCounter++;	    }	    lastChar = current;	    return lastChar;	}
int readAgain() {	    return lastChar;	}
@Override	public int read(char[] buf, int offset, int length) throws IOException {	    if (length == 0) {	        return 0;	    }	    int len = super.read(buf, offset, length);	    if (len > 0) {	        for (int i = offset; i < offset + len; i++) {	            char ch = buf[i];	            if (ch == '\n') {	                if ('\r' != (i > 0 ? buf[i - 1] : lastChar)) {	                    lineCounter++;	                }	            } else if (ch == '\r') {	                lineCounter++;	            }	        }	        lastChar = buf[offset + len - 1];	    } else if (len == -1) {	        lastChar = END_OF_STREAM;	    }	    return len;	}
@Override	public String readLine() throws IOException {	    String line = super.readLine();	    if (line != null) {	        if (line.length() > 0) {	            lastChar = line.charAt(line.length() - 1);	        }	        lineCounter++;	    } else {	        lastChar = END_OF_STREAM;	    }	    return line;	}
int lookAhead() throws IOException {	    super.mark(1);	    int c = super.read();	    super.reset();	    return c;	}
int getLineNumber() {	    return lineCounter;	}
@Override	Token nextToken(Token tkn) throws IOException {	    int lastChar = in.readAgain();	    int c = in.read();	    boolean eol = isEndOfLine(c);	    c = in.readAgain();	    if (emptyLinesIgnored) {	        while (eol && (lastChar == '\n' || lastChar == '\r' || lastChar == ExtendedBufferedReader.UNDEFINED) && !isEndOfFile(lastChar)) {	            lastChar = c;	            c = in.read();	            eol = isEndOfLine(c);	            c = in.readAgain();	            if (isEndOfFile(c)) {	                tkn.type = EOF;	                return tkn;	            }	        }	    }	    if (isEndOfFile(lastChar) || (!isDelimiter(lastChar) && isEndOfFile(c))) {	        tkn.type = EOF;	        return tkn;	    }	    while (tkn.type == INVALID) {	        if (surroundingSpacesIgnored) {	            while (isWhitespace(c) && !eol) {	                c = in.read();	                eol = isEndOfLine(c);	            }	        }	        if (isCommentStart(c)) {	            in.readLine();	            tkn = nextToken(tkn.reset());	        } else if (isDelimiter(c)) {	            tkn.type = TOKEN;	        } else if (eol) {	            tkn.type = EORECORD;	        } else if (isEncapsulator(c)) {	            encapsulatedTokenLexer(tkn, c);	        } else if (isEndOfFile(c)) {	            tkn.type = EOF;	            tkn.isReady = true;	        } else {	            simpleTokenLexer(tkn, c);	        }	    }	    return tkn;	}
private Token simpleTokenLexer(Token tkn, int c) throws IOException {	    while (true) {	        if (isEndOfLine(c)) {	            tkn.type = EORECORD;	            break;	        } else if (isEndOfFile(c)) {	            tkn.type = EOF;	            tkn.isReady = true;	            break;	        } else if (isDelimiter(c)) {	            tkn.type = TOKEN;	            break;	        } else if (isEscape(c)) {	            tkn.content.append((char) readEscape(c));	        } else {	            tkn.content.append((char) c);	        }	        c = in.read();	    }	    if (surroundingSpacesIgnored) {	        trimTrailingSpaces(tkn.content);	    }	    return tkn;	}
private Token encapsulatedTokenLexer(Token tkn, int c) throws IOException {	    int startLineNumber = getLineNumber();	    while (true) {	        c = in.read();	        if (isEscape(c)) {	            tkn.content.append((char) readEscape(c));	        } else if (isEncapsulator(c)) {	            if (isEncapsulator(in.lookAhead())) {	                c = in.read();	                tkn.content.append((char) c);	            } else {	                while (true) {	                    c = in.read();	                    if (isDelimiter(c)) {	                        tkn.type = TOKEN;	                        return tkn;	                    } else if (isEndOfFile(c)) {	                        tkn.type = EOF;	                        tkn.isReady = true;	                        return tkn;	                    } else if (isEndOfLine(c)) {	                        tkn.type = EORECORD;	                        return tkn;	                    } else if (!isWhitespace(c)) {	                        throw new IOException("(line " + getLineNumber() + ") invalid char between encapsulated token and delimiter");	                    }	                }	            }	        } else if (isEndOfFile(c)) {	            throw new IOException("(startline " + startLineNumber + ") EOF reached before encapsulated token finished");	        } else {	            tkn.content.append((char) c);	        }	    }	}
