private void init() { [EOL]     final List<Rule> rulesList = parsePattern(); [EOL]     mRules = rulesList.toArray(new Rule[rulesList.size()]); [EOL]     int len = 0; [EOL]     for (int i = mRules.length; --i >= 0; ) { [EOL]         len += mRules[i].estimateLength(); [EOL]     } [EOL]     mMaxLengthEstimate = len; [EOL] }
protected List<Rule> parsePattern() { [EOL]     final DateFormatSymbols symbols = new DateFormatSymbols(mLocale); [EOL]     final List<Rule> rules = new ArrayList<Rule>(); [EOL]     final String[] ERAs = symbols.getEras(); [EOL]     final String[] months = symbols.getMonths(); [EOL]     final String[] shortMonths = symbols.getShortMonths(); [EOL]     final String[] weekdays = symbols.getWeekdays(); [EOL]     final String[] shortWeekdays = symbols.getShortWeekdays(); [EOL]     final String[] AmPmStrings = symbols.getAmPmStrings(); [EOL]     final int length = mPattern.length(); [EOL]     final int[] indexRef = new int[1]; [EOL]     for (int i = 0; i < length; i++) { [EOL]         indexRef[0] = i; [EOL]         final String token = parseToken(mPattern, indexRef); [EOL]         i = indexRef[0]; [EOL]         final int tokenLen = token.length(); [EOL]         if (tokenLen == 0) { [EOL]             break; [EOL]         } [EOL]         Rule rule; [EOL]         final char c = token.charAt(0); [EOL]         switch(c) { [EOL]             case 'G': [EOL]                 rule = new TextField(Calendar.ERA, ERAs); [EOL]                 break; [EOL]             case 'y': [EOL]                 if (tokenLen == 2) { [EOL]                     rule = TwoDigitYearField.INSTANCE; [EOL]                 } else { [EOL]                     rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen); [EOL]                 } [EOL]                 break; [EOL]             case 'M': [EOL]                 if (tokenLen >= 4) { [EOL]                     rule = new TextField(Calendar.MONTH, months); [EOL]                 } else if (tokenLen == 3) { [EOL]                     rule = new TextField(Calendar.MONTH, shortMonths); [EOL]                 } else if (tokenLen == 2) { [EOL]                     rule = TwoDigitMonthField.INSTANCE; [EOL]                 } else { [EOL]                     rule = UnpaddedMonthField.INSTANCE; [EOL]                 } [EOL]                 break; [EOL]             case 'd': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'h': [EOL]                 rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen)); [EOL]                 break; [EOL]             case 'H': [EOL]                 rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen); [EOL]                 break; [EOL]             case 'm': [EOL]                 rule = selectNumberRule(Calendar.MINUTE, tokenLen); [EOL]                 break; [EOL]             case 's': [EOL]                 rule = selectNumberRule(Calendar.SECOND, tokenLen); [EOL]                 break; [EOL]             case 'S': [EOL]                 rule = selectNumberRule(Calendar.MILLISECOND, tokenLen); [EOL]                 break; [EOL]             case 'E': [EOL]                 rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays); [EOL]                 break; [EOL]             case 'D': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen); [EOL]                 break; [EOL]             case 'F': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'w': [EOL]                 rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen); [EOL]                 break; [EOL]             case 'W': [EOL]                 rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'a': [EOL]                 rule = new TextField(Calendar.AM_PM, AmPmStrings); [EOL]                 break; [EOL]             case 'k': [EOL]                 rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen)); [EOL]                 break; [EOL]             case 'K': [EOL]                 rule = selectNumberRule(Calendar.HOUR, tokenLen); [EOL]                 break; [EOL]             case 'z': [EOL]                 if (tokenLen >= 4) { [EOL]                     rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG); [EOL]                 } else { [EOL]                     rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT); [EOL]                 } [EOL]                 break; [EOL]             case 'Z': [EOL]                 if (tokenLen == 1) { [EOL]                     rule = TimeZoneNumberRule.INSTANCE_NO_COLON; [EOL]                 } else { [EOL]                     rule = TimeZoneNumberRule.INSTANCE_COLON; [EOL]                 } [EOL]                 break; [EOL]             case '\'': [EOL]                 final String sub = token.substring(1); [EOL]                 if (sub.length() == 1) { [EOL]                     rule = new CharacterLiteral(sub.charAt(0)); [EOL]                 } else { [EOL]                     rule = new StringLiteral(sub); [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 throw new IllegalArgumentException("Illegal pattern component: " + token); [EOL]         } [EOL]         rules.add(rule); [EOL]     } [EOL]     return rules; [EOL] }
protected String parseToken(final String pattern, final int[] indexRef) { [EOL]     final StringBuilder buf = new StringBuilder(); [EOL]     int i = indexRef[0]; [EOL]     final int length = pattern.length(); [EOL]     char c = pattern.charAt(i); [EOL]     if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') { [EOL]         buf.append(c); [EOL]         while (i + 1 < length) { [EOL]             final char peek = pattern.charAt(i + 1); [EOL]             if (peek == c) { [EOL]                 buf.append(c); [EOL]                 i++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         buf.append('\''); [EOL]         boolean inLiteral = false; [EOL]         for (; i < length; i++) { [EOL]             c = pattern.charAt(i); [EOL]             if (c == '\'') { [EOL]                 if (i + 1 < length && pattern.charAt(i + 1) == '\'') { [EOL]                     i++; [EOL]                     buf.append(c); [EOL]                 } else { [EOL]                     inLiteral = !inLiteral; [EOL]                 } [EOL]             } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) { [EOL]                 i--; [EOL]                 break; [EOL]             } else { [EOL]                 buf.append(c); [EOL]             } [EOL]         } [EOL]     } [EOL]     indexRef[0] = i; [EOL]     return buf.toString(); [EOL] }
protected NumberRule selectNumberRule(final int field, final int padding) { [EOL]     switch(padding) { [EOL]         case 1: [EOL]             return new UnpaddedNumberField(field); [EOL]         case 2: [EOL]             return new TwoDigitNumberField(field); [EOL]         default: [EOL]             return new PaddedNumberField(field, padding); [EOL]     } [EOL] }
@Override [EOL] public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) { [EOL]     if (obj instanceof Date) { [EOL]         return format((Date) obj, toAppendTo); [EOL]     } else if (obj instanceof Calendar) { [EOL]         return format((Calendar) obj, toAppendTo); [EOL]     } else if (obj instanceof Long) { [EOL]         return format(((Long) obj).longValue(), toAppendTo); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Unknown class: " + (obj == null ? "<null>" : obj.getClass().getName())); [EOL]     } [EOL] }
@Override [EOL] public String format(final long millis) { [EOL]     final Calendar c = newCalendar(); [EOL]     c.setTimeInMillis(millis); [EOL]     return applyRulesToString(c); [EOL] }
private String applyRulesToString(final Calendar c) { [EOL]     return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString(); [EOL] }
private GregorianCalendar newCalendar() { [EOL]     return new GregorianCalendar(mTimeZone, mLocale); [EOL] }
@Override [EOL] public String format(final Date date) { [EOL]     final Calendar c = newCalendar(); [EOL]     c.setTime(date); [EOL]     return applyRulesToString(c); [EOL] }
@Override [EOL] public String format(final Calendar calendar) { [EOL]     return format(calendar, new StringBuffer(mMaxLengthEstimate)).toString(); [EOL] }
@Override [EOL] public StringBuffer format(final long millis, final StringBuffer buf) { [EOL]     return format(new Date(millis), buf); [EOL] }
@Override [EOL] public StringBuffer format(final Date date, final StringBuffer buf) { [EOL]     final Calendar c = newCalendar(); [EOL]     c.setTime(date); [EOL]     return applyRules(c, buf); [EOL] }
@Override [EOL] public StringBuffer format(final Calendar calendar, final StringBuffer buf) { [EOL]     return applyRules(calendar, buf); [EOL] }
protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf) { [EOL]     for (final Rule rule : mRules) { [EOL]         rule.appendTo(buf, calendar); [EOL]     } [EOL]     return buf; [EOL] }
@Override [EOL] public String getPattern() { [EOL]     return mPattern; [EOL] }
@Override [EOL] public TimeZone getTimeZone() { [EOL]     return mTimeZone; [EOL] }
@Override [EOL] public Locale getLocale() { [EOL]     return mLocale; [EOL] }
public int getMaxLengthEstimate() { [EOL]     return mMaxLengthEstimate; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof FastDatePrinter == false) { [EOL]         return false; [EOL]     } [EOL]     final FastDatePrinter other = (FastDatePrinter) obj; [EOL]     return mPattern.equals(other.mPattern) && mTimeZone.equals(other.mTimeZone) && mLocale.equals(other.mLocale); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return mPattern.hashCode() + 13 * (mTimeZone.hashCode() + 13 * mLocale.hashCode()); [EOL] }
@Override [EOL] public String toString() { [EOL]     return "FastDatePrinter[" + mPattern + "," + mLocale + "," + mTimeZone.getID() + "]"; [EOL] }
private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException { [EOL]     in.defaultReadObject(); [EOL]     init(); [EOL] }
int estimateLength();
void appendTo(StringBuffer buffer, Calendar calendar);
void appendTo(StringBuffer buffer, int value);
@Override [EOL] public int estimateLength() { [EOL]     return 1; [EOL] }
@Override [EOL] public void appendTo(final StringBuffer buffer, final Calendar calendar) { [EOL]     buffer.append(mValue); [EOL] }
@Override [EOL] public int estimateLength() { [EOL]     return mValue.length(); [EOL] }
@Override [EOL] public void appendTo(final StringBuffer buffer, final Calendar calendar) { [EOL]     buffer.append(mValue); [EOL] }
@Override [EOL] public int estimateLength() { [EOL]     int max = 0; [EOL]     for (int i = mValues.length; --i >= 0; ) { [EOL]         final int len = mValues[i].length(); [EOL]         if (len > max) { [EOL]             max = len; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
@Override [EOL] public void appendTo(final StringBuffer buffer, final Calendar calendar) { [EOL]     buffer.append(mValues[calendar.get(mField)]); [EOL] }
@Override [EOL] public int estimateLength() { [EOL]     return 4; [EOL] }
@Override [EOL] public void appendTo(final StringBuffer buffer, final Calendar calendar) { [EOL]     appendTo(buffer, calendar.get(mField)); [EOL] }
@Override [EOL] public final void appendTo(final StringBuffer buffer, final int value) { [EOL]     if (value < 10) { [EOL]         buffer.append((char) (value + '0')); [EOL]     } else if (value < 100) { [EOL]         buffer.append((char) (value / 10 + '0')); [EOL]         buffer.append((char) (value % 10 + '0')); [EOL]     } else { [EOL]         buffer.append(Integer.toString(value)); [EOL]     } [EOL] }
@Override [EOL] public int estimateLength() { [EOL]     return 2; [EOL] }
@Override [EOL] public void appendTo(final StringBuffer buffer, final Calendar calendar) { [EOL]     appendTo(buffer, calendar.get(Calendar.MONTH) + 1); [EOL] }
@Override [EOL] public final void appendTo(final StringBuffer buffer, final int value) { [EOL]     if (value < 10) { [EOL]         buffer.append((char) (value + '0')); [EOL]     } else { [EOL]         buffer.append((char) (value / 10 + '0')); [EOL]         buffer.append((char) (value % 10 + '0')); [EOL]     } [EOL] }
@Override [EOL] public int estimateLength() { [EOL]     return 4; [EOL] }
@Override [EOL] public void appendTo(final StringBuffer buffer, final Calendar calendar) { [EOL]     appendTo(buffer, calendar.get(mField)); [EOL] }
@Override [EOL] public final void appendTo(final StringBuffer buffer, final int value) { [EOL]     if (value < 100) { [EOL]         for (int i = mSize; --i >= 2; ) { [EOL]             buffer.append('0'); [EOL]         } [EOL]         buffer.append((char) (value / 10 + '0')); [EOL]         buffer.append((char) (value % 10 + '0')); [EOL]     } else { [EOL]         int digits; [EOL]         if (value < 1000) { [EOL]             digits = 3; [EOL]         } else { [EOL]             Validate.isTrue(value > -1, "Negative values should not be possible", value); [EOL]             digits = Integer.toString(value).length(); [EOL]         } [EOL]         for (int i = mSize; --i >= digits; ) { [EOL]             buffer.append('0'); [EOL]         } [EOL]         buffer.append(Integer.toString(value)); [EOL]     } [EOL] }
@Override [EOL] public int estimateLength() { [EOL]     return 2; [EOL] }
@Override [EOL] public void appendTo(final StringBuffer buffer, final Calendar calendar) { [EOL]     appendTo(buffer, calendar.get(mField)); [EOL] }
@Override [EOL] public final void appendTo(final StringBuffer buffer, final int value) { [EOL]     if (value < 100) { [EOL]         buffer.append((char) (value / 10 + '0')); [EOL]         buffer.append((char) (value % 10 + '0')); [EOL]     } else { [EOL]         buffer.append(Integer.toString(value)); [EOL]     } [EOL] }
@Override [EOL] public int estimateLength() { [EOL]     return 2; [EOL] }
@Override [EOL] public void appendTo(final StringBuffer buffer, final Calendar calendar) { [EOL]     appendTo(buffer, calendar.get(Calendar.YEAR) % 100); [EOL] }
@Override [EOL] public final void appendTo(final StringBuffer buffer, final int value) { [EOL]     buffer.append((char) (value / 10 + '0')); [EOL]     buffer.append((char) (value % 10 + '0')); [EOL] }
@Override [EOL] public int estimateLength() { [EOL]     return 2; [EOL] }
@Override [EOL] public void appendTo(final StringBuffer buffer, final Calendar calendar) { [EOL]     appendTo(buffer, calendar.get(Calendar.MONTH) + 1); [EOL] }
@Override [EOL] public final void appendTo(final StringBuffer buffer, final int value) { [EOL]     buffer.append((char) (value / 10 + '0')); [EOL]     buffer.append((char) (value % 10 + '0')); [EOL] }
@Override [EOL] public int estimateLength() { [EOL]     return mRule.estimateLength(); [EOL] }
@Override [EOL] public void appendTo(final StringBuffer buffer, final Calendar calendar) { [EOL]     int value = calendar.get(Calendar.HOUR); [EOL]     if (value == 0) { [EOL]         value = calendar.getLeastMaximum(Calendar.HOUR) + 1; [EOL]     } [EOL]     mRule.appendTo(buffer, value); [EOL] }
@Override [EOL] public void appendTo(final StringBuffer buffer, final int value) { [EOL]     mRule.appendTo(buffer, value); [EOL] }
@Override [EOL] public int estimateLength() { [EOL]     return mRule.estimateLength(); [EOL] }
@Override [EOL] public void appendTo(final StringBuffer buffer, final Calendar calendar) { [EOL]     int value = calendar.get(Calendar.HOUR_OF_DAY); [EOL]     if (value == 0) { [EOL]         value = calendar.getMaximum(Calendar.HOUR_OF_DAY) + 1; [EOL]     } [EOL]     mRule.appendTo(buffer, value); [EOL] }
@Override [EOL] public void appendTo(final StringBuffer buffer, final int value) { [EOL]     mRule.appendTo(buffer, value); [EOL] }
static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale) { [EOL]     final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale); [EOL]     String value = cTimeZoneDisplayCache.get(key); [EOL]     if (value == null) { [EOL]         value = tz.getDisplayName(daylight, style, locale); [EOL]         final String prior = cTimeZoneDisplayCache.putIfAbsent(key, value); [EOL]         if (prior != null) { [EOL]             value = prior; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
@Override [EOL] public int estimateLength() { [EOL]     return Math.max(mStandard.length(), mDaylight.length()); [EOL] }
@Override [EOL] public void appendTo(final StringBuffer buffer, final Calendar calendar) { [EOL]     final TimeZone zone = calendar.getTimeZone(); [EOL]     if (zone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) { [EOL]         buffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale)); [EOL]     } else { [EOL]         buffer.append(getTimeZoneDisplay(zone, false, mStyle, mLocale)); [EOL]     } [EOL] }
@Override [EOL] public int estimateLength() { [EOL]     return 5; [EOL] }
@Override [EOL] public void appendTo(final StringBuffer buffer, final Calendar calendar) { [EOL]     int offset = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET); [EOL]     if (offset < 0) { [EOL]         buffer.append('-'); [EOL]         offset = -offset; [EOL]     } else { [EOL]         buffer.append('+'); [EOL]     } [EOL]     final int hours = offset / (60 * 60 * 1000); [EOL]     buffer.append((char) (hours / 10 + '0')); [EOL]     buffer.append((char) (hours % 10 + '0')); [EOL]     if (mColon) { [EOL]         buffer.append(':'); [EOL]     } [EOL]     final int minutes = offset / (60 * 1000) - 60 * hours; [EOL]     buffer.append((char) (minutes / 10 + '0')); [EOL]     buffer.append((char) (minutes % 10 + '0')); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return (mStyle * 31 + mLocale.hashCode()) * 31 + mTimeZone.hashCode(); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof TimeZoneDisplayKey) { [EOL]         final TimeZoneDisplayKey other = (TimeZoneDisplayKey) obj; [EOL]         return mTimeZone.equals(other.mTimeZone) && mStyle == other.mStyle && mLocale.equals(other.mLocale); [EOL]     } [EOL]     return false; [EOL] }
