private static StrTokenizer getCSVClone() { [EOL]     return (StrTokenizer) CSV_TOKENIZER_PROTOTYPE.clone(); [EOL] }
public static StrTokenizer getCSVInstance() { [EOL]     return getCSVClone(); [EOL] }
public static StrTokenizer getCSVInstance(final String input) { [EOL]     final StrTokenizer tok = getCSVClone(); [EOL]     tok.reset(input); [EOL]     return tok; [EOL] }
public static StrTokenizer getCSVInstance(final char[] input) { [EOL]     final StrTokenizer tok = getCSVClone(); [EOL]     tok.reset(input); [EOL]     return tok; [EOL] }
private static StrTokenizer getTSVClone() { [EOL]     return (StrTokenizer) TSV_TOKENIZER_PROTOTYPE.clone(); [EOL] }
public static StrTokenizer getTSVInstance() { [EOL]     return getTSVClone(); [EOL] }
public static StrTokenizer getTSVInstance(final String input) { [EOL]     final StrTokenizer tok = getTSVClone(); [EOL]     tok.reset(input); [EOL]     return tok; [EOL] }
public static StrTokenizer getTSVInstance(final char[] input) { [EOL]     final StrTokenizer tok = getTSVClone(); [EOL]     tok.reset(input); [EOL]     return tok; [EOL] }
public int size() { [EOL]     checkTokenized(); [EOL]     return tokens.length; [EOL] }
public String nextToken() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     return null; [EOL] }
public String previousToken() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     return null; [EOL] }
public String[] getTokenArray() { [EOL]     checkTokenized(); [EOL]     return tokens.clone(); [EOL] }
public List<String> getTokenList() { [EOL]     checkTokenized(); [EOL]     final List<String> list = new ArrayList<String>(tokens.length); [EOL]     for (final String element : tokens) { [EOL]         list.add(element); [EOL]     } [EOL]     return list; [EOL] }
public StrTokenizer reset() { [EOL]     tokenPos = 0; [EOL]     tokens = null; [EOL]     return this; [EOL] }
public StrTokenizer reset(final String input) { [EOL]     reset(); [EOL]     if (input != null) { [EOL]         this.chars = input.toCharArray(); [EOL]     } else { [EOL]         this.chars = null; [EOL]     } [EOL]     return this; [EOL] }
public StrTokenizer reset(final char[] input) { [EOL]     reset(); [EOL]     this.chars = ArrayUtils.clone(input); [EOL]     return this; [EOL] }
@Override [EOL] public boolean hasNext() { [EOL]     checkTokenized(); [EOL]     return tokenPos < tokens.length; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public boolean hasPrevious() { [EOL]     checkTokenized(); [EOL]     return tokenPos > 0; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
@Override [EOL] public void remove() { [EOL]     throw new UnsupportedOperationException("remove() is unsupported"); [EOL] }
@Override [EOL] public void set(final String obj) { [EOL]     throw new UnsupportedOperationException("set() is unsupported"); [EOL] }
@Override [EOL] public void add(final String obj) { [EOL]     throw new UnsupportedOperationException("add() is unsupported"); [EOL] }
private void checkTokenized() { [EOL]     if (tokens == null) { [EOL]         if (chars == null) { [EOL]             final List<String> split = tokenize(null, 0, 0); [EOL]             tokens = split.toArray(new String[split.size()]); [EOL]         } else { [EOL]             final List<String> split = tokenize(chars, 0, chars.length); [EOL]             tokens = split.toArray(new String[split.size()]); [EOL]         } [EOL]     } [EOL] }
protected List<String> tokenize(final char[] chars, final int offset, final int count) { [EOL]     if (chars == null || count == 0) { [EOL]         return Collections.emptyList(); [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(); [EOL]     final List<String> tokens = new ArrayList<String>(); [EOL]     int pos = offset; [EOL]     while (pos >= 0 && pos < count) { [EOL]         pos = readNextToken(chars, pos, count, buf, tokens); [EOL]         if (pos >= count) { [EOL]             addToken(tokens, ""); [EOL]         } [EOL]     } [EOL]     return tokens; [EOL] }
private void addToken(final List<String> list, String tok) { [EOL]     if (StringUtils.isEmpty(tok)) { [EOL]         if (isIgnoreEmptyTokens()) { [EOL]             return; [EOL]         } [EOL]         if (isEmptyTokenAsNull()) { [EOL]             tok = null; [EOL]         } [EOL]     } [EOL]     list.add(tok); [EOL] }
private int readNextToken(final char[] chars, int start, final int len, final StrBuilder workArea, final List<String> tokens) { [EOL]     while (start < len) { [EOL]         final int removeLen = Math.max(getIgnoredMatcher().isMatch(chars, start, start, len), getTrimmerMatcher().isMatch(chars, start, start, len)); [EOL]         if (removeLen == 0 || getDelimiterMatcher().isMatch(chars, start, start, len) > 0 || getQuoteMatcher().isMatch(chars, start, start, len) > 0) { [EOL]             break; [EOL]         } [EOL]         start += removeLen; [EOL]     } [EOL]     if (start >= len) { [EOL]         addToken(tokens, ""); [EOL]         return -1; [EOL]     } [EOL]     final int delimLen = getDelimiterMatcher().isMatch(chars, start, start, len); [EOL]     if (delimLen > 0) { [EOL]         addToken(tokens, ""); [EOL]         return start + delimLen; [EOL]     } [EOL]     final int quoteLen = getQuoteMatcher().isMatch(chars, start, start, len); [EOL]     if (quoteLen > 0) { [EOL]         return readWithQuotes(chars, start + quoteLen, len, workArea, tokens, start, quoteLen); [EOL]     } [EOL]     return readWithQuotes(chars, start, len, workArea, tokens, 0, 0); [EOL] }
private int readWithQuotes(final char[] chars, final int start, final int len, final StrBuilder workArea, final List<String> tokens, final int quoteStart, final int quoteLen) { [EOL]     workArea.clear(); [EOL]     int pos = start; [EOL]     boolean quoting = quoteLen > 0; [EOL]     int trimStart = 0; [EOL]     while (pos < len) { [EOL]         if (quoting) { [EOL]             if (isQuote(chars, pos, len, quoteStart, quoteLen)) { [EOL]                 if (isQuote(chars, pos + quoteLen, len, quoteStart, quoteLen)) { [EOL]                     workArea.append(chars, pos, quoteLen); [EOL]                     pos += quoteLen * 2; [EOL]                     trimStart = workArea.size(); [EOL]                     continue; [EOL]                 } [EOL]                 quoting = false; [EOL]                 pos += quoteLen; [EOL]                 continue; [EOL]             } [EOL]             workArea.append(chars[pos++]); [EOL]             trimStart = workArea.size(); [EOL]         } else { [EOL]             final int delimLen = getDelimiterMatcher().isMatch(chars, pos, start, len); [EOL]             if (delimLen > 0) { [EOL]                 addToken(tokens, workArea.substring(0, trimStart)); [EOL]                 return pos + delimLen; [EOL]             } [EOL]             if (quoteLen > 0 && isQuote(chars, pos, len, quoteStart, quoteLen)) { [EOL]                 quoting = true; [EOL]                 pos += quoteLen; [EOL]                 continue; [EOL]             } [EOL]             final int ignoredLen = getIgnoredMatcher().isMatch(chars, pos, start, len); [EOL]             if (ignoredLen > 0) { [EOL]                 pos += ignoredLen; [EOL]                 continue; [EOL]             } [EOL]             final int trimmedLen = getTrimmerMatcher().isMatch(chars, pos, start, len); [EOL]             if (trimmedLen > 0) { [EOL]                 workArea.append(chars, pos, trimmedLen); [EOL]                 pos += trimmedLen; [EOL]                 continue; [EOL]             } [EOL]             workArea.append(chars[pos++]); [EOL]             trimStart = workArea.size(); [EOL]         } [EOL]     } [EOL]     addToken(tokens, workArea.substring(0, trimStart)); [EOL]     return -1; [EOL] }
private boolean isQuote(final char[] chars, final int pos, final int len, final int quoteStart, final int quoteLen) { [EOL]     for (int i = 0; i < quoteLen; i++) { [EOL]         if (pos + i >= len || chars[pos + i] != chars[quoteStart + i]) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public StrMatcher getDelimiterMatcher() { [EOL]     return this.delimMatcher; [EOL] }
public StrTokenizer setDelimiterMatcher(final StrMatcher delim) { [EOL]     if (delim == null) { [EOL]         this.delimMatcher = StrMatcher.noneMatcher(); [EOL]     } else { [EOL]         this.delimMatcher = delim; [EOL]     } [EOL]     return this; [EOL] }
public StrTokenizer setDelimiterChar(final char delim) { [EOL]     return setDelimiterMatcher(StrMatcher.charMatcher(delim)); [EOL] }
public StrTokenizer setDelimiterString(final String delim) { [EOL]     return setDelimiterMatcher(StrMatcher.stringMatcher(delim)); [EOL] }
public StrMatcher getQuoteMatcher() { [EOL]     return quoteMatcher; [EOL] }
public StrTokenizer setQuoteMatcher(final StrMatcher quote) { [EOL]     if (quote != null) { [EOL]         this.quoteMatcher = quote; [EOL]     } [EOL]     return this; [EOL] }
public StrTokenizer setQuoteChar(final char quote) { [EOL]     return setQuoteMatcher(StrMatcher.charMatcher(quote)); [EOL] }
public StrMatcher getIgnoredMatcher() { [EOL]     return ignoredMatcher; [EOL] }
public StrTokenizer setIgnoredMatcher(final StrMatcher ignored) { [EOL]     if (ignored != null) { [EOL]         this.ignoredMatcher = ignored; [EOL]     } [EOL]     return this; [EOL] }
public StrTokenizer setIgnoredChar(final char ignored) { [EOL]     return setIgnoredMatcher(StrMatcher.charMatcher(ignored)); [EOL] }
public StrMatcher getTrimmerMatcher() { [EOL]     return trimmerMatcher; [EOL] }
public StrTokenizer setTrimmerMatcher(final StrMatcher trimmer) { [EOL]     if (trimmer != null) { [EOL]         this.trimmerMatcher = trimmer; [EOL]     } [EOL]     return this; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public StrTokenizer setEmptyTokenAsNull(final boolean emptyAsNull) { [EOL]     this.emptyAsNull = emptyAsNull; [EOL]     return this; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
public StrTokenizer setIgnoreEmptyTokens(final boolean ignoreEmptyTokens) { [EOL]     this.ignoreEmptyTokens = ignoreEmptyTokens; [EOL]     return this; [EOL] }
public String getContent() { [EOL]     if (chars == null) { [EOL]         return null; [EOL]     } [EOL]     return new String(chars); [EOL] }
@Override [EOL] public Object clone() { [EOL]     try { [EOL]         return cloneReset(); [EOL]     } catch (final CloneNotSupportedException ex) { [EOL]         return null; [EOL]     } [EOL] }
Object cloneReset() throws CloneNotSupportedException { [EOL]     final StrTokenizer cloned = (StrTokenizer) super.clone(); [EOL]     if (cloned.chars != null) { [EOL]         cloned.chars = cloned.chars.clone(); [EOL]     } [EOL]     cloned.reset(); [EOL]     return cloned; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (tokens == null) { [EOL]         return "StrTokenizer[not tokenized yet]"; [EOL]     } [EOL]     return "StrTokenizer" + getTokenList(); [EOL] }
