public List<CSVRecord> getRecords() throws IOException {	    List<CSVRecord> records = new ArrayList<CSVRecord>();	    CSVRecord rec;	    while ((rec = getRecord()) != null) {	        records.add(rec);	    }	    return records;	}
CSVRecord getRecord() throws IOException {	    CSVRecord result = new CSVRecord(null, headerMapping);	    record.clear();	    do {	        reusableToken.reset();	        lexer.nextToken(reusableToken);	        switch(reusableToken.type) {	            case TOKEN:	                record.add(reusableToken.content.toString());	                break;	            case EORECORD:	                record.add(reusableToken.content.toString());	                break;	            case EOF:	                if (reusableToken.isReady) {	                    record.add(reusableToken.content.toString());	                } else {	                    result = null;	                }	                break;	            case INVALID:	                throw new IOException("(line " + getLineNumber() + ") invalid parse sequence");	        }	    } while (reusableToken.type == TOKEN);	    if (!record.isEmpty()) {	        result = new CSVRecord(record.toArray(new String[record.size()]), headerMapping);	    }	    return result;	}
private Map<String, Integer> initializeHeader(CSVFormat format) throws IOException {	    Map<String, Integer> hdrMap = null;	    if (format.getHeader() != null) {	        hdrMap = new HashMap<String, Integer>();	        String[] header = null;	        if (format.getHeader().length == 0) {	            CSVRecord rec = getRecord();	            if (rec != null) {	                header = rec.values();	            }	        } else {	            header = format.getHeader();	        }	        if (header != null) {	            for (int i = 0; i < header.length; i++) {	                hdrMap.put(header[i], Integer.valueOf(i));	            }	        }	    }	    return hdrMap;	}
public boolean hasNext() {	    if (current == null) {	        current = getNextRecord();	    }	    return current != null;	}
public CSVRecord next() {	    CSVRecord next = current;	    current = null;	    if (next == null) {	        next = getNextRecord();	        if (next == null) {	            throw new NoSuchElementException("No more CSV records available");	        }	    }	    return next;	}
private CSVRecord getNextRecord() {	    try {	        return getRecord();	    } catch (IOException e) {	        throw new RuntimeException(e);	    }	}
public void remove() {	    throw new UnsupportedOperationException();	}
public Iterator<CSVRecord> iterator() {	    return new Iterator<CSVRecord>() {		        private CSVRecord current;		        public boolean hasNext() {	            if (current == null) {	                current = getNextRecord();	            }	            return current != null;	        }		        public CSVRecord next() {	            CSVRecord next = current;	            current = null;	            if (next == null) {	                next = getNextRecord();	                if (next == null) {	                    throw new NoSuchElementException("No more CSV records available");	                }	            }	            return next;	        }		        private CSVRecord getNextRecord() {	            try {	                return getRecord();	            } catch (IOException e) {	                throw new RuntimeException(e);	            }	        }		        public void remove() {	            throw new UnsupportedOperationException();	        }	    };	}
public int getLineNumber() {	    return lexer.getLineNumber();	}
