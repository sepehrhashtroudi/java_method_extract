public static void isTrue(final boolean expression, final String message, final long value) { [EOL]     if (expression == false) { [EOL]         throw new IllegalArgumentException(String.format(message, Long.valueOf(value))); [EOL]     } [EOL] }
public static void isTrue(final boolean expression, final String message, final double value) { [EOL]     if (expression == false) { [EOL]         throw new IllegalArgumentException(String.format(message, Double.valueOf(value))); [EOL]     } [EOL] }
public static void isTrue(final boolean expression, final String message, final Object... values) { [EOL]     if (expression == false) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL] }
public static void isTrue(final boolean expression) { [EOL]     if (expression == false) { [EOL]         throw new IllegalArgumentException(DEFAULT_IS_TRUE_EX_MESSAGE); [EOL]     } [EOL] }
public static <T> T notNull(final T object) { [EOL]     return notNull(object, DEFAULT_IS_NULL_EX_MESSAGE); [EOL] }
public static <T> T notNull(final T object, final String message, final Object... values) { [EOL]     if (object == null) { [EOL]         throw new NullPointerException(String.format(message, values)); [EOL]     } [EOL]     return object; [EOL] }
public static <T> T[] notEmpty(final T[] array, final String message, final Object... values) { [EOL]     if (array == null) { [EOL]         throw new NullPointerException(String.format(message, values)); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL]     return array; [EOL] }
public static <T> T[] notEmpty(final T[] array) { [EOL]     return notEmpty(array, DEFAULT_NOT_EMPTY_ARRAY_EX_MESSAGE); [EOL] }
public static <T extends Collection<?>> T notEmpty(final T collection, final String message, final Object... values) { [EOL]     if (collection == null) { [EOL]         throw new NullPointerException(String.format(message, values)); [EOL]     } [EOL]     if (collection.isEmpty()) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL]     return collection; [EOL] }
public static <T extends Collection<?>> T notEmpty(final T collection) { [EOL]     return notEmpty(collection, DEFAULT_NOT_EMPTY_COLLECTION_EX_MESSAGE); [EOL] }
public static <T extends Map<?, ?>> T notEmpty(final T map, final String message, final Object... values) { [EOL]     if (map == null) { [EOL]         throw new NullPointerException(String.format(message, values)); [EOL]     } [EOL]     if (map.isEmpty()) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL]     return map; [EOL] }
public static <T extends Map<?, ?>> T notEmpty(final T map) { [EOL]     return notEmpty(map, DEFAULT_NOT_EMPTY_MAP_EX_MESSAGE); [EOL] }
public static <T extends CharSequence> T notEmpty(final T chars, final String message, final Object... values) { [EOL]     if (chars == null) { [EOL]         throw new NullPointerException(String.format(message, values)); [EOL]     } [EOL]     if (chars.length() == 0) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL]     return chars; [EOL] }
public static <T extends CharSequence> T notEmpty(final T chars) { [EOL]     return notEmpty(chars, DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE); [EOL] }
public static <T extends CharSequence> T notBlank(final T chars, final String message, final Object... values) { [EOL]     if (chars == null) { [EOL]         throw new NullPointerException(String.format(message, values)); [EOL]     } [EOL]     if (StringUtils.isBlank(chars)) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL]     return chars; [EOL] }
public static <T extends CharSequence> T notBlank(final T chars) { [EOL]     return notBlank(chars, DEFAULT_NOT_BLANK_EX_MESSAGE); [EOL] }
public static <T> T[] noNullElements(final T[] array, final String message, final Object... values) { [EOL]     Validate.notNull(array); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         if (array[i] == null) { [EOL]             final Object[] values2 = ArrayUtils.add(values, Integer.valueOf(i)); [EOL]             throw new IllegalArgumentException(String.format(message, values2)); [EOL]         } [EOL]     } [EOL]     return array; [EOL] }
public static <T> T[] noNullElements(final T[] array) { [EOL]     return noNullElements(array, DEFAULT_NO_NULL_ELEMENTS_ARRAY_EX_MESSAGE); [EOL] }
public static <T extends Iterable<?>> T noNullElements(final T iterable, final String message, final Object... values) { [EOL]     Validate.notNull(iterable); [EOL]     int i = 0; [EOL]     for (final Iterator<?> it = iterable.iterator(); it.hasNext(); i++) { [EOL]         if (it.next() == null) { [EOL]             final Object[] values2 = ArrayUtils.addAll(values, Integer.valueOf(i)); [EOL]             throw new IllegalArgumentException(String.format(message, values2)); [EOL]         } [EOL]     } [EOL]     return iterable; [EOL] }
public static <T extends Iterable<?>> T noNullElements(final T iterable) { [EOL]     return noNullElements(iterable, DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE); [EOL] }
public static <T> T[] validIndex(final T[] array, final int index, final String message, final Object... values) { [EOL]     Validate.notNull(array); [EOL]     if (index < 0 || index >= array.length) { [EOL]         throw new IndexOutOfBoundsException(String.format(message, values)); [EOL]     } [EOL]     return array; [EOL] }
public static <T> T[] validIndex(final T[] array, final int index) { [EOL]     return validIndex(array, index, DEFAULT_VALID_INDEX_ARRAY_EX_MESSAGE, Integer.valueOf(index)); [EOL] }
public static <T extends Collection<?>> T validIndex(final T collection, final int index, final String message, final Object... values) { [EOL]     Validate.notNull(collection); [EOL]     if (index < 0 || index >= collection.size()) { [EOL]         throw new IndexOutOfBoundsException(String.format(message, values)); [EOL]     } [EOL]     return collection; [EOL] }
public static <T extends Collection<?>> T validIndex(final T collection, final int index) { [EOL]     return validIndex(collection, index, DEFAULT_VALID_INDEX_COLLECTION_EX_MESSAGE, Integer.valueOf(index)); [EOL] }
public static <T extends CharSequence> T validIndex(final T chars, final int index, final String message, final Object... values) { [EOL]     Validate.notNull(chars); [EOL]     if (index < 0 || index >= chars.length()) { [EOL]         throw new IndexOutOfBoundsException(String.format(message, values)); [EOL]     } [EOL]     return chars; [EOL] }
public static <T extends CharSequence> T validIndex(final T chars, final int index) { [EOL]     return validIndex(chars, index, DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE, Integer.valueOf(index)); [EOL] }
public static void validState(final boolean expression) { [EOL]     if (expression == false) { [EOL]         throw new IllegalStateException(DEFAULT_VALID_STATE_EX_MESSAGE); [EOL]     } [EOL] }
public static void validState(final boolean expression, final String message, final Object... values) { [EOL]     if (expression == false) { [EOL]         throw new IllegalStateException(String.format(message, values)); [EOL]     } [EOL] }
public static void matchesPattern(final CharSequence input, final String pattern) { [EOL]     if (Pattern.matches(pattern, input) == false) { [EOL]         throw new IllegalArgumentException(String.format(DEFAULT_MATCHES_PATTERN_EX, input, pattern)); [EOL]     } [EOL] }
public static void matchesPattern(final CharSequence input, final String pattern, final String message, final Object... values) { [EOL]     if (Pattern.matches(pattern, input) == false) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL] }
public static <T> void inclusiveBetween(final T start, final T end, final Comparable<T> value) { [EOL]     if (value.compareTo(start) < 0 || value.compareTo(end) > 0) { [EOL]         throw new IllegalArgumentException(String.format(DEFAULT_INCLUSIVE_BETWEEN_EX_MESSAGE, value, start, end)); [EOL]     } [EOL] }
public static <T> void inclusiveBetween(final T start, final T end, final Comparable<T> value, final String message, final Object... values) { [EOL]     if (value.compareTo(start) < 0 || value.compareTo(end) > 0) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL] }
public static <T> void exclusiveBetween(final T start, final T end, final Comparable<T> value) { [EOL]     if (value.compareTo(start) <= 0 || value.compareTo(end) >= 0) { [EOL]         throw new IllegalArgumentException(String.format(DEFAULT_EXCLUSIVE_BETWEEN_EX_MESSAGE, value, start, end)); [EOL]     } [EOL] }
public static <T> void exclusiveBetween(final T start, final T end, final Comparable<T> value, final String message, final Object... values) { [EOL]     if (value.compareTo(start) <= 0 || value.compareTo(end) >= 0) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL] }
public static void isInstanceOf(final Class<?> type, final Object obj) { [EOL]     if (type.isInstance(obj) == false) { [EOL]         throw new IllegalArgumentException(String.format(DEFAULT_IS_INSTANCE_OF_EX_MESSAGE, type.getName(), obj == null ? "null" : obj.getClass().getName())); [EOL]     } [EOL] }
public static void isInstanceOf(final Class<?> type, final Object obj, final String message, final Object... values) { [EOL]     if (type.isInstance(obj) == false) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL] }
public static void isAssignableFrom(final Class<?> superType, final Class<?> type) { [EOL]     if (superType.isAssignableFrom(type) == false) { [EOL]         throw new IllegalArgumentException(String.format(DEFAULT_IS_ASSIGNABLE_EX_MESSAGE, type == null ? "null" : type.getName(), superType.getName())); [EOL]     } [EOL] }
public static void isAssignableFrom(final Class<?> superType, final Class<?> type, final String message, final Object... values) { [EOL]     if (superType.isAssignableFrom(type) == false) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL] }
