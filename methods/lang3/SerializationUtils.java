public static <T extends Serializable> T clone(final T object) { [EOL]     if (object == null) { [EOL]         return null; [EOL]     } [EOL]     final byte[] objectData = serialize(object); [EOL]     final ByteArrayInputStream bais = new ByteArrayInputStream(objectData); [EOL]     ClassLoaderAwareObjectInputStream in = null; [EOL]     try { [EOL]         in = new ClassLoaderAwareObjectInputStream(bais, object.getClass().getClassLoader()); [EOL]         @SuppressWarnings("unchecked") [EOL]         final T readObject = (T) in.readObject(); [EOL]         return readObject; [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         throw new SerializationException("ClassNotFoundException while reading cloned object data", ex); [EOL]     } catch (final IOException ex) { [EOL]         throw new SerializationException("IOException while reading cloned object data", ex); [EOL]     } finally { [EOL]         try { [EOL]             if (in != null) { [EOL]                 in.close(); [EOL]             } [EOL]         } catch (final IOException ex) { [EOL]             throw new SerializationException("IOException on closing cloned object data InputStream.", ex); [EOL]         } [EOL]     } [EOL] }
public static void serialize(final Serializable obj, final OutputStream outputStream) { [EOL]     if (outputStream == null) { [EOL]         throw new IllegalArgumentException("The OutputStream must not be null"); [EOL]     } [EOL]     ObjectOutputStream out = null; [EOL]     try { [EOL]         out = new ObjectOutputStream(outputStream); [EOL]         out.writeObject(obj); [EOL]     } catch (final IOException ex) { [EOL]         throw new SerializationException(ex); [EOL]     } finally { [EOL]         try { [EOL]             if (out != null) { [EOL]                 out.close(); [EOL]             } [EOL]         } catch (final IOException ex) { [EOL]         } [EOL]     } [EOL] }
public static byte[] serialize(final Serializable obj) { [EOL]     final ByteArrayOutputStream baos = new ByteArrayOutputStream(512); [EOL]     serialize(obj, baos); [EOL]     return baos.toByteArray(); [EOL] }
public static <T> T deserialize(final InputStream inputStream) { [EOL]     if (inputStream == null) { [EOL]         throw new IllegalArgumentException("The InputStream must not be null"); [EOL]     } [EOL]     ObjectInputStream in = null; [EOL]     try { [EOL]         in = new ObjectInputStream(inputStream); [EOL]         @SuppressWarnings("unchecked") [EOL]         final T obj = (T) in.readObject(); [EOL]         return obj; [EOL]     } catch (final ClassCastException ex) { [EOL]         throw new SerializationException(ex); [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         throw new SerializationException(ex); [EOL]     } catch (final IOException ex) { [EOL]         throw new SerializationException(ex); [EOL]     } finally { [EOL]         try { [EOL]             if (in != null) { [EOL]                 in.close(); [EOL]             } [EOL]         } catch (final IOException ex) { [EOL]         } [EOL]     } [EOL] }
public static <T> T deserialize(final byte[] objectData) { [EOL]     if (objectData == null) { [EOL]         throw new IllegalArgumentException("The byte[] must not be null"); [EOL]     } [EOL]     return SerializationUtils.<T>deserialize(new ByteArrayInputStream(objectData)); [EOL] }
@Override [EOL] protected Class<?> resolveClass(final ObjectStreamClass desc) throws IOException, ClassNotFoundException { [EOL]     final String name = desc.getName(); [EOL]     try { [EOL]         return Class.forName(name, false, classLoader); [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         try { [EOL]             return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); [EOL]         } catch (final ClassNotFoundException cnfe) { [EOL]             final Class<?> cls = primitiveTypes.get(name); [EOL]             if (cls != null) { [EOL]                 return cls; [EOL]             } else { [EOL]                 throw cnfe; [EOL]             } [EOL]         } [EOL]     } [EOL] }
