static void setAccessibleWorkaround(final AccessibleObject o) { [EOL]     if (o == null || o.isAccessible()) { [EOL]         return; [EOL]     } [EOL]     final Member m = (Member) o; [EOL]     if (Modifier.isPublic(m.getModifiers()) && isPackageAccess(m.getDeclaringClass().getModifiers())) { [EOL]         try { [EOL]             o.setAccessible(true); [EOL]         } catch (final SecurityException e) { [EOL]         } [EOL]     } [EOL] } <line_num>: 54
static boolean isPackageAccess(final int modifiers) { [EOL]     return (modifiers & ACCESS_TEST) == 0; [EOL] } <line_num>: 74
static boolean isAccessible(final Member m) { [EOL]     return m != null && Modifier.isPublic(m.getModifiers()) && !m.isSynthetic(); [EOL] } <line_num>: 83
static int compareParameterTypes(final Class<?>[] left, final Class<?>[] right, final Class<?>[] actual) { [EOL]     final float leftCost = getTotalTransformationCost(actual, left); [EOL]     final float rightCost = getTotalTransformationCost(actual, right); [EOL]     return leftCost < rightCost ? -1 : rightCost < leftCost ? 1 : 0; [EOL] } <line_num>: 99
private static float getTotalTransformationCost(final Class<?>[] srcArgs, final Class<?>[] destArgs) { [EOL]     float totalCost = 0.0f; [EOL]     for (int i = 0; i < srcArgs.length; i++) { [EOL]         Class<?> srcClass, destClass; [EOL]         srcClass = srcArgs[i]; [EOL]         destClass = destArgs[i]; [EOL]         totalCost += getObjectTransformationCost(srcClass, destClass); [EOL]     } [EOL]     return totalCost; [EOL] } <line_num>: 112
private static float getObjectTransformationCost(Class<?> srcClass, final Class<?> destClass) { [EOL]     if (destClass.isPrimitive()) { [EOL]         return getPrimitivePromotionCost(srcClass, destClass); [EOL]     } [EOL]     float cost = 0.0f; [EOL]     while (srcClass != null && !destClass.equals(srcClass)) { [EOL]         if (destClass.isInterface() && ClassUtils.isAssignable(srcClass, destClass)) { [EOL]             cost += 0.25f; [EOL]             break; [EOL]         } [EOL]         cost++; [EOL]         srcClass = srcClass.getSuperclass(); [EOL]     } [EOL]     if (srcClass == null) { [EOL]         cost += 1.5f; [EOL]     } [EOL]     return cost; [EOL] } <line_num>: 131
private static float getPrimitivePromotionCost(final Class<?> srcClass, final Class<?> destClass) { [EOL]     float cost = 0.0f; [EOL]     Class<?> cls = srcClass; [EOL]     if (!cls.isPrimitive()) { [EOL]         cost += 0.1f; [EOL]         cls = ClassUtils.wrapperToPrimitive(cls); [EOL]     } [EOL]     for (int i = 0; cls != destClass && i < ORDERED_PRIMITIVE_TYPES.length; i++) { [EOL]         if (cls == ORDERED_PRIMITIVE_TYPES[i]) { [EOL]             cost += 0.1f; [EOL]             if (i < ORDERED_PRIMITIVE_TYPES.length - 1) { [EOL]                 cls = ORDERED_PRIMITIVE_TYPES[i + 1]; [EOL]             } [EOL]         } [EOL]     } [EOL]     return cost; [EOL] } <line_num>: 166
