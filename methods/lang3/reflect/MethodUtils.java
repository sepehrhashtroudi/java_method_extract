public static Object invokeMethod(final Object object, final String methodName, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Class<?>[] parameterTypes = ClassUtils.toClass(args); [EOL]     return invokeMethod(object, methodName, args, parameterTypes); [EOL] }
public static Object invokeMethod(final Object object, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Method method = getMatchingAccessibleMethod(object.getClass(), methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         throw new NoSuchMethodException("No such accessible method: " + methodName + "() on object: " + object.getClass().getName()); [EOL]     } [EOL]     return method.invoke(object, args); [EOL] }
public static Object invokeExactMethod(final Object object, final String methodName, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Class<?>[] parameterTypes = ClassUtils.toClass(args); [EOL]     return invokeExactMethod(object, methodName, args, parameterTypes); [EOL] }
public static Object invokeExactMethod(final Object object, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     final Method method = getAccessibleMethod(object.getClass(), methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         throw new NoSuchMethodException("No such accessible method: " + methodName + "() on object: " + object.getClass().getName()); [EOL]     } [EOL]     return method.invoke(object, args); [EOL] }
public static Object invokeExactStaticMethod(final Class<?> cls, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     final Method method = getAccessibleMethod(cls, methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         throw new NoSuchMethodException("No such accessible method: " + methodName + "() on class: " + cls.getName()); [EOL]     } [EOL]     return method.invoke(null, args); [EOL] }
public static Object invokeStaticMethod(final Class<?> cls, final String methodName, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Class<?>[] parameterTypes = ClassUtils.toClass(args); [EOL]     return invokeStaticMethod(cls, methodName, args, parameterTypes); [EOL] }
public static Object invokeStaticMethod(final Class<?> cls, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Method method = getMatchingAccessibleMethod(cls, methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         throw new NoSuchMethodException("No such accessible method: " + methodName + "() on class: " + cls.getName()); [EOL]     } [EOL]     return method.invoke(null, args); [EOL] }
public static Object invokeExactStaticMethod(final Class<?> cls, final String methodName, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Class<?>[] parameterTypes = ClassUtils.toClass(args); [EOL]     return invokeExactStaticMethod(cls, methodName, args, parameterTypes); [EOL] }
public static Method getAccessibleMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     try { [EOL]         return getAccessibleMethod(cls.getMethod(methodName, parameterTypes)); [EOL]     } catch (final NoSuchMethodException e) { [EOL]         return null; [EOL]     } [EOL] }
public static Method getAccessibleMethod(Method method) { [EOL]     if (!MemberUtils.isAccessible(method)) { [EOL]         return null; [EOL]     } [EOL]     final Class<?> cls = method.getDeclaringClass(); [EOL]     if (Modifier.isPublic(cls.getModifiers())) { [EOL]         return method; [EOL]     } [EOL]     final String methodName = method.getName(); [EOL]     final Class<?>[] parameterTypes = method.getParameterTypes(); [EOL]     method = getAccessibleMethodFromInterfaceNest(cls, methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         method = getAccessibleMethodFromSuperclass(cls, methodName, parameterTypes); [EOL]     } [EOL]     return method; [EOL] }
private static Method getAccessibleMethodFromSuperclass(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     Class<?> parentClass = cls.getSuperclass(); [EOL]     while (parentClass != null) { [EOL]         if (Modifier.isPublic(parentClass.getModifiers())) { [EOL]             try { [EOL]                 return parentClass.getMethod(methodName, parameterTypes); [EOL]             } catch (final NoSuchMethodException e) { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         parentClass = parentClass.getSuperclass(); [EOL]     } [EOL]     return null; [EOL] }
private static Method getAccessibleMethodFromInterfaceNest(Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     Method method = null; [EOL]     for (; cls != null; cls = cls.getSuperclass()) { [EOL]         final Class<?>[] interfaces = cls.getInterfaces(); [EOL]         for (int i = 0; i < interfaces.length; i++) { [EOL]             if (!Modifier.isPublic(interfaces[i].getModifiers())) { [EOL]                 continue; [EOL]             } [EOL]             try { [EOL]                 method = interfaces[i].getDeclaredMethod(methodName, parameterTypes); [EOL]             } catch (final NoSuchMethodException e) { [EOL]             } [EOL]             if (method != null) { [EOL]                 break; [EOL]             } [EOL]             method = getAccessibleMethodFromInterfaceNest(interfaces[i], methodName, parameterTypes); [EOL]             if (method != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return method; [EOL] }
public static Method getMatchingAccessibleMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     try { [EOL]         final Method method = cls.getMethod(methodName, parameterTypes); [EOL]         MemberUtils.setAccessibleWorkaround(method); [EOL]         return method; [EOL]     } catch (final NoSuchMethodException e) { [EOL]     } [EOL]     Method bestMatch = null; [EOL]     final Method[] methods = cls.getMethods(); [EOL]     for (final Method method : methods) { [EOL]         if (method.getName().equals(methodName) && ClassUtils.isAssignable(parameterTypes, method.getParameterTypes(), true)) { [EOL]             final Method accessibleMethod = getAccessibleMethod(method); [EOL]             if (accessibleMethod != null && (bestMatch == null || MemberUtils.compareParameterTypes(accessibleMethod.getParameterTypes(), bestMatch.getParameterTypes(), parameterTypes) < 0)) { [EOL]                 bestMatch = accessibleMethod; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (bestMatch != null) { [EOL]         MemberUtils.setAccessibleWorkaround(bestMatch); [EOL]     } [EOL]     return bestMatch; [EOL] }
