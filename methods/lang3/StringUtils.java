public static boolean isEmpty(final CharSequence cs) { [EOL]     return cs == null || cs.length() == 0; [EOL] }
public static boolean isNotEmpty(final CharSequence cs) { [EOL]     return !StringUtils.isEmpty(cs); [EOL] }
public static boolean isBlank(final CharSequence cs) { [EOL]     int strLen; [EOL]     if (cs == null || (strLen = cs.length()) == 0) { [EOL]         return true; [EOL]     } [EOL]     for (int i = 0; i < strLen; i++) { [EOL]         if (Character.isWhitespace(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isNotBlank(final CharSequence cs) { [EOL]     return !StringUtils.isBlank(cs); [EOL] }
public static String trim(final String str) { [EOL]     return str == null ? null : str.trim(); [EOL] }
public static String trimToNull(final String str) { [EOL]     final String ts = trim(str); [EOL]     return isEmpty(ts) ? null : ts; [EOL] }
public static String trimToEmpty(final String str) { [EOL]     return str == null ? EMPTY : str.trim(); [EOL] }
public static String strip(final String str) { [EOL]     return strip(str, null); [EOL] }
public static String stripToNull(String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     str = strip(str, null); [EOL]     return str.length() == 0 ? null : str; [EOL] }
public static String stripToEmpty(final String str) { [EOL]     return str == null ? EMPTY : strip(str, null); [EOL] }
public static String strip(String str, final String stripChars) { [EOL]     if (isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     str = stripStart(str, stripChars); [EOL]     return stripEnd(str, stripChars); [EOL] }
public static String stripStart(final String str, final String stripChars) { [EOL]     int strLen; [EOL]     if (str == null || (strLen = str.length()) == 0) { [EOL]         return str; [EOL]     } [EOL]     int start = 0; [EOL]     if (stripChars == null) { [EOL]         while (start != strLen && Character.isWhitespace(str.charAt(start))) { [EOL]             start++; [EOL]         } [EOL]     } else if (stripChars.length() == 0) { [EOL]         return str; [EOL]     } else { [EOL]         while (start != strLen && stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND) { [EOL]             start++; [EOL]         } [EOL]     } [EOL]     return str.substring(start); [EOL] }
public static String stripEnd(final String str, final String stripChars) { [EOL]     int end; [EOL]     if (str == null || (end = str.length()) == 0) { [EOL]         return str; [EOL]     } [EOL]     if (stripChars == null) { [EOL]         while (end != 0 && Character.isWhitespace(str.charAt(end - 1))) { [EOL]             end--; [EOL]         } [EOL]     } else if (stripChars.length() == 0) { [EOL]         return str; [EOL]     } else { [EOL]         while (end != 0 && stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND) { [EOL]             end--; [EOL]         } [EOL]     } [EOL]     return str.substring(0, end); [EOL] }
public static String[] stripAll(final String... strs) { [EOL]     return stripAll(strs, null); [EOL] }
public static String[] stripAll(final String[] strs, final String stripChars) { [EOL]     int strsLen; [EOL]     if (strs == null || (strsLen = strs.length) == 0) { [EOL]         return strs; [EOL]     } [EOL]     final String[] newArr = new String[strsLen]; [EOL]     for (int i = 0; i < strsLen; i++) { [EOL]         newArr[i] = strip(strs[i], stripChars); [EOL]     } [EOL]     return newArr; [EOL] }
public static String stripAccents(final String input) { [EOL]     if (input == null) { [EOL]         return null; [EOL]     } [EOL]     final Pattern pattern = Pattern.compile("\\p{InCombiningDiacriticalMarks}+"); [EOL]     final String decomposed = Normalizer.normalize(input, Normalizer.Form.NFD); [EOL]     return pattern.matcher(decomposed).replaceAll(""); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean equalsIgnoreCase(final CharSequence str1, final CharSequence str2) { [EOL]     if (str1 == null || str2 == null) { [EOL]         return str1 == str2; [EOL]     } else if (str1 == str2) { [EOL]         return true; [EOL]     } else if (str1.length() != str2.length()) { [EOL]         return false; [EOL]     } else { [EOL]         return CharSequenceUtils.regionMatches(str1, true, 0, str2, 0, str1.length()); [EOL]     } [EOL] }
public static int indexOf(final CharSequence seq, final int searchChar) { [EOL]     if (isEmpty(seq)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchChar, 0); [EOL] }
public static int indexOf(final CharSequence seq, final int searchChar, final int startPos) { [EOL]     if (isEmpty(seq)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchChar, startPos); [EOL] }
public static int indexOf(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, 0); [EOL] }
public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, startPos); [EOL] }
public static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal) { [EOL]     return ordinalIndexOf(str, searchStr, ordinal, false); [EOL] }
private static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal, final boolean lastIndex) { [EOL]     if (str == null || searchStr == null || ordinal <= 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (searchStr.length() == 0) { [EOL]         return lastIndex ? str.length() : 0; [EOL]     } [EOL]     int found = 0; [EOL]     int index = lastIndex ? str.length() : INDEX_NOT_FOUND; [EOL]     do { [EOL]         if (lastIndex) { [EOL]             index = CharSequenceUtils.lastIndexOf(str, searchStr, index - 1); [EOL]         } else { [EOL]             index = CharSequenceUtils.indexOf(str, searchStr, index + 1); [EOL]         } [EOL]         if (index < 0) { [EOL]             return index; [EOL]         } [EOL]         found++; [EOL]     } while (found < ordinal); [EOL]     return index; [EOL] }
public static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr) { [EOL]     return indexOfIgnoreCase(str, searchStr, 0); [EOL] }
public static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) { [EOL]     if (str == null || searchStr == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startPos < 0) { [EOL]         startPos = 0; [EOL]     } [EOL]     final int endLimit = str.length() - searchStr.length() + 1; [EOL]     if (startPos > endLimit) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (searchStr.length() == 0) { [EOL]         return startPos; [EOL]     } [EOL]     for (int i = startPos; i < endLimit; i++) { [EOL]         if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final CharSequence seq, final int searchChar) { [EOL]     if (isEmpty(seq)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return CharSequenceUtils.lastIndexOf(seq, searchChar, seq.length()); [EOL] }
public static int lastIndexOf(final CharSequence seq, final int searchChar, final int startPos) { [EOL]     if (isEmpty(seq)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return CharSequenceUtils.lastIndexOf(seq, searchChar, startPos); [EOL] }
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return CharSequenceUtils.lastIndexOf(seq, searchSeq, seq.length()); [EOL] }
public static int lastOrdinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal) { [EOL]     return ordinalIndexOf(str, searchStr, ordinal, true); [EOL] }
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos); [EOL] }
public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr) { [EOL]     if (str == null || searchStr == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return lastIndexOfIgnoreCase(str, searchStr, str.length()); [EOL] }
public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) { [EOL]     if (str == null || searchStr == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startPos > str.length() - searchStr.length()) { [EOL]         startPos = str.length() - searchStr.length(); [EOL]     } [EOL]     if (startPos < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (searchStr.length() == 0) { [EOL]         return startPos; [EOL]     } [EOL]     for (int i = startPos; i >= 0; i--) { [EOL]         if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final CharSequence seq, final int searchChar) { [EOL]     if (isEmpty(seq)) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchChar, 0) >= 0; [EOL] }
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0; [EOL] }
public static boolean containsIgnoreCase(final CharSequence str, final CharSequence searchStr) { [EOL]     if (str == null || searchStr == null) { [EOL]         return false; [EOL]     } [EOL]     final int len = searchStr.length(); [EOL]     final int max = str.length() - len; [EOL]     for (int i = 0; i <= max; i++) { [EOL]         if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, len)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean containsWhitespace(final CharSequence seq) { [EOL]     if (isEmpty(seq)) { [EOL]         return false; [EOL]     } [EOL]     final int strLen = seq.length(); [EOL]     for (int i = 0; i < strLen; i++) { [EOL]         if (Character.isWhitespace(seq.charAt(i))) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static int indexOfAny(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) { [EOL]                     if (searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return i; [EOL]                     } [EOL]                 } else { [EOL]                     return i; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOfAny(final CharSequence cs, final String searchChars) { [EOL]     if (isEmpty(cs) || isEmpty(searchChars)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return indexOfAny(cs, searchChars.toCharArray()); [EOL] }
public static boolean containsAny(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return false; [EOL]     } [EOL]     final int csLength = cs.length(); [EOL]     final int searchLength = searchChars.length; [EOL]     final int csLast = csLength - 1; [EOL]     final int searchLast = searchLength - 1; [EOL]     for (int i = 0; i < csLength; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLength; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (Character.isHighSurrogate(ch)) { [EOL]                     if (j == searchLast) { [EOL]                         return true; [EOL]                     } [EOL]                     if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return true; [EOL]                     } [EOL]                 } else { [EOL]                     return true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean containsAny(final CharSequence cs, final CharSequence searchChars) { [EOL]     if (searchChars == null) { [EOL]         return false; [EOL]     } [EOL]     return containsAny(cs, CharSequenceUtils.toCharArray(searchChars)); [EOL] }
public static int indexOfAnyBut(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     outer: for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) { [EOL]                     if (searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         continue outer; [EOL]                     } [EOL]                 } else { [EOL]                     continue outer; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return i; [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOfAnyBut(final CharSequence seq, final CharSequence searchChars) { [EOL]     if (isEmpty(seq) || isEmpty(searchChars)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int strLen = seq.length(); [EOL]     for (int i = 0; i < strLen; i++) { [EOL]         final char ch = seq.charAt(i); [EOL]         final boolean chFound = CharSequenceUtils.indexOf(searchChars, ch, 0) >= 0; [EOL]         if (i + 1 < strLen && Character.isHighSurrogate(ch)) { [EOL]             final char ch2 = seq.charAt(i + 1); [EOL]             if (chFound && CharSequenceUtils.indexOf(searchChars, ch2, 0) < 0) { [EOL]                 return i; [EOL]             } [EOL]         } else { [EOL]             if (!chFound) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static boolean containsOnly(final CharSequence cs, final char... valid) { [EOL]     if (valid == null || cs == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs.length() == 0) { [EOL]         return true; [EOL]     } [EOL]     if (valid.length == 0) { [EOL]         return false; [EOL]     } [EOL]     return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND; [EOL] }
public static boolean containsOnly(final CharSequence cs, final String validChars) { [EOL]     if (cs == null || validChars == null) { [EOL]         return false; [EOL]     } [EOL]     return containsOnly(cs, validChars.toCharArray()); [EOL] }
public static boolean containsNone(final CharSequence cs, final char... searchChars) { [EOL]     if (cs == null || searchChars == null) { [EOL]         return true; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (Character.isHighSurrogate(ch)) { [EOL]                     if (j == searchLast) { [EOL]                         return false; [EOL]                     } [EOL]                     if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return false; [EOL]                     } [EOL]                 } else { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean containsNone(final CharSequence cs, final String invalidChars) { [EOL]     if (cs == null || invalidChars == null) { [EOL]         return true; [EOL]     } [EOL]     return containsNone(cs, invalidChars.toCharArray()); [EOL] }
public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) { [EOL]     if (str == null || searchStrs == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int sz = searchStrs.length; [EOL]     int ret = Integer.MAX_VALUE; [EOL]     int tmp = 0; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final CharSequence search = searchStrs[i]; [EOL]         if (search == null) { [EOL]             continue; [EOL]         } [EOL]         tmp = CharSequenceUtils.indexOf(str, search, 0); [EOL]         if (tmp == INDEX_NOT_FOUND) { [EOL]             continue; [EOL]         } [EOL]         if (tmp < ret) { [EOL]             ret = tmp; [EOL]         } [EOL]     } [EOL]     return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret; [EOL] }
public static int lastIndexOfAny(final CharSequence str, final CharSequence... searchStrs) { [EOL]     if (str == null || searchStrs == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int sz = searchStrs.length; [EOL]     int ret = INDEX_NOT_FOUND; [EOL]     int tmp = 0; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final CharSequence search = searchStrs[i]; [EOL]         if (search == null) { [EOL]             continue; [EOL]         } [EOL]         tmp = CharSequenceUtils.lastIndexOf(str, search, str.length()); [EOL]         if (tmp > ret) { [EOL]             ret = tmp; [EOL]         } [EOL]     } [EOL]     return ret; [EOL] }
public static String substring(final String str, int start) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (start < 0) { [EOL]         start = str.length() + start; [EOL]     } [EOL]     if (start < 0) { [EOL]         start = 0; [EOL]     } [EOL]     if (start > str.length()) { [EOL]         return EMPTY; [EOL]     } [EOL]     return str.substring(start); [EOL] }
public static String substring(final String str, int start, int end) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (end < 0) { [EOL]         end = str.length() + end; [EOL]     } [EOL]     if (start < 0) { [EOL]         start = str.length() + start; [EOL]     } [EOL]     if (end > str.length()) { [EOL]         end = str.length(); [EOL]     } [EOL]     if (start > end) { [EOL]         return EMPTY; [EOL]     } [EOL]     if (start < 0) { [EOL]         start = 0; [EOL]     } [EOL]     if (end < 0) { [EOL]         end = 0; [EOL]     } [EOL]     return str.substring(start, end); [EOL] }
public static String left(final String str, final int len) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (len < 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     if (str.length() <= len) { [EOL]         return str; [EOL]     } [EOL]     return str.substring(0, len); [EOL] }
public static String right(final String str, final int len) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (len < 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     if (str.length() <= len) { [EOL]         return str; [EOL]     } [EOL]     return str.substring(str.length() - len); [EOL] }
public static String mid(final String str, int pos, final int len) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (len < 0 || pos > str.length()) { [EOL]         return EMPTY; [EOL]     } [EOL]     if (pos < 0) { [EOL]         pos = 0; [EOL]     } [EOL]     if (str.length() <= pos + len) { [EOL]         return str.substring(pos); [EOL]     } [EOL]     return str.substring(pos, pos + len); [EOL] }
public static String substringBefore(final String str, final String separator) { [EOL]     if (isEmpty(str) || separator == null) { [EOL]         return str; [EOL]     } [EOL]     if (separator.length() == 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int pos = str.indexOf(separator); [EOL]     if (pos == INDEX_NOT_FOUND) { [EOL]         return str; [EOL]     } [EOL]     return str.substring(0, pos); [EOL] }
public static String substringAfter(final String str, final String separator) { [EOL]     if (isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     if (separator == null) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int pos = str.indexOf(separator); [EOL]     if (pos == INDEX_NOT_FOUND) { [EOL]         return EMPTY; [EOL]     } [EOL]     return str.substring(pos + separator.length()); [EOL] }
public static String substringBeforeLast(final String str, final String separator) { [EOL]     if (isEmpty(str) || isEmpty(separator)) { [EOL]         return str; [EOL]     } [EOL]     final int pos = str.lastIndexOf(separator); [EOL]     if (pos == INDEX_NOT_FOUND) { [EOL]         return str; [EOL]     } [EOL]     return str.substring(0, pos); [EOL] }
public static String substringAfterLast(final String str, final String separator) { [EOL]     if (isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     if (isEmpty(separator)) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int pos = str.lastIndexOf(separator); [EOL]     if (pos == INDEX_NOT_FOUND || pos == str.length() - separator.length()) { [EOL]         return EMPTY; [EOL]     } [EOL]     return str.substring(pos + separator.length()); [EOL] }
public static String substringBetween(final String str, final String tag) { [EOL]     return substringBetween(str, tag, tag); [EOL] }
public static String substringBetween(final String str, final String open, final String close) { [EOL]     if (str == null || open == null || close == null) { [EOL]         return null; [EOL]     } [EOL]     final int start = str.indexOf(open); [EOL]     if (start != INDEX_NOT_FOUND) { [EOL]         final int end = str.indexOf(close, start + open.length()); [EOL]         if (end != INDEX_NOT_FOUND) { [EOL]             return str.substring(start + open.length(), end); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public static String[] substringsBetween(final String str, final String open, final String close) { [EOL]     if (str == null || isEmpty(open) || isEmpty(close)) { [EOL]         return null; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final int closeLen = close.length(); [EOL]     final int openLen = open.length(); [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int pos = 0; [EOL]     while (pos < strLen - closeLen) { [EOL]         int start = str.indexOf(open, pos); [EOL]         if (start < 0) { [EOL]             break; [EOL]         } [EOL]         start += openLen; [EOL]         final int end = str.indexOf(close, start); [EOL]         if (end < 0) { [EOL]             break; [EOL]         } [EOL]         list.add(str.substring(start, end)); [EOL]         pos = end + closeLen; [EOL]     } [EOL]     if (list.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] }
public static String[] split(final String str) { [EOL]     return split(str, null, -1); [EOL] }
public static String[] split(final String str, final char separatorChar) { [EOL]     return splitWorker(str, separatorChar, false); [EOL] }
public static String[] split(final String str, final String separatorChars) { [EOL]     return splitWorker(str, separatorChars, -1, false); [EOL] }
public static String[] split(final String str, final String separatorChars, final int max) { [EOL]     return splitWorker(str, separatorChars, max, false); [EOL] }
public static String[] splitByWholeSeparator(final String str, final String separator) { [EOL]     return splitByWholeSeparatorWorker(str, separator, -1, false); [EOL] }
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) { [EOL]     return splitByWholeSeparatorWorker(str, separator, max, false); [EOL] }
public static String[] splitByWholeSeparatorPreserveAllTokens(final String str, final String separator) { [EOL]     return splitByWholeSeparatorWorker(str, separator, -1, true); [EOL] }
public static String[] splitByWholeSeparatorPreserveAllTokens(final String str, final String separator, final int max) { [EOL]     return splitByWholeSeparatorWorker(str, separator, max, true); [EOL] }
private static String[] splitByWholeSeparatorWorker(final String str, final String separator, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     if (separator == null || EMPTY.equals(separator)) { [EOL]         return splitWorker(str, null, max, preserveAllTokens); [EOL]     } [EOL]     final int separatorLength = separator.length(); [EOL]     final ArrayList<String> substrings = new ArrayList<String>(); [EOL]     int numberOfSubstrings = 0; [EOL]     int beg = 0; [EOL]     int end = 0; [EOL]     while (end < len) { [EOL]         end = str.indexOf(separator, beg); [EOL]         if (end > -1) { [EOL]             if (end > beg) { [EOL]                 numberOfSubstrings += 1; [EOL]                 if (numberOfSubstrings == max) { [EOL]                     end = len; [EOL]                     substrings.add(str.substring(beg)); [EOL]                 } else { [EOL]                     substrings.add(str.substring(beg, end)); [EOL]                     beg = end + separatorLength; [EOL]                 } [EOL]             } else { [EOL]                 if (preserveAllTokens) { [EOL]                     numberOfSubstrings += 1; [EOL]                     if (numberOfSubstrings == max) { [EOL]                         end = len; [EOL]                         substrings.add(str.substring(beg)); [EOL]                     } else { [EOL]                         substrings.add(EMPTY); [EOL]                     } [EOL]                 } [EOL]                 beg = end + separatorLength; [EOL]             } [EOL]         } else { [EOL]             substrings.add(str.substring(beg)); [EOL]             end = len; [EOL]         } [EOL]     } [EOL]     return substrings.toArray(new String[substrings.size()]); [EOL] }
public static String[] splitPreserveAllTokens(final String str) { [EOL]     return splitWorker(str, null, -1, true); [EOL] }
public static String[] splitPreserveAllTokens(final String str, final char separatorChar) { [EOL]     return splitWorker(str, separatorChar, true); [EOL] }
private static String[] splitWorker(final String str, final char separatorChar, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     while (i < len) { [EOL]         if (str.charAt(i) == separatorChar) { [EOL]             if (match || preserveAllTokens) { [EOL]                 list.add(str.substring(start, i)); [EOL]                 match = false; [EOL]                 lastMatch = true; [EOL]             } [EOL]             start = ++i; [EOL]             continue; [EOL]         } [EOL]         lastMatch = false; [EOL]         match = true; [EOL]         i++; [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] }
public static String[] splitPreserveAllTokens(final String str, final String separatorChars) { [EOL]     return splitWorker(str, separatorChars, -1, true); [EOL] }
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) { [EOL]     return splitWorker(str, separatorChars, max, true); [EOL] }
private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] }
public static String[] splitByCharacterType(final String str) { [EOL]     return splitByCharacterType(str, false); [EOL] }
public static String[] splitByCharacterTypeCamelCase(final String str) { [EOL]     return splitByCharacterType(str, true); [EOL] }
private static String[] splitByCharacterType(final String str, final boolean camelCase) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.length() == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final char[] c = str.toCharArray(); [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int tokenStart = 0; [EOL]     int currentType = Character.getType(c[tokenStart]); [EOL]     for (int pos = tokenStart + 1; pos < c.length; pos++) { [EOL]         final int type = Character.getType(c[pos]); [EOL]         if (type == currentType) { [EOL]             continue; [EOL]         } [EOL]         if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) { [EOL]             final int newTokenStart = pos - 1; [EOL]             if (newTokenStart != tokenStart) { [EOL]                 list.add(new String(c, tokenStart, newTokenStart - tokenStart)); [EOL]                 tokenStart = newTokenStart; [EOL]             } [EOL]         } else { [EOL]             list.add(new String(c, tokenStart, pos - tokenStart)); [EOL]             tokenStart = pos; [EOL]         } [EOL]         currentType = type; [EOL]     } [EOL]     list.add(new String(c, tokenStart, c.length - tokenStart)); [EOL]     return list.toArray(new String[list.size()]); [EOL] }
public static <T> String join(final T... elements) { [EOL]     return join(elements, null); [EOL] }
public static String join(final Object[] array, final char separator) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return join(array, separator, 0, array.length); [EOL] }
public static String join(final long[] array, final char separator) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return join(array, separator, 0, array.length); [EOL] }
public static String join(final int[] array, final char separator) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return join(array, separator, 0, array.length); [EOL] }
public static String join(final short[] array, final char separator) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return join(array, separator, 0, array.length); [EOL] }
public static String join(final byte[] array, final char separator) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return join(array, separator, 0, array.length); [EOL] }
public static String join(final char[] array, final char separator) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return join(array, separator, 0, array.length); [EOL] }
public static String join(final float[] array, final char separator) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return join(array, separator, 0, array.length); [EOL] }
public static String join(final double[] array, final char separator) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return join(array, separator, 0, array.length); [EOL] }
public static String join(final Object[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         if (array[i] != null) { [EOL]             buf.append(array[i]); [EOL]         } [EOL]     } [EOL]     return buf.toString(); [EOL] }
public static String join(final long[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         buf.append(array[i]); [EOL]     } [EOL]     return buf.toString(); [EOL] }
public static String join(final int[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         buf.append(array[i]); [EOL]     } [EOL]     return buf.toString(); [EOL] }
public static String join(final byte[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         buf.append(array[i]); [EOL]     } [EOL]     return buf.toString(); [EOL] }
public static String join(final short[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         buf.append(array[i]); [EOL]     } [EOL]     return buf.toString(); [EOL] }
public static String join(final char[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         buf.append(array[i]); [EOL]     } [EOL]     return buf.toString(); [EOL] }
public static String join(final double[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         buf.append(array[i]); [EOL]     } [EOL]     return buf.toString(); [EOL] }
public static String join(final float[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         buf.append(array[i]); [EOL]     } [EOL]     return buf.toString(); [EOL] }
public static String join(final Object[] array, final String separator) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return join(array, separator, 0, array.length); [EOL] }
public static String join(final Object[] array, String separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (separator == null) { [EOL]         separator = EMPTY; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         if (array[i] != null) { [EOL]             buf.append(array[i]); [EOL]         } [EOL]     } [EOL]     return buf.toString(); [EOL] }
public static String join(final Iterator<?> iterator, final char separator) { [EOL]     if (iterator == null) { [EOL]         return null; [EOL]     } [EOL]     if (!iterator.hasNext()) { [EOL]         return EMPTY; [EOL]     } [EOL]     final Object first = iterator.next(); [EOL]     if (!iterator.hasNext()) { [EOL]         return ObjectUtils.toString(first); [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(256); [EOL]     if (first != null) { [EOL]         buf.append(first); [EOL]     } [EOL]     while (iterator.hasNext()) { [EOL]         buf.append(separator); [EOL]         final Object obj = iterator.next(); [EOL]         if (obj != null) { [EOL]             buf.append(obj); [EOL]         } [EOL]     } [EOL]     return buf.toString(); [EOL] }
public static String join(final Iterator<?> iterator, final String separator) { [EOL]     if (iterator == null) { [EOL]         return null; [EOL]     } [EOL]     if (!iterator.hasNext()) { [EOL]         return EMPTY; [EOL]     } [EOL]     final Object first = iterator.next(); [EOL]     if (!iterator.hasNext()) { [EOL]         return ObjectUtils.toString(first); [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(256); [EOL]     if (first != null) { [EOL]         buf.append(first); [EOL]     } [EOL]     while (iterator.hasNext()) { [EOL]         if (separator != null) { [EOL]             buf.append(separator); [EOL]         } [EOL]         final Object obj = iterator.next(); [EOL]         if (obj != null) { [EOL]             buf.append(obj); [EOL]         } [EOL]     } [EOL]     return buf.toString(); [EOL] }
public static String join(final Iterable<?> iterable, final char separator) { [EOL]     if (iterable == null) { [EOL]         return null; [EOL]     } [EOL]     return join(iterable.iterator(), separator); [EOL] }
public static String join(final Iterable<?> iterable, final String separator) { [EOL]     if (iterable == null) { [EOL]         return null; [EOL]     } [EOL]     return join(iterable.iterator(), separator); [EOL] }
public static String deleteWhitespace(final String str) { [EOL]     if (isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     final int sz = str.length(); [EOL]     final char[] chs = new char[sz]; [EOL]     int count = 0; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (!Character.isWhitespace(str.charAt(i))) { [EOL]             chs[count++] = str.charAt(i); [EOL]         } [EOL]     } [EOL]     if (count == sz) { [EOL]         return str; [EOL]     } [EOL]     return new String(chs, 0, count); [EOL] }
public static String removeStart(final String str, final String remove) { [EOL]     if (isEmpty(str) || isEmpty(remove)) { [EOL]         return str; [EOL]     } [EOL]     if (str.startsWith(remove)) { [EOL]         return str.substring(remove.length()); [EOL]     } [EOL]     return str; [EOL] }
public static String removeStartIgnoreCase(final String str, final String remove) { [EOL]     if (isEmpty(str) || isEmpty(remove)) { [EOL]         return str; [EOL]     } [EOL]     if (startsWithIgnoreCase(str, remove)) { [EOL]         return str.substring(remove.length()); [EOL]     } [EOL]     return str; [EOL] }
public static String removeEnd(final String str, final String remove) { [EOL]     if (isEmpty(str) || isEmpty(remove)) { [EOL]         return str; [EOL]     } [EOL]     if (str.endsWith(remove)) { [EOL]         return str.substring(0, str.length() - remove.length()); [EOL]     } [EOL]     return str; [EOL] }
public static String removeEndIgnoreCase(final String str, final String remove) { [EOL]     if (isEmpty(str) || isEmpty(remove)) { [EOL]         return str; [EOL]     } [EOL]     if (endsWithIgnoreCase(str, remove)) { [EOL]         return str.substring(0, str.length() - remove.length()); [EOL]     } [EOL]     return str; [EOL] }
public static String remove(final String str, final String remove) { [EOL]     if (isEmpty(str) || isEmpty(remove)) { [EOL]         return str; [EOL]     } [EOL]     return replace(str, remove, EMPTY, -1); [EOL] }
public static String remove(final String str, final char remove) { [EOL]     if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) { [EOL]         return str; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int pos = 0; [EOL]     for (int i = 0; i < chars.length; i++) { [EOL]         if (chars[i] != remove) { [EOL]             chars[pos++] = chars[i]; [EOL]         } [EOL]     } [EOL]     return new String(chars, 0, pos); [EOL] }
public static String replaceOnce(final String text, final String searchString, final String replacement) { [EOL]     return replace(text, searchString, replacement, 1); [EOL] }
public static String replacePattern(final String source, final String regex, final String replacement) { [EOL]     return Pattern.compile(regex, Pattern.DOTALL).matcher(source).replaceAll(replacement); [EOL] }
public static String removePattern(final String source, final String regex) { [EOL]     return replacePattern(source, regex, StringUtils.EMPTY); [EOL] }
public static String replace(final String text, final String searchString, final String replacement) { [EOL]     return replace(text, searchString, replacement, -1); [EOL] }
public static String replace(final String text, final String searchString, final String replacement, int max) { [EOL]     if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) { [EOL]         return text; [EOL]     } [EOL]     int start = 0; [EOL]     int end = text.indexOf(searchString, start); [EOL]     if (end == INDEX_NOT_FOUND) { [EOL]         return text; [EOL]     } [EOL]     final int replLength = searchString.length(); [EOL]     int increase = replacement.length() - replLength; [EOL]     increase = increase < 0 ? 0 : increase; [EOL]     increase *= max < 0 ? 16 : max > 64 ? 64 : max; [EOL]     final StringBuilder buf = new StringBuilder(text.length() + increase); [EOL]     while (end != INDEX_NOT_FOUND) { [EOL]         buf.append(text.substring(start, end)).append(replacement); [EOL]         start = end + replLength; [EOL]         if (--max == 0) { [EOL]             break; [EOL]         } [EOL]         end = text.indexOf(searchString, start); [EOL]     } [EOL]     buf.append(text.substring(start)); [EOL]     return buf.toString(); [EOL] }
public static String replaceEach(final String text, final String[] searchList, final String[] replacementList) { [EOL]     return replaceEach(text, searchList, replacementList, false, 0); [EOL] }
public static String replaceEachRepeatedly(final String text, final String[] searchList, final String[] replacementList) { [EOL]     final int timeToLive = searchList == null ? 0 : searchList.length; [EOL]     return replaceEach(text, searchList, replacementList, true, timeToLive); [EOL] }
private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) { [EOL]     if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) { [EOL]         return text; [EOL]     } [EOL]     if (timeToLive < 0) { [EOL]         throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another"); [EOL]     } [EOL]     final int searchLength = searchList.length; [EOL]     final int replacementLength = replacementList.length; [EOL]     if (searchLength != replacementLength) { [EOL]         throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength); [EOL]     } [EOL]     final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; [EOL]     int textIndex = -1; [EOL]     int replaceIndex = -1; [EOL]     int tempIndex = -1; [EOL]     for (int i = 0; i < searchLength; i++) { [EOL]         if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         tempIndex = text.indexOf(searchList[i]); [EOL]         if (tempIndex == -1) { [EOL]             noMoreMatchesForReplIndex[i] = true; [EOL]         } else { [EOL]             if (textIndex == -1 || tempIndex < textIndex) { [EOL]                 textIndex = tempIndex; [EOL]                 replaceIndex = i; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (textIndex == -1) { [EOL]         return text; [EOL]     } [EOL]     int start = 0; [EOL]     int increase = 0; [EOL]     for (int i = 0; i < searchList.length; i++) { [EOL]         if (searchList[i] == null || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         final int greater = replacementList[i].length() - searchList[i].length(); [EOL]         if (greater > 0) { [EOL]             increase += 3 * greater; [EOL]         } [EOL]     } [EOL]     increase = Math.min(increase, text.length() / 5); [EOL]     final StringBuilder buf = new StringBuilder(text.length() + increase); [EOL]     while (textIndex != -1) { [EOL]         for (int i = start; i < textIndex; i++) { [EOL]             buf.append(text.charAt(i)); [EOL]         } [EOL]         buf.append(replacementList[replaceIndex]); [EOL]         start = textIndex + searchList[replaceIndex].length(); [EOL]         textIndex = -1; [EOL]         replaceIndex = -1; [EOL]         tempIndex = -1; [EOL]         for (int i = 0; i < searchLength; i++) { [EOL]             if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) { [EOL]                 continue; [EOL]             } [EOL]             tempIndex = text.indexOf(searchList[i], start); [EOL]             if (tempIndex == -1) { [EOL]                 noMoreMatchesForReplIndex[i] = true; [EOL]             } else { [EOL]                 if (textIndex == -1 || tempIndex < textIndex) { [EOL]                     textIndex = tempIndex; [EOL]                     replaceIndex = i; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     final int textLength = text.length(); [EOL]     for (int i = start; i < textLength; i++) { [EOL]         buf.append(text.charAt(i)); [EOL]     } [EOL]     final String result = buf.toString(); [EOL]     if (!repeat) { [EOL]         return result; [EOL]     } [EOL]     return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); [EOL] }
public static String replaceChars(final String str, final char searchChar, final char replaceChar) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return str.replace(searchChar, replaceChar); [EOL] }
public static String replaceChars(final String str, final String searchChars, String replaceChars) { [EOL]     if (isEmpty(str) || isEmpty(searchChars)) { [EOL]         return str; [EOL]     } [EOL]     if (replaceChars == null) { [EOL]         replaceChars = EMPTY; [EOL]     } [EOL]     boolean modified = false; [EOL]     final int replaceCharsLength = replaceChars.length(); [EOL]     final int strLength = str.length(); [EOL]     final StringBuilder buf = new StringBuilder(strLength); [EOL]     for (int i = 0; i < strLength; i++) { [EOL]         final char ch = str.charAt(i); [EOL]         final int index = searchChars.indexOf(ch); [EOL]         if (index >= 0) { [EOL]             modified = true; [EOL]             if (index < replaceCharsLength) { [EOL]                 buf.append(replaceChars.charAt(index)); [EOL]             } [EOL]         } else { [EOL]             buf.append(ch); [EOL]         } [EOL]     } [EOL]     if (modified) { [EOL]         return buf.toString(); [EOL]     } [EOL]     return str; [EOL] }
public static String overlay(final String str, String overlay, int start, int end) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (overlay == null) { [EOL]         overlay = EMPTY; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (start < 0) { [EOL]         start = 0; [EOL]     } [EOL]     if (start > len) { [EOL]         start = len; [EOL]     } [EOL]     if (end < 0) { [EOL]         end = 0; [EOL]     } [EOL]     if (end > len) { [EOL]         end = len; [EOL]     } [EOL]     if (start > end) { [EOL]         final int temp = start; [EOL]         start = end; [EOL]         end = temp; [EOL]     } [EOL]     return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString(); [EOL] }
public static String chomp(final String str) { [EOL]     if (isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     if (str.length() == 1) { [EOL]         final char ch = str.charAt(0); [EOL]         if (ch == CharUtils.CR || ch == CharUtils.LF) { [EOL]             return EMPTY; [EOL]         } [EOL]         return str; [EOL]     } [EOL]     int lastIdx = str.length() - 1; [EOL]     final char last = str.charAt(lastIdx); [EOL]     if (last == CharUtils.LF) { [EOL]         if (str.charAt(lastIdx - 1) == CharUtils.CR) { [EOL]             lastIdx--; [EOL]         } [EOL]     } else if (last != CharUtils.CR) { [EOL]         lastIdx++; [EOL]     } [EOL]     return str.substring(0, lastIdx); [EOL] }
@Deprecated [EOL] public static String chomp(final String str, final String separator) { [EOL]     return removeEnd(str, separator); [EOL] }
public static String chop(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen < 2) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int lastIdx = strLen - 1; [EOL]     final String ret = str.substring(0, lastIdx); [EOL]     final char last = str.charAt(lastIdx); [EOL]     if (last == CharUtils.LF && ret.charAt(lastIdx - 1) == CharUtils.CR) { [EOL]         return ret.substring(0, lastIdx - 1); [EOL]     } [EOL]     return ret; [EOL] }
public static String repeat(final String str, final int repeat) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (repeat <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int inputLength = str.length(); [EOL]     if (repeat == 1 || inputLength == 0) { [EOL]         return str; [EOL]     } [EOL]     if (inputLength == 1 && repeat <= PAD_LIMIT) { [EOL]         return repeat(str.charAt(0), repeat); [EOL]     } [EOL]     final int outputLength = inputLength * repeat; [EOL]     switch(inputLength) { [EOL]         case 1: [EOL]             return repeat(str.charAt(0), repeat); [EOL]         case 2: [EOL]             final char ch0 = str.charAt(0); [EOL]             final char ch1 = str.charAt(1); [EOL]             final char[] output2 = new char[outputLength]; [EOL]             for (int i = repeat * 2 - 2; i >= 0; i--, i--) { [EOL]                 output2[i] = ch0; [EOL]                 output2[i + 1] = ch1; [EOL]             } [EOL]             return new String(output2); [EOL]         default: [EOL]             final StringBuilder buf = new StringBuilder(outputLength); [EOL]             for (int i = 0; i < repeat; i++) { [EOL]                 buf.append(str); [EOL]             } [EOL]             return buf.toString(); [EOL]     } [EOL] }
public static String repeat(final String str, final String separator, final int repeat) { [EOL]     if (str == null || separator == null) { [EOL]         return repeat(str, repeat); [EOL]     } else { [EOL]         final String result = repeat(str + separator, repeat); [EOL]         return removeEnd(result, separator); [EOL]     } [EOL] }
public static String repeat(final char ch, final int repeat) { [EOL]     final char[] buf = new char[repeat]; [EOL]     for (int i = repeat - 1; i >= 0; i--) { [EOL]         buf[i] = ch; [EOL]     } [EOL]     return new String(buf); [EOL] }
public static String rightPad(final String str, final int size) { [EOL]     return rightPad(str, size, ' '); [EOL] }
public static String rightPad(final String str, final int size, final char padChar) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int pads = size - str.length(); [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (pads > PAD_LIMIT) { [EOL]         return rightPad(str, size, String.valueOf(padChar)); [EOL]     } [EOL]     return str.concat(repeat(padChar, pads)); [EOL] }
public static String rightPad(final String str, final int size, String padStr) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int padLen = padStr.length(); [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (padLen == 1 && pads <= PAD_LIMIT) { [EOL]         return rightPad(str, size, padStr.charAt(0)); [EOL]     } [EOL]     if (pads == padLen) { [EOL]         return str.concat(padStr); [EOL]     } else if (pads < padLen) { [EOL]         return str.concat(padStr.substring(0, pads)); [EOL]     } else { [EOL]         final char[] padding = new char[pads]; [EOL]         final char[] padChars = padStr.toCharArray(); [EOL]         for (int i = 0; i < pads; i++) { [EOL]             padding[i] = padChars[i % padLen]; [EOL]         } [EOL]         return str.concat(new String(padding)); [EOL]     } [EOL] }
public static String leftPad(final String str, final int size) { [EOL]     return leftPad(str, size, ' '); [EOL] }
public static String leftPad(final String str, final int size, final char padChar) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int pads = size - str.length(); [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (pads > PAD_LIMIT) { [EOL]         return leftPad(str, size, String.valueOf(padChar)); [EOL]     } [EOL]     return repeat(padChar, pads).concat(str); [EOL] }
public static String leftPad(final String str, final int size, String padStr) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int padLen = padStr.length(); [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (padLen == 1 && pads <= PAD_LIMIT) { [EOL]         return leftPad(str, size, padStr.charAt(0)); [EOL]     } [EOL]     if (pads == padLen) { [EOL]         return padStr.concat(str); [EOL]     } else if (pads < padLen) { [EOL]         return padStr.substring(0, pads).concat(str); [EOL]     } else { [EOL]         final char[] padding = new char[pads]; [EOL]         final char[] padChars = padStr.toCharArray(); [EOL]         for (int i = 0; i < pads; i++) { [EOL]             padding[i] = padChars[i % padLen]; [EOL]         } [EOL]         return new String(padding).concat(str); [EOL]     } [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static String center(final String str, final int size) { [EOL]     return center(str, size, ' '); [EOL] }
public static String center(String str, final int size, final char padChar) { [EOL]     if (str == null || size <= 0) { [EOL]         return str; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     str = leftPad(str, strLen + pads / 2, padChar); [EOL]     str = rightPad(str, size, padChar); [EOL]     return str; [EOL] }
public static String center(String str, final int size, String padStr) { [EOL]     if (str == null || size <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     str = leftPad(str, strLen + pads / 2, padStr); [EOL]     str = rightPad(str, size, padStr); [EOL]     return str; [EOL] }
public static String upperCase(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return str.toUpperCase(); [EOL] }
public static String upperCase(final String str, final Locale locale) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return str.toUpperCase(locale); [EOL] }
public static String lowerCase(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return str.toLowerCase(); [EOL] }
public static String lowerCase(final String str, final Locale locale) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return str.toLowerCase(locale); [EOL] }
public static String capitalize(final String str) { [EOL]     int strLen; [EOL]     if (str == null || (strLen = str.length()) == 0) { [EOL]         return str; [EOL]     } [EOL]     return new StringBuilder(strLen).append(Character.toTitleCase(str.charAt(0))).append(str.substring(1)).toString(); [EOL] }
public static String uncapitalize(final String str) { [EOL]     int strLen; [EOL]     if (str == null || (strLen = str.length()) == 0) { [EOL]         return str; [EOL]     } [EOL]     return new StringBuilder(strLen).append(Character.toLowerCase(str.charAt(0))).append(str.substring(1)).toString(); [EOL] }
public static String swapCase(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (Character.isUpperCase(ch)) { [EOL]             buffer[i] = Character.toLowerCase(ch); [EOL]         } else if (Character.isTitleCase(ch)) { [EOL]             buffer[i] = Character.toLowerCase(ch); [EOL]         } else if (Character.isLowerCase(ch)) { [EOL]             buffer[i] = Character.toUpperCase(ch); [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static int countMatches(final CharSequence str, final CharSequence sub) { [EOL]     if (isEmpty(str) || isEmpty(sub)) { [EOL]         return 0; [EOL]     } [EOL]     int count = 0; [EOL]     int idx = 0; [EOL]     while ((idx = CharSequenceUtils.indexOf(str, sub, idx)) != INDEX_NOT_FOUND) { [EOL]         count++; [EOL]         idx += sub.length(); [EOL]     } [EOL]     return count; [EOL] }
public static boolean isAlpha(final CharSequence cs) { [EOL]     if (cs == null || cs.length() == 0) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isLetter(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isAlphaSpace(final CharSequence cs) { [EOL]     if (cs == null) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isLetter(cs.charAt(i)) == false && cs.charAt(i) != ' ') { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isAlphanumeric(final CharSequence cs) { [EOL]     if (cs == null || cs.length() == 0) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isLetterOrDigit(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isAlphanumericSpace(final CharSequence cs) { [EOL]     if (cs == null) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isLetterOrDigit(cs.charAt(i)) == false && cs.charAt(i) != ' ') { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isAsciiPrintable(final CharSequence cs) { [EOL]     if (cs == null) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isNumeric(final CharSequence cs) { [EOL]     if (cs == null || cs.length() == 0) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isDigit(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isNumericSpace(final CharSequence cs) { [EOL]     if (cs == null) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isDigit(cs.charAt(i)) == false && cs.charAt(i) != ' ') { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isWhitespace(final CharSequence cs) { [EOL]     if (cs == null) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isWhitespace(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isAllLowerCase(final CharSequence cs) { [EOL]     if (cs == null || isEmpty(cs)) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isLowerCase(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isAllUpperCase(final CharSequence cs) { [EOL]     if (cs == null || isEmpty(cs)) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isUpperCase(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static String defaultString(final String str) { [EOL]     return str == null ? EMPTY : str; [EOL] }
public static String defaultString(final String str, final String defaultStr) { [EOL]     return str == null ? defaultStr : str; [EOL] }
public static <T extends CharSequence> T defaultIfBlank(final T str, final T defaultStr) { [EOL]     return StringUtils.isBlank(str) ? defaultStr : str; [EOL] }
public static <T extends CharSequence> T defaultIfEmpty(final T str, final T defaultStr) { [EOL]     return StringUtils.isEmpty(str) ? defaultStr : str; [EOL] }
public static String reverse(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return new StringBuilder(str).reverse().toString(); [EOL] }
public static String reverseDelimited(final String str, final char separatorChar) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final String[] strs = split(str, separatorChar); [EOL]     ArrayUtils.reverse(strs); [EOL]     return join(strs, separatorChar); [EOL] }
public static String abbreviate(final String str, final int maxWidth) { [EOL]     return abbreviate(str, 0, maxWidth); [EOL] }
public static String abbreviate(final String str, int offset, final int maxWidth) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (maxWidth < 4) { [EOL]         throw new IllegalArgumentException("Minimum abbreviation width is 4"); [EOL]     } [EOL]     if (str.length() <= maxWidth) { [EOL]         return str; [EOL]     } [EOL]     if (offset > str.length()) { [EOL]         offset = str.length(); [EOL]     } [EOL]     if (str.length() - offset < maxWidth - 3) { [EOL]         offset = str.length() - (maxWidth - 3); [EOL]     } [EOL]     final String abrevMarker = "..."; [EOL]     if (offset <= 4) { [EOL]         return str.substring(0, maxWidth - 3) + abrevMarker; [EOL]     } [EOL]     if (maxWidth < 7) { [EOL]         throw new IllegalArgumentException("Minimum abbreviation width with offset is 7"); [EOL]     } [EOL]     if (offset + maxWidth - 3 < str.length()) { [EOL]         return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3); [EOL]     } [EOL]     return abrevMarker + str.substring(str.length() - (maxWidth - 3)); [EOL] }
public static String abbreviateMiddle(final String str, final String middle, final int length) { [EOL]     if (isEmpty(str) || isEmpty(middle)) { [EOL]         return str; [EOL]     } [EOL]     if (length >= str.length() || length < middle.length() + 2) { [EOL]         return str; [EOL]     } [EOL]     final int targetSting = length - middle.length(); [EOL]     final int startOffset = targetSting / 2 + targetSting % 2; [EOL]     final int endOffset = str.length() - targetSting / 2; [EOL]     final StringBuilder builder = new StringBuilder(length); [EOL]     builder.append(str.substring(0, startOffset)); [EOL]     builder.append(middle); [EOL]     builder.append(str.substring(endOffset)); [EOL]     return builder.toString(); [EOL] }
public static String difference(final String str1, final String str2) { [EOL]     if (str1 == null) { [EOL]         return str2; [EOL]     } [EOL]     if (str2 == null) { [EOL]         return str1; [EOL]     } [EOL]     final int at = indexOfDifference(str1, str2); [EOL]     if (at == INDEX_NOT_FOUND) { [EOL]         return EMPTY; [EOL]     } [EOL]     return str2.substring(at); [EOL] }
public static int indexOfDifference(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return 0; [EOL]     } [EOL]     int i; [EOL]     for (i = 0; i < cs1.length() && i < cs2.length(); ++i) { [EOL]         if (cs1.charAt(i) != cs2.charAt(i)) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (i < cs2.length() || i < cs1.length()) { [EOL]         return i; [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOfDifference(final CharSequence... css) { [EOL]     if (css == null || css.length <= 1) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     boolean anyStringNull = false; [EOL]     boolean allStringsNull = true; [EOL]     final int arrayLen = css.length; [EOL]     int shortestStrLen = Integer.MAX_VALUE; [EOL]     int longestStrLen = 0; [EOL]     for (int i = 0; i < arrayLen; i++) { [EOL]         if (css[i] == null) { [EOL]             anyStringNull = true; [EOL]             shortestStrLen = 0; [EOL]         } else { [EOL]             allStringsNull = false; [EOL]             shortestStrLen = Math.min(css[i].length(), shortestStrLen); [EOL]             longestStrLen = Math.max(css[i].length(), longestStrLen); [EOL]         } [EOL]     } [EOL]     if (allStringsNull || longestStrLen == 0 && !anyStringNull) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (shortestStrLen == 0) { [EOL]         return 0; [EOL]     } [EOL]     int firstDiff = -1; [EOL]     for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) { [EOL]         final char comparisonChar = css[0].charAt(stringPos); [EOL]         for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) { [EOL]             if (css[arrayPos].charAt(stringPos) != comparisonChar) { [EOL]                 firstDiff = stringPos; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (firstDiff != -1) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (firstDiff == -1 && shortestStrLen != longestStrLen) { [EOL]         return shortestStrLen; [EOL]     } [EOL]     return firstDiff; [EOL] }
public static String getCommonPrefix(final String... strs) { [EOL]     if (strs == null || strs.length == 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int smallestIndexOfDiff = indexOfDifference(strs); [EOL]     if (smallestIndexOfDiff == INDEX_NOT_FOUND) { [EOL]         if (strs[0] == null) { [EOL]             return EMPTY; [EOL]         } [EOL]         return strs[0]; [EOL]     } else if (smallestIndexOfDiff == 0) { [EOL]         return EMPTY; [EOL]     } else { [EOL]         return strs[0].substring(0, smallestIndexOfDiff); [EOL]     } [EOL] }
public static int getLevenshteinDistance(CharSequence s, CharSequence t) { [EOL]     if (s == null || t == null) { [EOL]         throw new IllegalArgumentException("Strings must not be null"); [EOL]     } [EOL]     int n = s.length(); [EOL]     int m = t.length(); [EOL]     if (n == 0) { [EOL]         return m; [EOL]     } else if (m == 0) { [EOL]         return n; [EOL]     } [EOL]     if (n > m) { [EOL]         final CharSequence tmp = s; [EOL]         s = t; [EOL]         t = tmp; [EOL]         n = m; [EOL]         m = t.length(); [EOL]     } [EOL]     int[] p = new int[n + 1]; [EOL]     int[] d = new int[n + 1]; [EOL]     int[] _d; [EOL]     int i; [EOL]     int j; [EOL]     char t_j; [EOL]     int cost; [EOL]     for (i = 0; i <= n; i++) { [EOL]         p[i] = i; [EOL]     } [EOL]     for (j = 1; j <= m; j++) { [EOL]         t_j = t.charAt(j - 1); [EOL]         d[0] = j; [EOL]         for (i = 1; i <= n; i++) { [EOL]             cost = s.charAt(i - 1) == t_j ? 0 : 1; [EOL]             d[i] = Math.min(Math.min(d[i - 1] + 1, p[i] + 1), p[i - 1] + cost); [EOL]         } [EOL]         _d = p; [EOL]         p = d; [EOL]         d = _d; [EOL]     } [EOL]     return p[n]; [EOL] }
public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) { [EOL]     if (s == null || t == null) { [EOL]         throw new IllegalArgumentException("Strings must not be null"); [EOL]     } [EOL]     if (threshold < 0) { [EOL]         throw new IllegalArgumentException("Threshold must not be negative"); [EOL]     } [EOL]     int n = s.length(); [EOL]     int m = t.length(); [EOL]     if (n == 0) { [EOL]         return m <= threshold ? m : -1; [EOL]     } else if (m == 0) { [EOL]         return n <= threshold ? n : -1; [EOL]     } [EOL]     if (n > m) { [EOL]         final CharSequence tmp = s; [EOL]         s = t; [EOL]         t = tmp; [EOL]         n = m; [EOL]         m = t.length(); [EOL]     } [EOL]     int[] p = new int[n + 1]; [EOL]     int[] d = new int[n + 1]; [EOL]     int[] _d; [EOL]     final int boundary = Math.min(n, threshold) + 1; [EOL]     for (int i = 0; i < boundary; i++) { [EOL]         p[i] = i; [EOL]     } [EOL]     Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE); [EOL]     Arrays.fill(d, Integer.MAX_VALUE); [EOL]     for (int j = 1; j <= m; j++) { [EOL]         final char t_j = t.charAt(j - 1); [EOL]         d[0] = j; [EOL]         final int min = Math.max(1, j - threshold); [EOL]         final int max = Math.min(n, j + threshold); [EOL]         if (min > max) { [EOL]             return -1; [EOL]         } [EOL]         if (min > 1) { [EOL]             d[min - 1] = Integer.MAX_VALUE; [EOL]         } [EOL]         for (int i = min; i <= max; i++) { [EOL]             if (s.charAt(i - 1) == t_j) { [EOL]                 d[i] = p[i - 1]; [EOL]             } else { [EOL]                 d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]); [EOL]             } [EOL]         } [EOL]         _d = p; [EOL]         p = d; [EOL]         d = _d; [EOL]     } [EOL]     if (p[n] <= threshold) { [EOL]         return p[n]; [EOL]     } else { [EOL]         return -1; [EOL]     } [EOL] }
public static boolean startsWith(final CharSequence str, final CharSequence prefix) { [EOL]     return startsWith(str, prefix, false); [EOL] }
public static boolean startsWithIgnoreCase(final CharSequence str, final CharSequence prefix) { [EOL]     return startsWith(str, prefix, true); [EOL] }
private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase) { [EOL]     if (str == null || prefix == null) { [EOL]         return str == null && prefix == null; [EOL]     } [EOL]     if (prefix.length() > str.length()) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length()); [EOL] }
public static boolean startsWithAny(final CharSequence string, final CharSequence... searchStrings) { [EOL]     if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) { [EOL]         return false; [EOL]     } [EOL]     for (final CharSequence searchString : searchStrings) { [EOL]         if (StringUtils.startsWith(string, searchString)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean endsWith(final CharSequence str, final CharSequence suffix) { [EOL]     return endsWith(str, suffix, false); [EOL] }
public static boolean endsWithIgnoreCase(final CharSequence str, final CharSequence suffix) { [EOL]     return endsWith(str, suffix, true); [EOL] }
private static boolean endsWith(final CharSequence str, final CharSequence suffix, final boolean ignoreCase) { [EOL]     if (str == null || suffix == null) { [EOL]         return str == null && suffix == null; [EOL]     } [EOL]     if (suffix.length() > str.length()) { [EOL]         return false; [EOL]     } [EOL]     final int strOffset = str.length() - suffix.length(); [EOL]     return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, suffix, 0, suffix.length()); [EOL] }
public static String normalizeSpace(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return WHITESPACE_PATTERN.matcher(trim(str)).replaceAll(SPACE); [EOL] }
public static boolean endsWithAny(final CharSequence string, final CharSequence... searchStrings) { [EOL]     if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) { [EOL]         return false; [EOL]     } [EOL]     for (final CharSequence searchString : searchStrings) { [EOL]         if (StringUtils.endsWith(string, searchString)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private static String appendIfMissing(final String str, final CharSequence suffix, final boolean ignoreCase, final CharSequence... suffixes) { [EOL]     if (str == null || isEmpty(suffix) || endsWith(str, suffix, ignoreCase)) { [EOL]         return str; [EOL]     } [EOL]     if (suffixes != null && suffixes.length > 0) { [EOL]         for (final CharSequence s : suffixes) { [EOL]             if (endsWith(str, s, ignoreCase)) { [EOL]                 return str; [EOL]             } [EOL]         } [EOL]     } [EOL]     return str + suffix.toString(); [EOL] }
public static String appendIfMissing(final String str, final CharSequence suffix, final CharSequence... suffixes) { [EOL]     return appendIfMissing(str, suffix, false, suffixes); [EOL] }
public static String appendIfMissingIgnoreCase(final String str, final CharSequence suffix, final CharSequence... suffixes) { [EOL]     return appendIfMissing(str, suffix, true, suffixes); [EOL] }
private static String prependIfMissing(final String str, final CharSequence prefix, final boolean ignoreCase, final CharSequence... prefixes) { [EOL]     if (str == null || isEmpty(prefix) || startsWith(str, prefix, ignoreCase)) { [EOL]         return str; [EOL]     } [EOL]     if (prefixes != null && prefixes.length > 0) { [EOL]         for (final CharSequence p : prefixes) { [EOL]             if (startsWith(str, p, ignoreCase)) { [EOL]                 return str; [EOL]             } [EOL]         } [EOL]     } [EOL]     return prefix.toString() + str; [EOL] }
public static String prependIfMissing(final String str, final CharSequence prefix, final CharSequence... prefixes) { [EOL]     return prependIfMissing(str, prefix, false, prefixes); [EOL] }
public static String prependIfMissingIgnoreCase(final String str, final CharSequence prefix, final CharSequence... prefixes) { [EOL]     return prependIfMissing(str, prefix, true, prefixes); [EOL] }
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException { [EOL]     return charsetName == null ? new String(bytes) : new String(bytes, charsetName); [EOL] }
